# Default values for haproxy-template-ic.

# Replica count for controller
# Default: 2 replicas for high availability with leader election
# Only the leader replica deploys configs; followers remain ready for failover
replicaCount: 2

# Controller image configuration
image:
  repository: ghcr.io/phihos/haproxy-template-ic
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Controller configuration
controller:
  # Name of the HAProxyTemplateConfig CRD
  # This is the name of the HAProxyTemplateConfig custom resource
  crdName: haproxy-template-ic-config

  # Debug HTTP server port (0 to disable)
  # Exposes /debug/vars and /debug/pprof endpoints for introspection
  # Access via: kubectl port-forward pod/controller-xxx 6060:6060
  debugPort: 0

# Webhook configuration
# Kubernetes admission webhook for resource validation
# ValidatingWebhookConfiguration is created by Helm at installation time
webhook:
  # Enable webhook validation
  # Requires watched_resources to have enable_validation_webhook: true
  enabled: true

  # Webhook HTTPS server port (inside container)
  port: 9443

  # Secret name containing webhook TLS certificates
  # The Secret must contain keys: tls.crt, tls.key, ca.crt
  # Defaults to: {{ include "haproxy-template-ic.fullname" . }}-webhook-cert
  # Leave empty to use the default naming convention
  secretName: ""

  # Service configuration for webhook endpoint
  service:
    # Service port (exposed to Kubernetes API server)
    port: 443

  # Certificate management
  # Choose ONE of the following options:
  #
  # Option 1: Use cert-manager (recommended for production)
  # Requires cert-manager to be installed in the cluster
  certManager:
    enabled: false
    # Issuer reference for cert-manager Certificate resource
    issuerRef:
      name: selfsigned-issuer
      kind: Issuer
      # group: cert-manager.io  # Optional, defaults to cert-manager.io
    # Certificate validity duration (default: 1 year)
    duration: 8760h  # 1 year
    # Renew certificate when this much time is left (default: 30 days)
    renewBefore: 720h  # 30 days

  # Option 2: Manual certificate management
  # Provide base64-encoded CA bundle for ValidatingWebhookConfiguration
  # This is required when certManager.enabled is false
  # Create the certificate Secret manually with keys: tls.crt, tls.key, ca.crt
  # Secret name is configured via webhook.secretName (default: haproxy-webhook-certs)
  caBundle: ""  # Base64-encoded CA certificate
  # Example:
  # caBundle: LS0tLS1CRUdJTi...

# Dataplane API credentials
credentials:
  dataplane:
    username: admin
    password: adminpass

# ServiceAccount configuration
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# RBAC configuration
rbac:
  # Specifies whether RBAC resources should be created
  create: true

# Pod annotations
podAnnotations: {}

# Pod labels
podLabels: {}

# Pod security context
podSecurityContext: {}
  # fsGroup: 2000

# Container security context
securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# Service configuration
# Exposes controller endpoints (health and metrics)
service:
  type: ClusterIP
  # Health check endpoint port
  healthzPort: 8080
  # Prometheus metrics endpoint port
  # Must match controller.config.controller.metrics_port
  metricsPort: 9090

# Liveness and readiness probes
# Disabled until /healthz endpoint is implemented in the controller
# livenessProbe:
#   httpGet:
#     path: /healthz
#     port: healthz
#   initialDelaySeconds: 10
#   periodSeconds: 10
#
# readinessProbe:
#   httpGet:
#     path: /healthz
#     port: healthz
#   initialDelaySeconds: 5
#   periodSeconds: 5

# Resources limits and requests
# Note: The controller automatically detects and respects container resource limits:
# - CPU limits: Go 1.25+ automatically sets GOMAXPROCS based on cgroup CPU limits
# - Memory limits: automemlimit library automatically sets GOMEMLIMIT to 90% of cgroup memory limits
#
# The AUTOMEMLIMIT environment variable can be used to adjust the memory limit ratio (default: 0.9)
# Example: AUTOMEMLIMIT=0.8 sets GOMEMLIMIT to 80% of the container memory limit
resources: {}
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user. This also increases chances charts run on environments with little
  # resources, such as Minikube. If you do want to specify resources, uncomment the following
  # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
  # limits:
  #   cpu: 200m
  #   memory: 256Mi
  # requests:
  #   cpu: 100m
  #   memory: 128Mi

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity rules
affinity: {}

# Autoscaling configuration
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# Pod Disruption Budget
podDisruptionBudget:
  enabled: false
  # Only one of minAvailable or maxUnavailable should be set
  minAvailable: 1
  # maxUnavailable: 1

# Prometheus Metrics and Monitoring
# The controller exposes 11 Prometheus metrics on port 9090 covering:
# - Reconciliation cycles and errors
# - Deployment operations and duration
# - Configuration validation
# - Resource counts and event bus activity
#
# Metrics endpoint: http://<pod-ip>:9090/metrics
# Access via: kubectl port-forward pod/<controller-pod> 9090:9090
#
# For complete metric definitions and queries, see:
# pkg/controller/metrics/README.md in the repository
monitoring:
  # ServiceMonitor for Prometheus Operator
  # Creates a ServiceMonitor resource that configures Prometheus to scrape metrics
  serviceMonitor:
    enabled: false
    # Scrape interval for metrics collection
    interval: 30s
    # Timeout for each scrape
    scrapeTimeout: 10s
    # Additional labels for ServiceMonitor resource
    # Used by Prometheus to select which ServiceMonitors to use
    labels: {}
    #   prometheus: kube-prometheus
    #   release: prometheus
    # Relabeling configurations applied before scraping
    # https://prometheus.io/docs/prometheus/latest/configuration/configuration/#relabel_config
    relabelings: []
    # Example: Add cluster label
    # - sourceLabels: [__address__]
    #   targetLabel: cluster
    #   replacement: production
    # Metric relabeling configurations applied to scraped metrics
    metricRelabelings: []
    # Example: Drop specific metrics
    # - sourceLabels: [__name__]
    #   regex: 'haproxy_ic_event_subscribers'
    #   action: drop

# NetworkPolicy configuration
networkPolicy:
  enabled: true

  # Egress rules
  egress:
    # Allow DNS resolution (required for service discovery)
    allowDNS: true

    # Kubernetes API Server access (required for watching resources)
    # Configure based on your cluster setup
    kubernetesApi:
      # For kind/standard clusters
      # Adjust this CIDR based on your cluster
      - cidr: 0.0.0.0/0  # Allow all by default, restrict in production
        ports:
          - port: 443
            protocol: TCP
          - port: 6443
            protocol: TCP

    # HAProxy Dataplane API pods (in any namespace)
    haproxyPods:
      # Allow access to all pods matching the pod_selector
      enabled: true
      # Pod selector for HAProxy pods
      podSelector:
        matchLabels:
          app: haproxy
          component: loadbalancer
      # Namespace selector - empty {} means all namespaces
      namespaceSelector: {}
      ports:
        - port: 5555  # Dataplane API
          protocol: TCP
        - port: 8404  # Health/stats
          protocol: TCP

    # Additional custom egress rules
    additionalRules: []
    # Example:
    # - to:
    #     - namespaceSelector:
    #         matchLabels:
    #           name: monitoring
    #   ports:
    #     - port: 9090
    #       protocol: TCP

  # Ingress rules
  ingress:
    # Allow Prometheus/monitoring to scrape metrics
    # IMPORTANT: Enable this if using ServiceMonitor with NetworkPolicy
    # Without this, Prometheus cannot access the metrics endpoint
    monitoring:
      enabled: false  # Set to true when using Prometheus with NetworkPolicy
      # Pod selector for monitoring systems (e.g., Prometheus)
      # Match the labels of your Prometheus pods
      podSelector: {}
      #   matchLabels:
      #     app: prometheus
      #     app.kubernetes.io/name: prometheus
      # Namespace selector for monitoring systems
      # Match the namespace where Prometheus is running
      namespaceSelector: {}
      #   matchLabels:
      #     name: monitoring
      #     kubernetes.io/metadata.name: monitoring
      ports:
        - port: 9090  # Metrics endpoint
          protocol: TCP

    # Allow health checks from load balancers/ingress
    healthChecks:
      enabled: true
      # Allow from anywhere for health checks
      from:
        - podSelector: {}
      ports:
        - port: 8080  # Healthz
          protocol: TCP

    # Allow Kubernetes API server to call webhook
    # IMPORTANT: Enable this when webhook is enabled with NetworkPolicy
    webhook:
      enabled: true  # Automatically enabled when webhook.enabled is true
      # Allow from all sources (API server nodes)
      # The Kubernetes API server needs to reach the webhook endpoint
      from:
        - podSelector: {}
        - namespaceSelector: {}

    # Additional custom ingress rules
    additionalRules: []
