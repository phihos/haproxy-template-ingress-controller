# Gateway API template library for HAProxy Template Ingress Controller
# Provides support for Kubernetes Gateway API v1.2.0 (gateway.networking.k8s.io/v1)
# Implements the resource_gateway_* plugin interface for the base library
#
# Full feature documentation: ../docs/gateway-api-support.md
#
# Supported resources:
# - HTTPRoute: HTTP/HTTPS routing with path matching and weighted traffic splitting
# - GRPCRoute: gRPC backend generation with HTTP/2 protocol support
#
# Key features:
# - Path matching: Exact, PathPrefix, RegularExpression (HTTPRoute only)
# - Method, header, and query parameter matching (HTTPRoute and GRPCRoute)
# - Core filters: RequestHeaderModifier, ResponseHeaderModifier, RequestRedirect, URLRewrite
# - Weighted traffic splitting: backendRefs with weights for both HTTPRoute and GRPCRoute
# - Host-based routing: Multiple hostnames per route
# - Backend deduplication: Prevents duplicate backend definitions
# - Optimized routing: Single backends use BACKEND qualifier, multiple use MULTIBACKEND
#
# Known limitations:
# - Extended filters not implemented: RequestMirror
# - GRPCRoute method-based routing not fully implemented (partial support)

watchedResources:
  httproutes:
    apiVersion: gateway.networking.k8s.io/v1
    resources: httproutes
    indexBy: ["metadata.namespace", "metadata.name"]
    enableValidationWebhook: true
    # Filter by Gateway reference using label selector
    # Users can label HTTPRoutes to target specific Gateways
    # Example: kubectl label httproute my-route gateway=haproxy

  grpcroutes:
    apiVersion: gateway.networking.k8s.io/v1
    resources: grpcroutes
    indexBy: ["metadata.namespace", "metadata.name"]
    enableValidationWebhook: true

  services:
    apiVersion: v1
    resources: services
    indexBy: ["metadata.namespace", "metadata.name"]

  endpoints:
    apiVersion: discovery.k8s.io/v1
    resources: endpointslices
    indexBy: ["metadata.namespace", "metadata.labels.kubernetes\\.io/service-name"]

templateSnippets:
  features-gateway-ssl-passthrough:
    priority: 100
    template: |
      {#-
        Gateway API SSL Passthrough Feature Registration

        Purpose:
          Scans Gateway API resources (HTTPRoute, TLSRoute) to detect SSL passthrough
          needs and registers backends with the global feature registry.

        Mechanism:
          Checks for extension references that indicate SSL passthrough requirement.
          The exact mechanism depends on how SSL passthrough is expressed in Gateway API:
          - ExtensionRef in HTTPRoute.spec.rules[].filters
          - TLSRoute resources (future support)

        Registration Format:
          {
            'name': 'ssl-passthrough-<namespace>-<name>',
            'sni': '<hostname>',
            'namespace': '<namespace>',
            'route': '<name>'
          }
      -#}
      {%- set ssl_passthrough_gateway_analysis = namespace(backends=[]) %}
      {%- compute_once ssl_passthrough_gateway_analysis %}
        {#- Scan HTTPRoutes for SSL passthrough extension refs #}
        {%- set ns = namespace(seen="") %}
        {%- for httproute in resources.httproutes.List() %}
          {%- set has_ssl_passthrough = false %}
          {#- Check if any rule has SSL passthrough filter #}
          {%- for rule in (httproute.spec.rules | default([])) %}
            {%- for filter in (rule.filters | default([])) %}
              {%- if filter.type == "ExtensionRef" %}
                {%- if filter.extensionRef.kind == "SSLPassthrough" %}
                  {%- set has_ssl_passthrough = true %}
                {%- elif filter.extensionRef.name and (filter.extensionRef.name | lower | regex_search("ssl.*passthrough")) %}
                  {%- set has_ssl_passthrough = true %}
                {%- endif %}
              {%- endif %}
            {%- endfor %}
          {%- endfor %}

          {%- if has_ssl_passthrough %}
            {#- Register each hostname as a passthrough backend #}
            {%- for hostname in (httproute.spec.hostnames | default([])) %}
              {%- if ("|" ~ hostname ~ "|") not in ns.seen %}
                {%- set ns.seen = ns.seen ~ "|" ~ hostname ~ "|" %}
                {%- set backend_name = "ssl-passthrough-" ~ httproute.metadata.namespace ~ "-" ~ httproute.metadata.name %}
                {%- set ssl_passthrough_gateway_analysis.backends =
                    ssl_passthrough_gateway_analysis.backends.append({
                      'name': backend_name,
                      'sni': hostname,
                      'namespace': httproute.metadata.namespace,
                      'route': httproute.metadata.name,
                      'route_type': 'httproute'
                    }) %}
              {%- endif %}
            {%- endfor %}
          {%- endif %}
        {%- endfor %}

        {#- TODO: Add TLSRoute support when available #}
        {#- TLSRoute is the natural Gateway API resource for SSL passthrough #}
      {%- endcompute_once %}

      {#- Register backends with global feature registry (only if SSL library is loaded) #}
      {%- if global_features.ssl_passthrough_backends is defined %}
        {%- set global_features.ssl_passthrough_backends =
            global_features.ssl_passthrough_backends + ssl_passthrough_gateway_analysis.backends %}
      {%- endif %}

  # Route analysis system - collects and analyzes all routes for conflicts
  util-analyze-routes:
    template: |
      {%- macro analyze_routes(result, resources) %}
        {#-
          Gateway API Conflict Resolution Precedence

          When multiple HTTPRoutes match the same host and path, the following
          precedence order is used to select the winning route:

          1. HTTP method specificity (routes with method matchers win over catch-all)
          2. Number of header matchers (more specific matchers win)
          3. Number of query parameter matchers (more specific matchers win)
          4. Route order (older resources / earlier rules win as tie-breaker)

          This implements Gateway API spec semantics for route precedence.

          The analyze_routes macro:
          - Collects all routes with normalized structure
          - Detects conflicts (same host + path with different matchers)
          - Builds conflict_group strings for VAR qualifier routing
          - Sorts routes by precedence order for advanced matcher generation
          - Modifies result namespace with: all_routes, path_groups, sorted_routes
        -#}
        {%- set ns_routes = namespace(all_routes=[]) %}

        {#- Process HTTPRoutes #}
        {%- for route in resources.httproutes.List() %}
          {%- for hostname in (route.spec.hostnames | default([""])) %}
            {%- set rule_counter = namespace(idx=0) %}
            {%- for rule in route.spec.rules | default([]) %}
              {%- set matches_list = rule.matches | default([]) %}
              {%- if matches_list | length == 0 %}
                {%- set matches_list = [{"path": {"type": "PathPrefix", "value": "/"}}] %}
              {%- endif %}

              {%- for match in matches_list %}
                {%- set path_value = match.path | default({"type": "PathPrefix", "value": "/"}) %}
                {%- set route_info = {
                  "route": route,
                  "hostname": hostname,
                  "rule": rule,
                  "rule_idx": rule_counter.idx,
                  "match": match,
                  "path": path_value,
                  "filters": rule.filters | default([]),
                  "is_grpc": false,
                  "resource_type": "httproute"
                } %}
                {%- set ns_routes.all_routes = ns_routes.all_routes.append(route_info) %}
              {%- endfor %}
              {#- Increment rule counter after processing all matches for this rule #}
              {%- set rule_counter.idx = rule_counter.idx + 1 %}
            {%- endfor %}
          {%- endfor %}
        {%- endfor %}

        {#- Process GRPCRoutes similarly #}
        {%- for route in resources.grpcroutes.List() %}
          {%- for hostname in (route.spec.hostnames | default([""])) %}
            {%- set rule_counter = namespace(idx=0) %}
            {%- for rule in route.spec.rules | default([]) %}
              {%- set matches_list = rule.matches | default([]) %}
              {%- if matches_list | length == 0 %}
                {%- set matches_list = [{"method": {}}] %}
              {%- endif %}

              {%- for match in matches_list %}
                {%- set route_info = {
                  "route": route,
                  "hostname": hostname,
                  "rule": rule,
                  "rule_idx": rule_counter.idx,
                  "match": match,
                  "path": {"type": "Exact", "value": "/"},
                  "filters": rule.filters | default([]),
                  "is_grpc": true,
                  "resource_type": "grpcroute"
                } %}
                {%- set ns_routes.all_routes = ns_routes.all_routes.append(route_info) %}
              {%- endfor %}
              {#- Increment rule counter after processing all matches for this rule #}
              {%- set rule_counter.idx = rule_counter.idx + 1 %}
            {%- endfor %}
          {%- endfor %}
        {%- endfor %}

        {#- Group by path key to detect conflicts #}
        {#- Manual grouping since group_by result may not iterate properly in namespace #}
        {#- MUST use namespace for mutable state - plain dicts don't persist across iterations! #}
        {%- set ns_groups = namespace(data={}) %}
        {%- for route_info in ns_routes.all_routes %}
          {%- set path_key = route_info.hostname ~ '|' ~ route_info.path.type ~ '|' ~ route_info.path.value %}
          {%- if path_key not in ns_groups.data %}
            {%- set ns_groups.data = ns_groups.data.update({path_key: []}) %}
          {%- endif %}
          {#- Get list, append with reassignment, update dict with modified list #}
          {%- set current_list = ns_groups.data[path_key] %}
          {%- set current_list = current_list.append(route_info) %}
          {%- set ns_groups.data = ns_groups.data.update({path_key: current_list}) %}
        {%- endfor %}
        {#- Check for conflicts and mark routes needing VAR qualifier #}
        {%- for path_key in ns_groups.data.keys() | list %}
          {%- set routes = ns_groups.data[path_key] %}
          {#- DEBUG CONFLICT: path_key={{ path_key }} routes_count={{ routes | length }} -#}
          {#- Check if routes in this group have different matchers #}
          {%- set ns_conflict = namespace(has_conflicts=false) %}
          {%- if routes | length > 1 %}
            {#- Build comparison key from match conditions using namespace for mutable state #}
            {%- set ns_cond_builder = namespace(first_conditions="", route_conditions="") %}
            {%- set first_match = routes[0].match %}
            {%- if first_match.method %}
              {%- set ns_cond_builder.first_conditions = ns_cond_builder.first_conditions ~ "method:" ~ first_match.method %}
            {%- endif %}
            {%- set first_headers = first_match.headers | default([]) %}
            {%- if first_headers | length > 0 %}
              {%- for idx in range(first_headers | length) %}
                {%- set header = first_headers[idx] %}
                {%- set ns_cond_builder.first_conditions = ns_cond_builder.first_conditions ~ ";header:" ~ header.name ~ "=" ~ header.value %}
              {%- endfor %}
            {%- endif %}
            {%- set first_params = first_match.queryParams | default([]) %}
            {%- if first_params | length > 0 %}
              {%- for idx in range(first_params | length) %}
                {%- set param = first_params[idx] %}
                {%- set ns_cond_builder.first_conditions = ns_cond_builder.first_conditions ~ ";param:" ~ param.name ~ "=" ~ param.value %}
              {%- endfor %}
            {%- endif %}
            {%- set first_conditions = ns_cond_builder.first_conditions %}

            {#- Check if any other route has different conditions #}
            {%- for i in range(1, routes | length) %}
              {%- set route = routes[i] %}
              {%- set ns_cond_builder.route_conditions = "" %}
              {%- set route_match = route.match %}
              {%- if route_match.method %}
                {%- set ns_cond_builder.route_conditions = ns_cond_builder.route_conditions ~ "method:" ~ route_match.method %}
              {%- endif %}
              {%- set route_headers = route_match.headers | default([]) %}
              {%- if route_headers | length > 0 %}
                {%- for idx in range(route_headers | length) %}
                  {%- set header = route_headers[idx] %}
                  {%- set ns_cond_builder.route_conditions = ns_cond_builder.route_conditions ~ ";header:" ~ header.name ~ "=" ~ header.value %}
                {%- endfor %}
              {%- endif %}
              {%- set route_params = route_match.queryParams | default([]) %}
              {%- if route_params | length > 0 %}
                {%- for idx in range(route_params | length) %}
                  {%- set param = route_params[idx] %}
                  {%- set ns_cond_builder.route_conditions = ns_cond_builder.route_conditions ~ ";param:" ~ param.name ~ "=" ~ param.value %}
                {%- endfor %}
              {%- endif %}

              {%- if first_conditions != ns_cond_builder.route_conditions %}
                {%- set ns_conflict.has_conflicts = true %}
              {%- endif %}
            {%- endfor %}
          {%- endif %}

          {#- Rebuild routes list with updated dicts (namespace copy semantics) #}
          {%- set ns_updated = namespace(routes=[]) %}
          {%- for route in routes %}
            {%- set updated_route = route.update({
              "has_conflicts": ns_conflict.has_conflicts,
              "path_key": path_key,
              "route_id": route.route.metadata.namespace ~ "_" ~ route.route.metadata.name ~ "_" ~ route.rule_idx
            }) %}
            {%- set ns_updated.routes = ns_updated.routes.append(updated_route) %}
          {%- endfor %}

          {#- Build conflict_group string #}
          {#- For conflicts: joined route_ids (e.g., "ns_route1_0__ns_route2_0") #}
          {#- For single route: just the route_id (e.g., "ns_route1_0") #}
          {%- set ns_ids = namespace(route_ids=[]) %}
          {%- for route in ns_updated.routes %}
            {%- set ns_ids.route_ids = ns_ids.route_ids.append(route.route_id) %}
          {%- endfor %}
          {%- set conflict_group = ns_ids.route_ids | join("__") %}
          {#- Add conflict_group to each route #}
          {%- set ns_final = namespace(routes=[]) %}
          {%- for route in ns_updated.routes %}
            {%- set route_with_group = route.update({"conflict_group": conflict_group}) %}
            {%- set ns_final.routes = ns_final.routes.append(route_with_group) %}
          {%- endfor %}
          {%- set ns_updated.routes = ns_final.routes %}

          {#- Update path_groups with modified routes #}
          {%- set ns_groups.data = ns_groups.data.update({path_key: ns_updated.routes}) %}
        {%- endfor %}
        {%- set path_groups = ns_groups.data %}

        {#- Rebuild all_routes from updated path_groups #}
        {%- set ns_all = namespace(routes=[]) %}
        {%- for path_key in path_groups %}
          {%- for route in path_groups[path_key] %}
            {%- set ns_all.routes = ns_all.routes.append(route) %}
          {%- endfor %}
        {%- endfor %}

        {#- Collect ALL routes for advanced matcher generation #}
        {#- Every route needs a matcher to set req.gw_rule_id, even routes without #}
        {#- method/header/query conditions (they get default matcher with just guard conditions) #}
        {%- set ns_advanced = namespace(routes=[]) %}
        {%- for route in ns_all.routes %}
          {%- set ns_advanced.routes = ns_advanced.routes.append(route) %}
        {%- endfor %}

        {%- set sorted_routes = ns_advanced.routes | sort_by([
          "$.path.type",
          "$.path.value | length:desc",
          "$.match.method:exists:desc",
          "$.match.headers | length:desc",
          "$.match.queryParams | length:desc",
          "$.route.metadata.creationTimestamp",
          "$.route.metadata.namespace ~ '/' ~ $.route.metadata.name",
          "$.rule_idx"
        ]) %}

        {#- Populate result namespace with analysis data #}
        {%- set result.path_groups = path_groups %}
        {%- set result.sorted_routes = sorted_routes %}
        {%- set result.all_routes = ns_all.routes %}
      {%- endmacro %}

  util-backend-name-gateway:
    template: >-
      {{- "" -}}gtw_{{ route.metadata.namespace }}_{{ route.metadata.name }}_{{ backend.name }}_{{ backend.port }}

  util-generate-backends-gateway:
    template: |
      {#- Macro to generate backends for Gateway API routes (HTTPRoute/GRPCRoute) #}
      {#- Deduplicates backends across all routes using shared namespace.seen tracking #}
      {#- Parameters: #}
      {#-   routes: list of routes to process (from resources.httproutes or resources.grpcroutes) #}
      {#-   proto_flag: protocol flag for default-server ("" for HTTP, "h2" for gRPC) #}
      {#-   ns: namespace object with seen="" for deduplication tracking (shared across calls) #}
      {%- macro generate_gateway_backends(routes, proto_flag, ns) -%}
      {%- for route in routes -%}
      {%- for rule in (route.spec.rules | default([])) -%}
      {%- if rule.backendRefs %}
      {%- for backendRef in rule.backendRefs -%}
      {%- set backend = {"name": backendRef.name, "port": backendRef.port} -%}
      {%- set backend_key = route.metadata.namespace ~ "_" ~ route.metadata.name ~ "_" ~ backend.name ~ "_" ~ backend.port -%}
      {%- if ("|" ~ backend_key ~ "|") not in ns.seen -%}
      {%- set ns.seen = ns.seen ~ "|" ~ backend_key ~ "|" %}
      # Backend for: {{ "HTTPRoute" if proto_flag == "" else "GRPCRoute" }} {{ route.metadata.namespace }}/{{ route.metadata.name }} â†’ Service {{ backend.name }}:{{ backend.port }}
      backend {%+ include "util-backend-name-gateway" +%}
        balance roundrobin
        default-server check{{ " proto " ~ proto_flag if proto_flag else "" }}
        {%- filter indent(2, first=True) %}
        {% include "backend-directives" %}
        {% set service_name = backend.name %}
        {% set port = backend.port %}
        {% include "util-backend-servers" %}
        {%- endfilter -%}
      {%- endif -%}
      {%- endfor -%}
      {%- endif -%}
      {%- endfor -%}
      {%- endfor -%}
      {%- endmacro -%}

  backends-gateway:
    template: |
      {#- Generate backend definitions from HTTPRoute and GRPCRoute resources #}
      {#- Implements backends-* extension point from base library #}
      {#- Deduplicates backends: one backend per unique (namespace, route, service, port) combination #}
      {#- Import backend generation macro #}
      {%- from "util-generate-backends-gateway" import generate_gateway_backends %}
      {#- Use namespace with string tracking for seen backends (shared across both route types) #}
      {%- set ns = namespace(seen="") %}
      # gateway/backends-gateway

      {#- HTTPRoute backends (HTTP protocol) #}
      {{ generate_gateway_backends(resources.httproutes.List(), "", ns) -}}
      {#- GRPCRoute backends (HTTP/2 protocol) #}
      {{- generate_gateway_backends(resources.grpcroutes.List(), "h2", ns) -}}

  backends-gateway-ssl-passthrough:
    priority: 501
    template: |
      {#-
        Gateway API SSL Passthrough Backends

        Purpose:
          TCP backends for SSL passthrough from Gateway API resources.
          Forwards encrypted traffic directly to pods without SSL termination.
          Reuses cached analysis from features-gateway-ssl-passthrough.

        Supported Resources:
          - HTTPRoute with ExtensionRef filters indicating SSL passthrough
          - TLSRoute (future support)

        Generated HAProxy Config:
          backend ssl-passthrough-<namespace>-<name>
            mode tcp
            server SRV_1 <pod-ip>:<pod-port> check
      -#}
      {#- Reuse cached analysis from features phase via compute_once #}
      {%- set ssl_passthrough_gateway_analysis = namespace(backends=[]) %}
      {%- compute_once ssl_passthrough_gateway_analysis %}
        {#- Scan HTTPRoutes for SSL passthrough extension refs #}
        {%- set ns = namespace(seen="") %}
        {%- for httproute in resources.httproutes.List() %}
          {%- set has_ssl_passthrough = false %}
          {#- Check if any rule has SSL passthrough filter #}
          {%- for rule in (httproute.spec.rules | default([])) %}
            {%- for filter in (rule.filters | default([])) %}
              {%- if filter.type == "ExtensionRef" %}
                {%- if filter.extensionRef.kind == "SSLPassthrough" %}
                  {%- set has_ssl_passthrough = true %}
                {%- elif filter.extensionRef.name and (filter.extensionRef.name | lower | regex_search("ssl.*passthrough")) %}
                  {%- set has_ssl_passthrough = true %}
                {%- endif %}
              {%- endif %}
            {%- endfor %}
          {%- endfor %}

          {%- if has_ssl_passthrough %}
            {#- Register each hostname as a passthrough backend #}
            {%- for hostname in (httproute.spec.hostnames | default([])) %}
              {%- if ("|" ~ hostname ~ "|") not in ns.seen %}
                {%- set ns.seen = ns.seen ~ "|" ~ hostname ~ "|" %}
                {%- set backend_name = "ssl-passthrough-" ~ httproute.metadata.namespace ~ "-" ~ httproute.metadata.name %}
                {%- set ssl_passthrough_gateway_analysis.backends =
                    ssl_passthrough_gateway_analysis.backends.append({
                      'name': backend_name,
                      'sni': hostname,
                      'namespace': httproute.metadata.namespace,
                      'route': httproute.metadata.name,
                      'route_type': 'httproute'
                    }) %}
              {%- endif %}
            {%- endfor %}
          {%- endif %}
        {%- endfor %}
      {%- endcompute_once %}

      {%- set ns = namespace(processed="") %}
      {%- for backend_info in ssl_passthrough_gateway_analysis.backends %}
        {%- set route_key = backend_info.namespace ~ "/" ~ backend_info.route %}
        {%- if ("|" ~ route_key ~ "|") not in ns.processed %}
          {%- set ns.processed = ns.processed ~ "|" ~ route_key ~ "|" %}
          {#- Get the actual HTTPRoute resource to extract service details #}
          {%- if backend_info.route_type == "httproute" %}
            {%- set route = resources.httproutes.GetSingle(backend_info.namespace, backend_info.route) %}
            {%- set ns_backend = namespace(generated=false) %}
            {%- for rule in (route.spec.rules | default([])) %}
              {%- if not ns_backend.generated %}
                {%- for backendRef in (rule.backendRefs | default([])) %}
                  {%- if not ns_backend.generated %}
                    {%- set service_name = backendRef.name %}
                    {%- set port = backendRef.port | default(80) %}
      # gateway/backends-gateway-ssl-passthrough

      backend {{ backend_info.name }}
          mode tcp
          balance roundrobin
                    {%- filter indent(8, first=False) -%}
                    {%- include "util-backend-servers" -%}
                    {%- endfilter %}
                    {%- set ns_backend.generated = true %}
                  {%- endif %}
                {%- endfor %}
              {%- endif %}
            {%- endfor %}
          {%- endif %}
        {%- endif %}
      {%- endfor %}

  util-path-map-entry-gateway:
    template: |
      {#- Generate HTTPRoute path matching map entries with qualifiers #}
      {#- Single backend: BACKEND:<backend_name> #}
      {#- Multiple backends: MULTIBACKEND:<total_weight>:<route_key> #}
      {#- Conflicting paths: GW_ROUTE_ID:<route_type>:<route_ids> #}
      {#- Usage: {% include "util-path-map-entry-gateway" with context %} where path_type = "Exact" or "PathPrefix" #}
      # gateway/util-path-map-entry-gateway

      {#- Compute route analysis once per render (cached across all includes) #}
      {%- set analysis = namespace(path_groups={}, sorted_routes=[], all_routes=[]) %}
      {%- compute_once analysis %}
        {%- from "util-analyze-routes" import analyze_routes %}
        {{- analyze_routes(analysis, resources) -}}
      {%- endcompute_once %}

      {#- Iterate over all routes in precedence order (sorted_routes contains all routes) #}
      {%- set ns_seen = namespace(paths="") %}
      {%- for route_info in analysis.sorted_routes %}
        {%- set path_key = route_info.hostname ~ '|' ~ route_info.path.type ~ '|' ~ route_info.path.value %}
        {%- if ("|" ~ path_key ~ "|") not in ns_seen.paths %}
          {%- set ns_seen.paths = ns_seen.paths ~ "|" ~ path_key ~ "|" %}
          {%- set routes = analysis.path_groups[path_key] %}
          {%- set first_route = routes[0] %}
        {#- Only process routes matching the current path_type #}
        {%- if first_route.path and first_route.path.type == path_type %}
          {#- Always use GW_ROUTE_ID qualifier for all Gateway API routes #}
          {#- NOTE: Do NOT append suffix to GW_ROUTE_ID qualifier - it would break advanced matcher string matching #}
          {%- set ns_ids = namespace(route_ids=[]) %}
          {%- for route_info in routes %}
            {%- set ns_ids.route_ids = ns_ids.route_ids.append(route_info.route_id) %}
          {%- endfor %}
          {%- set route_ids_str = ns_ids.route_ids | join("__") -%}
      {{ "\n" }}{{ first_route.hostname }}{{ first_route.path.value }} GW_ROUTE_ID:{{ first_route.resource_type | replace("httproute", "http") | replace("grpcroute", "grpc") }}:{{ route_ids_str }}
        {%- endif %}
        {%- endif %}
      {%- endfor %}

  util-generate-host-map-gateway:
    template: |
      {#- Macro to generate host map entries for Gateway API routes #}
      {#- Parameters: #}
      {#-   routes: list of routes to process (from resources.httproutes or resources.grpcroutes) #}
      {#-   route_type: route type name for comments ("HTTPRoute" or "GRPCRoute") #}
      {%- macro generate_host_map(routes, route_type) -%}
      {%- for route in routes %}
      {%- set hostnames = route.spec.hostnames | default([]) %}
      {%- if hostnames | length > 0 %}
      # {{ route_type }}: {{ route.metadata.namespace }}/{{ route.metadata.name }} ({{ hostnames | length }} hosts)
      {% for hostname in hostnames %}
      {{ hostname }} {{ hostname }}
      {%- endfor %}
      {%- endif %}
      {%- endfor %}
      {%- endmacro -%}

  map-host-gateway:
    template: |
      {#- Generate host map entries for Gateway API routes #}
      {%- from "util-generate-host-map-gateway" import generate_host_map %}
      # gateway/map-host-gateway
      {{- generate_host_map(resources.httproutes.List(), "HTTPRoute") -}}
      {{- generate_host_map(resources.grpcroutes.List(), "GRPCRoute") -}}

  map-path-exact-gateway:
    template: |
      {#- Generate exact path map entries for HTTPRoute #}
      # gateway/map-path-exact-gateway
      {% set path_type = "Exact" %}
      {%- set suffix = "" %}
      {% include "util-path-map-entry-gateway" %}

  map-path-prefix-exact-gateway:
    template: |
      {#- Generate prefix-exact path map entries for HTTPRoute #}
      # gateway/map-path-prefix-exact-gateway
      {% set path_type = "PathPrefix" %}
      {%- set suffix = "" %}
      {% include "util-path-map-entry-gateway" %}

  map-path-prefix-gateway:
    template: |
      {#- Generate prefix path map entries with trailing slash for HTTPRoute #}
      # gateway/map-path-prefix-gateway
      {% set path_type = "PathPrefix" %}
      {%- set suffix = "/" %}
      {% include "util-path-map-entry-gateway" %}

  map-path-regex-gateway:
    template: |
      {#- Generate regex path map entries for HTTPRoute with RegularExpression type #}
      # gateway/map-path-regex-gateway
      {%- for route in resources.httproutes.List() %}
      {#- Count regex path entries for this route -#}
      {%- set ns_outer = namespace(entry_count=0) %}
      {%- for hostname in (route.spec.hostnames | default([""])) %}
        {%- for rule in (route.spec.rules | default([])) %}
          {%- if rule.backendRefs %}
            {%- for match in (rule.matches | default([{}])) %}
              {%- if match.path and match.path.type == "RegularExpression" %}
                {%- set ns_outer.entry_count = ns_outer.entry_count + 1 %}
              {%- endif %}
            {%- endfor %}
          {%- endif %}
        {%- endfor %}
      {%- endfor %}
      {%- if ns_outer.entry_count > 0 %}
      # HTTPRoute: {{ route.metadata.namespace }}/{{ route.metadata.name }} ({{ ns_outer.entry_count }} regex paths)
      {%- endif %}
      {%- for hostname in (route.spec.hostnames | default([""])) %}
      {%- for rule in (route.spec.rules | default([])) %}
      {%- if rule.backendRefs %}
      {%- set first_backend = rule.backendRefs[0] %}
      {%- set backend = {"name": first_backend.name, "port": first_backend.port} %}
      {%- for match in (rule.matches | default([{}])) %}
      {%- if match.path and match.path.type == "RegularExpression" %}
      {{ hostname }}{{ match.path.value | default("/") }} {% include "util-backend-name-gateway" %}
      {% endif %}
      {%- endfor %}
      {%- endif %}
      {%- endfor %}
      {%- endfor %}
      {%- endfor %}

  map-weighted-backend-gateway:
    template: |
      {#- Generate expanded weighted backend entries for HTTPRoute #}
      {#- Format: <random_number>:<route_key> <backend_name> #}
      {#- Each weight N generates N consecutive entries pointing to same backend #}
      {#- This allows O(1) weighted selection via single map lookup #}
      # gateway/map-weighted-backend-gateway

      {%- for route in resources.httproutes.List() %}
      {#- Count weighted rules for this route -#}
      {%- set weighted_rules = [] %}
      {%- for rule in (route.spec.rules | default([])) %}
        {%- if rule.backendRefs and (rule.backendRefs | length) > 1 %}
          {%- set _ = weighted_rules.append(rule) %}
        {%- endif %}
      {%- endfor %}
      {%- if weighted_rules | length > 0 %}
      # HTTPRoute: {{ route.metadata.namespace }}/{{ route.metadata.name }} ({{ weighted_rules | length }} weighted rules)
      {% endif %}
      {%- set rule_counter = namespace(idx=0) %}
      {% for rule in (route.spec.rules | default([])) %}
        {%- if rule.backendRefs and (rule.backendRefs | length) > 1 %}

          {%- set route_key = route.metadata.namespace ~ "_" ~ route.metadata.name ~ "_" ~ rule_counter.idx %}
          {%- set ns = namespace(cumulative=0) %}

          {%- for backendRef in rule.backendRefs %}
            {%- set backend = {"name": backendRef.name, "port": backendRef.port} %}
            {%- set weight = backendRef.weight | default(1) %}

            {#- Generate <weight> consecutive entries for this backend -#}
            {%- for i in range(ns.cumulative, ns.cumulative + weight) -%}
      {{ i }}:{{ route_key }} {{ "" }}{% include "util-backend-name-gateway" %}{{ "\n" -}}
            {%- endfor %}

            {%- set ns.cumulative = ns.cumulative + weight %}
          {%- endfor %}

        {%- endif %}
        {#- Increment rule counter after each rule #}
        {%- set rule_counter.idx = rule_counter.idx + 1 %}
      {%- endfor %}
      {%- endfor %}

  # Advanced matcher setup - processes GW_ROUTE_ID qualifier (runs early via priority)
  frontend-matchers-advanced-gateway-route-id-setup:
    priority: 10
    template: |
      {#- Process GW_ROUTE_ID qualifier to extract route type and route ID #}
      {#- Format: GW_ROUTE_ID:<route_type>:<route_ids> #}
      {#- Example: GW_ROUTE_ID:http:ns1_route1_0__ns2_route2_1 #}
      {#- This runs early (priority 10) to set variables used by later matchers #}
      # gateway/frontend-matchers-advanced-gateway-route-id-setup
      http-request set-var(req.gw_route_type) var(txn.path_match),field(2,:) if { var(txn.path_match),field(1,:) -m str GW_ROUTE_ID }
      http-request set-var(req.gw_route_id) var(txn.path_match),field(3,:) if { var(txn.path_match),field(1,:) -m str GW_ROUTE_ID }

  # Advanced matcher generator - creates http-request statements for method/header/query matching
  frontend-matchers-advanced-gateway:
    template: |
      {#- Generate http-request statements for routes with advanced matchers #}
      {#- This is injected into base template via the advanced-matcher-* extension point #}
      # gateway/advanced-matcher-gateway

      {%- from "util-regex-sanitize" import sanitize_regex %}

      {#- Compute route analysis once per render (cached across all includes) #}
      {%- set analysis = namespace(path_groups={}, sorted_routes=[], all_routes=[]) %}
      {%- compute_once analysis %}
        {%- from "util-analyze-routes" import analyze_routes %}
        {{- analyze_routes(analysis, resources) -}}
      {%- endcompute_once %}

      {%- if analysis.sorted_routes | length > 0 %}
      # Advanced route matching (method/header/query)
      {%- for route_info in analysis.sorted_routes %}
        {#- Early exit: skip if another matcher already won #}
        {%- set ns_cond = namespace(conditions=['!{ var(req.gw_rule_id) -m found }']) %}

        {#- Only run matcher if this route was matched by the map #}
        {%- set ns_cond.conditions = ns_cond.conditions.append('{ var(req.gw_route_id) -m str "' ~ route_info.conflict_group ~ '" }') %}

        {#- Method matcher (HTTPRoute only) #}
        {%- if route_info.match.method and route_info.resource_type == "httproute" %}
          {%- set ns_cond.conditions = ns_cond.conditions.append('{ method ' ~ route_info.match.method ~ ' }') %}
        {%- endif %}

        {#- Header matchers #}
        {%- for header in (route_info.match.headers | default([])) %}
          {%- if header.type == "Exact" %}
            {%- set ns_cond.conditions = ns_cond.conditions.append('{ req.hdr(' ~ header.name ~ ') "' ~ header.value ~ '" }') %}
          {%- elif header.type == "RegularExpression" %}
            {%- set ns_cond.conditions = ns_cond.conditions.append('{ req.hdr(' ~ header.name ~ ') -m reg "' ~ sanitize_regex(header.value) ~ '" }') %}
          {%- endif %}
        {%- endfor %}

        {#- Query parameter matchers (HTTPRoute only) #}
        {%- for param in (route_info.match.queryParams | default([])) %}
          {%- if param.type == "Exact" %}
            {%- set ns_cond.conditions = ns_cond.conditions.append('{ urlp(' ~ param.name ~ ') "' ~ param.value ~ '" }') %}
          {%- elif param.type == "RegularExpression" %}
            {%- set ns_cond.conditions = ns_cond.conditions.append('{ urlp(' ~ param.name ~ ') -m reg "' ~ sanitize_regex(param.value) ~ '" }') %}
          {%- endif %}
        {%- endfor %}

        {#- GRPCRoute method matcher #}
        {%- if route_info.is_grpc and route_info.match.method %}
          {#- Build gRPC method path #}
          {%- set grpc_path = "" %}
          {%- if route_info.match.method.service %}
            {%- set grpc_path = "/" ~ route_info.match.method.service %}
            {%- if route_info.match.method.method %}
              {%- set grpc_path = grpc_path ~ "/" ~ route_info.match.method.method %}
            {%- endif %}
            {#- Match against :path header which contains gRPC method #}
            {%- if route_info.match.method.type == "Exact" %}
              {%- set ns_cond.conditions = ns_cond.conditions.append('{ req.hdr(:path) "' ~ grpc_path ~ '" }') %}
            {%- elif route_info.match.method.type == "RegularExpression" %}
              {%- set ns_cond.conditions = ns_cond.conditions.append('{ req.hdr(:path) -m reg "' ~ sanitize_regex(grpc_path) ~ '" }') %}
            {%- endif %}
          {%- endif %}
        {%- endif %}
        {%- set conditions = ns_cond.conditions %}

        {#- Set req.gw_rule_id to mark this rule as winner #}
        {%- if conditions %}
          {#- Build matcher type description for provenance comment #}
          {%- set ns_types = namespace(desc=[]) %}
          {%- if route_info.match.method and route_info.resource_type == "httproute" %}
            {%- set ns_types.desc = ns_types.desc.append("method " ~ route_info.match.method) %}
          {%- endif %}
          {%- if route_info.match.headers %}
            {%- set ns_types.desc = ns_types.desc.append(route_info.match.headers | length ~ " headers") %}
          {%- endif %}
          {%- if route_info.match.queryParams %}
            {%- set ns_types.desc = ns_types.desc.append(route_info.match.queryParams | length ~ " query params") %}
          {%- endif %}
          {%- if route_info.is_grpc and route_info.match.method %}
            {%- set ns_types.desc = ns_types.desc.append("gRPC method") %}
          {%- endif %}
          {%- set matcher_desc = (ns_types.desc | join(", ")) | default("path-only") %}
      # Rule: {{ route_info.resource_type | title }} {{ route_info.route.metadata.namespace }}/{{ route_info.route.metadata.name }} rule[{{ route_info.rule_idx }}] - {{ matcher_desc }}
      http-request set-var(req.gw_rule_id) str({{ route_info.route_id }}) if {{ conditions | join(" ") }}
          {#- Debug headers if enabled #}
          {%- if debug | default(false) %}
            {#- Build detailed match reason #}
            {%- set ns_match = namespace(types=[]) %}
            {%- if route_info.match.method and route_info.resource_type == "httproute" %}
              {%- set ns_match.types = ns_match.types.append("method") %}
            {%- endif %}
            {%- if route_info.match.headers %}
              {%- set ns_match.types = ns_match.types.append("header") %}
            {%- endif %}
            {%- if route_info.match.queryParams %}
              {%- set ns_match.types = ns_match.types.append("query") %}
            {%- endif %}
            {%- if route_info.is_grpc and route_info.match.method %}
              {%- set ns_match.types = ns_match.types.append("grpc-method") %}
            {%- endif %}
            {%- set match_types_str = (ns_match.types | join("+")) | default("advanced") %}
      http-request set-var(txn.matched_route) str({{ route_info.route.metadata.namespace }}/{{ route_info.route.metadata.name }}/rule{{ route_info.rule_idx }}) if {{ conditions | join(" ") }}
      http-request set-var(txn.match_reason) str({{ match_types_str }}) if {{ conditions | join(" ") }}
          {%- endif %}
        {%- endif %}
      {%- endfor %}
      {%- endif %}

  # Path match setting - sets txn.path_match based on winning rule ID
  frontend-matchers-advanced-gateway-path-match:
    priority: 900
    template: |
      {#- Set txn.path_match for backend selection based on winning rule #}
      {#- Runs after frontend-matchers-advanced-gateway sets req.gw_rule_id (priority ensures late ordering) #}
      # gateway/frontend-matchers-advanced-gateway-path-match

      {%- set analysis = namespace(path_groups={}, sorted_routes=[], all_routes=[]) %}
      {%- compute_once analysis %}
        {%- from "util-analyze-routes" import analyze_routes %}
        {{- analyze_routes(analysis, resources) -}}
      {%- endcompute_once %}

      {%- if analysis.all_routes | length > 0 %}
      # Set txn.path_match for backend selection based on req.gw_rule_id
      {%- for route_info in analysis.all_routes %}
        {%- if route_info.rule.backendRefs %}
          {%- if (route_info.rule.backendRefs | length) == 1 %}
            {#- Single backend: BACKEND qualifier #}
            {%- set backend_ref = route_info.rule.backendRefs[0] %}
            {%- set backend_name = "gtw_" ~ route_info.route.metadata.namespace ~ "_" ~ route_info.route.metadata.name ~ "_" ~ backend_ref.name ~ "_" ~ backend_ref.port %}
            {%- set qualifier = "BACKEND:" ~ backend_name %}
          {%- else %}
            {#- Multiple backends: MULTIBACKEND qualifier #}
            {%- set ns = namespace(total_weight=0) %}
            {%- for ref in route_info.rule.backendRefs %}
              {%- set ns.total_weight = ns.total_weight + (ref.weight | default(1)) %}
            {%- endfor %}
            {%- set route_key = route_info.route.metadata.namespace ~ "_" ~ route_info.route.metadata.name ~ "_" ~ route_info.rule_idx %}
            {%- set qualifier = "MULTIBACKEND:" ~ ns.total_weight ~ ":" ~ route_key %}
          {%- endif %}
      http-request set-var(txn.path_match) str({{ qualifier }}) if { var(req.gw_rule_id) -m str "{{ route_info.route_id }}" }
        {%- endif -%}
      {%- endfor -%}
      {%- endif -%}
  # Filter: RequestHeaderModifier - modifies request headers before backend selection
  frontend-filters-gateway-request-header:
    template: |
      {#- Generate http-request header modification statements #}
      {#- This is injected into base template via the frontend-filters-* extension point #}
      {#- Runs AFTER routing decisions, BEFORE backend selection #}
      {%- from "util-regex-sanitize" import sanitize_regex -%}
      {#- Compute route analysis once per render (cached across all includes) #}
      {%- set analysis = namespace(path_groups={}, sorted_routes=[], all_routes=[]) -%}
      {%- compute_once analysis -%}
        {%- from "util-analyze-routes" import analyze_routes -%}
        {{- analyze_routes(analysis, resources) -}}
      {%- endcompute_once -%}

      {#- Process all routes that have RequestHeaderModifier filters #}
      {%- set ns_has_filters = namespace(found=false) -%}
      {%- for route_info in analysis.all_routes -%}
        {%- for filter in route_info.filters -%}
          {%- if filter.type == "RequestHeaderModifier" -%}
            {%- set ns_has_filters.found = true -%}
          {%- endif -%}
        {%- endfor -%}
      {%- endfor -%}

      {%- if ns_has_filters.found %}
      # gateway/frontend-filters-gateway-request-header
      # RequestHeaderModifier filters
      {%- for route_info in analysis.all_routes %}
        {%- for filter in route_info.filters %}
          {%- if filter.type == "RequestHeaderModifier" %}
            {#- Simple route ID check - all condition evaluation done by advanced matchers #}
            {%- set conditions = ['{ var(req.gw_rule_id) -m str "' ~ route_info.route_id ~ '" }'] %}
            {#- Generate header modification statements #}
            {%- if filter.requestHeaderModifier %}
              {#- Set headers (replace if exists) #}
              {%- for header in (filter.requestHeaderModifier.set | default([])) %}
      http-request set-header {{ header.name }} "{{ header.value }}" if {{ conditions | join(" ") }}
              {%- endfor %}

              {#- Add headers (append if exists) #}
              {%- for header in (filter.requestHeaderModifier.add | default([])) %}
      http-request add-header {{ header.name }} "{{ header.value }}" if {{ conditions | join(" ") }}
              {%- endfor %}

              {#- Remove headers #}
              {%- for header_name in (filter.requestHeaderModifier.remove | default([])) %}
      http-request del-header {{ header_name }} if {{ conditions | join(" ") }}
              {%- endfor %}

              {#- Debug: track filter application #}
              {%- if debug | default(false) %}
      http-request set-var(txn.filters_applied) str(RequestHeaderModifier) if {{ conditions | join(" ") }} !{ var(txn.filters_applied) -m found }
              {%- endif %}
            {%- endif %}
          {%- endif %}
        {%- endfor %}
      {%- endfor -%}
      {%- endif -%}
  # Filter: ResponseHeaderModifier - modifies response headers before sending to client
  frontend-filters-gateway-response-header:
    template: |
      {#- Generate http-response header modification statements #}
      {#- This is injected into base template via the frontend-filters-* extension point #}
      {#- Runs AFTER routing decisions, BEFORE backend selection #}
      {%- from "util-regex-sanitize" import sanitize_regex -%}
      {#- Compute route analysis once per render (cached across all includes) #}
      {%- set analysis = namespace(path_groups={}, sorted_routes=[], all_routes=[]) -%}
      {%- compute_once analysis -%}
        {%- from "util-analyze-routes" import analyze_routes -%}
        {{- analyze_routes(analysis, resources) -}}
      {%- endcompute_once -%}

      {#- Process all routes that have ResponseHeaderModifier filters #}
      {%- set ns_has_filters = namespace(found=false) -%}
      {%- for route_info in analysis.all_routes -%}
        {%- for filter in route_info.filters -%}
          {%- if filter.type == "ResponseHeaderModifier" -%}
            {%- set ns_has_filters.found = true -%}
          {%- endif -%}
        {%- endfor -%}
      {%- endfor -%}

      {%- if ns_has_filters.found %}
      # ResponseHeaderModifier filters
      {%- for route_info in analysis.all_routes %}
        {%- for filter in route_info.filters %}
          {%- if filter.type == "ResponseHeaderModifier" %}
            {#- Simple route ID check - all condition evaluation done by advanced matchers #}
            {%- set conditions = ['{ var(req.gw_rule_id) -m str "' ~ route_info.route_id ~ '" }'] %}

            {#- Generate response header modification statements #}
            {%- if filter.responseHeaderModifier %}
              {#- Debug: track filter application (must be http-request for txn variables) #}
              {%- if debug | default(false) %}
      http-request set-var(txn.filters_applied) str(ResponseHeaderModifier) if {{ conditions | join(" ") }} !{ var(txn.filters_applied) -m found }
              {%- endif %}

              {#- Set headers (replace if exists) #}
              {%- for header in (filter.responseHeaderModifier.set | default([])) %}
      http-response set-header {{ header.name }} "{{ header.value }}" if {{ conditions | join(" ") }}
              {%- endfor %}

              {#- Add headers (append if exists) #}
              {%- for header in (filter.responseHeaderModifier.add | default([])) %}
      http-response add-header {{ header.name }} "{{ header.value }}" if {{ conditions | join(" ") }}
              {%- endfor %}

              {#- Remove headers #}
              {%- for header_name in (filter.responseHeaderModifier.remove | default([])) %}
      http-response del-header {{ header_name }} if {{ conditions | join(" ") }}
              {%- endfor %}
            {%- endif %}
          {%- endif %}
        {%- endfor %}
      {%- endfor -%}
      {%- endif -%}
  # Filter: RequestRedirect - redirects requests to different locations
  frontend-filters-gateway-redirect:
    template: |
      {#- Generate http-request redirect statements #}
      {#- This is injected into base template via the frontend-filters-* extension point #}
      {#- Runs AFTER routing decisions, BEFORE backend selection #}
      {%- from "util-regex-sanitize" import sanitize_regex -%}
      {#- Compute route analysis once per render (cached across all includes) #}
      {%- set analysis = namespace(path_groups={}, sorted_routes=[], all_routes=[]) -%}
      {%- compute_once analysis -%}
        {%- from "util-analyze-routes" import analyze_routes -%}
        {{- analyze_routes(analysis, resources) -}}
      {%- endcompute_once -%}

      {#- Process all routes that have RequestRedirect filters #}
      {%- set ns_has_filters = namespace(found=false) -%}
      {%- for route_info in analysis.all_routes -%}
        {%- for filter in route_info.filters -%}
          {%- if filter.type == "RequestRedirect" and route_info.resource_type == "httproute" -%}
            {%- set ns_has_filters.found = true -%}
          {%- endif -%}
        {%- endfor -%}
      {%- endfor -%}

      {%- if ns_has_filters.found %}
      # gateway/frontend-filters-gateway-redirect
      # RequestRedirect filters
      {%- for route_info in analysis.all_routes %}
        {%- for filter in route_info.filters %}
          {%- if filter.type == "RequestRedirect" and route_info.resource_type == "httproute" %}
            {#- Simple route ID check - all condition evaluation done by advanced matchers #}
            {%- set conditions = ['{ var(req.gw_rule_id) -m str "' ~ route_info.route_id ~ '" }'] %}
            {#- Build redirect directive #}
            {%- if filter.requestRedirect %}
              {%- set redirect = filter.requestRedirect %}
              {%- set status_code = redirect.statusCode | default(302) %}
              {#- Build redirect location components #}
              {%- set ns_redir = namespace(parts=[]) %}
              {#- Scheme #}
              {%- if redirect.scheme %}
                {%- set ns_redir.parts = ns_redir.parts.append("scheme " ~ redirect.scheme) %}
              {%- endif %}

              {#- Path modification #}
              {%- if redirect.path %}
                {%- if redirect.path.type == "ReplaceFullPath" %}
                  {#- Full path replacement: use location with scheme://host:port/newpath #}
                  {%- set scheme = redirect.scheme | default("http") %}
                  {%- set hostname = redirect.hostname | default("%[req.hdr(Host)]") %}
                  {%- set port = redirect.port | default("") %}
                  {%- if port %}
                    {%- set location = scheme ~ "://" ~ hostname ~ ":" ~ port ~ redirect.path.replaceFullPath %}
                  {%- else %}
                    {%- set location = scheme ~ "://" ~ hostname ~ redirect.path.replaceFullPath %}
                  {%- endif %}
                  {%- set ns_redir.parts = ns_redir.parts.append('location "' ~ location ~ '"') %}
                {%- elif redirect.path.type == "ReplacePrefixMatch" %}
                  {#- Prefix replacement: use prefix #}
                  {%- set ns_redir.parts = ns_redir.parts.append('prefix "' ~ redirect.path.replacePrefixMatch ~ '"') %}
                {%- endif %}
              {%- elif redirect.hostname or redirect.port %}
                {#- Hostname/port change without path modification: construct full location #}
                {%- set scheme = redirect.scheme | default("http") %}
                {%- set hostname = redirect.hostname | default("%[req.hdr(Host)]") %}
                {%- set port = redirect.port | default("") %}
                {%- if port %}
                  {%- set location = scheme ~ "://" ~ hostname ~ ":" ~ port ~ "%[path]" %}
                {%- else %}
                  {%- set location = scheme ~ "://" ~ hostname ~ "%[path]" %}
                {%- endif %}
                {%- set ns_redir.parts = ns_redir.parts.append('location "' ~ location ~ '"') %}
              {%- endif %}

              {#- Status code #}
              {%- set ns_redir.parts = ns_redir.parts.append("code " ~ status_code) %}

              {#- Debug: track filter application #}
              {%- if debug | default(false) %}
      http-request set-var(txn.filters_applied) str(RequestRedirect) if {{ conditions | join(" ") }} !{ var(txn.filters_applied) -m found }
              {%- endif %}

              {#- Generate redirect directive #}
      http-request redirect {{ ns_redir.parts | join(" ") }} if {{ conditions | join(" ") }}
            {%- endif %}
          {%- endif %}
        {%- endfor %}
      {%- endfor -%}
      {%- endif -%}
  # Filter: URLRewrite - rewrites request URLs before sending to backend
  frontend-filters-gateway-urlrewrite:
    template: |
      {#- Generate http-request URL rewrite statements #}
      {#- This is injected into base template via the frontend-filters-* extension point #}
      {#- Runs AFTER routing decisions, BEFORE backend selection #}
      {%- from "util-regex-sanitize" import sanitize_regex -%}
      {#- Compute route analysis once per render (cached across all includes) #}
      {%- set analysis = namespace(path_groups={}, sorted_routes=[], all_routes=[]) -%}
      {%- compute_once analysis -%}
        {%- from "util-analyze-routes" import analyze_routes -%}
        {{- analyze_routes(analysis, resources) -}}
      {%- endcompute_once -%}

      {#- Process all routes that have URLRewrite filters #}
      {%- set ns_has_filters = namespace(found=false) -%}
      {%- for route_info in analysis.all_routes -%}
        {%- for filter in route_info.filters -%}
          {%- if filter.type == "URLRewrite" and route_info.resource_type == "httproute" -%}
            {%- set ns_has_filters.found = true -%}
          {%- endif -%}
        {%- endfor -%}
      {%- endfor -%}

      {%- if ns_has_filters.found %}
      # gateway/frontend-filters-gateway-urlrewrite
      # URLRewrite filters
      {%- for route_info in analysis.all_routes %}
        {%- for filter in route_info.filters %}
          {%- if filter.type == "URLRewrite" and route_info.resource_type == "httproute" %}
            {#- Simple route ID check - all condition evaluation done by advanced matchers #}
            {%- set conditions = ['{ var(req.gw_rule_id) -m str "' ~ route_info.route_id ~ '" }'] %}

            {#- Apply URL rewrite directives #}
            {%- if filter.urlRewrite %}
              {%- set rewrite = filter.urlRewrite %}
              {#- Debug: track filter application #}
              {%- if debug | default(false) %}
      http-request set-var(txn.filters_applied) str(URLRewrite) if {{ conditions | join(" ") }} !{ var(txn.filters_applied) -m found }
              {%- endif %}
              {#- Hostname rewrite #}
              {%- if rewrite.hostname %}
      http-request set-header Host "{{ rewrite.hostname }}" if {{ conditions | join(" ") }}
              {%- endif %}
              {#- Path rewrite #}
              {%- if rewrite.path %}
                {%- if rewrite.path.type == "ReplaceFullPath" %}
      http-request set-path "{{ rewrite.path.replaceFullPath }}" if {{ conditions | join(" ") }}
                {%- elif rewrite.path.type == "ReplacePrefixMatch" %}
                  {#- For prefix replacement, use replace-path to substitute the matched prefix #}
                  {#- Match the route's path prefix and replace with new prefix #}
                  {%- set original_prefix = route_info.path.value %}
                  {%- set new_prefix = rewrite.path.replacePrefixMatch %}
                  {#- Escape regex special chars in original prefix for matching #}
                  {%- set regex_prefix = original_prefix | replace(".", "\\.") | replace("/", "\\/") %}
      http-request replace-path "^{{ regex_prefix }}(.*)" "{{ new_prefix }}\\1" if {{ conditions | join(" ") }}
                {%- endif %}
              {%- endif %}
            {%- endif %}
          {%- endif %}
        {%- endfor %}
      {%- endfor -%}
      {%- endif -%}
validationTests:
  test-httproute-duplicate-backend-different-ports:
    description: HTTPRoute with multiple rules to same service but different ports (tests deduplication)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-svc
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
              - name: admin
                port: 81
                targetPort: 8081
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-svc-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-svc
          endpoints:
            - addresses: ["10.0.0.1"]
              targetRef:
                name: api-pod-1
          ports:
            - port: 8080
            - port: 8081
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: multi-port
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                backendRefs:
                  - name: api-svc
                    port: 80
              - matches:
                  - path:
                      type: PathPrefix
                      value: /admin
                backendRefs:
                  - name: api-svc
                    port: 81
              - matches:
                  - path:
                      type: PathPrefix
                      value: /app
                backendRefs:
                  - name: api-svc
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_multi-port_api-svc_80"
        description: Must generate backend for port 80

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_multi-port_api-svc_81"
        description: Must generate backend for port 81

      - type: match_count
        target: haproxy.cfg
        pattern: "(?m)^backend gtw_default_multi-port_api-svc_"
        expected: "2"
        description: Must generate exactly 2 backends (deduplication test)

  test-grpcroute-duplicate-backend-different-ports:
    description: GRPCRoute with multiple rules to same service but different ports (tests deduplication)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-svc
            namespace: default
          spec:
            ports:
              - name: grpc
                port: 9090
                targetPort: 9090
              - name: grpc-admin
                port: 9091
                targetPort: 9091
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-svc-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-svc
          endpoints:
            - addresses: ["10.0.0.2"]
              targetRef:
                name: grpc-pod-1
          ports:
            - port: 9090
            - port: 9091
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: multi-port
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - grpc.example.com
            rules:
              - matches:
                  - method:
                      type: Exact
                      service: com.example.API
                      method: Method1
                backendRefs:
                  - name: grpc-svc
                    port: 9090
              - matches:
                  - method:
                      type: Exact
                      service: com.example.Admin
                      method: Method1
                backendRefs:
                  - name: grpc-svc
                    port: 9091
              - matches:
                  - method:
                      type: Exact
                      service: com.example.App
                      method: Method1
                backendRefs:
                  - name: grpc-svc
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_multi-port_grpc-svc_9090"
        description: Must generate backend for port 9090

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_multi-port_grpc-svc_9091"
        description: Must generate backend for port 9091

      - type: match_count
        target: haproxy.cfg
        pattern: "(?m)^backend gtw_default_multi-port_grpc-svc_"
        expected: "2"
        description: Must generate exactly 2 backends (deduplication test)

  test-httproute-weight-two-backends:
    description: HTTPRoute with two weighted backends (70/30 split)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v1
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v2
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v1
          endpoints:
            - addresses: ["10.0.1.1"]
              targetRef:
                name: app-v1-pod-1
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v2
          endpoints:
            - addresses: ["10.0.2.1"]
              targetRef:
                name: app-v2-pod-1
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: split-route
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - split.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /app
                backendRefs:
                  - name: app-v1
                    port: 80
                    weight: 70
                  - name: app-v2
                    port: 80
                    weight: 30
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_split-route_app-v1_80"
        description: Must generate backend for app-v1

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_split-route_app-v2_80"
        description: Must generate backend for app-v2

      - type: contains
        target: map:path-prefix.map
        pattern: "split.example.com/app GW_ROUTE_ID:http:default_split-route_0"
        description: Path map must use GW_ROUTE_ID qualifier

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "0:default_split-route_0 gtw_default_split-route_app-v1_80"
        description: Weighted map must contain first entry for v1

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "69:default_split-route_0 gtw_default_split-route_app-v1_80"
        description: Weighted map must contain last entry for v1 (weight 70 = entries 0-69)

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "70:default_split-route_0 gtw_default_split-route_app-v2_80"
        description: Weighted map must contain first entry for v2

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "99:default_split-route_0 gtw_default_split-route_app-v2_80"
        description: Weighted map must contain last entry for v2 (weight 30 = entries 70-99)

      - type: not_contains
        target: map:weighted-multi-backend.map
        pattern: "0:default_split-route_0 gtw_default_split-route_app-v1_801:default_split-route_0"
        description: Entries must be on separate lines (not concatenated)

      - type: not_contains
        target: map:weighted-multi-backend.map
        pattern: "69:default_split-route_0 gtw_default_split-route_app-v1_8070:default_split-route_0"
        description: Boundary entries (v1 end / v2 start) must be on separate lines

      # Map Formatting Tests - Ensure comments don't concatenate with entries
      - type: not_contains
        target: map:host.map
        pattern: "hosts\\)\\S"
        description: Host map comments must not concatenate with entries (Gateway API)

      - type: not_contains
        target: map:path-prefix.map
        pattern: "paths\\)\\S"
        description: Path prefix map comments must not concatenate with entries (Gateway API)

      - type: not_contains
        target: map:weighted-multi-backend.map
        pattern: "rules\\)\\S"
        description: Weighted map comments must not concatenate with entries

      - type: contains
        target: map:host.map
        pattern: "(?m)^split\\.example\\.com split\\.example\\.com$"
        description: Host map entries must start at beginning of line (Gateway API)

      - type: contains
        target: map:path-prefix.map
        pattern: "(?m)^split\\.example\\.com/app GW_ROUTE_ID:"
        description: Path map entries must start at beginning of line (Gateway API)

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "(?m)^\\d+:default_split-route_0 gtw_"
        description: Weighted map entries must start at beginning of line

  test-httproute-weight-no-matches:
    description: HTTPRoute with no matches block defaults to PathPrefix /
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v1
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v2
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v1
          endpoints:
            - addresses: ["10.0.1.1"]
              targetRef:
                name: app-v1-pod-1
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v2
          endpoints:
            - addresses: ["10.0.2.1"]
              targetRef:
                name: app-v2-pod-1
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: default-path
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - default.example.com
            rules:
              - backendRefs:
                  - name: app-v1
                    port: 80
                    weight: 50
                  - name: app-v2
                    port: 80
                    weight: 50
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-prefix.map
        pattern: "default.example.com/ GW_ROUTE_ID:http:default_default-path_0"
        description: Missing matches must default to PathPrefix / with weight 100

  test-httproute-weight-default:
    description: HTTPRoute with default weights (omitted weight defaults to 1)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v1
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
        - apiVersion: v1
          kind: Service
          metadata:
            name: app-v2
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v1
          endpoints:
            - addresses: ["10.0.1.1"]
              targetRef:
                name: app-v1-pod-1
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app-v2
          endpoints:
            - addresses: ["10.0.2.1"]
              targetRef:
                name: app-v2-pod-1
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: default-weight
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - weight.example.com
            rules:
              - matches:
                  - path:
                      type: Exact
                      value: /test
                backendRefs:
                  - name: app-v1
                    port: 80
                  - name: app-v2
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-exact.map
        pattern: "weight.example.com/test GW_ROUTE_ID:http:default_default-weight_0"
        description: Omitted weights must default to 1 (total weight = 2)

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "0:default_default-weight_0 gtw_default_default-weight_app-v1_80"
        description: Default weight creates single entry for v1

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "1:default_default-weight_0 gtw_default_default-weight_app-v2_80"
        description: Default weight creates single entry for v2

  test-httproute-single-backend:
    description: HTTPRoute with single backend uses BACKEND qualifier
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: app
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: app-abc
            namespace: default
            labels:
              kubernetes.io/service-name: app
          endpoints:
            - addresses: ["10.0.3.1"]
              targetRef:
                name: app-pod-1
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: single-backend
            namespace: default
          spec:
            parentRefs:
              - name: gateway
                namespace: default
            hostnames:
              - single.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                backendRefs:
                  - name: app
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "backend gtw_default_single-backend_app_80"
        description: Must generate backend for single backend

      - type: contains
        target: map:path-prefix.map
        pattern: "single.example.com/ GW_ROUTE_ID:http:default_single-backend_0"
        description: Single backend must use GW_ROUTE_ID qualifier

      - type: not_contains
        target: map:weighted-multi-backend.map
        pattern: "default_single-backend"
        description: Single backend must not generate weighted-multi-backend entries

  test-httproute-method-matching:
    description: HTTPRoute with method matching (GET vs POST to same path)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: read-service
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
        - apiVersion: v1
          kind: Service
          metadata:
            name: write-service
            namespace: default
          spec:
            ports:
              - name: http
                port: 80
                targetPort: 8080
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: read-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: read-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: write-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: write-service
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: method-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: GET
                backendRefs:
                  - name: read-service
                    port: 80
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: POST
                backendRefs:
                  - name: write-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-prefix.map
        pattern: "api.example.com/api GW_ROUTE_ID:http"
        description: Conflicting paths must use GW_ROUTE_ID qualifier

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_method-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_method-route_0__default_method-route_1\" \\} \\{ method GET \\}"
        description: Must generate req.gw_rule_id for GET method

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_method-route_1\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_method-route_0__default_method-route_1\" \\} \\{ method POST \\}"
        description: Must generate req.gw_rule_id for POST method

  test-httproute-header-exact:
    description: HTTPRoute with exact header matching
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: v1-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: v1-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: v1-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: header-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    headers:
                      - type: Exact
                        name: X-Version
                        value: v1
                backendRefs:
                  - name: v1-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_header-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_header-route_0\" \\} \\{ req\\.hdr\\(X-Version\\) \"v1\" \\}"
        description: Must generate header exact match condition

  test-httproute-header-regex:
    description: HTTPRoute with regex header matching
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: regex-header-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    headers:
                      - type: RegularExpression
                        name: User-Agent
                        value: "^Mozilla.*"
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_regex-header-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_regex-header-route_0\" \\} \\{ req\\.hdr\\(User-Agent\\) -m reg \"\\^Mozilla\\.\\*\" \\}"
        description: Must generate header regex match condition

  test-httproute-query-params:
    description: HTTPRoute with query parameter matching
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: search-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: search-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: search-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: query-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /search
                    queryParams:
                      - type: Exact
                        name: version
                        value: v2
                      - type: RegularExpression
                        name: filter
                        value: "^active.*"
                backendRefs:
                  - name: search-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_query-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_query-route_0\" \\} \\{ urlp\\(version\\) \"v2\" \\} \\{ urlp\\(filter\\) -m reg \"\\^active\\.\\*\" \\}"
        description: Must generate query parameter match conditions

  test-httproute-regex-dollar-escaping:
    description: HTTPRoute with query parameter regex containing dollar signs for anchoring
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: regex-dollar-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    queryParams:
                      - type: RegularExpression
                        name: token
                        value: "^secret[0-9]+$"
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid (dollar signs must be escaped)

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_regex-dollar-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_regex-dollar-route_0\" \\} \\{ urlp\\(token\\) -m reg \"\\^secret\\[0-9\\]\\+\\\\\\$\" \\}"
        description: Must generate query parameter regex with properly escaped dollar sign

  test-httproute-precedence:
    description: Complex precedence ordering with multiple conflicting routes
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc1
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc2
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc3
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc1
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc2
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc3-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc3
          endpoints:
            - addresses: ["10.0.3.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: route1
            namespace: default
            creationTimestamp: "2024-01-01T00:00:00Z"
          spec:
            hostnames:
              - example.com
            rules:
              # Most specific: /api/v1/users with method and headers
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api/v1/users
                    method: GET
                    headers:
                      - type: Exact
                        name: X-Auth
                        value: token
                backendRefs:
                  - name: svc1
                    port: 80
              # Less specific: /api/v1 with just method
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api/v1
                    method: GET
                backendRefs:
                  - name: svc2
                    port: 80
              # Least specific: /api with no extra matchers
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                backendRefs:
                  - name: svc3
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      # Verify routes are ordered by Gateway API precedence (most specific first)
      - type: match_order
        target: map:path-prefix.map
        patterns:
          - "/api/v1/users.*default_route1_0"   # Most specific: longest path + method + headers
          - "/api/v1[^/].*default_route1_1"      # Medium: medium path + method
          - "/api[^/].*default_route1_2"         # Least specific: shortest path, no extra matchers
        description: Routes must be ordered by Gateway API precedence (most specific first)

  test-httproute-same-path-matcher-precedence:
    description: Routes with SAME path sorted by matcher specificity (method/headers/query)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc-main
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: svc-v2
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc-main-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc-main
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: svc-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: svc-v2
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: precedence-test
            namespace: default
            creationTimestamp: "2024-01-01T00:00:00Z"
          spec:
            hostnames:
              - test.example.com
            rules:
              # RULE 0: Medium precedence - GET + 1 header
              # Declared FIRST but should sort to position 2
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                    method: GET
                    headers:
                      - type: Exact
                        name: X-Version
                        value: v1
                backendRefs:
                  - name: svc-main
                    port: 80
              # RULE 1: Lowest precedence - No matchers (catch-all)
              # Declared SECOND but should sort to position 4 (last)
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                backendRefs:
                  - name: svc-main
                    port: 80
              # RULE 2: Highest precedence - GET + 2 headers + 1 query
              # Declared THIRD but should sort to position 1 (first)
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                    method: GET
                    headers:
                      - type: Exact
                        name: X-Version
                        value: v2
                      - type: Exact
                        name: X-Environment
                        value: prod
                    queryParams:
                      - type: Exact
                        name: debug
                        value: "true"
                backendRefs:
                  - name: svc-v2
                    port: 80
              # RULE 3: Low precedence - GET only
              # Declared FOURTH but should sort to position 3
              - matches:
                  - path:
                      type: PathPrefix
                      value: /
                    method: GET
                backendRefs:
                  - name: svc-v2
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      # Verify all 4 rules are present (including catch-all)
      - type: contains
        target: haproxy.cfg
        pattern: 'gw_rule_id.*precedence-test_0'
        description: Rule 0 (GET + 1 header) must be present

      - type: contains
        target: haproxy.cfg
        pattern: 'gw_rule_id.*precedence-test_1'
        description: Rule 1 (catch-all) must be present

      - type: contains
        target: haproxy.cfg
        pattern: 'gw_rule_id.*precedence-test_2'
        description: Rule 2 (GET + 2 headers + 1 query) must be present

      - type: contains
        target: haproxy.cfg
        pattern: 'gw_rule_id.*precedence-test_3'
        description: Rule 3 (GET only) must be present

  test-httproute-weighted-with-matchers:
    description: Weighted routing combined with method/header matchers
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: canary-v1
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: canary-v2
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: canary-v1-abc
            namespace: default
            labels:
              kubernetes.io/service-name: canary-v1
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: canary-v2-abc
            namespace: default
            labels:
              kubernetes.io/service-name: canary-v2
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: canary-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: GET
                    headers:
                      - type: Exact
                        name: X-Canary
                        value: "true"
                backendRefs:
                  - name: canary-v1
                    port: 80
                    weight: 90
                  - name: canary-v2
                    port: 80
                    weight: 10
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_canary-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_canary-route_0\" \\} \\{ method GET \\} \\{ req\\.hdr\\(X-Canary\\) \"true\" \\}"
        description: Must generate req.gw_rule_id with conditions

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "0:default_canary-route_0 gtw_default_canary-route_canary-v1_80"
        description: Weighted map must contain v1 entries

      - type: contains
        target: map:weighted-multi-backend.map
        pattern: "90:default_canary-route_0 gtw_default_canary-route_canary-v2_80"
        description: Weighted map must contain v2 entries

  test-httproute-same-route-conflicts:
    description: Multiple rules in same HTTPRoute with path conflicts
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: auth-service
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: public-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: auth-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: auth-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: public-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: public-service
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: multi-rule
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              # Rule 0: /api with auth header
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    headers:
                      - type: Exact
                        name: Authorization
                        value: Bearer
                backendRefs:
                  - name: auth-service
                    port: 80
              # Rule 1: /api without auth (conflicts with rule 0)
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                backendRefs:
                  - name: public-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-prefix.map
        pattern: "api.example.com/api GW_ROUTE_ID:http:default_multi-rule_0__default_multi-rule_1"
        description: Same route conflicts must include both rule indices

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_multi-rule_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_multi-rule_0__default_multi-rule_1\" \\} \\{ req\\.hdr\\(Authorization\\) \"Bearer\" \\}"
        description: Must set req.gw_rule_id for rule index 0 with header matcher

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(txn\\.path_match\\) str\\(BACKEND:gtw_default_multi-rule_public-service_80\\) if \\{ var\\(req\\.gw_rule_id\\) -m str \"default_multi-rule_1\" \\}"
        description: Must set txn.path_match for rule index 1 based on req.gw_rule_id

  test-httproute-path-exact:
    description: HTTPRoute with Exact path type (no prefix matching)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: exact-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: exact-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: exact-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: exact-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: Exact
                      value: /api/users
                backendRefs:
                  - name: exact-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-exact.map
        pattern: "api.example.com/api/users GW_ROUTE_ID:http:default_exact-route_0"
        description: Exact path must be in path-exact.map

      - type: not_contains
        target: map:path-prefix.map
        pattern: "api.example.com/api/users"
        description: Exact path must not be in path-prefix.map

  test-httproute-path-regex:
    description: HTTPRoute with RegularExpression path type
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: versioned-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: versioned-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: versioned-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: regex-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: RegularExpression
                      value: "^/api/v[0-9]+/users$"
                backendRefs:
                  - name: versioned-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-regex.map
        pattern: "api\\.example\\.com\\^/api/v\\[0-9\\]\\+/users\\$gtw_default_regex-route_versioned-service_80"
        description: Regex path must be in path-regex.map

      - type: not_contains
        target: map:path-prefix.map
        pattern: "api.example.com/.*users"
        description: Regex path must not be in path-prefix.map

  test-grpcroute-headers:
    description: GRPCRoute with header matching (Exact and RegularExpression)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-api
            namespace: default
          spec:
            ports:
              - port: 9090
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-api-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-api
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 9090
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: grpc-header-route
            namespace: default
          spec:
            hostnames:
              - grpc.example.com
            rules:
              - matches:
                  - method:
                      type: Exact
                      service: com.example.API
                      method: GetUser
                    headers:
                      - type: Exact
                        name: X-API-Version
                        value: v1
                      - type: RegularExpression
                        name: User-Agent
                        value: "^grpc-.*"
                backendRefs:
                  - name: grpc-api
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_grpc-header-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\}.*\\{ req\\.hdr\\(X-API-Version\\) \"v1\" \\} \\{ req\\.hdr\\(User-Agent\\) -m reg \"\\^grpc-\\.\\*\" \\}"
        description: Must generate header match conditions for GRPCRoute

  test-grpcroute-method-regex:
    description: GRPCRoute with RegularExpression method type
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-multi
            namespace: default
          spec:
            ports:
              - port: 9090
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-multi-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-multi
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 9090
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: grpc-regex-route
            namespace: default
          spec:
            hostnames:
              - grpc.example.com
            rules:
              - matches:
                  - method:
                      type: RegularExpression
                      service: com.example.*
                      method: Get.*
                backendRefs:
                  - name: grpc-multi
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_grpc-regex-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_grpc-regex-route_0\" \\} \\{ req\\.hdr\\(:path\\) -m reg \"/com\\.example\\.\\*/Get\\.\\*\" \\}"
        description: Must generate regex method match for GRPCRoute

  test-httproute-all-matchers:
    description: HTTPRoute with all matcher types combined (method + headers + query params)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: combined-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: combined-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: combined-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: combined-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: POST
                    headers:
                      - type: Exact
                        name: Content-Type
                        value: application/json
                    queryParams:
                      - type: Exact
                        name: version
                        value: v2
                backendRefs:
                  - name: combined-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_combined-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_combined-route_0\" \\} \\{ method POST \\} \\{ req\\.hdr\\(Content-Type\\) \"application/json\" \\} \\{ urlp\\(version\\) \"v2\" \\}"
        description: Must combine all matchers with AND logic

  test-httproute-cross-route-conflicts:
    description: Multiple separate HTTPRoutes with conflicting paths (different matchers)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: route1-service
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: route2-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: route1-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: route1-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 80
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: route2-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: route2-service
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 80
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: route-get
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: GET
                backendRefs:
                  - name: route1-service
                    port: 80
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: route-post
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    method: POST
                backendRefs:
                  - name: route2-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:path-prefix.map
        pattern: "api.example.com/api GW_ROUTE_ID:http:default_route-get_0__default_route-post_0"
        description: Cross-route conflicts must be detected and marked with GW_ROUTE_ID qualifier

  test-grpcroute-multiple-headers:
    description: GRPCRoute with multiple header matchers of different types
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-multi-header
            namespace: default
          spec:
            ports:
              - port: 9090
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-multi-header-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-multi-header
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 9090
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: grpc-multi-header-route
            namespace: default
          spec:
            hostnames:
              - grpc.example.com
            rules:
              - matches:
                  - method:
                      type: Exact
                      service: com.example.API
                      method: Create
                    headers:
                      - type: Exact
                        name: X-Tenant-ID
                        value: tenant1
                      - type: Exact
                        name: X-Environment
                        value: production
                      - type: RegularExpression
                        name: Authorization
                        value: "^Bearer .*"
                backendRefs:
                  - name: grpc-multi-header
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "\\{ req\\.hdr\\(X-Tenant-ID\\) \"tenant1\" \\} \\{ req\\.hdr\\(X-Environment\\) \"production\" \\} \\{ req\\.hdr\\(Authorization\\) -m reg \"\\^Bearer \\.\\*\" \\}"
        description: Must combine all header matchers with AND logic

  test-httproute-invalid-regex:
    description: HTTPRoute with invalid regex pattern (negative test)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: test-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: test-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: test-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: invalid-route
            namespace: default
          spec:
            hostnames:
              - invalid.example.com
            rules:
              - matches:
                  - headers:
                      - type: RegularExpression
                        name: X-Token
                        value: "[invalid"  # Unclosed bracket - invalid regex
                backendRefs:
                  - name: test-service
                    port: 80
    assertions:
      - type: not_contains
        target: haproxy.cfg
        pattern: "invalid\\.example\\.com"
        description: Invalid regex should not generate routing config

  test-httproute-header-edge-cases:
    description: HTTPRoute with edge case header matching (special characters)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: edge-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: edge-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: edge-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: edge-route
            namespace: default
          spec:
            hostnames:
              - edge.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                    headers:
                      - type: Exact
                        name: X-Special-Chars
                        value: "value-with-dashes_and_underscores.dots"
                backendRefs:
                  - name: edge-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: "\\{ req\\.hdr\\(X-Special-Chars\\) \"value-with-dashes_and_underscores\\.dots\" \\}"
        description: Must handle special characters in header values

  test-httproute-grpcroute-precedence:
    description: Mixed HTTPRoute and GRPCRoute on same hostname (precedence validation)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: http-service
            namespace: default
          spec:
            ports:
              - port: 80
        - apiVersion: v1
          kind: Service
          metadata:
            name: grpc-service
            namespace: default
          spec:
            ports:
              - port: 9090
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: http-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: http-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: grpc-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: grpc-service
          endpoints:
            - addresses: ["10.0.2.1"]
          ports:
            - port: 9090
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: http-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /rest
                backendRefs:
                  - name: http-service
                    port: 80
      grpcroutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: GRPCRoute
          metadata:
            name: grpc-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - method:
                      type: Exact
                      service: com.example.Service
                      method: GetData
                backendRefs:
                  - name: grpc-service
                    port: 9090
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: map:host.map
        pattern: "api\\.example\\.com api\\.example\\.com"
        description: Shared hostname must be in host map

      - type: contains
        target: map:path-prefix.map
        pattern: "api\\.example\\.com/rest GW_ROUTE_ID:http:default_http-route_0"
        description: HTTPRoute path must route to HTTP service

      - type: contains
        target: haproxy.cfg
        pattern: "http-request set-var\\(req\\.gw_rule_id\\) str\\(default_grpc-route_0\\) if !\\{ var\\(req\\.gw_rule_id\\) -m found \\} \\{ var\\(req\\.gw_route_id\\) -m str \"default_grpc-route_0\" \\} \\{ req\\.hdr\\(:path\\) \"/com\\.example\\.Service/GetData\" \\}"
        description: GRPCRoute method must route to gRPC service

  test-httproute-request-header-modifier:
    description: HTTPRoute with RequestHeaderModifier filter (add, set, remove headers)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: header-filter-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                filters:
                  - type: RequestHeaderModifier
                    requestHeaderModifier:
                      add:
                        - name: X-Custom-Header
                          value: custom-value
                      set:
                        - name: X-Replace-Header
                          value: new-value
                      remove:
                        - X-Remove-Header
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request add-header X-Custom-Header "custom-value" if'
        description: Must generate add-header directive for RequestHeaderModifier filter

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request set-header X-Replace-Header "new-value" if'
        description: Must generate set-header directive for RequestHeaderModifier filter

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request del-header X-Remove-Header if'
        description: Must generate del-header directive for RequestHeaderModifier filter

  test-httproute-response-header-modifier:
    description: HTTPRoute with ResponseHeaderModifier filter (add, set, remove response headers)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: response-filter-route
            namespace: default
          spec:
            hostnames:
              - api.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api
                filters:
                  - type: ResponseHeaderModifier
                    responseHeaderModifier:
                      add:
                        - name: X-Response-Header
                          value: response-value
                      set:
                        - name: X-Replace-Response
                          value: new-response
                      remove:
                        - X-Remove-Response
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: 'http-response add-header X-Response-Header "response-value" if'
        description: Must generate add-header directive for ResponseHeaderModifier filter

      - type: contains
        target: haproxy.cfg
        pattern: 'http-response set-header X-Replace-Response "new-response" if'
        description: Must generate set-header directive for ResponseHeaderModifier filter

      - type: contains
        target: haproxy.cfg
        pattern: 'http-response del-header X-Remove-Response if'
        description: Must generate del-header directive for ResponseHeaderModifier filter

  test-httproute-request-redirect:
    description: HTTPRoute with RequestRedirect filter (scheme, path, status code)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: redirect-route
            namespace: default
          spec:
            hostnames:
              - old.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /old
                filters:
                  - type: RequestRedirect
                    requestRedirect:
                      scheme: https
                      hostname: new.example.com
                      path:
                        type: ReplacePrefixMatch
                        replacePrefixMatch: /new
                      statusCode: 301
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request redirect scheme https prefix "/new" code 301 if'
        description: Must generate redirect directive with scheme, prefix, and status code

  test-httproute-url-rewrite:
    description: HTTPRoute with URLRewrite filter (hostname and path rewrite)
    fixtures:
      services:
        - apiVersion: v1
          kind: Service
          metadata:
            name: api-service
            namespace: default
          spec:
            ports:
              - port: 80
      endpoints:
        - apiVersion: discovery.k8s.io/v1
          kind: EndpointSlice
          metadata:
            name: api-service-abc
            namespace: default
            labels:
              kubernetes.io/service-name: api-service
          endpoints:
            - addresses: ["10.0.1.1"]
          ports:
            - port: 8080
      httproutes:
        - apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: rewrite-route
            namespace: default
          spec:
            hostnames:
              - external.example.com
            rules:
              - matches:
                  - path:
                      type: PathPrefix
                      value: /api/v1
                filters:
                  - type: URLRewrite
                    urlRewrite:
                      hostname: internal.example.com
                      path:
                        type: ReplacePrefixMatch
                        replacePrefixMatch: /api/v2
                backendRefs:
                  - name: api-service
                    port: 80
    assertions:
      - type: haproxy_valid
        description: HAProxy configuration must be syntactically valid

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request set-header Host "internal.example.com" if'
        description: Must generate hostname rewrite directive

      - type: contains
        target: haproxy.cfg
        pattern: 'http-request replace-path'
        description: Must generate path prefix replacement directive

      - type: contains
        target: haproxy.cfg
        pattern: '"/api/v2'
        description: Must rewrite to new path prefix
