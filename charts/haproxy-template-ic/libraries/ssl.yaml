# SSL/TLS Infrastructure Library for HAProxy Template Ingress Controller
# Contains SSL certificate management, HTTPS frontends, and SSL passthrough infrastructure
# Must be loaded after base.yaml to access frontend-routing-logic and file registry

# Test certificate fixtures (YAML anchors for reuse across validation tests)
_test_tls_crt: &test_tls_crt LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURDekNDQWZPZ0F3SUJBZ0lVT2FGRWhyWlRXZ1JpbEorSFJCOWhJQnlzT2xNd0RRWUpLb1pJaHZjTkFRRUwKQlFBd0ZERVNNQkFHQTFVRUF3d0piRzlqWVd4b2IzTjBNQ0FYRFRJMU1URXhPVEU0TWpVMU1Wb1lEekl4TWpVeApNREkyTVRneU5UVXhXakFVTVJJd0VBWURWUVFEREFsc2IyTmhiR2h2YzNRd2dnRWlNQTBHQ1NxR1NJYjNEUUVCCkFRVUFBNElCRHdBd2dnRUtBb0lCQVFDWDJIQnA0V00rbFIvSXljLzRMR01qUHk0bUdFcUtVYm5xaFdRbU9nMXgKNHlnRkkzMkcyNWZYR1djZ0ZtVmg4YkZSZVFxdTB0Z1k2SUo5UE9nWmd5eHNhaUgzeldBMi8wbkdEejVvN2dYeQp5Z0VLaTdZY3M3bHNFNng0Y3lLK2tZaFdvZkNNaDJDck5LNWVCVzlRUnh3U3pieDNWREZqVS9HdVVaQnRBVWxICkRLd2ZCb0ZHNEhzaEZDUHl2Y3BuTlNLbUdwS0wwZ0UyczNBTHN5NWpqYjRpMnpyQng4Mng0Y3hQZUlCOEt6ckMKMDZvQXVwbzJDdUxaQTFMMkMrZVB5UlQ0QWxRUGNOL2l3WmdqMyt3eG8vWkFJaUxQK2NXbUY1dUdXeTZUREoybAo2K2FLYWFOajFCVVBWSkxTdW92WFhCMmc2akYxdWxIM1VWNVhPMlVMQ1ZzUkFnTUJBQUdqVXpCUk1CMEdBMVVkCkRnUVdCQlRHdi9VWG5nZ2tKaytpTkN0WnFwMStTSS9JaGpBZkJnTlZIU01FR0RBV2dCVEd2L1VYbmdna0prK2kKTkN0WnFwMStTSS9JaGpBUEJnTlZIUk1CQWY4RUJUQURBUUgvTUEwR0NTcUdTSWIzRFFFQkN3VUFBNElCQVFBSwozb3QyQTRyR05DWEpuZHB5OWlBa0dUUnk2SWxCcExKUlNJZ1JOWmlZQkU4SEtlWnUyR3JnUGI3V0ZUL1RyWkI2Cm5jMjhzVjdsYUNDNXlyZVUxeGVpL2ZjTllPSHlscWdBR2lFYmt2Um1za1hTd24wSlFaanpUNWl1a2hObVBkV0QKSWx0bWhCU3FsZlRsWFRYaytjMVlzeUJrVkN5TVNOdUZMd3pkODlLanJlU2xsZzE5clRVUmlLRzZGU0o2azBPSQprVE1lbWczRGZabldZSytNZnBxdjlVSDJSblBhMVJlbHJ4aTNLTWZoV0h2b2wxeUlVSGdnT0g3MkE4Wkd6eFZMClh4L09rSS8weXozUFhvM0xtUkRqczMzWUpXSzRTMmRwaFpyS3RMS2hqcEFIZzI1Nk8zUlN1bWd2d2NpYzZVRWMKaEpvWitneWZacUdBcnJ6M1dWTTkKLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQo=
_test_tls_key: &test_tls_key LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV1d0lCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktVd2dnU2hBZ0VBQW9JQkFRQ1gySEJwNFdNK2xSL0kKeWMvNExHTWpQeTRtR0VxS1VibnFoV1FtT2cxeDR5Z0ZJMzJHMjVmWEdXY2dGbVZoOGJGUmVRcXUwdGdZNklKOQpQT2daZ3l4c2FpSDN6V0EyLzBuR0R6NW83Z1h5eWdFS2k3WWNzN2xzRTZ4NGN5SytrWWhXb2ZDTWgyQ3JOSzVlCkJXOVFSeHdTemJ4M1ZERmpVL0d1VVpCdEFVbEhES3dmQm9GRzRIc2hGQ1B5dmNwbk5TS21HcEtMMGdFMnMzQUwKc3k1ampiNGkyenJCeDgyeDRjeFBlSUI4S3pyQzA2b0F1cG8yQ3VMWkExTDJDK2VQeVJUNEFsUVBjTi9pd1pnagozK3d4by9aQUlpTFArY1dtRjV1R1d5NlRESjJsNithS2FhTmoxQlVQVkpMU3VvdlhYQjJnNmpGMXVsSDNVVjVYCk8yVUxDVnNSQWdNQkFBRUNnZjhKSHBhaHhVZVFtcVF1Q3ZEU2x0ZmRaZzMvZTdYK1dLb3h5NUVZT3FSVUVyQjAKbm8wTGJHVFNKbFJyT08wZDFNWXhmbk9GekdQdUd3aTdQTTB6dXcwUDljL1VjaUUxTEYvaDVVaDZSTkZXbzRzcwpkdmVaQWJKQksyMVFUcG5ubUJYNEhnRzBidXovVzBxZG12WDBmRkRUVUVmaFlzMFVpaFlad2d4S2Y2bEcrd1FzClZRclNiTzlMKzRJaHN2cnNSQlRGYU1nV0FMNGp0a3VpcTdSaVFkamRpejRkMmZJd1FtcVR5VEFvWlh5ZW9WRmEKM2JlRXh3aWtJME5pcXBNTWlaUjlXeTYzZkw2TlowZ0F5T0dKL09FaVU2Q3kyV2JCQzZrbVhnRlpOVW1Va1B5dAp3TXlqNTg5ZG1taDNaTGw1VEloNzVOc1dTNlVvTm1abzV3MmxLWUVDZ1lFQXh5N3dJeWxFbDlLaURvT1Q5V3gyCjFOcnp3bjQzLzVVbFAxakVFM0NiMXBiRDJCQjRUNXM4TmxCSEFOa0tFeFI1RUJnNTNYakw3aVlvTU1rWWUwL1YKRFVOdWFLRzlaaHhUSklualdPNURNUDE2NVFwNlBzdklObmlVZ1JLcW1Bc1hSNkNkN0NXeVIzcEZVOUZPcEJpWgo2aWt1eFVNYnZFWW8xVHNUWjB2Umw5RUNnWUVBd3lpNVNORWpEM2x6UHozcm5OVllRTEJBL2V1NS8wS1JXc2hQCmJVcit0YUszN1l4ZEJMV1JHOVpjOHd2ZU9pVWZTUHhWNmwyWnFRdVQ0VVVFdmYrbTlJWEZGZXZxUE1IanNZUVQKVVlRQVRxMkgwelF3Mm5kS2thdDlWSk81UVZKV252N0YxaWY5S3VPRFozbEhiUk96aEJjZjZXUWlBS0RNQWQ3cwpQNDNYbjBFQ2dZRUFxNmFacjlONmwxUWY4RjRYL2lLdzdaS2JDdnQzQ3J6ZlVvNE91Nm9Kd280K3pFNjFQL1ZKCm1JenFBNk1HK1pabEZpZXFobC81Ym94WGltTml3N0h5cXZGM2pwZ0QvcUZlVFZpL0lmNkN6UTlFLzJsZUhBdkYKeUp0MWJ4NUZBYTVkSzQ4UlNWYmJJcG9PY01NcUFHUnJEODdaelltZHQwekhGNnRIZDNkeGNtRUNnWUFzRWJNZApWVlNVZHZsbVM0WTc2UlUvcmsxT3lYODd1LzEwd1l6bUFpeFlPY0ZNM0FoWk91TGtwVmhoN2NrbDJpSWhhaEhBCmxaaFFTdlAreDRZVm5YaEcrVG9UQkMzbHdHYTVQRGpjakhGQlV3QTcyaW81K3Z3VXZ1UFRTSFJwNHJ6NnRFOWEKVjdkY2l2bXVVUDJuRE83Wm9oc3JxZGZmeW0rbThIN3FydzRFd1FLQmdEV1RqME82TXpyUUVhQVlrUVVucERVLwpYOFd5OGlPcStFYU5ZejNWWUtKSm5xVkJTeldLZDIrRFRQVmlvVHZqOVhVYkhGK1p3MW9ieXljcklDcVgrd0RCCkl4ZXBoMlBNNERKUHVlRnFJVzRqY3lQSkJuVGt4OVBuNUNKem1XSUJybE1vZjZON2tvWFIzMFBMbjlDRlRpNFoKa1dhTnhjR3BROVNldjVQeEoxL2QKLS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLQo=

# Watch secrets for SSL certificate loading
watchedResources:
  secrets:
    apiVersion: v1
    resources: secrets
    indexBy: ["metadata.namespace", "metadata.name"]

templateSnippets:
  # SSL bind options utility - used by both HTTPS frontend and SSL passthrough
  # Uses crt-list for certificate management with per-certificate OCSP configuration
  util-ssl-bind-options:
    template: >-
      {{- " " -}}ssl crt-list {{ "certificate-list.txt" | get_path("crt-list") }} alpn h2,http/1.1

  # Feature initialization - must run early to initialize SSL infrastructure
  # Resource libraries (gateway.yaml, haproxytech.yaml, ingress.yaml) register SSL features here
  features-ssl-initialization:
    priority: 50
    template: |
      {#- SSL infrastructure initialization #}
      {#- Initialize data structures for resource libraries to register SSL features #}
      {#- This runs early (priority 50) so other features-* snippets can append to it #}
      {#- Only initialize if not already defined (idempotent) #}

      {#- SSL passthrough backends array #}
      {%- if global_features.ssl_passthrough_backends is not defined %}
        {%- set global_features.ssl_passthrough_backends = [] %}
      {%- endif %}

      {#- TLS certificates array - each entry: {secret_namespace, secret_name, sni_patterns[]} #}
      {#- Resource libraries register TLS secrets here with their SNI patterns #}
      {%- if global_features.tls_certificates is not defined %}
        {%- set global_features.tls_certificates = [] %}
      {%- endif %}

  # Generate CRT-list file from registered TLS certificates
  # Runs after TLS certificates are registered (priority 100) by resource libraries
  features-ssl-crtlist:
    priority: 150
    template: |
      {#- Generate crt-list file dynamically from registered TLS certificates #}
      {#- This file is used by HAProxy's ssl crt-list directive for certificate selection #}
      {#- Format: <cert-path> [ssl-options] [sni-filter ...] #}
      {#- See: https://www.haproxy.com/documentation/haproxy-configuration-manual/latest/#5.1-crt-list #}

      {%- set ns = namespace(crtlist_lines=[]) %}

      {#- Generate entries for each registered TLS certificate #}
      {%- for tls_cert in global_features.tls_certificates | default([]) %}
        {%- set cert_filename = tls_cert.secret_namespace ~ "_" ~ tls_cert.secret_name ~ ".pem" %}
        {%- set cert_path = "" | get_path("cert") ~ "/" ~ cert_filename %}
        {%- set ssl_options = "[ocsp-update on]" %}
        {%- set sni_list = tls_cert.sni_patterns | join(" ") %}
        {%- set line = cert_path ~ " " ~ ssl_options ~ " " ~ sni_list %}
        {%- set ns.crtlist_lines = ns.crtlist_lines.append(line) %}
      {%- endfor %}

      {#- Default certificate (no SNI filter = matches everything not matched above) #}
      {%- set default_line = "" | get_path("cert") ~ "/default.pem [ocsp-update on]" %}
      {%- set ns.crtlist_lines = ns.crtlist_lines.append(default_line) %}

      {#- Register the crt-list file with file_registry #}
      {#- Add trailing newline to satisfy HAProxy's parser #}
      {%- set crtlist_content = ns.crtlist_lines | join("\n") ~ "\n" %}
      {%- set _ = file_registry.Register("crt-list", "certificate-list.txt", crtlist_content) %}

  # Global OCSP configuration - enables automatic OCSP stapling for all SSL certificates
  global-ssl-ocsp-config:
    template: |
      {#- Global OCSP Update Configuration #}
      {#- Enables automatic fetching and caching of OCSP responses for certificate validation #}
      {#- See: https://www.haproxy.com/documentation/haproxy-configuration-manual/latest/#3.1-ocsp-update.mode #}
      # ssl/global-ssl-ocsp-config
      ocsp-update.mode on
      ocsp-update.mindelay 300
      ocsp-update.maxdelay 3600

  # SSL passthrough TCP frontend (conditional - only when backends registered)
  frontends-ssl-tcp:
    template: |
      {#- SSL Passthrough Infrastructure - Conditional Architecture #}
      {#- Only generated when SSL passthrough backends are registered by resource libraries #}
      {#- Architecture: TCP frontend + unix socket HTTPS frontend + loopback backend #}
      {%- if global_features.ssl_passthrough_backends | length > 0 %}
      {#- TCP frontend extracts SNI and routes to passthrough backends or loopback #}
      # ssl/frontends-ssl-tcp

      frontend ssl-tcp
          mode tcp
          bind *:{{ httpsPort | default(8443) | int }}

          # Extract SNI for routing decisions (wait up to 5s for client hello)
          tcp-request inspect-delay 5s
          tcp-request content accept if { req_ssl_hello_type 1 }

          # Route to passthrough backends based on SNI
          {%- for backend in global_features.ssl_passthrough_backends %}
          use_backend {{ backend.name }} if { req_ssl_sni -m str {{ backend.sni }} }
          {%- endfor %}

          # Default: route to loopback backend for SSL termination
          default_backend ssl-loopback

      {%- endif %}

  # SSL loopback backend (bridges TCP frontend to HTTPS frontend)
  backends-ssl-loopback:
    template: |
      {%- if global_features.ssl_passthrough_backends | length > 0 %}
      # ssl/backends-ssl-loopback

      backend ssl-loopback
          mode tcp
          server loopback unix@/var/run/ssl-frontend.sock send-proxy-v2

      {%- endif %}

  # HTTPS frontend with SSL termination
  frontends-https:
    template: |
      # ssl/frontends-https

      frontend https
          mode http
          {%- if global_features.ssl_passthrough_backends | length > 0 %}
          bind unix@/var/run/ssl-frontend.sock user haproxy mode 660{% include "util-ssl-bind-options" %} accept-proxy
          {%- else %}
          bind *:{{ httpsPort | default(8443) | int }}{% include "util-ssl-bind-options" %}
          {%- endif %}

          {#- Reuse frontend routing logic from base.yaml #}
          {%- filter indent(8, first=False) %}
          {% include "frontend-routing-logic" -%}
          {%- endfilter %}

          # Use backend from txn.backend_name (set by qualifier logic)
          use_backend %[var(txn.backend_name)] if { var(txn.backend_name) -m found }

          # Default backend
          default_backend default_backend

# SSL certificate files
#
# NOTE: Dynamic TLS certificate file generation
# ============================================
# TLS certificates are automatically generated using file_registry.Register() by resource
# libraries (ingress.yaml, gateway.yaml) when processing Ingress spec.tls and Gateway TLS
# configurations. No pre-declaration is needed - any TLS Secret referenced in these resources
# will be automatically converted to a certificate file.
#
# The crt-list file below references these certificates using the naming pattern:
#   {namespace}_{secretname}.pem
#
# Only the default certificate (fallback for SNI mismatch) needs to be defined here.
# All other certificates are registered dynamically at template rendering time.

sslCertificates:
  # Default SSL certificate (fallback for SNI mismatch)
  default.pem:
    template: |
      {#- Default SSL certificate for HTTPS frontend #}
      {#- Loads certificate from TLS Secret (configurable via values.yaml) #}
      {#- Secret name and namespace come from templatingSettings.extraContext #}
      {%- set cert_namespace = default_ssl_cert_namespace | default("haproxy-template-ic") %}
      {%- set cert_name = default_ssl_cert_name | default("default-ssl-cert") %}
      {%- set secret = resources.secrets.GetSingle(cert_namespace, cert_name) %}
      {%- if not secret %}
      {{- fail("TLS Secret not found: " ~ cert_namespace ~ "/" ~ cert_name ~ ". Ensure the Secret exists and is watched.") -}}
      {%- endif %}
      {%- if not secret.data or not secret.data["tls.crt"] or not secret.data["tls.key"] %}
      {{- fail("Invalid TLS Secret " ~ cert_namespace ~ "/" ~ cert_name ~ ": missing tls.crt or tls.key fields. Ensure the Secret is of type kubernetes.io/tls.") -}}
      {%- endif %}
      {{- secret.data["tls.crt"] | b64decode -}}
      {{- secret.data["tls.key"] | b64decode -}}

# Validation tests for SSL functionality
validationTests:
  _global:
    description: Global SSL test fixtures
    fixtures:
      secrets:
        # Provide default SSL certificate in both common namespaces for test flexibility
        - apiVersion: v1
          kind: Secret
          type: kubernetes.io/tls
          metadata:
            name: default-ssl-cert
            namespace: haproxy-template-ic
          data:
            tls.crt: *test_tls_crt
            tls.key: *test_tls_key
        - apiVersion: v1
          kind: Secret
          type: kubernetes.io/tls
          metadata:
            name: default-ssl-cert
            namespace: default
          data:
            tls.crt: *test_tls_crt
            tls.key: *test_tls_key

  test-ssl-certificate-loading:
    description: Verify default SSL certificate is loaded correctly
    fixtures: {}  # Uses _global fixtures
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid with SSL certificate loaded

  test-ssl-https-frontend-basic:
    description: Verify HTTPS frontend is generated with correct bind options
    fixtures: {}  # Uses _global fixtures
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid

      - type: contains
        target: haproxy.cfg
        pattern: "frontend https"
        description: Must generate HTTPS frontend

      - type: contains
        target: haproxy.cfg
        pattern: "bind .*:8443.*ssl crt"
        description: HTTPS frontend must bind with SSL options

      - type: contains
        target: haproxy.cfg
        pattern: "alpn h2,http/1.1"
        description: HTTPS frontend must enable ALPN negotiation

  test-ssl-crtlist-basic:
    description: Verify crt-list file is generated with OCSP configuration
    fixtures: {}  # Uses _global fixtures
    assertions:
      - type: haproxy_valid
        description: HAProxy config must be valid

      - type: contains
        target: haproxy.cfg
        pattern: "ssl crt-list .*/certificate-list\\.txt"
        description: HTTPS frontend must use crt-list for certificate loading

      - type: contains
        target: crt-list:certificate-list.txt
        pattern: "default\\.pem \\[ocsp-update on\\]"
        description: CRT-list must include default certificate with OCSP enabled

      - type: not_contains
        target: crt-list:certificate-list.txt
        pattern: "^\\s*$"
        description: CRT-list must not contain empty lines
