# Base template library for HAProxy Template Ingress Controller
# Contains resource-agnostic core template snippets, files, and HAProxy configuration
# Uses plugin patterns (resource_*) to discover resource-specific implementations

templateSnippets:
  util-macros:
    template: |
      {#- Reusable macro: Include all snippets matching a glob pattern #}
      {#- Usage: {% from "util-macros" import include_matching %}{{ include_matching("pattern-*") }} #}
      {%- macro include_matching(pattern) -%}
      {%- set matching = template_snippets | glob_match(pattern) %}
      {%- for snippet_name in matching %}
      {%- include snippet_name -%}
      {%- endfor %}
      {%- endmacro -%}

  util-regex-sanitize:
    template: |
      {#- Macro to sanitize regex patterns for HAProxy double-quoted context #}
      {#- Escapes $ as \$ to prevent environment variable substitution #}
      {#- Usage: {% from "util-regex-sanitize" import sanitize_regex %}{{ sanitize_regex(pattern) }} #}
      {%- macro sanitize_regex(pattern) -%}
      {%- set result = pattern | replace("$", "\\$") -%}
      {{- result -}}
      {%- endmacro -%}

  util-ssl-bind-options:
    template: >-
      {{- " " -}}ssl crt {{ "" | get_path("cert") }}/ alpn h2,http/1.1

  frontend-routing-logic:
    template: |-
      {#- Frontend routing logic with qualifier system #}
      {#- Supports BACKEND and MULTIBACKEND qualifiers #}
      {#- Default ordering: Exact > Regex > Prefix (de facto standard) #}
      {#- Override this snippet in path-regex-last library for performance-first ordering #}
      # base/frontend-routing-logic

      # Set variables for path-based routing
      http-request set-var(txn.base) base
      http-request set-var(txn.path) path
      http-request set-var(txn.host) req.hdr(Host),field(1,:),lower
      http-request set-var(txn.host_match) var(txn.host),map({{ "host.map" | get_path("map") }})
      http-request set-var(txn.host_match) var(txn.host),regsub(^[^.]*,,),map({{ "host.map" | get_path("map") }},'') if !{ var(txn.host_match) -m found }

      # Path matching order: Exact > Regex > Prefix-exact > Prefix
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map({{ "path-exact.map" | get_path("map") }})
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_reg({{ "path-regex.map" | get_path("map") }}) if !{ var(txn.path_match) -m found }
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map({{ "path-prefix-exact.map" | get_path("map") }}) if !{ var(txn.path_match) -m found }
      http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_beg({{ "path-prefix.map" | get_path("map") }}) if !{ var(txn.path_match) -m found }

      # Parse qualifier from path match (field 1 = qualifier type)
      # Empty string if no path match - falls through gracefully
      http-request set-var(txn.path_match_qualifier) var(txn.path_match),field(1,:)

      # Extension point for advanced matchers (method/header/query)
      # Libraries can inject ordered http-request statements here
      {%- from "util-macros" import include_matching -%}
      {%- filter indent(6, first=True) -%}
      {{ include_matching("frontend-matchers-advanced-*") | trim }}
      {%- endfilter -%}
      # Re-parse path_match_qualifier after advanced matchers may have changed path_match
      http-request set-var(txn.path_match_qualifier) var(txn.path_match),field(1,:)

      # MULTIBACKEND qualifier: weighted routing
      # Format: MULTIBACKEND:<total_weight>:<route_key>
      # Field 2 = total_weight, Field 3 = route_key
      # Result: sets txn.backend_name via weighted-multi-backend.map lookup
      http-request set-var(txn.total_weight) var(txn.path_match),field(2,:) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.random_weight) rand(),mod(txn.total_weight) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.route_key) var(txn.path_match),field(3,:) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.lookup_key) var(txn.random_weight),concat(:,txn.route_key,) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }
      http-request set-var(txn.backend_name) var(txn.lookup_key),map({{ "weighted-multi-backend.map" | get_path("map") }}) if { var(txn.path_match_qualifier) -m str MULTIBACKEND }

      # BACKEND qualifier: direct routing
      # Format: BACKEND:<backend_name>
      # Field 2 = backend name
      # Result: sets txn.backend_name directly
      http-request set-var(txn.backend_name) var(txn.path_match),field(2,:) if { var(txn.path_match_qualifier) -m str BACKEND }
  util-backend-servers:
    template: |
      {#- Pre-allocated server pool with auto-expansion #}
      {%- if max_server_slots is defined %}
        {%- set initial_slots = max_server_slots %}
      {%- else %}
        {%- set initial_slots = 10 %}  {#- Default when not specified #}
      {%- endif %}

      {#- === Endpoint Collection === #}
      {#- Collect active endpoints using O(1) indexed lookup #}
      {#- Use namespace() to maintain list across loop scopes #}
      {%- set ns = namespace(active_endpoints=[]) %}
      {%- for endpoint_slice in resources.endpoints.Fetch(service_name) %}
        {%- for endpoint in (endpoint_slice.endpoints | default([])) %}
          {%- for address in (endpoint.addresses | default([])) %}
            {%- if endpoint.targetRef is defined and endpoint.targetRef.name is defined %}
              {%- set endpoint_name = endpoint.targetRef.name %}
            {%- else %}
              {%- set endpoint_name = address %}
            {%- endif %}
            {%- set ns.active_endpoints = ns.active_endpoints.append({'name': endpoint_name, 'address': address, 'port': port}) %}
          {%- endfor %}
        {%- endfor %}
      {%- endfor %}

      {#- Calculate required slots using simpler approach #}
      {%- set active_count = ns.active_endpoints|length %}
      {#- For now, just use initial_slots since we have few endpoints #}
      {%- set max_servers = initial_slots %}
      # base/util-backend-servers

      {#- === Maxconn Value (Generic, Resource-Agnostic) === #}
      {#- Resource-specific libraries (haproxytech.yaml) set ns_server_opts.pod_maxconn_value #}
      {#- base.yaml is resource-agnostic and reads from namespace (persists across includes) #}

      {#- === Server Options Building === #}
      {#- Build server options string from namespace variable array #}
      {%- set server_opts = "" %}
      {%- if ns_server_opts is defined and (ns_server_opts.flags | length) > 0 %}
        {%- set server_opts = " " ~ (ns_server_opts.flags | join(" ")) %}
      {%- endif %}

      {#- === Server Line Generation === #}
      {#- Generate all server slots with fixed names #}
      {%- for i in range(1, max_servers + 1) %}
        {%- if loop.index0 < ns.active_endpoints|length %}
          {#- Active server with real endpoint #}
          {%- set endpoint = ns.active_endpoints[loop.index0] %}
      server SRV_{{ i }} {{ endpoint.address }}:{{ endpoint.port }}{{ server_opts }}{%- if ns_server_opts is defined and ns_server_opts.pod_maxconn_value is defined %} maxconn {{ ns_server_opts.pod_maxconn_value }}{%- endif %} check  # Pod: {{ endpoint.name }}
        {%- else %}
          {#- Disabled placeholder server #}
      server SRV_{{ i }} 127.0.0.1:1 disabled  # Placeholder
        {%- endif -%}
      {%- endfor -%}
  global-top:
    priority: 100
    template: |
      {#- Orchestrator snippet that includes all global-top-* snippets #}
      {#- Global snippets generate top-level HAProxy elements like userlist sections #}
      {#- Usage: {% include "global-top" %} in haproxy.cfg #}
      {%- from "util-macros" import include_matching -%}
      {{- include_matching("global-top-*") -}}

  backend-directives:
    priority: 100
    template: |
      {#- Orchestrator snippet that includes all backend-directives-* snippets #}
      {#- Backend directive snippets generate per-backend directives like http-request auth #}
      {#- Usage: {% include "backend-directives" %} in backend definitions #}
      {%- from "util-macros" import include_matching -%}
      {{- include_matching("backend-directives-*") -}}

maps:
  host.map:
    template: |
      # base/host.map
      {#- Generic host mapping infrastructure #}
      {#- Resource libraries populate this map via map-host-* snippets #}
      {%- from "util-macros" import include_matching -%}
      {{- include_matching("map-host-*") -}}

  path-exact.map:
    template: |
      # base/path-exact.map
      # This map is used to match the host header (without ":port") concatenated with the requested path (without query params) to an HAProxy backend defined in haproxy.cfg.
      # It should be used with the equality string matcher. Example:
      #   http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map({{ "path-exact.map" | get_path("map") }})
      {#- Resource libraries populate this map via map-path-exact-* snippets #}
      {%- from "util-macros" import include_matching -%}
      {{- include_matching("map-path-exact-*") -}}

  path-prefix-exact.map:
    template: |
      # base/path-prefix-exact.map
      # This map is used to match the host header (without ":port") concatenated with the requested path (without query params) to an HAProxy backend defined in haproxy.cfg.
      {#- Resource libraries populate this map via map-path-prefix-exact-* snippets #}
      {%- from "util-macros" import include_matching -%}
      {{- include_matching("map-path-prefix-exact-*") -}}

  path-prefix.map:
    template: |
      # base/path-prefix.map
      # This map is used to match the host header (without ":port") concatenated with the requested path (without query params) to an HAProxy backend defined in haproxy.cfg.
      # It should be used with the prefix string matcher. Example:
      #   http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_beg({{ "path-prefix.map" | get_path("map") }})
      {#- Resource libraries populate this map via map-path-prefix-* snippets #}
      {%- from "util-macros" import include_matching -%}
      {{- include_matching("map-path-prefix-*") -}}

  path-regex.map:
    template: |
      # base/path-regex.map
      # This map is used to match the host header (without ":port") concatenated with the requested path (without query params) to an HAProxy backend defined in haproxy.cfg.
      # It should be used with the regex string matcher. Example:
      #   http-request set-var(txn.path_match) var(txn.host_match),concat(,txn.path,),map_reg({{ "path-regex.map" | get_path("map") }})
      {#- Resource libraries populate this map via map-path-regex-* snippets #}
      {%- from "util-macros" import include_matching -%}
      {{- include_matching("map-path-regex-*") -}}

  weighted-multi-backend.map:
    template: |
      # base/weighted-multi-backend.map
      # Weighted multi-backend routing map
      # Maps random_number:route_key to backend name for MULTIBACKEND qualifier
      # Format: <0 to total_weight-1>:<namespace>_<resource>_<rule_idx> <backend_name>
      # Entries are expanded: weight N generates N consecutive entries
      # Libraries populate via map-weighted-backend-* pattern
      {% from "util-macros" import include_matching %}
      {{- include_matching("map-weighted-backend-*") }}

files:
  400.http:
    template: |
      HTTP/1.0 400 Bad Request
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>400 Bad Request</h1>
      <p>Your browser sent a request that this server could not understand.</p>
      </body></html>

  403.http:
    template: |
      HTTP/1.0 403 Forbidden
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>403 Forbidden</h1>
      <p>You don't have permission to access this resource.</p>
      </body></html>

  408.http:
    template: |
      HTTP/1.0 408 Request Time-out
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>408 Request Time-out</h1>
      <p>Your browser didn't send a complete request in time.</p>
      </body></html>

  500.http:
    template: |
      HTTP/1.0 500 Internal Server Error
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>500 Internal Server Error</h1>
      <p>An internal server error occurred.</p>
      </body></html>

  502.http:
    template: |
      HTTP/1.0 502 Bad Gateway
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>502 Bad Gateway</h1>
      <p>The server received an invalid response from an upstream server.</p>
      </body></html>

  503.http:
    template: |
      HTTP/1.0 503 Service Unavailable
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>503 Service Unavailable</h1>
      <p>No server is available to handle this request.</p>
      </body></html>

  504.http:
    template: |
      HTTP/1.0 504 Gateway Time-out
      Cache-Control: no-cache
      Connection: close
      Content-Type: text/html

      <html><body><h1>504 Gateway Time-out</h1>
      <p>The server didn't respond in time.</p>
      </body></html>

sslCertificates:
  default.pem:
    template: |
      {#- Default SSL certificate for HTTPS frontend #}
      {#- Loads certificate from TLS Secret (configurable via values.yaml) #}
      {#- Secret name and namespace come from templatingSettings.extraContext #}
      {%- set cert_namespace = default_ssl_cert_namespace | default("haproxy-template-ic") %}
      {%- set cert_name = default_ssl_cert_name | default("default-ssl-cert") %}
      {%- set secret = resources.secrets.GetSingle(cert_namespace, cert_name) %}
      {%- if secret %}
      {{- secret.data["tls.crt"] | b64decode -}}
      {{- secret.data["tls.key"] | b64decode -}}
      {%- endif %}

haproxyConfig:
  template: |
    global
        log stdout len 4096 local0 info
        user haproxy
        group haproxy
        daemon
        ca-base /etc/ssl/certs
        crt-base /etc/haproxy/ssl
        tune.ssl.default-dh-param 2048

    defaults
        mode http
        log global
        option httplog
        option dontlognull
        option log-health-checks
        option forwardfor
        timeout connect 5000
        timeout client 50000
        timeout server 50000
        errorfile 400 {{ "400.http" | get_path("file") }}
        errorfile 403 {{ "403.http" | get_path("file") }}
        errorfile 408 {{ "408.http" | get_path("file") }}
        errorfile 500 {{ "500.http" | get_path("file") }}
        errorfile 502 {{ "502.http" | get_path("file") }}
        errorfile 503 {{ "503.http" | get_path("file") }}
        errorfile 504 {{ "504.http" | get_path("file") }}

    {#- Include global top-level snippets (e.g., userlist sections) #}
    {% include "global-top" %}

    {#- Initialize global feature registry for conditional infrastructure #}
    {#- Libraries can register feature needs via features-* snippets #}
    {%- set global_features = namespace(
        ssl_passthrough_backends=[]
    ) %}

    {#- Phase 1: Feature Registration #}
    {#- Let resource libraries scan resources and register infrastructure needs #}
    {%- from "util-macros" import include_matching -%}
    {{- include_matching("features-*") | trim }}

    frontend status
        bind *:8404
        no log
        http-request return status 200 content-type text/plain string "OK" if { path /healthz }
        http-request return status 200 content-type text/plain string "READY" if { path /ready }

    frontend http_frontend
        bind *:{{ httpPort | default(8080) | int }}

        {#- Include frontend routing logic (can be overridden by libraries) #}
        {%- filter indent(8, first=False) %}
        {% include "frontend-routing-logic" -%}
        {%- endfilter %}
        # Debug headers (when enabled via templating settings)
        {%- if debug | default(false) %}
        # HAProxy routing decision introspection
        http-response set-header X-HAProxy-Backend %[var(txn.backend_name)] if { var(txn.backend_name) -m found }
        http-response set-header X-HAProxy-Host-Match %[var(txn.host_match)] if { var(txn.host_match) -m found }
        http-response set-header X-HAProxy-Path-Match %[var(txn.path_match)] if { var(txn.path_match) -m found }
        http-response set-header X-HAProxy-Path-Match-Qualifier %[var(txn.path_match_qualifier)] if { var(txn.path_match_qualifier) -m found }
        http-response set-header X-HAProxy-Total-Weight %[var(txn.total_weight)] if { var(txn.total_weight) -m found }
        http-response set-header X-HAProxy-Random-Weight %[var(txn.random_weight)] if { var(txn.random_weight) -m found }
        http-response set-header X-HAProxy-Route-Key %[var(txn.route_key)] if { var(txn.route_key) -m found }
        # Gateway-specific headers (set by gateway.yaml advanced matchers)
        http-response set-header X-Gateway-Matched-Route %[var(txn.matched_route)] if { var(txn.matched_route) -m found }
        http-response set-header X-Gateway-Match-Reason %[var(txn.match_reason)] if { var(txn.match_reason) -m found }
        http-response set-header X-Gateway-Filters-Applied %[var(txn.filters_applied)] if { var(txn.filters_applied) -m found }
        {%- endif -%}
        {#- Extension point for frontend request/response filters #}
        {#- Runs AFTER routing decisions, BEFORE backend selection #}
        {#- Libraries can inject filter logic here (header modification, redirects, rewrites) #}
        {%- from "util-macros" import include_matching -%}
        {%- filter indent(8, first=False) -%}
        {{- include_matching("frontend-filters-*") | trim }}
        {%- endfilter -%}
        # Use backend from txn.backend_name (set by qualifier logic in "frontend-routing-logic")
        # Falls through to default_backend if backend_name is empty
        use_backend %[var(txn.backend_name)] if { var(txn.backend_name) -m found }

        # Default backend
        default_backend default_backend

    {#- SSL Passthrough Infrastructure - Conditional Architecture #}
    {#- Only generated when SSL passthrough backends are registered #}
    {#- Architecture: TCP frontend + unix socket HTTPS frontend + loopback backend #}
    {%- if global_features.ssl_passthrough_backends | length > 0 %}
    {#- TCP frontend extracts SNI and routes to passthrough backends or loopback #}
    # base/frontends-ssl-tcp

    frontend ssl-tcp
        mode tcp
        bind *:{{ httpsPort | default(8443) | int }}

        # Extract SNI for routing decisions (wait up to 5s for client hello)
        tcp-request inspect-delay 5s
        tcp-request content accept if { req_ssl_hello_type 1 }

        # Route to passthrough backends based on SNI
        {%- for backend in global_features.ssl_passthrough_backends %}
        use_backend {{ backend.name }} if { req_ssl_sni -m str {{ backend.sni }} }
        {%- endfor %}

        # Default: route to loopback backend for SSL termination
        default_backend ssl-loopback

    # base/backends-ssl-loopback

    backend ssl-loopback
        mode tcp
        server loopback unix@/var/run/ssl-frontend.sock send-proxy-v2

    {%- endif %}

    # base/frontends-https

    frontend https
        mode http
        {%- if global_features.ssl_passthrough_backends | length > 0 %}
        bind unix@/var/run/ssl-frontend.sock{% include "util-ssl-bind-options" %} accept-proxy
        {%- else %}
        bind *:{{ httpsPort | default(8443) | int }}{% include "util-ssl-bind-options" %}
        {%- endif %}

        {#- Reuse frontend routing logic from base.yaml #}
        {%- filter indent(8, first=False) %}
        {% include "frontend-routing-logic" -%}
        {%- endfilter %}

        # Use backend from txn.backend_name (set by qualifier logic)
        use_backend %[var(txn.backend_name)] if { var(txn.backend_name) -m found }

        # Default backend
        default_backend default_backend

    {#- Extension point for additional frontends (e.g., custom TCP services) #}
    {#- Resource libraries can inject frontends-* snippets #}
    {%- from "util-macros" import include_matching -%}
    {{- include_matching("frontends-*") | trim }}

    {#- Include all resource-specific backend definitions using plugin pattern #}
    {#- Resource libraries implement backends-* snippets (e.g., backends-ingress, backends-gateway) #}
    {{- include_matching("backends-*") | trim }}
    backend default_backend
        http-request return status 404
    {%+ if false +%}{%+ endif +%}

  # Post-processing: Normalize indentation to 2 spaces
  # Applies regex replacement to ensure consistent indentation throughout the config
  postProcessing:
    - type: regex_replace
      params:
        pattern: "^[ ]+"
        replace: "  "
