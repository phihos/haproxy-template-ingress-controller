// Package v32 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package v32

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Basic_authScopes = "basic_auth.Scopes"
)

// Defines values for AcmeProviderChallenge.
const (
	AcmeProviderChallengeDns01  AcmeProviderChallenge = "dns-01"
	AcmeProviderChallengeHttp01 AcmeProviderChallenge = "http-01"
)

// Defines values for AcmeProviderKeytype.
const (
	AcmeProviderKeytypeECDSA AcmeProviderKeytype = "ECDSA"
	AcmeProviderKeytypeRSA   AcmeProviderKeytype = "RSA"
)

// Defines values for AcmeProviderReuseKey.
const (
	AcmeProviderReuseKeyDisabled AcmeProviderReuseKey = "disabled"
	AcmeProviderReuseKeyEnabled  AcmeProviderReuseKey = "enabled"
)

// Defines values for AwsRegionIpv4Address.
const (
	AwsRegionIpv4AddressPrivate AwsRegionIpv4Address = "private"
	AwsRegionIpv4AddressPublic  AwsRegionIpv4Address = "public"
)

// Defines values for AwsRegionServerSlotsGrowthType.
const (
	AwsRegionServerSlotsGrowthTypeExponential AwsRegionServerSlotsGrowthType = "exponential"
	AwsRegionServerSlotsGrowthTypeLinear      AwsRegionServerSlotsGrowthType = "linear"
)

// Defines values for BackendAbortonclose.
const (
	BackendAbortoncloseDisabled BackendAbortonclose = "disabled"
	BackendAbortoncloseEnabled  BackendAbortonclose = "enabled"
)

// Defines values for BackendAcceptInvalidHttpResponse.
const (
	BackendAcceptInvalidHttpResponseDisabled BackendAcceptInvalidHttpResponse = "disabled"
	BackendAcceptInvalidHttpResponseEnabled  BackendAcceptInvalidHttpResponse = "enabled"
)

// Defines values for BackendAcceptUnsafeViolationsInHttpResponse.
const (
	BackendAcceptUnsafeViolationsInHttpResponseDisabled BackendAcceptUnsafeViolationsInHttpResponse = "disabled"
	BackendAcceptUnsafeViolationsInHttpResponseEnabled  BackendAcceptUnsafeViolationsInHttpResponse = "enabled"
)

// Defines values for BackendAdvCheck.
const (
	BackendAdvCheckHttpchk     BackendAdvCheck = "httpchk"
	BackendAdvCheckLdapCheck   BackendAdvCheck = "ldap-check"
	BackendAdvCheckMysqlCheck  BackendAdvCheck = "mysql-check"
	BackendAdvCheckPgsqlCheck  BackendAdvCheck = "pgsql-check"
	BackendAdvCheckRedisCheck  BackendAdvCheck = "redis-check"
	BackendAdvCheckSmtpchk     BackendAdvCheck = "smtpchk"
	BackendAdvCheckSslHelloChk BackendAdvCheck = "ssl-hello-chk"
	BackendAdvCheckTcpCheck    BackendAdvCheck = "tcp-check"
)

// Defines values for BackendAllbackups.
const (
	BackendAllbackupsDisabled BackendAllbackups = "disabled"
	BackendAllbackupsEnabled  BackendAllbackups = "enabled"
)

// Defines values for BackendCheckcache.
const (
	BackendCheckcacheDisabled BackendCheckcache = "disabled"
	BackendCheckcacheEnabled  BackendCheckcache = "enabled"
)

// Defines values for BackendExternalCheck.
const (
	BackendExternalCheckDisabled BackendExternalCheck = "disabled"
	BackendExternalCheckEnabled  BackendExternalCheck = "enabled"
)

// Defines values for BackendForcePersistCond.
const (
	BackendForcePersistCondIf     BackendForcePersistCond = "if"
	BackendForcePersistCondUnless BackendForcePersistCond = "unless"
)

// Defines values for BackendForcePersistListCond.
const (
	BackendForcePersistListCondIf     BackendForcePersistListCond = "if"
	BackendForcePersistListCondUnless BackendForcePersistListCond = "unless"
)

// Defines values for BackendH1CaseAdjustBogusServer.
const (
	BackendH1CaseAdjustBogusServerDisabled BackendH1CaseAdjustBogusServer = "disabled"
	BackendH1CaseAdjustBogusServerEnabled  BackendH1CaseAdjustBogusServer = "enabled"
)

// Defines values for BackendHashPreserveAffinity.
const (
	BackendHashPreserveAffinityAlways   BackendHashPreserveAffinity = "always"
	BackendHashPreserveAffinityMaxconn  BackendHashPreserveAffinity = "maxconn"
	BackendHashPreserveAffinityMaxqueue BackendHashPreserveAffinity = "maxqueue"
)

// Defines values for BackendHttpBufferRequest.
const (
	BackendHttpBufferRequestDisabled BackendHttpBufferRequest = "disabled"
	BackendHttpBufferRequestEnabled  BackendHttpBufferRequest = "enabled"
)

// Defines values for BackendHttpDropRequestTrailers.
const (
	BackendHttpDropRequestTrailersDisabled BackendHttpDropRequestTrailers = "disabled"
	BackendHttpDropRequestTrailersEnabled  BackendHttpDropRequestTrailers = "enabled"
)

// Defines values for BackendHttpNoDelay.
const (
	BackendHttpNoDelayDisabled BackendHttpNoDelay = "disabled"
	BackendHttpNoDelayEnabled  BackendHttpNoDelay = "enabled"
)

// Defines values for BackendHttpUseHtx.
const (
	BackendHttpUseHtxDisabled BackendHttpUseHtx = "disabled"
	BackendHttpUseHtxEnabled  BackendHttpUseHtx = "enabled"
)

// Defines values for BackendHttpConnectionMode.
const (
	BackendHttpConnectionModeHttpKeepAlive   BackendHttpConnectionMode = "http-keep-alive"
	BackendHttpConnectionModeHttpServerClose BackendHttpConnectionMode = "http-server-close"
	BackendHttpConnectionModeHttpclose       BackendHttpConnectionMode = "httpclose"
)

// Defines values for BackendHttpPretendKeepalive.
const (
	BackendHttpPretendKeepaliveDisabled BackendHttpPretendKeepalive = "disabled"
	BackendHttpPretendKeepaliveEnabled  BackendHttpPretendKeepalive = "enabled"
)

// Defines values for BackendHttpProxy.
const (
	BackendHttpProxyDisabled BackendHttpProxy = "disabled"
	BackendHttpProxyEnabled  BackendHttpProxy = "enabled"
)

// Defines values for BackendHttpRestrictReqHdrNames.
const (
	BackendHttpRestrictReqHdrNamesDelete   BackendHttpRestrictReqHdrNames = "delete"
	BackendHttpRestrictReqHdrNamesPreserve BackendHttpRestrictReqHdrNames = "preserve"
	BackendHttpRestrictReqHdrNamesReject   BackendHttpRestrictReqHdrNames = "reject"
)

// Defines values for BackendHttpReuse.
const (
	BackendHttpReuseAggressive BackendHttpReuse = "aggressive"
	BackendHttpReuseAlways     BackendHttpReuse = "always"
	BackendHttpReuseNever      BackendHttpReuse = "never"
	BackendHttpReuseSafe       BackendHttpReuse = "safe"
)

// Defines values for BackendIgnorePersistCond.
const (
	BackendIgnorePersistCondIf     BackendIgnorePersistCond = "if"
	BackendIgnorePersistCondUnless BackendIgnorePersistCond = "unless"
)

// Defines values for BackendIgnorePersistListCond.
const (
	BackendIgnorePersistListCondIf     BackendIgnorePersistListCond = "if"
	BackendIgnorePersistListCondUnless BackendIgnorePersistListCond = "unless"
)

// Defines values for BackendIndependentStreams.
const (
	BackendIndependentStreamsDisabled BackendIndependentStreams = "disabled"
	BackendIndependentStreamsEnabled  BackendIndependentStreams = "enabled"
)

// Defines values for BackendLoadServerStateFromFile.
const (
	BackendLoadServerStateFromFileGlobal BackendLoadServerStateFromFile = "global"
	BackendLoadServerStateFromFileLocal  BackendLoadServerStateFromFile = "local"
	BackendLoadServerStateFromFileNone   BackendLoadServerStateFromFile = "none"
)

// Defines values for BackendLogHealthChecks.
const (
	BackendLogHealthChecksDisabled BackendLogHealthChecks = "disabled"
	BackendLogHealthChecksEnabled  BackendLogHealthChecks = "enabled"
)

// Defines values for BackendMode.
const (
	BackendModeHttp BackendMode = "http"
	BackendModeLog  BackendMode = "log"
	BackendModeTcp  BackendMode = "tcp"
)

// Defines values for BackendNolinger.
const (
	BackendNolingerDisabled BackendNolinger = "disabled"
	BackendNolingerEnabled  BackendNolinger = "enabled"
)

// Defines values for BackendPersist.
const (
	BackendPersistDisabled BackendPersist = "disabled"
	BackendPersistEnabled  BackendPersist = "enabled"
)

// Defines values for BackendPreferLastServer.
const (
	BackendPreferLastServerDisabled BackendPreferLastServer = "disabled"
	BackendPreferLastServerEnabled  BackendPreferLastServer = "enabled"
)

// Defines values for BackendSpliceAuto.
const (
	BackendSpliceAutoDisabled BackendSpliceAuto = "disabled"
	BackendSpliceAutoEnabled  BackendSpliceAuto = "enabled"
)

// Defines values for BackendSpliceRequest.
const (
	BackendSpliceRequestDisabled BackendSpliceRequest = "disabled"
	BackendSpliceRequestEnabled  BackendSpliceRequest = "enabled"
)

// Defines values for BackendSpliceResponse.
const (
	BackendSpliceResponseDisabled BackendSpliceResponse = "disabled"
	BackendSpliceResponseEnabled  BackendSpliceResponse = "enabled"
)

// Defines values for BackendSpopCheck.
const (
	BackendSpopCheckDisabled BackendSpopCheck = "disabled"
	BackendSpopCheckEnabled  BackendSpopCheck = "enabled"
)

// Defines values for BackendSrvtcpka.
const (
	BackendSrvtcpkaDisabled BackendSrvtcpka = "disabled"
	BackendSrvtcpkaEnabled  BackendSrvtcpka = "enabled"
)

// Defines values for BackendTcpSmartConnect.
const (
	BackendTcpSmartConnectDisabled BackendTcpSmartConnect = "disabled"
	BackendTcpSmartConnectEnabled  BackendTcpSmartConnect = "enabled"
)

// Defines values for BackendTcpka.
const (
	BackendTcpkaDisabled BackendTcpka = "disabled"
	BackendTcpkaEnabled  BackendTcpka = "enabled"
)

// Defines values for BackendTransparent.
const (
	BackendTransparentDisabled BackendTransparent = "disabled"
	BackendTransparentEnabled  BackendTransparent = "enabled"
)

// Defines values for BackendBaseAbortonclose.
const (
	BackendBaseAbortoncloseDisabled BackendBaseAbortonclose = "disabled"
	BackendBaseAbortoncloseEnabled  BackendBaseAbortonclose = "enabled"
)

// Defines values for BackendBaseAcceptInvalidHttpResponse.
const (
	BackendBaseAcceptInvalidHttpResponseDisabled BackendBaseAcceptInvalidHttpResponse = "disabled"
	BackendBaseAcceptInvalidHttpResponseEnabled  BackendBaseAcceptInvalidHttpResponse = "enabled"
)

// Defines values for BackendBaseAcceptUnsafeViolationsInHttpResponse.
const (
	BackendBaseAcceptUnsafeViolationsInHttpResponseDisabled BackendBaseAcceptUnsafeViolationsInHttpResponse = "disabled"
	BackendBaseAcceptUnsafeViolationsInHttpResponseEnabled  BackendBaseAcceptUnsafeViolationsInHttpResponse = "enabled"
)

// Defines values for BackendBaseAdvCheck.
const (
	BackendBaseAdvCheckHttpchk     BackendBaseAdvCheck = "httpchk"
	BackendBaseAdvCheckLdapCheck   BackendBaseAdvCheck = "ldap-check"
	BackendBaseAdvCheckMysqlCheck  BackendBaseAdvCheck = "mysql-check"
	BackendBaseAdvCheckPgsqlCheck  BackendBaseAdvCheck = "pgsql-check"
	BackendBaseAdvCheckRedisCheck  BackendBaseAdvCheck = "redis-check"
	BackendBaseAdvCheckSmtpchk     BackendBaseAdvCheck = "smtpchk"
	BackendBaseAdvCheckSslHelloChk BackendBaseAdvCheck = "ssl-hello-chk"
	BackendBaseAdvCheckTcpCheck    BackendBaseAdvCheck = "tcp-check"
)

// Defines values for BackendBaseAllbackups.
const (
	BackendBaseAllbackupsDisabled BackendBaseAllbackups = "disabled"
	BackendBaseAllbackupsEnabled  BackendBaseAllbackups = "enabled"
)

// Defines values for BackendBaseCheckcache.
const (
	BackendBaseCheckcacheDisabled BackendBaseCheckcache = "disabled"
	BackendBaseCheckcacheEnabled  BackendBaseCheckcache = "enabled"
)

// Defines values for BackendBaseExternalCheck.
const (
	BackendBaseExternalCheckDisabled BackendBaseExternalCheck = "disabled"
	BackendBaseExternalCheckEnabled  BackendBaseExternalCheck = "enabled"
)

// Defines values for BackendBaseForcePersistCond.
const (
	BackendBaseForcePersistCondIf     BackendBaseForcePersistCond = "if"
	BackendBaseForcePersistCondUnless BackendBaseForcePersistCond = "unless"
)

// Defines values for BackendBaseForcePersistListCond.
const (
	BackendBaseForcePersistListCondIf     BackendBaseForcePersistListCond = "if"
	BackendBaseForcePersistListCondUnless BackendBaseForcePersistListCond = "unless"
)

// Defines values for BackendBaseH1CaseAdjustBogusServer.
const (
	BackendBaseH1CaseAdjustBogusServerDisabled BackendBaseH1CaseAdjustBogusServer = "disabled"
	BackendBaseH1CaseAdjustBogusServerEnabled  BackendBaseH1CaseAdjustBogusServer = "enabled"
)

// Defines values for BackendBaseHashPreserveAffinity.
const (
	BackendBaseHashPreserveAffinityAlways   BackendBaseHashPreserveAffinity = "always"
	BackendBaseHashPreserveAffinityMaxconn  BackendBaseHashPreserveAffinity = "maxconn"
	BackendBaseHashPreserveAffinityMaxqueue BackendBaseHashPreserveAffinity = "maxqueue"
)

// Defines values for BackendBaseHttpBufferRequest.
const (
	BackendBaseHttpBufferRequestDisabled BackendBaseHttpBufferRequest = "disabled"
	BackendBaseHttpBufferRequestEnabled  BackendBaseHttpBufferRequest = "enabled"
)

// Defines values for BackendBaseHttpDropRequestTrailers.
const (
	BackendBaseHttpDropRequestTrailersDisabled BackendBaseHttpDropRequestTrailers = "disabled"
	BackendBaseHttpDropRequestTrailersEnabled  BackendBaseHttpDropRequestTrailers = "enabled"
)

// Defines values for BackendBaseHttpNoDelay.
const (
	BackendBaseHttpNoDelayDisabled BackendBaseHttpNoDelay = "disabled"
	BackendBaseHttpNoDelayEnabled  BackendBaseHttpNoDelay = "enabled"
)

// Defines values for BackendBaseHttpUseHtx.
const (
	BackendBaseHttpUseHtxDisabled BackendBaseHttpUseHtx = "disabled"
	BackendBaseHttpUseHtxEnabled  BackendBaseHttpUseHtx = "enabled"
)

// Defines values for BackendBaseHttpConnectionMode.
const (
	BackendBaseHttpConnectionModeHttpKeepAlive   BackendBaseHttpConnectionMode = "http-keep-alive"
	BackendBaseHttpConnectionModeHttpServerClose BackendBaseHttpConnectionMode = "http-server-close"
	BackendBaseHttpConnectionModeHttpclose       BackendBaseHttpConnectionMode = "httpclose"
)

// Defines values for BackendBaseHttpPretendKeepalive.
const (
	BackendBaseHttpPretendKeepaliveDisabled BackendBaseHttpPretendKeepalive = "disabled"
	BackendBaseHttpPretendKeepaliveEnabled  BackendBaseHttpPretendKeepalive = "enabled"
)

// Defines values for BackendBaseHttpProxy.
const (
	BackendBaseHttpProxyDisabled BackendBaseHttpProxy = "disabled"
	BackendBaseHttpProxyEnabled  BackendBaseHttpProxy = "enabled"
)

// Defines values for BackendBaseHttpRestrictReqHdrNames.
const (
	BackendBaseHttpRestrictReqHdrNamesDelete   BackendBaseHttpRestrictReqHdrNames = "delete"
	BackendBaseHttpRestrictReqHdrNamesPreserve BackendBaseHttpRestrictReqHdrNames = "preserve"
	BackendBaseHttpRestrictReqHdrNamesReject   BackendBaseHttpRestrictReqHdrNames = "reject"
)

// Defines values for BackendBaseHttpReuse.
const (
	BackendBaseHttpReuseAggressive BackendBaseHttpReuse = "aggressive"
	BackendBaseHttpReuseAlways     BackendBaseHttpReuse = "always"
	BackendBaseHttpReuseNever      BackendBaseHttpReuse = "never"
	BackendBaseHttpReuseSafe       BackendBaseHttpReuse = "safe"
)

// Defines values for BackendBaseIgnorePersistCond.
const (
	BackendBaseIgnorePersistCondIf     BackendBaseIgnorePersistCond = "if"
	BackendBaseIgnorePersistCondUnless BackendBaseIgnorePersistCond = "unless"
)

// Defines values for BackendBaseIgnorePersistListCond.
const (
	BackendBaseIgnorePersistListCondIf     BackendBaseIgnorePersistListCond = "if"
	BackendBaseIgnorePersistListCondUnless BackendBaseIgnorePersistListCond = "unless"
)

// Defines values for BackendBaseIndependentStreams.
const (
	BackendBaseIndependentStreamsDisabled BackendBaseIndependentStreams = "disabled"
	BackendBaseIndependentStreamsEnabled  BackendBaseIndependentStreams = "enabled"
)

// Defines values for BackendBaseLoadServerStateFromFile.
const (
	BackendBaseLoadServerStateFromFileGlobal BackendBaseLoadServerStateFromFile = "global"
	BackendBaseLoadServerStateFromFileLocal  BackendBaseLoadServerStateFromFile = "local"
	BackendBaseLoadServerStateFromFileNone   BackendBaseLoadServerStateFromFile = "none"
)

// Defines values for BackendBaseLogHealthChecks.
const (
	BackendBaseLogHealthChecksDisabled BackendBaseLogHealthChecks = "disabled"
	BackendBaseLogHealthChecksEnabled  BackendBaseLogHealthChecks = "enabled"
)

// Defines values for BackendBaseMode.
const (
	BackendBaseModeHttp BackendBaseMode = "http"
	BackendBaseModeLog  BackendBaseMode = "log"
	BackendBaseModeTcp  BackendBaseMode = "tcp"
)

// Defines values for BackendBaseNolinger.
const (
	BackendBaseNolingerDisabled BackendBaseNolinger = "disabled"
	BackendBaseNolingerEnabled  BackendBaseNolinger = "enabled"
)

// Defines values for BackendBasePersist.
const (
	BackendBasePersistDisabled BackendBasePersist = "disabled"
	BackendBasePersistEnabled  BackendBasePersist = "enabled"
)

// Defines values for BackendBasePreferLastServer.
const (
	BackendBasePreferLastServerDisabled BackendBasePreferLastServer = "disabled"
	BackendBasePreferLastServerEnabled  BackendBasePreferLastServer = "enabled"
)

// Defines values for BackendBaseSpliceAuto.
const (
	BackendBaseSpliceAutoDisabled BackendBaseSpliceAuto = "disabled"
	BackendBaseSpliceAutoEnabled  BackendBaseSpliceAuto = "enabled"
)

// Defines values for BackendBaseSpliceRequest.
const (
	BackendBaseSpliceRequestDisabled BackendBaseSpliceRequest = "disabled"
	BackendBaseSpliceRequestEnabled  BackendBaseSpliceRequest = "enabled"
)

// Defines values for BackendBaseSpliceResponse.
const (
	BackendBaseSpliceResponseDisabled BackendBaseSpliceResponse = "disabled"
	BackendBaseSpliceResponseEnabled  BackendBaseSpliceResponse = "enabled"
)

// Defines values for BackendBaseSpopCheck.
const (
	BackendBaseSpopCheckDisabled BackendBaseSpopCheck = "disabled"
	BackendBaseSpopCheckEnabled  BackendBaseSpopCheck = "enabled"
)

// Defines values for BackendBaseSrvtcpka.
const (
	BackendBaseSrvtcpkaDisabled BackendBaseSrvtcpka = "disabled"
	BackendBaseSrvtcpkaEnabled  BackendBaseSrvtcpka = "enabled"
)

// Defines values for BackendBaseTcpSmartConnect.
const (
	BackendBaseTcpSmartConnectDisabled BackendBaseTcpSmartConnect = "disabled"
	BackendBaseTcpSmartConnectEnabled  BackendBaseTcpSmartConnect = "enabled"
)

// Defines values for BackendBaseTcpka.
const (
	BackendBaseTcpkaDisabled BackendBaseTcpka = "disabled"
	BackendBaseTcpkaEnabled  BackendBaseTcpka = "enabled"
)

// Defines values for BackendBaseTransparent.
const (
	BackendBaseTransparentDisabled BackendBaseTransparent = "disabled"
	BackendBaseTransparentEnabled  BackendBaseTransparent = "enabled"
)

// Defines values for BackendSwitchingRuleCond.
const (
	BackendSwitchingRuleCondIf     BackendSwitchingRuleCond = "if"
	BackendSwitchingRuleCondUnless BackendSwitchingRuleCond = "unless"
)

// Defines values for BalanceAlgorithm.
const (
	BalanceAlgorithmFirst      BalanceAlgorithm = "first"
	BalanceAlgorithmHash       BalanceAlgorithm = "hash"
	BalanceAlgorithmHdr        BalanceAlgorithm = "hdr"
	BalanceAlgorithmLeastconn  BalanceAlgorithm = "leastconn"
	BalanceAlgorithmRandom     BalanceAlgorithm = "random"
	BalanceAlgorithmRdpCookie  BalanceAlgorithm = "rdp-cookie"
	BalanceAlgorithmRoundrobin BalanceAlgorithm = "roundrobin"
	BalanceAlgorithmSource     BalanceAlgorithm = "source"
	BalanceAlgorithmStaticRr   BalanceAlgorithm = "static-rr"
	BalanceAlgorithmUri        BalanceAlgorithm = "uri"
	BalanceAlgorithmUrlParam   BalanceAlgorithm = "url_param"
)

// Defines values for BindForceStrictSni.
const (
	BindForceStrictSniDisabled BindForceStrictSni = "disabled"
	BindForceStrictSniEnabled  BindForceStrictSni = "enabled"
)

// Defines values for BindLevel.
const (
	BindLevelAdmin    BindLevel = "admin"
	BindLevelOperator BindLevel = "operator"
	BindLevelUser     BindLevel = "user"
)

// Defines values for BindQuicCcAlgo.
const (
	BindQuicCcAlgoBbr     BindQuicCcAlgo = "bbr"
	BindQuicCcAlgoCubic   BindQuicCcAlgo = "cubic"
	BindQuicCcAlgoNewreno BindQuicCcAlgo = "newreno"
	BindQuicCcAlgoNocc    BindQuicCcAlgo = "nocc"
)

// Defines values for BindQuicSocket.
const (
	BindQuicSocketConnection BindQuicSocket = "connection"
	BindQuicSocketListener   BindQuicSocket = "listener"
)

// Defines values for BindSeverityOutput.
const (
	BindSeverityOutputNone   BindSeverityOutput = "none"
	BindSeverityOutputNumber BindSeverityOutput = "number"
	BindSeverityOutputString BindSeverityOutput = "string"
)

// Defines values for BindSslMaxVer.
const (
	BindSslMaxVerSSLv3  BindSslMaxVer = "SSLv3"
	BindSslMaxVerTLSv10 BindSslMaxVer = "TLSv1.0"
	BindSslMaxVerTLSv11 BindSslMaxVer = "TLSv1.1"
	BindSslMaxVerTLSv12 BindSslMaxVer = "TLSv1.2"
	BindSslMaxVerTLSv13 BindSslMaxVer = "TLSv1.3"
)

// Defines values for BindSslMinVer.
const (
	BindSslMinVerSSLv3  BindSslMinVer = "SSLv3"
	BindSslMinVerTLSv10 BindSslMinVer = "TLSv1.0"
	BindSslMinVerTLSv11 BindSslMinVer = "TLSv1.1"
	BindSslMinVerTLSv12 BindSslMinVer = "TLSv1.2"
	BindSslMinVerTLSv13 BindSslMinVer = "TLSv1.3"
)

// Defines values for BindSslv3.
const (
	BindSslv3Disabled BindSslv3 = "disabled"
	BindSslv3Enabled  BindSslv3 = "enabled"
)

// Defines values for BindTlsTickets.
const (
	BindTlsTicketsDisabled BindTlsTickets = "disabled"
	BindTlsTicketsEnabled  BindTlsTickets = "enabled"
)

// Defines values for BindTlsv10.
const (
	BindTlsv10Disabled BindTlsv10 = "disabled"
	BindTlsv10Enabled  BindTlsv10 = "enabled"
)

// Defines values for BindTlsv11.
const (
	BindTlsv11Disabled BindTlsv11 = "disabled"
	BindTlsv11Enabled  BindTlsv11 = "enabled"
)

// Defines values for BindTlsv12.
const (
	BindTlsv12Disabled BindTlsv12 = "disabled"
	BindTlsv12Enabled  BindTlsv12 = "enabled"
)

// Defines values for BindTlsv13.
const (
	BindTlsv13Disabled BindTlsv13 = "disabled"
	BindTlsv13Enabled  BindTlsv13 = "enabled"
)

// Defines values for BindVerify.
const (
	BindVerifyNone     BindVerify = "none"
	BindVerifyOptional BindVerify = "optional"
	BindVerifyRequired BindVerify = "required"
)

// Defines values for BindParamsForceStrictSni.
const (
	BindParamsForceStrictSniDisabled BindParamsForceStrictSni = "disabled"
	BindParamsForceStrictSniEnabled  BindParamsForceStrictSni = "enabled"
)

// Defines values for BindParamsLevel.
const (
	BindParamsLevelAdmin    BindParamsLevel = "admin"
	BindParamsLevelOperator BindParamsLevel = "operator"
	BindParamsLevelUser     BindParamsLevel = "user"
)

// Defines values for BindParamsQuicCcAlgo.
const (
	BindParamsQuicCcAlgoBbr     BindParamsQuicCcAlgo = "bbr"
	BindParamsQuicCcAlgoCubic   BindParamsQuicCcAlgo = "cubic"
	BindParamsQuicCcAlgoNewreno BindParamsQuicCcAlgo = "newreno"
	BindParamsQuicCcAlgoNocc    BindParamsQuicCcAlgo = "nocc"
)

// Defines values for BindParamsQuicSocket.
const (
	BindParamsQuicSocketConnection BindParamsQuicSocket = "connection"
	BindParamsQuicSocketListener   BindParamsQuicSocket = "listener"
)

// Defines values for BindParamsSeverityOutput.
const (
	BindParamsSeverityOutputNone   BindParamsSeverityOutput = "none"
	BindParamsSeverityOutputNumber BindParamsSeverityOutput = "number"
	BindParamsSeverityOutputString BindParamsSeverityOutput = "string"
)

// Defines values for BindParamsSslMaxVer.
const (
	BindParamsSslMaxVerSSLv3  BindParamsSslMaxVer = "SSLv3"
	BindParamsSslMaxVerTLSv10 BindParamsSslMaxVer = "TLSv1.0"
	BindParamsSslMaxVerTLSv11 BindParamsSslMaxVer = "TLSv1.1"
	BindParamsSslMaxVerTLSv12 BindParamsSslMaxVer = "TLSv1.2"
	BindParamsSslMaxVerTLSv13 BindParamsSslMaxVer = "TLSv1.3"
)

// Defines values for BindParamsSslMinVer.
const (
	BindParamsSslMinVerSSLv3  BindParamsSslMinVer = "SSLv3"
	BindParamsSslMinVerTLSv10 BindParamsSslMinVer = "TLSv1.0"
	BindParamsSslMinVerTLSv11 BindParamsSslMinVer = "TLSv1.1"
	BindParamsSslMinVerTLSv12 BindParamsSslMinVer = "TLSv1.2"
	BindParamsSslMinVerTLSv13 BindParamsSslMinVer = "TLSv1.3"
)

// Defines values for BindParamsSslv3.
const (
	BindParamsSslv3Disabled BindParamsSslv3 = "disabled"
	BindParamsSslv3Enabled  BindParamsSslv3 = "enabled"
)

// Defines values for BindParamsTlsTickets.
const (
	BindParamsTlsTicketsDisabled BindParamsTlsTickets = "disabled"
	BindParamsTlsTicketsEnabled  BindParamsTlsTickets = "enabled"
)

// Defines values for BindParamsTlsv10.
const (
	BindParamsTlsv10Disabled BindParamsTlsv10 = "disabled"
	BindParamsTlsv10Enabled  BindParamsTlsv10 = "enabled"
)

// Defines values for BindParamsTlsv11.
const (
	BindParamsTlsv11Disabled BindParamsTlsv11 = "disabled"
	BindParamsTlsv11Enabled  BindParamsTlsv11 = "enabled"
)

// Defines values for BindParamsTlsv12.
const (
	BindParamsTlsv12Disabled BindParamsTlsv12 = "disabled"
	BindParamsTlsv12Enabled  BindParamsTlsv12 = "enabled"
)

// Defines values for BindParamsTlsv13.
const (
	BindParamsTlsv13Disabled BindParamsTlsv13 = "disabled"
	BindParamsTlsv13Enabled  BindParamsTlsv13 = "enabled"
)

// Defines values for BindParamsVerify.
const (
	BindParamsVerifyNone     BindParamsVerify = "none"
	BindParamsVerifyOptional BindParamsVerify = "optional"
	BindParamsVerifyRequired BindParamsVerify = "required"
)

// Defines values for CaptureType.
const (
	CaptureTypeRequest  CaptureType = "request"
	CaptureTypeResponse CaptureType = "response"
)

// Defines values for ClusterSettingsClusterLogTargetsProtocol.
const (
	ClusterSettingsClusterLogTargetsProtocolTcp ClusterSettingsClusterLogTargetsProtocol = "tcp"
	ClusterSettingsClusterLogTargetsProtocolUdp ClusterSettingsClusterLogTargetsProtocol = "udp"
)

// Defines values for ClusterSettingsMode.
const (
	ClusterSettingsModeCluster ClusterSettingsMode = "cluster"
	ClusterSettingsModeSingle  ClusterSettingsMode = "single"
)

// Defines values for ClusterSettingsStatus.
const (
	ClusterSettingsStatusActive          ClusterSettingsStatus = "active"
	ClusterSettingsStatusUnreachable     ClusterSettingsStatus = "unreachable"
	ClusterSettingsStatusWaitingApproval ClusterSettingsStatus = "waiting_approval"
)

// Defines values for CompressionAlgoReq.
const (
	CompressionAlgoReqDeflate    CompressionAlgoReq = "deflate"
	CompressionAlgoReqGzip       CompressionAlgoReq = "gzip"
	CompressionAlgoReqIdentity   CompressionAlgoReq = "identity"
	CompressionAlgoReqRawDeflate CompressionAlgoReq = "raw-deflate"
)

// Defines values for CompressionAlgorithms.
const (
	CompressionAlgorithmsDeflate    CompressionAlgorithms = "deflate"
	CompressionAlgorithmsGzip       CompressionAlgorithms = "gzip"
	CompressionAlgorithmsIdentity   CompressionAlgorithms = "identity"
	CompressionAlgorithmsRawDeflate CompressionAlgorithms = "raw-deflate"
)

// Defines values for CompressionAlgosRes.
const (
	CompressionAlgosResDeflate    CompressionAlgosRes = "deflate"
	CompressionAlgosResGzip       CompressionAlgosRes = "gzip"
	CompressionAlgosResIdentity   CompressionAlgosRes = "identity"
	CompressionAlgosResRawDeflate CompressionAlgosRes = "raw-deflate"
)

// Defines values for CompressionDirection.
const (
	CompressionDirectionBoth     CompressionDirection = "both"
	CompressionDirectionRequest  CompressionDirection = "request"
	CompressionDirectionResponse CompressionDirection = "response"
)

// Defines values for ConfigStickTableSrvkey.
const (
	ConfigStickTableSrvkeyAddr ConfigStickTableSrvkey = "addr"
	ConfigStickTableSrvkeyName ConfigStickTableSrvkey = "name"
)

// Defines values for ConfigStickTableType.
const (
	ConfigStickTableTypeBinary  ConfigStickTableType = "binary"
	ConfigStickTableTypeInteger ConfigStickTableType = "integer"
	ConfigStickTableTypeIp      ConfigStickTableType = "ip"
	ConfigStickTableTypeIpv6    ConfigStickTableType = "ipv6"
	ConfigStickTableTypeString  ConfigStickTableType = "string"
)

// Defines values for ConsulHealthCheckPolicy.
const (
	ConsulHealthCheckPolicyAll  ConsulHealthCheckPolicy = "all"
	ConsulHealthCheckPolicyAny  ConsulHealthCheckPolicy = "any"
	ConsulHealthCheckPolicyMin  ConsulHealthCheckPolicy = "min"
	ConsulHealthCheckPolicyNone ConsulHealthCheckPolicy = "none"
)

// Defines values for ConsulMode.
const (
	ConsulModeHttp  ConsulMode = "http"
	ConsulModeHttps ConsulMode = "https"
)

// Defines values for ConsulServerSlotsGrowthType.
const (
	ConsulServerSlotsGrowthTypeExponential ConsulServerSlotsGrowthType = "exponential"
	ConsulServerSlotsGrowthTypeLinear      ConsulServerSlotsGrowthType = "linear"
)

// Defines values for CookieType.
const (
	CookieTypeInsert  CookieType = "insert"
	CookieTypePrefix  CookieType = "prefix"
	CookieTypeRewrite CookieType = "rewrite"
)

// Defines values for CrtLoadOcspUpdate.
const (
	CrtLoadOcspUpdateDisabled CrtLoadOcspUpdate = "disabled"
	CrtLoadOcspUpdateEnabled  CrtLoadOcspUpdate = "enabled"
)

// Defines values for DefaultBindForceStrictSni.
const (
	DefaultBindForceStrictSniDisabled DefaultBindForceStrictSni = "disabled"
	DefaultBindForceStrictSniEnabled  DefaultBindForceStrictSni = "enabled"
)

// Defines values for DefaultBindLevel.
const (
	DefaultBindLevelAdmin    DefaultBindLevel = "admin"
	DefaultBindLevelOperator DefaultBindLevel = "operator"
	DefaultBindLevelUser     DefaultBindLevel = "user"
)

// Defines values for DefaultBindQuicCcAlgo.
const (
	DefaultBindQuicCcAlgoBbr     DefaultBindQuicCcAlgo = "bbr"
	DefaultBindQuicCcAlgoCubic   DefaultBindQuicCcAlgo = "cubic"
	DefaultBindQuicCcAlgoNewreno DefaultBindQuicCcAlgo = "newreno"
	DefaultBindQuicCcAlgoNocc    DefaultBindQuicCcAlgo = "nocc"
)

// Defines values for DefaultBindQuicSocket.
const (
	DefaultBindQuicSocketConnection DefaultBindQuicSocket = "connection"
	DefaultBindQuicSocketListener   DefaultBindQuicSocket = "listener"
)

// Defines values for DefaultBindSeverityOutput.
const (
	DefaultBindSeverityOutputNone   DefaultBindSeverityOutput = "none"
	DefaultBindSeverityOutputNumber DefaultBindSeverityOutput = "number"
	DefaultBindSeverityOutputString DefaultBindSeverityOutput = "string"
)

// Defines values for DefaultBindSslMaxVer.
const (
	DefaultBindSslMaxVerSSLv3  DefaultBindSslMaxVer = "SSLv3"
	DefaultBindSslMaxVerTLSv10 DefaultBindSslMaxVer = "TLSv1.0"
	DefaultBindSslMaxVerTLSv11 DefaultBindSslMaxVer = "TLSv1.1"
	DefaultBindSslMaxVerTLSv12 DefaultBindSslMaxVer = "TLSv1.2"
	DefaultBindSslMaxVerTLSv13 DefaultBindSslMaxVer = "TLSv1.3"
)

// Defines values for DefaultBindSslMinVer.
const (
	DefaultBindSslMinVerSSLv3  DefaultBindSslMinVer = "SSLv3"
	DefaultBindSslMinVerTLSv10 DefaultBindSslMinVer = "TLSv1.0"
	DefaultBindSslMinVerTLSv11 DefaultBindSslMinVer = "TLSv1.1"
	DefaultBindSslMinVerTLSv12 DefaultBindSslMinVer = "TLSv1.2"
	DefaultBindSslMinVerTLSv13 DefaultBindSslMinVer = "TLSv1.3"
)

// Defines values for DefaultBindSslv3.
const (
	DefaultBindSslv3Disabled DefaultBindSslv3 = "disabled"
	DefaultBindSslv3Enabled  DefaultBindSslv3 = "enabled"
)

// Defines values for DefaultBindTlsTickets.
const (
	DefaultBindTlsTicketsDisabled DefaultBindTlsTickets = "disabled"
	DefaultBindTlsTicketsEnabled  DefaultBindTlsTickets = "enabled"
)

// Defines values for DefaultBindTlsv10.
const (
	DefaultBindTlsv10Disabled DefaultBindTlsv10 = "disabled"
	DefaultBindTlsv10Enabled  DefaultBindTlsv10 = "enabled"
)

// Defines values for DefaultBindTlsv11.
const (
	DefaultBindTlsv11Disabled DefaultBindTlsv11 = "disabled"
	DefaultBindTlsv11Enabled  DefaultBindTlsv11 = "enabled"
)

// Defines values for DefaultBindTlsv12.
const (
	DefaultBindTlsv12Disabled DefaultBindTlsv12 = "disabled"
	DefaultBindTlsv12Enabled  DefaultBindTlsv12 = "enabled"
)

// Defines values for DefaultBindTlsv13.
const (
	DefaultBindTlsv13Disabled DefaultBindTlsv13 = "disabled"
	DefaultBindTlsv13Enabled  DefaultBindTlsv13 = "enabled"
)

// Defines values for DefaultBindVerify.
const (
	DefaultBindVerifyNone     DefaultBindVerify = "none"
	DefaultBindVerifyOptional DefaultBindVerify = "optional"
	DefaultBindVerifyRequired DefaultBindVerify = "required"
)

// Defines values for DefaultsAbortonclose.
const (
	DefaultsAbortoncloseDisabled DefaultsAbortonclose = "disabled"
	DefaultsAbortoncloseEnabled  DefaultsAbortonclose = "enabled"
)

// Defines values for DefaultsAcceptInvalidHttpRequest.
const (
	DefaultsAcceptInvalidHttpRequestDisabled DefaultsAcceptInvalidHttpRequest = "disabled"
	DefaultsAcceptInvalidHttpRequestEnabled  DefaultsAcceptInvalidHttpRequest = "enabled"
)

// Defines values for DefaultsAcceptInvalidHttpResponse.
const (
	DefaultsAcceptInvalidHttpResponseDisabled DefaultsAcceptInvalidHttpResponse = "disabled"
	DefaultsAcceptInvalidHttpResponseEnabled  DefaultsAcceptInvalidHttpResponse = "enabled"
)

// Defines values for DefaultsAcceptUnsafeViolationsInHttpRequest.
const (
	DefaultsAcceptUnsafeViolationsInHttpRequestDisabled DefaultsAcceptUnsafeViolationsInHttpRequest = "disabled"
	DefaultsAcceptUnsafeViolationsInHttpRequestEnabled  DefaultsAcceptUnsafeViolationsInHttpRequest = "enabled"
)

// Defines values for DefaultsAcceptUnsafeViolationsInHttpResponse.
const (
	DefaultsAcceptUnsafeViolationsInHttpResponseDisabled DefaultsAcceptUnsafeViolationsInHttpResponse = "disabled"
	DefaultsAcceptUnsafeViolationsInHttpResponseEnabled  DefaultsAcceptUnsafeViolationsInHttpResponse = "enabled"
)

// Defines values for DefaultsAdvCheck.
const (
	DefaultsAdvCheckHttpchk     DefaultsAdvCheck = "httpchk"
	DefaultsAdvCheckLdapCheck   DefaultsAdvCheck = "ldap-check"
	DefaultsAdvCheckMysqlCheck  DefaultsAdvCheck = "mysql-check"
	DefaultsAdvCheckPgsqlCheck  DefaultsAdvCheck = "pgsql-check"
	DefaultsAdvCheckRedisCheck  DefaultsAdvCheck = "redis-check"
	DefaultsAdvCheckSmtpchk     DefaultsAdvCheck = "smtpchk"
	DefaultsAdvCheckSslHelloChk DefaultsAdvCheck = "ssl-hello-chk"
	DefaultsAdvCheckTcpCheck    DefaultsAdvCheck = "tcp-check"
)

// Defines values for DefaultsAllbackups.
const (
	DefaultsAllbackupsDisabled DefaultsAllbackups = "disabled"
	DefaultsAllbackupsEnabled  DefaultsAllbackups = "enabled"
)

// Defines values for DefaultsCheckcache.
const (
	DefaultsCheckcacheDisabled DefaultsCheckcache = "disabled"
	DefaultsCheckcacheEnabled  DefaultsCheckcache = "enabled"
)

// Defines values for DefaultsClitcpka.
const (
	DefaultsClitcpkaDisabled DefaultsClitcpka = "disabled"
	DefaultsClitcpkaEnabled  DefaultsClitcpka = "enabled"
)

// Defines values for DefaultsContstats.
const (
	DefaultsContstatsEnabled DefaultsContstats = "enabled"
)

// Defines values for DefaultsDisableH2Upgrade.
const (
	DefaultsDisableH2UpgradeDisabled DefaultsDisableH2Upgrade = "disabled"
	DefaultsDisableH2UpgradeEnabled  DefaultsDisableH2Upgrade = "enabled"
)

// Defines values for DefaultsDontlogNormal.
const (
	DefaultsDontlogNormalDisabled DefaultsDontlogNormal = "disabled"
	DefaultsDontlogNormalEnabled  DefaultsDontlogNormal = "enabled"
)

// Defines values for DefaultsDontlognull.
const (
	DefaultsDontlognullDisabled DefaultsDontlognull = "disabled"
	DefaultsDontlognullEnabled  DefaultsDontlognull = "enabled"
)

// Defines values for DefaultsExternalCheck.
const (
	DefaultsExternalCheckDisabled DefaultsExternalCheck = "disabled"
	DefaultsExternalCheckEnabled  DefaultsExternalCheck = "enabled"
)

// Defines values for DefaultsH1CaseAdjustBogusClient.
const (
	DefaultsH1CaseAdjustBogusClientDisabled DefaultsH1CaseAdjustBogusClient = "disabled"
	DefaultsH1CaseAdjustBogusClientEnabled  DefaultsH1CaseAdjustBogusClient = "enabled"
)

// Defines values for DefaultsH1CaseAdjustBogusServer.
const (
	DefaultsH1CaseAdjustBogusServerDisabled DefaultsH1CaseAdjustBogusServer = "disabled"
	DefaultsH1CaseAdjustBogusServerEnabled  DefaultsH1CaseAdjustBogusServer = "enabled"
)

// Defines values for DefaultsHashPreserveAffinity.
const (
	DefaultsHashPreserveAffinityAlways   DefaultsHashPreserveAffinity = "always"
	DefaultsHashPreserveAffinityMaxconn  DefaultsHashPreserveAffinity = "maxconn"
	DefaultsHashPreserveAffinityMaxqueue DefaultsHashPreserveAffinity = "maxqueue"
)

// Defines values for DefaultsHttpBufferRequest.
const (
	DefaultsHttpBufferRequestDisabled DefaultsHttpBufferRequest = "disabled"
	DefaultsHttpBufferRequestEnabled  DefaultsHttpBufferRequest = "enabled"
)

// Defines values for DefaultsHttpDropRequestTrailers.
const (
	DefaultsHttpDropRequestTrailersDisabled DefaultsHttpDropRequestTrailers = "disabled"
	DefaultsHttpDropRequestTrailersEnabled  DefaultsHttpDropRequestTrailers = "enabled"
)

// Defines values for DefaultsHttpDropResponseTrailers.
const (
	DefaultsHttpDropResponseTrailersDisabled DefaultsHttpDropResponseTrailers = "disabled"
	DefaultsHttpDropResponseTrailersEnabled  DefaultsHttpDropResponseTrailers = "enabled"
)

// Defines values for DefaultsHttpUseHtx.
const (
	DefaultsHttpUseHtxDisabled DefaultsHttpUseHtx = "disabled"
	DefaultsHttpUseHtxEnabled  DefaultsHttpUseHtx = "enabled"
)

// Defines values for DefaultsHttpConnectionMode.
const (
	DefaultsHttpConnectionModeHttpKeepAlive   DefaultsHttpConnectionMode = "http-keep-alive"
	DefaultsHttpConnectionModeHttpServerClose DefaultsHttpConnectionMode = "http-server-close"
	DefaultsHttpConnectionModeHttpclose       DefaultsHttpConnectionMode = "httpclose"
)

// Defines values for DefaultsHttpIgnoreProbes.
const (
	DefaultsHttpIgnoreProbesDisabled DefaultsHttpIgnoreProbes = "disabled"
	DefaultsHttpIgnoreProbesEnabled  DefaultsHttpIgnoreProbes = "enabled"
)

// Defines values for DefaultsHttpNoDelay.
const (
	DefaultsHttpNoDelayDisabled DefaultsHttpNoDelay = "disabled"
	DefaultsHttpNoDelayEnabled  DefaultsHttpNoDelay = "enabled"
)

// Defines values for DefaultsHttpPretendKeepalive.
const (
	DefaultsHttpPretendKeepaliveDisabled DefaultsHttpPretendKeepalive = "disabled"
	DefaultsHttpPretendKeepaliveEnabled  DefaultsHttpPretendKeepalive = "enabled"
)

// Defines values for DefaultsHttpRestrictReqHdrNames.
const (
	DefaultsHttpRestrictReqHdrNamesDelete   DefaultsHttpRestrictReqHdrNames = "delete"
	DefaultsHttpRestrictReqHdrNamesPreserve DefaultsHttpRestrictReqHdrNames = "preserve"
	DefaultsHttpRestrictReqHdrNamesReject   DefaultsHttpRestrictReqHdrNames = "reject"
)

// Defines values for DefaultsHttpReuse.
const (
	DefaultsHttpReuseAggressive DefaultsHttpReuse = "aggressive"
	DefaultsHttpReuseAlways     DefaultsHttpReuse = "always"
	DefaultsHttpReuseNever      DefaultsHttpReuse = "never"
	DefaultsHttpReuseSafe       DefaultsHttpReuse = "safe"
)

// Defines values for DefaultsHttpUseProxyHeader.
const (
	DefaultsHttpUseProxyHeaderDisabled DefaultsHttpUseProxyHeader = "disabled"
	DefaultsHttpUseProxyHeaderEnabled  DefaultsHttpUseProxyHeader = "enabled"
)

// Defines values for DefaultsHttpslog.
const (
	DefaultsHttpslogDisabled DefaultsHttpslog = "disabled"
	DefaultsHttpslogEnabled  DefaultsHttpslog = "enabled"
)

// Defines values for DefaultsIdleCloseOnResponse.
const (
	DefaultsIdleCloseOnResponseDisabled DefaultsIdleCloseOnResponse = "disabled"
	DefaultsIdleCloseOnResponseEnabled  DefaultsIdleCloseOnResponse = "enabled"
)

// Defines values for DefaultsIndependentStreams.
const (
	DefaultsIndependentStreamsDisabled DefaultsIndependentStreams = "disabled"
	DefaultsIndependentStreamsEnabled  DefaultsIndependentStreams = "enabled"
)

// Defines values for DefaultsLoadServerStateFromFile.
const (
	DefaultsLoadServerStateFromFileGlobal DefaultsLoadServerStateFromFile = "global"
	DefaultsLoadServerStateFromFileLocal  DefaultsLoadServerStateFromFile = "local"
	DefaultsLoadServerStateFromFileNone   DefaultsLoadServerStateFromFile = "none"
)

// Defines values for DefaultsLogHealthChecks.
const (
	DefaultsLogHealthChecksDisabled DefaultsLogHealthChecks = "disabled"
	DefaultsLogHealthChecksEnabled  DefaultsLogHealthChecks = "enabled"
)

// Defines values for DefaultsLogSeparateErrors.
const (
	DefaultsLogSeparateErrorsDisabled DefaultsLogSeparateErrors = "disabled"
	DefaultsLogSeparateErrorsEnabled  DefaultsLogSeparateErrors = "enabled"
)

// Defines values for DefaultsLogSteps.
const (
	DefaultsLogStepsAccept   DefaultsLogSteps = "accept"
	DefaultsLogStepsAny      DefaultsLogSteps = "any"
	DefaultsLogStepsClose    DefaultsLogSteps = "close"
	DefaultsLogStepsConnect  DefaultsLogSteps = "connect"
	DefaultsLogStepsError    DefaultsLogSteps = "error"
	DefaultsLogStepsRequest  DefaultsLogSteps = "request"
	DefaultsLogStepsResponse DefaultsLogSteps = "response"
)

// Defines values for DefaultsLogasap.
const (
	DefaultsLogasapDisabled DefaultsLogasap = "disabled"
	DefaultsLogasapEnabled  DefaultsLogasap = "enabled"
)

// Defines values for DefaultsMode.
const (
	DefaultsModeHttp DefaultsMode = "http"
	DefaultsModeLog  DefaultsMode = "log"
	DefaultsModeTcp  DefaultsMode = "tcp"
)

// Defines values for DefaultsNolinger.
const (
	DefaultsNolingerDisabled DefaultsNolinger = "disabled"
	DefaultsNolingerEnabled  DefaultsNolinger = "enabled"
)

// Defines values for DefaultsPersist.
const (
	DefaultsPersistDisabled DefaultsPersist = "disabled"
	DefaultsPersistEnabled  DefaultsPersist = "enabled"
)

// Defines values for DefaultsPreferLastServer.
const (
	DefaultsPreferLastServerDisabled DefaultsPreferLastServer = "disabled"
	DefaultsPreferLastServerEnabled  DefaultsPreferLastServer = "enabled"
)

// Defines values for DefaultsSocketStats.
const (
	DefaultsSocketStatsDisabled DefaultsSocketStats = "disabled"
	DefaultsSocketStatsEnabled  DefaultsSocketStats = "enabled"
)

// Defines values for DefaultsSpliceAuto.
const (
	DefaultsSpliceAutoDisabled DefaultsSpliceAuto = "disabled"
	DefaultsSpliceAutoEnabled  DefaultsSpliceAuto = "enabled"
)

// Defines values for DefaultsSpliceRequest.
const (
	DefaultsSpliceRequestDisabled DefaultsSpliceRequest = "disabled"
	DefaultsSpliceRequestEnabled  DefaultsSpliceRequest = "enabled"
)

// Defines values for DefaultsSpliceResponse.
const (
	DefaultsSpliceResponseDisabled DefaultsSpliceResponse = "disabled"
	DefaultsSpliceResponseEnabled  DefaultsSpliceResponse = "enabled"
)

// Defines values for DefaultsSrvtcpka.
const (
	DefaultsSrvtcpkaDisabled DefaultsSrvtcpka = "disabled"
	DefaultsSrvtcpkaEnabled  DefaultsSrvtcpka = "enabled"
)

// Defines values for DefaultsTcpSmartAccept.
const (
	DefaultsTcpSmartAcceptDisabled DefaultsTcpSmartAccept = "disabled"
	DefaultsTcpSmartAcceptEnabled  DefaultsTcpSmartAccept = "enabled"
)

// Defines values for DefaultsTcpSmartConnect.
const (
	DefaultsTcpSmartConnectDisabled DefaultsTcpSmartConnect = "disabled"
	DefaultsTcpSmartConnectEnabled  DefaultsTcpSmartConnect = "enabled"
)

// Defines values for DefaultsTcpka.
const (
	DefaultsTcpkaDisabled DefaultsTcpka = "disabled"
	DefaultsTcpkaEnabled  DefaultsTcpka = "enabled"
)

// Defines values for DefaultsTransparent.
const (
	DefaultsTransparentDisabled DefaultsTransparent = "disabled"
	DefaultsTransparentEnabled  DefaultsTransparent = "enabled"
)

// Defines values for DefaultsBaseAbortonclose.
const (
	DefaultsBaseAbortoncloseDisabled DefaultsBaseAbortonclose = "disabled"
	DefaultsBaseAbortoncloseEnabled  DefaultsBaseAbortonclose = "enabled"
)

// Defines values for DefaultsBaseAcceptInvalidHttpRequest.
const (
	DefaultsBaseAcceptInvalidHttpRequestDisabled DefaultsBaseAcceptInvalidHttpRequest = "disabled"
	DefaultsBaseAcceptInvalidHttpRequestEnabled  DefaultsBaseAcceptInvalidHttpRequest = "enabled"
)

// Defines values for DefaultsBaseAcceptInvalidHttpResponse.
const (
	DefaultsBaseAcceptInvalidHttpResponseDisabled DefaultsBaseAcceptInvalidHttpResponse = "disabled"
	DefaultsBaseAcceptInvalidHttpResponseEnabled  DefaultsBaseAcceptInvalidHttpResponse = "enabled"
)

// Defines values for DefaultsBaseAcceptUnsafeViolationsInHttpRequest.
const (
	DefaultsBaseAcceptUnsafeViolationsInHttpRequestDisabled DefaultsBaseAcceptUnsafeViolationsInHttpRequest = "disabled"
	DefaultsBaseAcceptUnsafeViolationsInHttpRequestEnabled  DefaultsBaseAcceptUnsafeViolationsInHttpRequest = "enabled"
)

// Defines values for DefaultsBaseAcceptUnsafeViolationsInHttpResponse.
const (
	DefaultsBaseAcceptUnsafeViolationsInHttpResponseDisabled DefaultsBaseAcceptUnsafeViolationsInHttpResponse = "disabled"
	DefaultsBaseAcceptUnsafeViolationsInHttpResponseEnabled  DefaultsBaseAcceptUnsafeViolationsInHttpResponse = "enabled"
)

// Defines values for DefaultsBaseAdvCheck.
const (
	DefaultsBaseAdvCheckHttpchk     DefaultsBaseAdvCheck = "httpchk"
	DefaultsBaseAdvCheckLdapCheck   DefaultsBaseAdvCheck = "ldap-check"
	DefaultsBaseAdvCheckMysqlCheck  DefaultsBaseAdvCheck = "mysql-check"
	DefaultsBaseAdvCheckPgsqlCheck  DefaultsBaseAdvCheck = "pgsql-check"
	DefaultsBaseAdvCheckRedisCheck  DefaultsBaseAdvCheck = "redis-check"
	DefaultsBaseAdvCheckSmtpchk     DefaultsBaseAdvCheck = "smtpchk"
	DefaultsBaseAdvCheckSslHelloChk DefaultsBaseAdvCheck = "ssl-hello-chk"
	DefaultsBaseAdvCheckTcpCheck    DefaultsBaseAdvCheck = "tcp-check"
)

// Defines values for DefaultsBaseAllbackups.
const (
	DefaultsBaseAllbackupsDisabled DefaultsBaseAllbackups = "disabled"
	DefaultsBaseAllbackupsEnabled  DefaultsBaseAllbackups = "enabled"
)

// Defines values for DefaultsBaseCheckcache.
const (
	DefaultsBaseCheckcacheDisabled DefaultsBaseCheckcache = "disabled"
	DefaultsBaseCheckcacheEnabled  DefaultsBaseCheckcache = "enabled"
)

// Defines values for DefaultsBaseClitcpka.
const (
	DefaultsBaseClitcpkaDisabled DefaultsBaseClitcpka = "disabled"
	DefaultsBaseClitcpkaEnabled  DefaultsBaseClitcpka = "enabled"
)

// Defines values for DefaultsBaseContstats.
const (
	DefaultsBaseContstatsEnabled DefaultsBaseContstats = "enabled"
)

// Defines values for DefaultsBaseDisableH2Upgrade.
const (
	DefaultsBaseDisableH2UpgradeDisabled DefaultsBaseDisableH2Upgrade = "disabled"
	DefaultsBaseDisableH2UpgradeEnabled  DefaultsBaseDisableH2Upgrade = "enabled"
)

// Defines values for DefaultsBaseDontlogNormal.
const (
	DefaultsBaseDontlogNormalDisabled DefaultsBaseDontlogNormal = "disabled"
	DefaultsBaseDontlogNormalEnabled  DefaultsBaseDontlogNormal = "enabled"
)

// Defines values for DefaultsBaseDontlognull.
const (
	DefaultsBaseDontlognullDisabled DefaultsBaseDontlognull = "disabled"
	DefaultsBaseDontlognullEnabled  DefaultsBaseDontlognull = "enabled"
)

// Defines values for DefaultsBaseExternalCheck.
const (
	DefaultsBaseExternalCheckDisabled DefaultsBaseExternalCheck = "disabled"
	DefaultsBaseExternalCheckEnabled  DefaultsBaseExternalCheck = "enabled"
)

// Defines values for DefaultsBaseH1CaseAdjustBogusClient.
const (
	DefaultsBaseH1CaseAdjustBogusClientDisabled DefaultsBaseH1CaseAdjustBogusClient = "disabled"
	DefaultsBaseH1CaseAdjustBogusClientEnabled  DefaultsBaseH1CaseAdjustBogusClient = "enabled"
)

// Defines values for DefaultsBaseH1CaseAdjustBogusServer.
const (
	DefaultsBaseH1CaseAdjustBogusServerDisabled DefaultsBaseH1CaseAdjustBogusServer = "disabled"
	DefaultsBaseH1CaseAdjustBogusServerEnabled  DefaultsBaseH1CaseAdjustBogusServer = "enabled"
)

// Defines values for DefaultsBaseHashPreserveAffinity.
const (
	DefaultsBaseHashPreserveAffinityAlways   DefaultsBaseHashPreserveAffinity = "always"
	DefaultsBaseHashPreserveAffinityMaxconn  DefaultsBaseHashPreserveAffinity = "maxconn"
	DefaultsBaseHashPreserveAffinityMaxqueue DefaultsBaseHashPreserveAffinity = "maxqueue"
)

// Defines values for DefaultsBaseHttpBufferRequest.
const (
	DefaultsBaseHttpBufferRequestDisabled DefaultsBaseHttpBufferRequest = "disabled"
	DefaultsBaseHttpBufferRequestEnabled  DefaultsBaseHttpBufferRequest = "enabled"
)

// Defines values for DefaultsBaseHttpDropRequestTrailers.
const (
	DefaultsBaseHttpDropRequestTrailersDisabled DefaultsBaseHttpDropRequestTrailers = "disabled"
	DefaultsBaseHttpDropRequestTrailersEnabled  DefaultsBaseHttpDropRequestTrailers = "enabled"
)

// Defines values for DefaultsBaseHttpDropResponseTrailers.
const (
	DefaultsBaseHttpDropResponseTrailersDisabled DefaultsBaseHttpDropResponseTrailers = "disabled"
	DefaultsBaseHttpDropResponseTrailersEnabled  DefaultsBaseHttpDropResponseTrailers = "enabled"
)

// Defines values for DefaultsBaseHttpUseHtx.
const (
	DefaultsBaseHttpUseHtxDisabled DefaultsBaseHttpUseHtx = "disabled"
	DefaultsBaseHttpUseHtxEnabled  DefaultsBaseHttpUseHtx = "enabled"
)

// Defines values for DefaultsBaseHttpConnectionMode.
const (
	DefaultsBaseHttpConnectionModeHttpKeepAlive   DefaultsBaseHttpConnectionMode = "http-keep-alive"
	DefaultsBaseHttpConnectionModeHttpServerClose DefaultsBaseHttpConnectionMode = "http-server-close"
	DefaultsBaseHttpConnectionModeHttpclose       DefaultsBaseHttpConnectionMode = "httpclose"
)

// Defines values for DefaultsBaseHttpIgnoreProbes.
const (
	DefaultsBaseHttpIgnoreProbesDisabled DefaultsBaseHttpIgnoreProbes = "disabled"
	DefaultsBaseHttpIgnoreProbesEnabled  DefaultsBaseHttpIgnoreProbes = "enabled"
)

// Defines values for DefaultsBaseHttpNoDelay.
const (
	DefaultsBaseHttpNoDelayDisabled DefaultsBaseHttpNoDelay = "disabled"
	DefaultsBaseHttpNoDelayEnabled  DefaultsBaseHttpNoDelay = "enabled"
)

// Defines values for DefaultsBaseHttpPretendKeepalive.
const (
	DefaultsBaseHttpPretendKeepaliveDisabled DefaultsBaseHttpPretendKeepalive = "disabled"
	DefaultsBaseHttpPretendKeepaliveEnabled  DefaultsBaseHttpPretendKeepalive = "enabled"
)

// Defines values for DefaultsBaseHttpRestrictReqHdrNames.
const (
	DefaultsBaseHttpRestrictReqHdrNamesDelete   DefaultsBaseHttpRestrictReqHdrNames = "delete"
	DefaultsBaseHttpRestrictReqHdrNamesPreserve DefaultsBaseHttpRestrictReqHdrNames = "preserve"
	DefaultsBaseHttpRestrictReqHdrNamesReject   DefaultsBaseHttpRestrictReqHdrNames = "reject"
)

// Defines values for DefaultsBaseHttpReuse.
const (
	DefaultsBaseHttpReuseAggressive DefaultsBaseHttpReuse = "aggressive"
	DefaultsBaseHttpReuseAlways     DefaultsBaseHttpReuse = "always"
	DefaultsBaseHttpReuseNever      DefaultsBaseHttpReuse = "never"
	DefaultsBaseHttpReuseSafe       DefaultsBaseHttpReuse = "safe"
)

// Defines values for DefaultsBaseHttpUseProxyHeader.
const (
	DefaultsBaseHttpUseProxyHeaderDisabled DefaultsBaseHttpUseProxyHeader = "disabled"
	DefaultsBaseHttpUseProxyHeaderEnabled  DefaultsBaseHttpUseProxyHeader = "enabled"
)

// Defines values for DefaultsBaseHttpslog.
const (
	DefaultsBaseHttpslogDisabled DefaultsBaseHttpslog = "disabled"
	DefaultsBaseHttpslogEnabled  DefaultsBaseHttpslog = "enabled"
)

// Defines values for DefaultsBaseIdleCloseOnResponse.
const (
	DefaultsBaseIdleCloseOnResponseDisabled DefaultsBaseIdleCloseOnResponse = "disabled"
	DefaultsBaseIdleCloseOnResponseEnabled  DefaultsBaseIdleCloseOnResponse = "enabled"
)

// Defines values for DefaultsBaseIndependentStreams.
const (
	DefaultsBaseIndependentStreamsDisabled DefaultsBaseIndependentStreams = "disabled"
	DefaultsBaseIndependentStreamsEnabled  DefaultsBaseIndependentStreams = "enabled"
)

// Defines values for DefaultsBaseLoadServerStateFromFile.
const (
	DefaultsBaseLoadServerStateFromFileGlobal DefaultsBaseLoadServerStateFromFile = "global"
	DefaultsBaseLoadServerStateFromFileLocal  DefaultsBaseLoadServerStateFromFile = "local"
	DefaultsBaseLoadServerStateFromFileNone   DefaultsBaseLoadServerStateFromFile = "none"
)

// Defines values for DefaultsBaseLogHealthChecks.
const (
	DefaultsBaseLogHealthChecksDisabled DefaultsBaseLogHealthChecks = "disabled"
	DefaultsBaseLogHealthChecksEnabled  DefaultsBaseLogHealthChecks = "enabled"
)

// Defines values for DefaultsBaseLogSeparateErrors.
const (
	DefaultsBaseLogSeparateErrorsDisabled DefaultsBaseLogSeparateErrors = "disabled"
	DefaultsBaseLogSeparateErrorsEnabled  DefaultsBaseLogSeparateErrors = "enabled"
)

// Defines values for DefaultsBaseLogSteps.
const (
	DefaultsBaseLogStepsAccept   DefaultsBaseLogSteps = "accept"
	DefaultsBaseLogStepsAny      DefaultsBaseLogSteps = "any"
	DefaultsBaseLogStepsClose    DefaultsBaseLogSteps = "close"
	DefaultsBaseLogStepsConnect  DefaultsBaseLogSteps = "connect"
	DefaultsBaseLogStepsError    DefaultsBaseLogSteps = "error"
	DefaultsBaseLogStepsRequest  DefaultsBaseLogSteps = "request"
	DefaultsBaseLogStepsResponse DefaultsBaseLogSteps = "response"
)

// Defines values for DefaultsBaseLogasap.
const (
	DefaultsBaseLogasapDisabled DefaultsBaseLogasap = "disabled"
	DefaultsBaseLogasapEnabled  DefaultsBaseLogasap = "enabled"
)

// Defines values for DefaultsBaseMode.
const (
	DefaultsBaseModeHttp DefaultsBaseMode = "http"
	DefaultsBaseModeLog  DefaultsBaseMode = "log"
	DefaultsBaseModeTcp  DefaultsBaseMode = "tcp"
)

// Defines values for DefaultsBaseNolinger.
const (
	DefaultsBaseNolingerDisabled DefaultsBaseNolinger = "disabled"
	DefaultsBaseNolingerEnabled  DefaultsBaseNolinger = "enabled"
)

// Defines values for DefaultsBasePersist.
const (
	DefaultsBasePersistDisabled DefaultsBasePersist = "disabled"
	DefaultsBasePersistEnabled  DefaultsBasePersist = "enabled"
)

// Defines values for DefaultsBasePreferLastServer.
const (
	DefaultsBasePreferLastServerDisabled DefaultsBasePreferLastServer = "disabled"
	DefaultsBasePreferLastServerEnabled  DefaultsBasePreferLastServer = "enabled"
)

// Defines values for DefaultsBaseSocketStats.
const (
	DefaultsBaseSocketStatsDisabled DefaultsBaseSocketStats = "disabled"
	DefaultsBaseSocketStatsEnabled  DefaultsBaseSocketStats = "enabled"
)

// Defines values for DefaultsBaseSpliceAuto.
const (
	DefaultsBaseSpliceAutoDisabled DefaultsBaseSpliceAuto = "disabled"
	DefaultsBaseSpliceAutoEnabled  DefaultsBaseSpliceAuto = "enabled"
)

// Defines values for DefaultsBaseSpliceRequest.
const (
	DefaultsBaseSpliceRequestDisabled DefaultsBaseSpliceRequest = "disabled"
	DefaultsBaseSpliceRequestEnabled  DefaultsBaseSpliceRequest = "enabled"
)

// Defines values for DefaultsBaseSpliceResponse.
const (
	DefaultsBaseSpliceResponseDisabled DefaultsBaseSpliceResponse = "disabled"
	DefaultsBaseSpliceResponseEnabled  DefaultsBaseSpliceResponse = "enabled"
)

// Defines values for DefaultsBaseSrvtcpka.
const (
	DefaultsBaseSrvtcpkaDisabled DefaultsBaseSrvtcpka = "disabled"
	DefaultsBaseSrvtcpkaEnabled  DefaultsBaseSrvtcpka = "enabled"
)

// Defines values for DefaultsBaseTcpSmartAccept.
const (
	DefaultsBaseTcpSmartAcceptDisabled DefaultsBaseTcpSmartAccept = "disabled"
	DefaultsBaseTcpSmartAcceptEnabled  DefaultsBaseTcpSmartAccept = "enabled"
)

// Defines values for DefaultsBaseTcpSmartConnect.
const (
	DefaultsBaseTcpSmartConnectDisabled DefaultsBaseTcpSmartConnect = "disabled"
	DefaultsBaseTcpSmartConnectEnabled  DefaultsBaseTcpSmartConnect = "enabled"
)

// Defines values for DefaultsBaseTcpka.
const (
	DefaultsBaseTcpkaDisabled DefaultsBaseTcpka = "disabled"
	DefaultsBaseTcpkaEnabled  DefaultsBaseTcpka = "enabled"
)

// Defines values for DefaultsBaseTransparent.
const (
	DefaultsBaseTransparentDisabled DefaultsBaseTransparent = "disabled"
	DefaultsBaseTransparentEnabled  DefaultsBaseTransparent = "enabled"
)

// Defines values for EmailAlertLevel.
const (
	EmailAlertLevelAlert   EmailAlertLevel = "alert"
	EmailAlertLevelCrit    EmailAlertLevel = "crit"
	EmailAlertLevelDebug   EmailAlertLevel = "debug"
	EmailAlertLevelEmerg   EmailAlertLevel = "emerg"
	EmailAlertLevelErr     EmailAlertLevel = "err"
	EmailAlertLevelInfo    EmailAlertLevel = "info"
	EmailAlertLevelNotice  EmailAlertLevel = "notice"
	EmailAlertLevelWarning EmailAlertLevel = "warning"
)

// Defines values for ErrorfileCode.
const (
	ErrorfileCodeN200 ErrorfileCode = 200
	ErrorfileCodeN400 ErrorfileCode = 400
	ErrorfileCodeN401 ErrorfileCode = 401
	ErrorfileCodeN403 ErrorfileCode = 403
	ErrorfileCodeN404 ErrorfileCode = 404
	ErrorfileCodeN405 ErrorfileCode = 405
	ErrorfileCodeN407 ErrorfileCode = 407
	ErrorfileCodeN408 ErrorfileCode = 408
	ErrorfileCodeN410 ErrorfileCode = 410
	ErrorfileCodeN413 ErrorfileCode = 413
	ErrorfileCodeN425 ErrorfileCode = 425
	ErrorfileCodeN429 ErrorfileCode = 429
	ErrorfileCodeN500 ErrorfileCode = 500
	ErrorfileCodeN501 ErrorfileCode = 501
	ErrorfileCodeN502 ErrorfileCode = 502
	ErrorfileCodeN503 ErrorfileCode = 503
	ErrorfileCodeN504 ErrorfileCode = 504
)

// Defines values for ErrorfilesCodes.
const (
	ErrorfilesCodesN200 ErrorfilesCodes = 200
	ErrorfilesCodesN400 ErrorfilesCodes = 400
	ErrorfilesCodesN401 ErrorfilesCodes = 401
	ErrorfilesCodesN403 ErrorfilesCodes = 403
	ErrorfilesCodesN404 ErrorfilesCodes = 404
	ErrorfilesCodesN405 ErrorfilesCodes = 405
	ErrorfilesCodesN407 ErrorfilesCodes = 407
	ErrorfilesCodesN408 ErrorfilesCodes = 408
	ErrorfilesCodesN410 ErrorfilesCodes = 410
	ErrorfilesCodesN413 ErrorfilesCodes = 413
	ErrorfilesCodesN425 ErrorfilesCodes = 425
	ErrorfilesCodesN429 ErrorfilesCodes = 429
	ErrorfilesCodesN500 ErrorfilesCodes = 500
	ErrorfilesCodesN501 ErrorfilesCodes = 501
	ErrorfilesCodesN502 ErrorfilesCodes = 502
	ErrorfilesCodesN503 ErrorfilesCodes = 503
	ErrorfilesCodesN504 ErrorfilesCodes = 504
)

// Defines values for ErrorlocCode.
const (
	ErrorlocCodeN200 ErrorlocCode = 200
	ErrorlocCodeN400 ErrorlocCode = 400
	ErrorlocCodeN401 ErrorlocCode = 401
	ErrorlocCodeN403 ErrorlocCode = 403
	ErrorlocCodeN404 ErrorlocCode = 404
	ErrorlocCodeN405 ErrorlocCode = 405
	ErrorlocCodeN407 ErrorlocCode = 407
	ErrorlocCodeN408 ErrorlocCode = 408
	ErrorlocCodeN410 ErrorlocCode = 410
	ErrorlocCodeN413 ErrorlocCode = 413
	ErrorlocCodeN425 ErrorlocCode = 425
	ErrorlocCodeN429 ErrorlocCode = 429
	ErrorlocCodeN500 ErrorlocCode = 500
	ErrorlocCodeN501 ErrorlocCode = 501
	ErrorlocCodeN502 ErrorlocCode = 502
	ErrorlocCodeN503 ErrorlocCode = 503
	ErrorlocCodeN504 ErrorlocCode = 504
)

// Defines values for FcgiAppGetValues.
const (
	FcgiAppGetValuesDisabled FcgiAppGetValues = "disabled"
	FcgiAppGetValuesEnabled  FcgiAppGetValues = "enabled"
)

// Defines values for FcgiAppKeepConn.
const (
	FcgiAppKeepConnDisabled FcgiAppKeepConn = "disabled"
	FcgiAppKeepConnEnabled  FcgiAppKeepConn = "enabled"
)

// Defines values for FcgiAppMpxsConns.
const (
	FcgiAppMpxsConnsDisabled FcgiAppMpxsConns = "disabled"
	FcgiAppMpxsConnsEnabled  FcgiAppMpxsConns = "enabled"
)

// Defines values for FcgiAppBaseGetValues.
const (
	FcgiAppBaseGetValuesDisabled FcgiAppBaseGetValues = "disabled"
	FcgiAppBaseGetValuesEnabled  FcgiAppBaseGetValues = "enabled"
)

// Defines values for FcgiAppBaseKeepConn.
const (
	FcgiAppBaseKeepConnDisabled FcgiAppBaseKeepConn = "disabled"
	FcgiAppBaseKeepConnEnabled  FcgiAppBaseKeepConn = "enabled"
)

// Defines values for FcgiAppBaseMpxsConns.
const (
	FcgiAppBaseMpxsConnsDisabled FcgiAppBaseMpxsConns = "disabled"
	FcgiAppBaseMpxsConnsEnabled  FcgiAppBaseMpxsConns = "enabled"
)

// Defines values for FcgiPassHeaderCond.
const (
	FcgiPassHeaderCondIf     FcgiPassHeaderCond = "if"
	FcgiPassHeaderCondUnless FcgiPassHeaderCond = "unless"
)

// Defines values for FcgiSetParamCond.
const (
	FcgiSetParamCondIf     FcgiSetParamCond = "if"
	FcgiSetParamCondUnless FcgiSetParamCond = "unless"
)

// Defines values for FilterType.
const (
	FilterTypeBwlimIn     FilterType = "bwlim-in"
	FilterTypeBwlimOut    FilterType = "bwlim-out"
	FilterTypeCache       FilterType = "cache"
	FilterTypeCompression FilterType = "compression"
	FilterTypeFcgiApp     FilterType = "fcgi-app"
	FilterTypeSpoe        FilterType = "spoe"
	FilterTypeTrace       FilterType = "trace"
)

// Defines values for ForwardforEnabled.
const (
	ForwardforEnabledEnabled ForwardforEnabled = "enabled"
)

// Defines values for FrontendAcceptInvalidHttpRequest.
const (
	FrontendAcceptInvalidHttpRequestDisabled FrontendAcceptInvalidHttpRequest = "disabled"
	FrontendAcceptInvalidHttpRequestEnabled  FrontendAcceptInvalidHttpRequest = "enabled"
)

// Defines values for FrontendAcceptUnsafeViolationsInHttpRequest.
const (
	FrontendAcceptUnsafeViolationsInHttpRequestDisabled FrontendAcceptUnsafeViolationsInHttpRequest = "disabled"
	FrontendAcceptUnsafeViolationsInHttpRequestEnabled  FrontendAcceptUnsafeViolationsInHttpRequest = "enabled"
)

// Defines values for FrontendClitcpka.
const (
	FrontendClitcpkaDisabled FrontendClitcpka = "disabled"
	FrontendClitcpkaEnabled  FrontendClitcpka = "enabled"
)

// Defines values for FrontendContstats.
const (
	FrontendContstatsEnabled FrontendContstats = "enabled"
)

// Defines values for FrontendDisableH2Upgrade.
const (
	FrontendDisableH2UpgradeDisabled FrontendDisableH2Upgrade = "disabled"
	FrontendDisableH2UpgradeEnabled  FrontendDisableH2Upgrade = "enabled"
)

// Defines values for FrontendDontlogNormal.
const (
	FrontendDontlogNormalDisabled FrontendDontlogNormal = "disabled"
	FrontendDontlogNormalEnabled  FrontendDontlogNormal = "enabled"
)

// Defines values for FrontendDontlognull.
const (
	FrontendDontlognullDisabled FrontendDontlognull = "disabled"
	FrontendDontlognullEnabled  FrontendDontlognull = "enabled"
)

// Defines values for FrontendH1CaseAdjustBogusClient.
const (
	FrontendH1CaseAdjustBogusClientDisabled FrontendH1CaseAdjustBogusClient = "disabled"
	FrontendH1CaseAdjustBogusClientEnabled  FrontendH1CaseAdjustBogusClient = "enabled"
)

// Defines values for FrontendHttpBufferRequest.
const (
	FrontendHttpBufferRequestDisabled FrontendHttpBufferRequest = "disabled"
	FrontendHttpBufferRequestEnabled  FrontendHttpBufferRequest = "enabled"
)

// Defines values for FrontendHttpDropResponseTrailers.
const (
	FrontendHttpDropResponseTrailersDisabled FrontendHttpDropResponseTrailers = "disabled"
	FrontendHttpDropResponseTrailersEnabled  FrontendHttpDropResponseTrailers = "enabled"
)

// Defines values for FrontendHttpUseHtx.
const (
	FrontendHttpUseHtxDisabled FrontendHttpUseHtx = "disabled"
	FrontendHttpUseHtxEnabled  FrontendHttpUseHtx = "enabled"
)

// Defines values for FrontendHttpConnectionMode.
const (
	FrontendHttpConnectionModeHttpKeepAlive   FrontendHttpConnectionMode = "http-keep-alive"
	FrontendHttpConnectionModeHttpServerClose FrontendHttpConnectionMode = "http-server-close"
	FrontendHttpConnectionModeHttpclose       FrontendHttpConnectionMode = "httpclose"
)

// Defines values for FrontendHttpIgnoreProbes.
const (
	FrontendHttpIgnoreProbesDisabled FrontendHttpIgnoreProbes = "disabled"
	FrontendHttpIgnoreProbesEnabled  FrontendHttpIgnoreProbes = "enabled"
)

// Defines values for FrontendHttpNoDelay.
const (
	FrontendHttpNoDelayDisabled FrontendHttpNoDelay = "disabled"
	FrontendHttpNoDelayEnabled  FrontendHttpNoDelay = "enabled"
)

// Defines values for FrontendHttpRestrictReqHdrNames.
const (
	FrontendHttpRestrictReqHdrNamesDelete   FrontendHttpRestrictReqHdrNames = "delete"
	FrontendHttpRestrictReqHdrNamesPreserve FrontendHttpRestrictReqHdrNames = "preserve"
	FrontendHttpRestrictReqHdrNamesReject   FrontendHttpRestrictReqHdrNames = "reject"
)

// Defines values for FrontendHttpUseProxyHeader.
const (
	FrontendHttpUseProxyHeaderDisabled FrontendHttpUseProxyHeader = "disabled"
	FrontendHttpUseProxyHeaderEnabled  FrontendHttpUseProxyHeader = "enabled"
)

// Defines values for FrontendHttpslog.
const (
	FrontendHttpslogDisabled FrontendHttpslog = "disabled"
	FrontendHttpslogEnabled  FrontendHttpslog = "enabled"
)

// Defines values for FrontendIdleCloseOnResponse.
const (
	FrontendIdleCloseOnResponseDisabled FrontendIdleCloseOnResponse = "disabled"
	FrontendIdleCloseOnResponseEnabled  FrontendIdleCloseOnResponse = "enabled"
)

// Defines values for FrontendIndependentStreams.
const (
	FrontendIndependentStreamsDisabled FrontendIndependentStreams = "disabled"
	FrontendIndependentStreamsEnabled  FrontendIndependentStreams = "enabled"
)

// Defines values for FrontendLogSeparateErrors.
const (
	FrontendLogSeparateErrorsDisabled FrontendLogSeparateErrors = "disabled"
	FrontendLogSeparateErrorsEnabled  FrontendLogSeparateErrors = "enabled"
)

// Defines values for FrontendLogSteps.
const (
	FrontendLogStepsAccept   FrontendLogSteps = "accept"
	FrontendLogStepsAny      FrontendLogSteps = "any"
	FrontendLogStepsClose    FrontendLogSteps = "close"
	FrontendLogStepsConnect  FrontendLogSteps = "connect"
	FrontendLogStepsError    FrontendLogSteps = "error"
	FrontendLogStepsRequest  FrontendLogSteps = "request"
	FrontendLogStepsResponse FrontendLogSteps = "response"
)

// Defines values for FrontendLogasap.
const (
	FrontendLogasapDisabled FrontendLogasap = "disabled"
	FrontendLogasapEnabled  FrontendLogasap = "enabled"
)

// Defines values for FrontendMode.
const (
	FrontendModeHttp FrontendMode = "http"
	FrontendModeTcp  FrontendMode = "tcp"
)

// Defines values for FrontendNolinger.
const (
	FrontendNolingerDisabled FrontendNolinger = "disabled"
	FrontendNolingerEnabled  FrontendNolinger = "enabled"
)

// Defines values for FrontendSocketStats.
const (
	FrontendSocketStatsDisabled FrontendSocketStats = "disabled"
	FrontendSocketStatsEnabled  FrontendSocketStats = "enabled"
)

// Defines values for FrontendSpliceAuto.
const (
	FrontendSpliceAutoDisabled FrontendSpliceAuto = "disabled"
	FrontendSpliceAutoEnabled  FrontendSpliceAuto = "enabled"
)

// Defines values for FrontendSpliceRequest.
const (
	FrontendSpliceRequestDisabled FrontendSpliceRequest = "disabled"
	FrontendSpliceRequestEnabled  FrontendSpliceRequest = "enabled"
)

// Defines values for FrontendSpliceResponse.
const (
	FrontendSpliceResponseDisabled FrontendSpliceResponse = "disabled"
	FrontendSpliceResponseEnabled  FrontendSpliceResponse = "enabled"
)

// Defines values for FrontendTcpSmartAccept.
const (
	FrontendTcpSmartAcceptDisabled FrontendTcpSmartAccept = "disabled"
	FrontendTcpSmartAcceptEnabled  FrontendTcpSmartAccept = "enabled"
)

// Defines values for FrontendTcpka.
const (
	FrontendTcpkaDisabled FrontendTcpka = "disabled"
	FrontendTcpkaEnabled  FrontendTcpka = "enabled"
)

// Defines values for FrontendBaseAcceptInvalidHttpRequest.
const (
	FrontendBaseAcceptInvalidHttpRequestDisabled FrontendBaseAcceptInvalidHttpRequest = "disabled"
	FrontendBaseAcceptInvalidHttpRequestEnabled  FrontendBaseAcceptInvalidHttpRequest = "enabled"
)

// Defines values for FrontendBaseAcceptUnsafeViolationsInHttpRequest.
const (
	FrontendBaseAcceptUnsafeViolationsInHttpRequestDisabled FrontendBaseAcceptUnsafeViolationsInHttpRequest = "disabled"
	FrontendBaseAcceptUnsafeViolationsInHttpRequestEnabled  FrontendBaseAcceptUnsafeViolationsInHttpRequest = "enabled"
)

// Defines values for FrontendBaseClitcpka.
const (
	FrontendBaseClitcpkaDisabled FrontendBaseClitcpka = "disabled"
	FrontendBaseClitcpkaEnabled  FrontendBaseClitcpka = "enabled"
)

// Defines values for FrontendBaseContstats.
const (
	FrontendBaseContstatsEnabled FrontendBaseContstats = "enabled"
)

// Defines values for FrontendBaseDisableH2Upgrade.
const (
	FrontendBaseDisableH2UpgradeDisabled FrontendBaseDisableH2Upgrade = "disabled"
	FrontendBaseDisableH2UpgradeEnabled  FrontendBaseDisableH2Upgrade = "enabled"
)

// Defines values for FrontendBaseDontlogNormal.
const (
	FrontendBaseDontlogNormalDisabled FrontendBaseDontlogNormal = "disabled"
	FrontendBaseDontlogNormalEnabled  FrontendBaseDontlogNormal = "enabled"
)

// Defines values for FrontendBaseDontlognull.
const (
	FrontendBaseDontlognullDisabled FrontendBaseDontlognull = "disabled"
	FrontendBaseDontlognullEnabled  FrontendBaseDontlognull = "enabled"
)

// Defines values for FrontendBaseH1CaseAdjustBogusClient.
const (
	FrontendBaseH1CaseAdjustBogusClientDisabled FrontendBaseH1CaseAdjustBogusClient = "disabled"
	FrontendBaseH1CaseAdjustBogusClientEnabled  FrontendBaseH1CaseAdjustBogusClient = "enabled"
)

// Defines values for FrontendBaseHttpBufferRequest.
const (
	FrontendBaseHttpBufferRequestDisabled FrontendBaseHttpBufferRequest = "disabled"
	FrontendBaseHttpBufferRequestEnabled  FrontendBaseHttpBufferRequest = "enabled"
)

// Defines values for FrontendBaseHttpDropResponseTrailers.
const (
	FrontendBaseHttpDropResponseTrailersDisabled FrontendBaseHttpDropResponseTrailers = "disabled"
	FrontendBaseHttpDropResponseTrailersEnabled  FrontendBaseHttpDropResponseTrailers = "enabled"
)

// Defines values for FrontendBaseHttpUseHtx.
const (
	FrontendBaseHttpUseHtxDisabled FrontendBaseHttpUseHtx = "disabled"
	FrontendBaseHttpUseHtxEnabled  FrontendBaseHttpUseHtx = "enabled"
)

// Defines values for FrontendBaseHttpConnectionMode.
const (
	FrontendBaseHttpConnectionModeHttpKeepAlive   FrontendBaseHttpConnectionMode = "http-keep-alive"
	FrontendBaseHttpConnectionModeHttpServerClose FrontendBaseHttpConnectionMode = "http-server-close"
	FrontendBaseHttpConnectionModeHttpclose       FrontendBaseHttpConnectionMode = "httpclose"
)

// Defines values for FrontendBaseHttpIgnoreProbes.
const (
	FrontendBaseHttpIgnoreProbesDisabled FrontendBaseHttpIgnoreProbes = "disabled"
	FrontendBaseHttpIgnoreProbesEnabled  FrontendBaseHttpIgnoreProbes = "enabled"
)

// Defines values for FrontendBaseHttpNoDelay.
const (
	FrontendBaseHttpNoDelayDisabled FrontendBaseHttpNoDelay = "disabled"
	FrontendBaseHttpNoDelayEnabled  FrontendBaseHttpNoDelay = "enabled"
)

// Defines values for FrontendBaseHttpRestrictReqHdrNames.
const (
	FrontendBaseHttpRestrictReqHdrNamesDelete   FrontendBaseHttpRestrictReqHdrNames = "delete"
	FrontendBaseHttpRestrictReqHdrNamesPreserve FrontendBaseHttpRestrictReqHdrNames = "preserve"
	FrontendBaseHttpRestrictReqHdrNamesReject   FrontendBaseHttpRestrictReqHdrNames = "reject"
)

// Defines values for FrontendBaseHttpUseProxyHeader.
const (
	FrontendBaseHttpUseProxyHeaderDisabled FrontendBaseHttpUseProxyHeader = "disabled"
	FrontendBaseHttpUseProxyHeaderEnabled  FrontendBaseHttpUseProxyHeader = "enabled"
)

// Defines values for FrontendBaseHttpslog.
const (
	FrontendBaseHttpslogDisabled FrontendBaseHttpslog = "disabled"
	FrontendBaseHttpslogEnabled  FrontendBaseHttpslog = "enabled"
)

// Defines values for FrontendBaseIdleCloseOnResponse.
const (
	FrontendBaseIdleCloseOnResponseDisabled FrontendBaseIdleCloseOnResponse = "disabled"
	FrontendBaseIdleCloseOnResponseEnabled  FrontendBaseIdleCloseOnResponse = "enabled"
)

// Defines values for FrontendBaseIndependentStreams.
const (
	FrontendBaseIndependentStreamsDisabled FrontendBaseIndependentStreams = "disabled"
	FrontendBaseIndependentStreamsEnabled  FrontendBaseIndependentStreams = "enabled"
)

// Defines values for FrontendBaseLogSeparateErrors.
const (
	FrontendBaseLogSeparateErrorsDisabled FrontendBaseLogSeparateErrors = "disabled"
	FrontendBaseLogSeparateErrorsEnabled  FrontendBaseLogSeparateErrors = "enabled"
)

// Defines values for FrontendBaseLogSteps.
const (
	FrontendBaseLogStepsAccept   FrontendBaseLogSteps = "accept"
	FrontendBaseLogStepsAny      FrontendBaseLogSteps = "any"
	FrontendBaseLogStepsClose    FrontendBaseLogSteps = "close"
	FrontendBaseLogStepsConnect  FrontendBaseLogSteps = "connect"
	FrontendBaseLogStepsError    FrontendBaseLogSteps = "error"
	FrontendBaseLogStepsRequest  FrontendBaseLogSteps = "request"
	FrontendBaseLogStepsResponse FrontendBaseLogSteps = "response"
)

// Defines values for FrontendBaseLogasap.
const (
	FrontendBaseLogasapDisabled FrontendBaseLogasap = "disabled"
	FrontendBaseLogasapEnabled  FrontendBaseLogasap = "enabled"
)

// Defines values for FrontendBaseMode.
const (
	FrontendBaseModeHttp FrontendBaseMode = "http"
	FrontendBaseModeTcp  FrontendBaseMode = "tcp"
)

// Defines values for FrontendBaseNolinger.
const (
	FrontendBaseNolingerDisabled FrontendBaseNolinger = "disabled"
	FrontendBaseNolingerEnabled  FrontendBaseNolinger = "enabled"
)

// Defines values for FrontendBaseSocketStats.
const (
	FrontendBaseSocketStatsDisabled FrontendBaseSocketStats = "disabled"
	FrontendBaseSocketStatsEnabled  FrontendBaseSocketStats = "enabled"
)

// Defines values for FrontendBaseSpliceAuto.
const (
	FrontendBaseSpliceAutoDisabled FrontendBaseSpliceAuto = "disabled"
	FrontendBaseSpliceAutoEnabled  FrontendBaseSpliceAuto = "enabled"
)

// Defines values for FrontendBaseSpliceRequest.
const (
	FrontendBaseSpliceRequestDisabled FrontendBaseSpliceRequest = "disabled"
	FrontendBaseSpliceRequestEnabled  FrontendBaseSpliceRequest = "enabled"
)

// Defines values for FrontendBaseSpliceResponse.
const (
	FrontendBaseSpliceResponseDisabled FrontendBaseSpliceResponse = "disabled"
	FrontendBaseSpliceResponseEnabled  FrontendBaseSpliceResponse = "enabled"
)

// Defines values for FrontendBaseTcpSmartAccept.
const (
	FrontendBaseTcpSmartAcceptDisabled FrontendBaseTcpSmartAccept = "disabled"
	FrontendBaseTcpSmartAcceptEnabled  FrontendBaseTcpSmartAccept = "enabled"
)

// Defines values for FrontendBaseTcpka.
const (
	FrontendBaseTcpkaDisabled FrontendBaseTcpka = "disabled"
	FrontendBaseTcpkaEnabled  FrontendBaseTcpka = "enabled"
)

// Defines values for GlobalCpuPolicy.
const (
	GlobalCpuPolicyEfficiency       GlobalCpuPolicy = "efficiency"
	GlobalCpuPolicyFirstUsableNode  GlobalCpuPolicy = "first-usable-node"
	GlobalCpuPolicyGroupBy2Ccx      GlobalCpuPolicy = "group-by-2-ccx"
	GlobalCpuPolicyGroupBy2Clusters GlobalCpuPolicy = "group-by-2-clusters"
	GlobalCpuPolicyGroupBy3Ccx      GlobalCpuPolicy = "group-by-3-ccx"
	GlobalCpuPolicyGroupBy3Clusters GlobalCpuPolicy = "group-by-3-clusters"
	GlobalCpuPolicyGroupBy4Ccx      GlobalCpuPolicy = "group-by-4-ccx"
	GlobalCpuPolicyGroupBy4Cluster  GlobalCpuPolicy = "group-by-4-cluster"
	GlobalCpuPolicyGroupByCcx       GlobalCpuPolicy = "group-by-ccx"
	GlobalCpuPolicyGroupByCluster   GlobalCpuPolicy = "group-by-cluster"
	GlobalCpuPolicyNone             GlobalCpuPolicy = "none"
	GlobalCpuPolicyPerformance      GlobalCpuPolicy = "performance"
	GlobalCpuPolicyResource         GlobalCpuPolicy = "resource"
)

// Defines values for GlobalCpuSetDirective.
const (
	GlobalCpuSetDirectiveDropCluster GlobalCpuSetDirective = "drop-cluster"
	GlobalCpuSetDirectiveDropCore    GlobalCpuSetDirective = "drop-core"
	GlobalCpuSetDirectiveDropCpu     GlobalCpuSetDirective = "drop-cpu"
	GlobalCpuSetDirectiveDropNode    GlobalCpuSetDirective = "drop-node"
	GlobalCpuSetDirectiveDropThread  GlobalCpuSetDirective = "drop-thread"
	GlobalCpuSetDirectiveOnlyCluster GlobalCpuSetDirective = "only-cluster"
	GlobalCpuSetDirectiveOnlyCore    GlobalCpuSetDirective = "only-core"
	GlobalCpuSetDirectiveOnlyCpu     GlobalCpuSetDirective = "only-cpu"
	GlobalCpuSetDirectiveOnlyNode    GlobalCpuSetDirective = "only-node"
	GlobalCpuSetDirectiveOnlyThread  GlobalCpuSetDirective = "only-thread"
	GlobalCpuSetDirectiveReset       GlobalCpuSetDirective = "reset"
)

// Defines values for GlobalDefaultPathType.
const (
	GlobalDefaultPathTypeConfig  GlobalDefaultPathType = "config"
	GlobalDefaultPathTypeCurrent GlobalDefaultPathType = "current"
	GlobalDefaultPathTypeOrigin  GlobalDefaultPathType = "origin"
	GlobalDefaultPathTypeParent  GlobalDefaultPathType = "parent"
)

// Defines values for GlobalHardenRejectPrivilegedPortsQuic.
const (
	GlobalHardenRejectPrivilegedPortsQuicDisabled GlobalHardenRejectPrivilegedPortsQuic = "disabled"
	GlobalHardenRejectPrivilegedPortsQuicEnabled  GlobalHardenRejectPrivilegedPortsQuic = "enabled"
)

// Defines values for GlobalHardenRejectPrivilegedPortsTcp.
const (
	GlobalHardenRejectPrivilegedPortsTcpDisabled GlobalHardenRejectPrivilegedPortsTcp = "disabled"
	GlobalHardenRejectPrivilegedPortsTcpEnabled  GlobalHardenRejectPrivilegedPortsTcp = "enabled"
)

// Defines values for GlobalLogSendHostnameEnabled.
const (
	GlobalLogSendHostnameEnabledDisabled GlobalLogSendHostnameEnabled = "disabled"
	GlobalLogSendHostnameEnabledEnabled  GlobalLogSendHostnameEnabled = "enabled"
)

// Defines values for GlobalNumaCpuMapping.
const (
	GlobalNumaCpuMappingDisabled GlobalNumaCpuMapping = "disabled"
	GlobalNumaCpuMappingEnabled  GlobalNumaCpuMapping = "enabled"
)

// Defines values for GlobalRuntimeApisForceStrictSni.
const (
	GlobalRuntimeApisForceStrictSniDisabled GlobalRuntimeApisForceStrictSni = "disabled"
	GlobalRuntimeApisForceStrictSniEnabled  GlobalRuntimeApisForceStrictSni = "enabled"
)

// Defines values for GlobalRuntimeApisLevel.
const (
	GlobalRuntimeApisLevelAdmin    GlobalRuntimeApisLevel = "admin"
	GlobalRuntimeApisLevelOperator GlobalRuntimeApisLevel = "operator"
	GlobalRuntimeApisLevelUser     GlobalRuntimeApisLevel = "user"
)

// Defines values for GlobalRuntimeApisQuicCcAlgo.
const (
	GlobalRuntimeApisQuicCcAlgoBbr     GlobalRuntimeApisQuicCcAlgo = "bbr"
	GlobalRuntimeApisQuicCcAlgoCubic   GlobalRuntimeApisQuicCcAlgo = "cubic"
	GlobalRuntimeApisQuicCcAlgoNewreno GlobalRuntimeApisQuicCcAlgo = "newreno"
	GlobalRuntimeApisQuicCcAlgoNocc    GlobalRuntimeApisQuicCcAlgo = "nocc"
)

// Defines values for GlobalRuntimeApisQuicSocket.
const (
	GlobalRuntimeApisQuicSocketConnection GlobalRuntimeApisQuicSocket = "connection"
	GlobalRuntimeApisQuicSocketListener   GlobalRuntimeApisQuicSocket = "listener"
)

// Defines values for GlobalRuntimeApisSeverityOutput.
const (
	GlobalRuntimeApisSeverityOutputNone   GlobalRuntimeApisSeverityOutput = "none"
	GlobalRuntimeApisSeverityOutputNumber GlobalRuntimeApisSeverityOutput = "number"
	GlobalRuntimeApisSeverityOutputString GlobalRuntimeApisSeverityOutput = "string"
)

// Defines values for GlobalRuntimeApisSslMaxVer.
const (
	GlobalRuntimeApisSslMaxVerSSLv3  GlobalRuntimeApisSslMaxVer = "SSLv3"
	GlobalRuntimeApisSslMaxVerTLSv10 GlobalRuntimeApisSslMaxVer = "TLSv1.0"
	GlobalRuntimeApisSslMaxVerTLSv11 GlobalRuntimeApisSslMaxVer = "TLSv1.1"
	GlobalRuntimeApisSslMaxVerTLSv12 GlobalRuntimeApisSslMaxVer = "TLSv1.2"
	GlobalRuntimeApisSslMaxVerTLSv13 GlobalRuntimeApisSslMaxVer = "TLSv1.3"
)

// Defines values for GlobalRuntimeApisSslMinVer.
const (
	GlobalRuntimeApisSslMinVerSSLv3  GlobalRuntimeApisSslMinVer = "SSLv3"
	GlobalRuntimeApisSslMinVerTLSv10 GlobalRuntimeApisSslMinVer = "TLSv1.0"
	GlobalRuntimeApisSslMinVerTLSv11 GlobalRuntimeApisSslMinVer = "TLSv1.1"
	GlobalRuntimeApisSslMinVerTLSv12 GlobalRuntimeApisSslMinVer = "TLSv1.2"
	GlobalRuntimeApisSslMinVerTLSv13 GlobalRuntimeApisSslMinVer = "TLSv1.3"
)

// Defines values for GlobalRuntimeApisSslv3.
const (
	GlobalRuntimeApisSslv3Disabled GlobalRuntimeApisSslv3 = "disabled"
	GlobalRuntimeApisSslv3Enabled  GlobalRuntimeApisSslv3 = "enabled"
)

// Defines values for GlobalRuntimeApisTlsTickets.
const (
	GlobalRuntimeApisTlsTicketsDisabled GlobalRuntimeApisTlsTickets = "disabled"
	GlobalRuntimeApisTlsTicketsEnabled  GlobalRuntimeApisTlsTickets = "enabled"
)

// Defines values for GlobalRuntimeApisTlsv10.
const (
	GlobalRuntimeApisTlsv10Disabled GlobalRuntimeApisTlsv10 = "disabled"
	GlobalRuntimeApisTlsv10Enabled  GlobalRuntimeApisTlsv10 = "enabled"
)

// Defines values for GlobalRuntimeApisTlsv11.
const (
	GlobalRuntimeApisTlsv11Disabled GlobalRuntimeApisTlsv11 = "disabled"
	GlobalRuntimeApisTlsv11Enabled  GlobalRuntimeApisTlsv11 = "enabled"
)

// Defines values for GlobalRuntimeApisTlsv12.
const (
	GlobalRuntimeApisTlsv12Disabled GlobalRuntimeApisTlsv12 = "disabled"
	GlobalRuntimeApisTlsv12Enabled  GlobalRuntimeApisTlsv12 = "enabled"
)

// Defines values for GlobalRuntimeApisTlsv13.
const (
	GlobalRuntimeApisTlsv13Disabled GlobalRuntimeApisTlsv13 = "disabled"
	GlobalRuntimeApisTlsv13Enabled  GlobalRuntimeApisTlsv13 = "enabled"
)

// Defines values for GlobalRuntimeApisVerify.
const (
	GlobalRuntimeApisVerifyNone     GlobalRuntimeApisVerify = "none"
	GlobalRuntimeApisVerifyOptional GlobalRuntimeApisVerify = "optional"
	GlobalRuntimeApisVerifyRequired GlobalRuntimeApisVerify = "required"
)

// Defines values for GlobalBaseCpuPolicy.
const (
	GlobalBaseCpuPolicyEfficiency       GlobalBaseCpuPolicy = "efficiency"
	GlobalBaseCpuPolicyFirstUsableNode  GlobalBaseCpuPolicy = "first-usable-node"
	GlobalBaseCpuPolicyGroupBy2Ccx      GlobalBaseCpuPolicy = "group-by-2-ccx"
	GlobalBaseCpuPolicyGroupBy2Clusters GlobalBaseCpuPolicy = "group-by-2-clusters"
	GlobalBaseCpuPolicyGroupBy3Ccx      GlobalBaseCpuPolicy = "group-by-3-ccx"
	GlobalBaseCpuPolicyGroupBy3Clusters GlobalBaseCpuPolicy = "group-by-3-clusters"
	GlobalBaseCpuPolicyGroupBy4Ccx      GlobalBaseCpuPolicy = "group-by-4-ccx"
	GlobalBaseCpuPolicyGroupBy4Cluster  GlobalBaseCpuPolicy = "group-by-4-cluster"
	GlobalBaseCpuPolicyGroupByCcx       GlobalBaseCpuPolicy = "group-by-ccx"
	GlobalBaseCpuPolicyGroupByCluster   GlobalBaseCpuPolicy = "group-by-cluster"
	GlobalBaseCpuPolicyNone             GlobalBaseCpuPolicy = "none"
	GlobalBaseCpuPolicyPerformance      GlobalBaseCpuPolicy = "performance"
	GlobalBaseCpuPolicyResource         GlobalBaseCpuPolicy = "resource"
)

// Defines values for GlobalBaseCpuSetDirective.
const (
	GlobalBaseCpuSetDirectiveDropCluster GlobalBaseCpuSetDirective = "drop-cluster"
	GlobalBaseCpuSetDirectiveDropCore    GlobalBaseCpuSetDirective = "drop-core"
	GlobalBaseCpuSetDirectiveDropCpu     GlobalBaseCpuSetDirective = "drop-cpu"
	GlobalBaseCpuSetDirectiveDropNode    GlobalBaseCpuSetDirective = "drop-node"
	GlobalBaseCpuSetDirectiveDropThread  GlobalBaseCpuSetDirective = "drop-thread"
	GlobalBaseCpuSetDirectiveOnlyCluster GlobalBaseCpuSetDirective = "only-cluster"
	GlobalBaseCpuSetDirectiveOnlyCore    GlobalBaseCpuSetDirective = "only-core"
	GlobalBaseCpuSetDirectiveOnlyCpu     GlobalBaseCpuSetDirective = "only-cpu"
	GlobalBaseCpuSetDirectiveOnlyNode    GlobalBaseCpuSetDirective = "only-node"
	GlobalBaseCpuSetDirectiveOnlyThread  GlobalBaseCpuSetDirective = "only-thread"
	GlobalBaseCpuSetDirectiveReset       GlobalBaseCpuSetDirective = "reset"
)

// Defines values for GlobalBaseDefaultPathType.
const (
	GlobalBaseDefaultPathTypeConfig  GlobalBaseDefaultPathType = "config"
	GlobalBaseDefaultPathTypeCurrent GlobalBaseDefaultPathType = "current"
	GlobalBaseDefaultPathTypeOrigin  GlobalBaseDefaultPathType = "origin"
	GlobalBaseDefaultPathTypeParent  GlobalBaseDefaultPathType = "parent"
)

// Defines values for GlobalBaseHardenRejectPrivilegedPortsQuic.
const (
	GlobalBaseHardenRejectPrivilegedPortsQuicDisabled GlobalBaseHardenRejectPrivilegedPortsQuic = "disabled"
	GlobalBaseHardenRejectPrivilegedPortsQuicEnabled  GlobalBaseHardenRejectPrivilegedPortsQuic = "enabled"
)

// Defines values for GlobalBaseHardenRejectPrivilegedPortsTcp.
const (
	GlobalBaseHardenRejectPrivilegedPortsTcpDisabled GlobalBaseHardenRejectPrivilegedPortsTcp = "disabled"
	GlobalBaseHardenRejectPrivilegedPortsTcpEnabled  GlobalBaseHardenRejectPrivilegedPortsTcp = "enabled"
)

// Defines values for GlobalBaseLogSendHostnameEnabled.
const (
	GlobalBaseLogSendHostnameEnabledDisabled GlobalBaseLogSendHostnameEnabled = "disabled"
	GlobalBaseLogSendHostnameEnabledEnabled  GlobalBaseLogSendHostnameEnabled = "enabled"
)

// Defines values for GlobalBaseNumaCpuMapping.
const (
	GlobalBaseNumaCpuMappingDisabled GlobalBaseNumaCpuMapping = "disabled"
	GlobalBaseNumaCpuMappingEnabled  GlobalBaseNumaCpuMapping = "enabled"
)

// Defines values for GlobalBaseRuntimeApisForceStrictSni.
const (
	GlobalBaseRuntimeApisForceStrictSniDisabled GlobalBaseRuntimeApisForceStrictSni = "disabled"
	GlobalBaseRuntimeApisForceStrictSniEnabled  GlobalBaseRuntimeApisForceStrictSni = "enabled"
)

// Defines values for GlobalBaseRuntimeApisLevel.
const (
	GlobalBaseRuntimeApisLevelAdmin    GlobalBaseRuntimeApisLevel = "admin"
	GlobalBaseRuntimeApisLevelOperator GlobalBaseRuntimeApisLevel = "operator"
	GlobalBaseRuntimeApisLevelUser     GlobalBaseRuntimeApisLevel = "user"
)

// Defines values for GlobalBaseRuntimeApisQuicCcAlgo.
const (
	GlobalBaseRuntimeApisQuicCcAlgoBbr     GlobalBaseRuntimeApisQuicCcAlgo = "bbr"
	GlobalBaseRuntimeApisQuicCcAlgoCubic   GlobalBaseRuntimeApisQuicCcAlgo = "cubic"
	GlobalBaseRuntimeApisQuicCcAlgoNewreno GlobalBaseRuntimeApisQuicCcAlgo = "newreno"
	GlobalBaseRuntimeApisQuicCcAlgoNocc    GlobalBaseRuntimeApisQuicCcAlgo = "nocc"
)

// Defines values for GlobalBaseRuntimeApisQuicSocket.
const (
	GlobalBaseRuntimeApisQuicSocketConnection GlobalBaseRuntimeApisQuicSocket = "connection"
	GlobalBaseRuntimeApisQuicSocketListener   GlobalBaseRuntimeApisQuicSocket = "listener"
)

// Defines values for GlobalBaseRuntimeApisSeverityOutput.
const (
	GlobalBaseRuntimeApisSeverityOutputNone   GlobalBaseRuntimeApisSeverityOutput = "none"
	GlobalBaseRuntimeApisSeverityOutputNumber GlobalBaseRuntimeApisSeverityOutput = "number"
	GlobalBaseRuntimeApisSeverityOutputString GlobalBaseRuntimeApisSeverityOutput = "string"
)

// Defines values for GlobalBaseRuntimeApisSslMaxVer.
const (
	GlobalBaseRuntimeApisSslMaxVerSSLv3  GlobalBaseRuntimeApisSslMaxVer = "SSLv3"
	GlobalBaseRuntimeApisSslMaxVerTLSv10 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.0"
	GlobalBaseRuntimeApisSslMaxVerTLSv11 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.1"
	GlobalBaseRuntimeApisSslMaxVerTLSv12 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.2"
	GlobalBaseRuntimeApisSslMaxVerTLSv13 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.3"
)

// Defines values for GlobalBaseRuntimeApisSslMinVer.
const (
	GlobalBaseRuntimeApisSslMinVerSSLv3  GlobalBaseRuntimeApisSslMinVer = "SSLv3"
	GlobalBaseRuntimeApisSslMinVerTLSv10 GlobalBaseRuntimeApisSslMinVer = "TLSv1.0"
	GlobalBaseRuntimeApisSslMinVerTLSv11 GlobalBaseRuntimeApisSslMinVer = "TLSv1.1"
	GlobalBaseRuntimeApisSslMinVerTLSv12 GlobalBaseRuntimeApisSslMinVer = "TLSv1.2"
	GlobalBaseRuntimeApisSslMinVerTLSv13 GlobalBaseRuntimeApisSslMinVer = "TLSv1.3"
)

// Defines values for GlobalBaseRuntimeApisSslv3.
const (
	GlobalBaseRuntimeApisSslv3Disabled GlobalBaseRuntimeApisSslv3 = "disabled"
	GlobalBaseRuntimeApisSslv3Enabled  GlobalBaseRuntimeApisSslv3 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisTlsTickets.
const (
	GlobalBaseRuntimeApisTlsTicketsDisabled GlobalBaseRuntimeApisTlsTickets = "disabled"
	GlobalBaseRuntimeApisTlsTicketsEnabled  GlobalBaseRuntimeApisTlsTickets = "enabled"
)

// Defines values for GlobalBaseRuntimeApisTlsv10.
const (
	GlobalBaseRuntimeApisTlsv10Disabled GlobalBaseRuntimeApisTlsv10 = "disabled"
	GlobalBaseRuntimeApisTlsv10Enabled  GlobalBaseRuntimeApisTlsv10 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisTlsv11.
const (
	GlobalBaseRuntimeApisTlsv11Disabled GlobalBaseRuntimeApisTlsv11 = "disabled"
	GlobalBaseRuntimeApisTlsv11Enabled  GlobalBaseRuntimeApisTlsv11 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisTlsv12.
const (
	GlobalBaseRuntimeApisTlsv12Disabled GlobalBaseRuntimeApisTlsv12 = "disabled"
	GlobalBaseRuntimeApisTlsv12Enabled  GlobalBaseRuntimeApisTlsv12 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisTlsv13.
const (
	GlobalBaseRuntimeApisTlsv13Disabled GlobalBaseRuntimeApisTlsv13 = "disabled"
	GlobalBaseRuntimeApisTlsv13Enabled  GlobalBaseRuntimeApisTlsv13 = "enabled"
)

// Defines values for GlobalBaseRuntimeApisVerify.
const (
	GlobalBaseRuntimeApisVerifyNone     GlobalBaseRuntimeApisVerify = "none"
	GlobalBaseRuntimeApisVerifyOptional GlobalBaseRuntimeApisVerify = "optional"
	GlobalBaseRuntimeApisVerifyRequired GlobalBaseRuntimeApisVerify = "required"
)

// Defines values for HashTypeFunction.
const (
	HashTypeFunctionCrc32 HashTypeFunction = "crc32"
	HashTypeFunctionDjb2  HashTypeFunction = "djb2"
	HashTypeFunctionNone  HashTypeFunction = "none"
	HashTypeFunctionSdbm  HashTypeFunction = "sdbm"
	HashTypeFunctionWt6   HashTypeFunction = "wt6"
)

// Defines values for HashTypeMethod.
const (
	HashTypeMethodConsistent HashTypeMethod = "consistent"
	HashTypeMethodMapBased   HashTypeMethod = "map-based"
)

// Defines values for HashTypeModifier.
const (
	HashTypeModifierAvalanche HashTypeModifier = "avalanche"
)

// Defines values for HealthHaproxy.
const (
	HealthHaproxyDown    HealthHaproxy = "down"
	HealthHaproxyUnknown HealthHaproxy = "unknown"
	HealthHaproxyUp      HealthHaproxy = "up"
)

// Defines values for HttpAfterResponseRuleCond.
const (
	HttpAfterResponseRuleCondIf     HttpAfterResponseRuleCond = "if"
	HttpAfterResponseRuleCondUnless HttpAfterResponseRuleCond = "unless"
)

// Defines values for HttpAfterResponseRuleLogLevel.
const (
	HttpAfterResponseRuleLogLevelAlert   HttpAfterResponseRuleLogLevel = "alert"
	HttpAfterResponseRuleLogLevelCrit    HttpAfterResponseRuleLogLevel = "crit"
	HttpAfterResponseRuleLogLevelDebug   HttpAfterResponseRuleLogLevel = "debug"
	HttpAfterResponseRuleLogLevelEmerg   HttpAfterResponseRuleLogLevel = "emerg"
	HttpAfterResponseRuleLogLevelErr     HttpAfterResponseRuleLogLevel = "err"
	HttpAfterResponseRuleLogLevelInfo    HttpAfterResponseRuleLogLevel = "info"
	HttpAfterResponseRuleLogLevelNotice  HttpAfterResponseRuleLogLevel = "notice"
	HttpAfterResponseRuleLogLevelSilent  HttpAfterResponseRuleLogLevel = "silent"
	HttpAfterResponseRuleLogLevelWarning HttpAfterResponseRuleLogLevel = "warning"
)

// Defines values for HttpAfterResponseRuleStrictMode.
const (
	HttpAfterResponseRuleStrictModeOff HttpAfterResponseRuleStrictMode = "off"
	HttpAfterResponseRuleStrictModeOn  HttpAfterResponseRuleStrictMode = "on"
)

// Defines values for HttpAfterResponseRuleType.
const (
	HttpAfterResponseRuleTypeAddHeader     HttpAfterResponseRuleType = "add-header"
	HttpAfterResponseRuleTypeAllow         HttpAfterResponseRuleType = "allow"
	HttpAfterResponseRuleTypeCapture       HttpAfterResponseRuleType = "capture"
	HttpAfterResponseRuleTypeDelAcl        HttpAfterResponseRuleType = "del-acl"
	HttpAfterResponseRuleTypeDelHeader     HttpAfterResponseRuleType = "del-header"
	HttpAfterResponseRuleTypeDelMap        HttpAfterResponseRuleType = "del-map"
	HttpAfterResponseRuleTypeDoLog         HttpAfterResponseRuleType = "do-log"
	HttpAfterResponseRuleTypeReplaceHeader HttpAfterResponseRuleType = "replace-header"
	HttpAfterResponseRuleTypeReplaceValue  HttpAfterResponseRuleType = "replace-value"
	HttpAfterResponseRuleTypeScAddGpc      HttpAfterResponseRuleType = "sc-add-gpc"
	HttpAfterResponseRuleTypeScIncGpc      HttpAfterResponseRuleType = "sc-inc-gpc"
	HttpAfterResponseRuleTypeScIncGpc0     HttpAfterResponseRuleType = "sc-inc-gpc0"
	HttpAfterResponseRuleTypeScIncGpc1     HttpAfterResponseRuleType = "sc-inc-gpc1"
	HttpAfterResponseRuleTypeScSetGpt      HttpAfterResponseRuleType = "sc-set-gpt"
	HttpAfterResponseRuleTypeScSetGpt0     HttpAfterResponseRuleType = "sc-set-gpt0"
	HttpAfterResponseRuleTypeSetHeader     HttpAfterResponseRuleType = "set-header"
	HttpAfterResponseRuleTypeSetLogLevel   HttpAfterResponseRuleType = "set-log-level"
	HttpAfterResponseRuleTypeSetMap        HttpAfterResponseRuleType = "set-map"
	HttpAfterResponseRuleTypeSetStatus     HttpAfterResponseRuleType = "set-status"
	HttpAfterResponseRuleTypeSetVar        HttpAfterResponseRuleType = "set-var"
	HttpAfterResponseRuleTypeSetVarFmt     HttpAfterResponseRuleType = "set-var-fmt"
	HttpAfterResponseRuleTypeStrictMode    HttpAfterResponseRuleType = "strict-mode"
	HttpAfterResponseRuleTypeUnsetVar      HttpAfterResponseRuleType = "unset-var"
)

// Defines values for HttpCheckErrorStatus.
const (
	HttpCheckErrorStatusL4CON HttpCheckErrorStatus = "L4CON"
	HttpCheckErrorStatusL6RSP HttpCheckErrorStatus = "L6RSP"
	HttpCheckErrorStatusL7OKC HttpCheckErrorStatus = "L7OKC"
	HttpCheckErrorStatusL7RSP HttpCheckErrorStatus = "L7RSP"
	HttpCheckErrorStatusL7STS HttpCheckErrorStatus = "L7STS"
)

// Defines values for HttpCheckMatch.
const (
	HttpCheckMatchFhdr    HttpCheckMatch = "fhdr"
	HttpCheckMatchHdr     HttpCheckMatch = "hdr"
	HttpCheckMatchRstatus HttpCheckMatch = "rstatus"
	HttpCheckMatchRstring HttpCheckMatch = "rstring"
	HttpCheckMatchStatus  HttpCheckMatch = "status"
	HttpCheckMatchString  HttpCheckMatch = "string"
)

// Defines values for HttpCheckMethod.
const (
	HttpCheckMethodCONNECT HttpCheckMethod = "CONNECT"
	HttpCheckMethodDELETE  HttpCheckMethod = "DELETE"
	HttpCheckMethodGET     HttpCheckMethod = "GET"
	HttpCheckMethodHEAD    HttpCheckMethod = "HEAD"
	HttpCheckMethodOPTIONS HttpCheckMethod = "OPTIONS"
	HttpCheckMethodPATCH   HttpCheckMethod = "PATCH"
	HttpCheckMethodPOST    HttpCheckMethod = "POST"
	HttpCheckMethodPUT     HttpCheckMethod = "PUT"
	HttpCheckMethodTRACE   HttpCheckMethod = "TRACE"
)

// Defines values for HttpCheckOkStatus.
const (
	HttpCheckOkStatusL4OK  HttpCheckOkStatus = "L4OK"
	HttpCheckOkStatusL6OK  HttpCheckOkStatus = "L6OK"
	HttpCheckOkStatusL7OK  HttpCheckOkStatus = "L7OK"
	HttpCheckOkStatusL7OKC HttpCheckOkStatus = "L7OKC"
)

// Defines values for HttpCheckToutStatus.
const (
	HttpCheckToutStatusL4TOUT HttpCheckToutStatus = "L4TOUT"
	HttpCheckToutStatusL6TOUT HttpCheckToutStatus = "L6TOUT"
	HttpCheckToutStatusL7TOUT HttpCheckToutStatus = "L7TOUT"
)

// Defines values for HttpCheckType.
const (
	HttpCheckTypeComment      HttpCheckType = "comment"
	HttpCheckTypeConnect      HttpCheckType = "connect"
	HttpCheckTypeDisableOn404 HttpCheckType = "disable-on-404"
	HttpCheckTypeExpect       HttpCheckType = "expect"
	HttpCheckTypeSend         HttpCheckType = "send"
	HttpCheckTypeSendState    HttpCheckType = "send-state"
	HttpCheckTypeSetVar       HttpCheckType = "set-var"
	HttpCheckTypeSetVarFmt    HttpCheckType = "set-var-fmt"
	HttpCheckTypeUnsetVar     HttpCheckType = "unset-var"
)

// Defines values for HttpClientOptionsResolversDisabled.
const (
	HttpClientOptionsResolversDisabledDisabled HttpClientOptionsResolversDisabled = "disabled"
	HttpClientOptionsResolversDisabledEnabled  HttpClientOptionsResolversDisabled = "enabled"
)

// Defines values for HttpClientOptionsResolversPrefer.
const (
	HttpClientOptionsResolversPreferIpv4 HttpClientOptionsResolversPrefer = "ipv4"
	HttpClientOptionsResolversPreferIpv6 HttpClientOptionsResolversPrefer = "ipv6"
)

// Defines values for HttpClientOptionsSslVerify.
const (
	HttpClientOptionsSslVerifyEmpty    HttpClientOptionsSslVerify = ""
	HttpClientOptionsSslVerifyNone     HttpClientOptionsSslVerify = "none"
	HttpClientOptionsSslVerifyRequired HttpClientOptionsSslVerify = "required"
)

// Defines values for HttpErrorRuleReturnContentFormat.
const (
	HttpErrorRuleReturnContentFormatDefaultErrorfiles HttpErrorRuleReturnContentFormat = "default-errorfiles"
	HttpErrorRuleReturnContentFormatErrorfile         HttpErrorRuleReturnContentFormat = "errorfile"
	HttpErrorRuleReturnContentFormatErrorfiles        HttpErrorRuleReturnContentFormat = "errorfiles"
	HttpErrorRuleReturnContentFormatFile              HttpErrorRuleReturnContentFormat = "file"
	HttpErrorRuleReturnContentFormatLfFile            HttpErrorRuleReturnContentFormat = "lf-file"
	HttpErrorRuleReturnContentFormatLfString          HttpErrorRuleReturnContentFormat = "lf-string"
	HttpErrorRuleReturnContentFormatString            HttpErrorRuleReturnContentFormat = "string"
)

// Defines values for HttpErrorRuleStatus.
const (
	HttpErrorRuleStatusN200 HttpErrorRuleStatus = 200
	HttpErrorRuleStatusN400 HttpErrorRuleStatus = 400
	HttpErrorRuleStatusN401 HttpErrorRuleStatus = 401
	HttpErrorRuleStatusN403 HttpErrorRuleStatus = 403
	HttpErrorRuleStatusN404 HttpErrorRuleStatus = 404
	HttpErrorRuleStatusN405 HttpErrorRuleStatus = 405
	HttpErrorRuleStatusN407 HttpErrorRuleStatus = 407
	HttpErrorRuleStatusN408 HttpErrorRuleStatus = 408
	HttpErrorRuleStatusN410 HttpErrorRuleStatus = 410
	HttpErrorRuleStatusN413 HttpErrorRuleStatus = 413
	HttpErrorRuleStatusN425 HttpErrorRuleStatus = 425
	HttpErrorRuleStatusN429 HttpErrorRuleStatus = 429
	HttpErrorRuleStatusN500 HttpErrorRuleStatus = 500
	HttpErrorRuleStatusN501 HttpErrorRuleStatus = 501
	HttpErrorRuleStatusN502 HttpErrorRuleStatus = 502
	HttpErrorRuleStatusN503 HttpErrorRuleStatus = 503
	HttpErrorRuleStatusN504 HttpErrorRuleStatus = 504
)

// Defines values for HttpErrorRuleType.
const (
	HttpErrorRuleTypeStatus HttpErrorRuleType = "status"
)

// Defines values for HttpRequestRuleCond.
const (
	HttpRequestRuleCondIf     HttpRequestRuleCond = "if"
	HttpRequestRuleCondUnless HttpRequestRuleCond = "unless"
)

// Defines values for HttpRequestRuleLogLevel.
const (
	HttpRequestRuleLogLevelAlert   HttpRequestRuleLogLevel = "alert"
	HttpRequestRuleLogLevelCrit    HttpRequestRuleLogLevel = "crit"
	HttpRequestRuleLogLevelDebug   HttpRequestRuleLogLevel = "debug"
	HttpRequestRuleLogLevelEmerg   HttpRequestRuleLogLevel = "emerg"
	HttpRequestRuleLogLevelErr     HttpRequestRuleLogLevel = "err"
	HttpRequestRuleLogLevelInfo    HttpRequestRuleLogLevel = "info"
	HttpRequestRuleLogLevelNotice  HttpRequestRuleLogLevel = "notice"
	HttpRequestRuleLogLevelSilent  HttpRequestRuleLogLevel = "silent"
	HttpRequestRuleLogLevelWarning HttpRequestRuleLogLevel = "warning"
)

// Defines values for HttpRequestRuleNormalizer.
const (
	HttpRequestRuleNormalizerFragmentEncode          HttpRequestRuleNormalizer = "fragment-encode"
	HttpRequestRuleNormalizerFragmentStrip           HttpRequestRuleNormalizer = "fragment-strip"
	HttpRequestRuleNormalizerPathMergeSlashes        HttpRequestRuleNormalizer = "path-merge-slashes"
	HttpRequestRuleNormalizerPathStripDot            HttpRequestRuleNormalizer = "path-strip-dot"
	HttpRequestRuleNormalizerPathStripDotdot         HttpRequestRuleNormalizer = "path-strip-dotdot"
	HttpRequestRuleNormalizerPercentDecodeUnreserved HttpRequestRuleNormalizer = "percent-decode-unreserved"
	HttpRequestRuleNormalizerPercentToUppercase      HttpRequestRuleNormalizer = "percent-to-uppercase"
	HttpRequestRuleNormalizerQuerySortByName         HttpRequestRuleNormalizer = "query-sort-by-name"
)

// Defines values for HttpRequestRuleProtocol.
const (
	HttpRequestRuleProtocolIpv4 HttpRequestRuleProtocol = "ipv4"
	HttpRequestRuleProtocolIpv6 HttpRequestRuleProtocol = "ipv6"
)

// Defines values for HttpRequestRuleRedirCode.
const (
	HttpRequestRuleRedirCodeN301 HttpRequestRuleRedirCode = 301
	HttpRequestRuleRedirCodeN302 HttpRequestRuleRedirCode = 302
	HttpRequestRuleRedirCodeN303 HttpRequestRuleRedirCode = 303
	HttpRequestRuleRedirCodeN307 HttpRequestRuleRedirCode = 307
	HttpRequestRuleRedirCodeN308 HttpRequestRuleRedirCode = 308
)

// Defines values for HttpRequestRuleRedirType.
const (
	HttpRequestRuleRedirTypeLocation HttpRequestRuleRedirType = "location"
	HttpRequestRuleRedirTypePrefix   HttpRequestRuleRedirType = "prefix"
	HttpRequestRuleRedirTypeScheme   HttpRequestRuleRedirType = "scheme"
)

// Defines values for HttpRequestRuleReturnContentFormat.
const (
	HttpRequestRuleReturnContentFormatDefaultErrorfiles HttpRequestRuleReturnContentFormat = "default-errorfiles"
	HttpRequestRuleReturnContentFormatErrorfile         HttpRequestRuleReturnContentFormat = "errorfile"
	HttpRequestRuleReturnContentFormatErrorfiles        HttpRequestRuleReturnContentFormat = "errorfiles"
	HttpRequestRuleReturnContentFormatFile              HttpRequestRuleReturnContentFormat = "file"
	HttpRequestRuleReturnContentFormatLfFile            HttpRequestRuleReturnContentFormat = "lf-file"
	HttpRequestRuleReturnContentFormatLfString          HttpRequestRuleReturnContentFormat = "lf-string"
	HttpRequestRuleReturnContentFormatString            HttpRequestRuleReturnContentFormat = "string"
)

// Defines values for HttpRequestRuleStrictMode.
const (
	HttpRequestRuleStrictModeOff HttpRequestRuleStrictMode = "off"
	HttpRequestRuleStrictModeOn  HttpRequestRuleStrictMode = "on"
)

// Defines values for HttpRequestRuleTimeoutType.
const (
	HttpRequestRuleTimeoutTypeClient HttpRequestRuleTimeoutType = "client"
	HttpRequestRuleTimeoutTypeServer HttpRequestRuleTimeoutType = "server"
	HttpRequestRuleTimeoutTypeTunnel HttpRequestRuleTimeoutType = "tunnel"
)

// Defines values for HttpRequestRuleType.
const (
	HttpRequestRuleTypeAddAcl            HttpRequestRuleType = "add-acl"
	HttpRequestRuleTypeAddHeader         HttpRequestRuleType = "add-header"
	HttpRequestRuleTypeAllow             HttpRequestRuleType = "allow"
	HttpRequestRuleTypeAuth              HttpRequestRuleType = "auth"
	HttpRequestRuleTypeCacheUse          HttpRequestRuleType = "cache-use"
	HttpRequestRuleTypeCapture           HttpRequestRuleType = "capture"
	HttpRequestRuleTypeDelAcl            HttpRequestRuleType = "del-acl"
	HttpRequestRuleTypeDelHeader         HttpRequestRuleType = "del-header"
	HttpRequestRuleTypeDelMap            HttpRequestRuleType = "del-map"
	HttpRequestRuleTypeDeny              HttpRequestRuleType = "deny"
	HttpRequestRuleTypeDisableL7Retry    HttpRequestRuleType = "disable-l7-retry"
	HttpRequestRuleTypeDoLog             HttpRequestRuleType = "do-log"
	HttpRequestRuleTypeDoResolve         HttpRequestRuleType = "do-resolve"
	HttpRequestRuleTypeEarlyHint         HttpRequestRuleType = "early-hint"
	HttpRequestRuleTypeLua               HttpRequestRuleType = "lua"
	HttpRequestRuleTypeNormalizeUri      HttpRequestRuleType = "normalize-uri"
	HttpRequestRuleTypePause             HttpRequestRuleType = "pause"
	HttpRequestRuleTypeRedirect          HttpRequestRuleType = "redirect"
	HttpRequestRuleTypeReject            HttpRequestRuleType = "reject"
	HttpRequestRuleTypeReplaceHeader     HttpRequestRuleType = "replace-header"
	HttpRequestRuleTypeReplacePath       HttpRequestRuleType = "replace-path"
	HttpRequestRuleTypeReplacePathq      HttpRequestRuleType = "replace-pathq"
	HttpRequestRuleTypeReplaceUri        HttpRequestRuleType = "replace-uri"
	HttpRequestRuleTypeReplaceValue      HttpRequestRuleType = "replace-value"
	HttpRequestRuleTypeReturn            HttpRequestRuleType = "return"
	HttpRequestRuleTypeScAddGpc          HttpRequestRuleType = "sc-add-gpc"
	HttpRequestRuleTypeScIncGpc          HttpRequestRuleType = "sc-inc-gpc"
	HttpRequestRuleTypeScIncGpc0         HttpRequestRuleType = "sc-inc-gpc0"
	HttpRequestRuleTypeScIncGpc1         HttpRequestRuleType = "sc-inc-gpc1"
	HttpRequestRuleTypeScSetGpt          HttpRequestRuleType = "sc-set-gpt"
	HttpRequestRuleTypeScSetGpt0         HttpRequestRuleType = "sc-set-gpt0"
	HttpRequestRuleTypeSendSpoeGroup     HttpRequestRuleType = "send-spoe-group"
	HttpRequestRuleTypeSetBandwidthLimit HttpRequestRuleType = "set-bandwidth-limit"
	HttpRequestRuleTypeSetBcMark         HttpRequestRuleType = "set-bc-mark"
	HttpRequestRuleTypeSetBcTos          HttpRequestRuleType = "set-bc-tos"
	HttpRequestRuleTypeSetDst            HttpRequestRuleType = "set-dst"
	HttpRequestRuleTypeSetDstPort        HttpRequestRuleType = "set-dst-port"
	HttpRequestRuleTypeSetFcMark         HttpRequestRuleType = "set-fc-mark"
	HttpRequestRuleTypeSetFcTos          HttpRequestRuleType = "set-fc-tos"
	HttpRequestRuleTypeSetHeader         HttpRequestRuleType = "set-header"
	HttpRequestRuleTypeSetLogLevel       HttpRequestRuleType = "set-log-level"
	HttpRequestRuleTypeSetMap            HttpRequestRuleType = "set-map"
	HttpRequestRuleTypeSetMark           HttpRequestRuleType = "set-mark"
	HttpRequestRuleTypeSetMethod         HttpRequestRuleType = "set-method"
	HttpRequestRuleTypeSetNice           HttpRequestRuleType = "set-nice"
	HttpRequestRuleTypeSetPath           HttpRequestRuleType = "set-path"
	HttpRequestRuleTypeSetPathq          HttpRequestRuleType = "set-pathq"
	HttpRequestRuleTypeSetPriorityClass  HttpRequestRuleType = "set-priority-class"
	HttpRequestRuleTypeSetPriorityOffset HttpRequestRuleType = "set-priority-offset"
	HttpRequestRuleTypeSetQuery          HttpRequestRuleType = "set-query"
	HttpRequestRuleTypeSetRetries        HttpRequestRuleType = "set-retries"
	HttpRequestRuleTypeSetSrc            HttpRequestRuleType = "set-src"
	HttpRequestRuleTypeSetSrcPort        HttpRequestRuleType = "set-src-port"
	HttpRequestRuleTypeSetTimeout        HttpRequestRuleType = "set-timeout"
	HttpRequestRuleTypeSetTos            HttpRequestRuleType = "set-tos"
	HttpRequestRuleTypeSetUri            HttpRequestRuleType = "set-uri"
	HttpRequestRuleTypeSetVar            HttpRequestRuleType = "set-var"
	HttpRequestRuleTypeSetVarFmt         HttpRequestRuleType = "set-var-fmt"
	HttpRequestRuleTypeSilentDrop        HttpRequestRuleType = "silent-drop"
	HttpRequestRuleTypeStrictMode        HttpRequestRuleType = "strict-mode"
	HttpRequestRuleTypeTarpit            HttpRequestRuleType = "tarpit"
	HttpRequestRuleTypeTrackSc           HttpRequestRuleType = "track-sc"
	HttpRequestRuleTypeUnsetVar          HttpRequestRuleType = "unset-var"
	HttpRequestRuleTypeUseService        HttpRequestRuleType = "use-service"
	HttpRequestRuleTypeWaitForBody       HttpRequestRuleType = "wait-for-body"
	HttpRequestRuleTypeWaitForHandshake  HttpRequestRuleType = "wait-for-handshake"
)

// Defines values for HttpResponseRuleCond.
const (
	HttpResponseRuleCondIf     HttpResponseRuleCond = "if"
	HttpResponseRuleCondUnless HttpResponseRuleCond = "unless"
)

// Defines values for HttpResponseRuleLogLevel.
const (
	HttpResponseRuleLogLevelAlert   HttpResponseRuleLogLevel = "alert"
	HttpResponseRuleLogLevelCrit    HttpResponseRuleLogLevel = "crit"
	HttpResponseRuleLogLevelDebug   HttpResponseRuleLogLevel = "debug"
	HttpResponseRuleLogLevelEmerg   HttpResponseRuleLogLevel = "emerg"
	HttpResponseRuleLogLevelErr     HttpResponseRuleLogLevel = "err"
	HttpResponseRuleLogLevelInfo    HttpResponseRuleLogLevel = "info"
	HttpResponseRuleLogLevelNotice  HttpResponseRuleLogLevel = "notice"
	HttpResponseRuleLogLevelSilent  HttpResponseRuleLogLevel = "silent"
	HttpResponseRuleLogLevelWarning HttpResponseRuleLogLevel = "warning"
)

// Defines values for HttpResponseRuleRedirCode.
const (
	HttpResponseRuleRedirCodeN301 HttpResponseRuleRedirCode = 301
	HttpResponseRuleRedirCodeN302 HttpResponseRuleRedirCode = 302
	HttpResponseRuleRedirCodeN303 HttpResponseRuleRedirCode = 303
	HttpResponseRuleRedirCodeN307 HttpResponseRuleRedirCode = 307
	HttpResponseRuleRedirCodeN308 HttpResponseRuleRedirCode = 308
)

// Defines values for HttpResponseRuleRedirType.
const (
	HttpResponseRuleRedirTypeLocation HttpResponseRuleRedirType = "location"
	HttpResponseRuleRedirTypePrefix   HttpResponseRuleRedirType = "prefix"
	HttpResponseRuleRedirTypeScheme   HttpResponseRuleRedirType = "scheme"
)

// Defines values for HttpResponseRuleReturnContentFormat.
const (
	HttpResponseRuleReturnContentFormatDefaultErrorfiles HttpResponseRuleReturnContentFormat = "default-errorfiles"
	HttpResponseRuleReturnContentFormatErrorfile         HttpResponseRuleReturnContentFormat = "errorfile"
	HttpResponseRuleReturnContentFormatErrorfiles        HttpResponseRuleReturnContentFormat = "errorfiles"
	HttpResponseRuleReturnContentFormatFile              HttpResponseRuleReturnContentFormat = "file"
	HttpResponseRuleReturnContentFormatLfFile            HttpResponseRuleReturnContentFormat = "lf-file"
	HttpResponseRuleReturnContentFormatLfString          HttpResponseRuleReturnContentFormat = "lf-string"
	HttpResponseRuleReturnContentFormatString            HttpResponseRuleReturnContentFormat = "string"
)

// Defines values for HttpResponseRuleStrictMode.
const (
	HttpResponseRuleStrictModeOff HttpResponseRuleStrictMode = "off"
	HttpResponseRuleStrictModeOn  HttpResponseRuleStrictMode = "on"
)

// Defines values for HttpResponseRuleTimeoutType.
const (
	HttpResponseRuleTimeoutTypeClient HttpResponseRuleTimeoutType = "client"
	HttpResponseRuleTimeoutTypeServer HttpResponseRuleTimeoutType = "server"
	HttpResponseRuleTimeoutTypeTunnel HttpResponseRuleTimeoutType = "tunnel"
)

// Defines values for HttpResponseRuleType.
const (
	HttpResponseRuleTypeAddAcl            HttpResponseRuleType = "add-acl"
	HttpResponseRuleTypeAddHeader         HttpResponseRuleType = "add-header"
	HttpResponseRuleTypeAllow             HttpResponseRuleType = "allow"
	HttpResponseRuleTypeCacheStore        HttpResponseRuleType = "cache-store"
	HttpResponseRuleTypeCapture           HttpResponseRuleType = "capture"
	HttpResponseRuleTypeDelAcl            HttpResponseRuleType = "del-acl"
	HttpResponseRuleTypeDelHeader         HttpResponseRuleType = "del-header"
	HttpResponseRuleTypeDelMap            HttpResponseRuleType = "del-map"
	HttpResponseRuleTypeDeny              HttpResponseRuleType = "deny"
	HttpResponseRuleTypeDoLog             HttpResponseRuleType = "do-log"
	HttpResponseRuleTypeLua               HttpResponseRuleType = "lua"
	HttpResponseRuleTypePause             HttpResponseRuleType = "pause"
	HttpResponseRuleTypeRedirect          HttpResponseRuleType = "redirect"
	HttpResponseRuleTypeReplaceHeader     HttpResponseRuleType = "replace-header"
	HttpResponseRuleTypeReplaceValue      HttpResponseRuleType = "replace-value"
	HttpResponseRuleTypeReturn            HttpResponseRuleType = "return"
	HttpResponseRuleTypeScAddGpc          HttpResponseRuleType = "sc-add-gpc"
	HttpResponseRuleTypeScIncGpc          HttpResponseRuleType = "sc-inc-gpc"
	HttpResponseRuleTypeScIncGpc0         HttpResponseRuleType = "sc-inc-gpc0"
	HttpResponseRuleTypeScIncGpc1         HttpResponseRuleType = "sc-inc-gpc1"
	HttpResponseRuleTypeScSetGpt          HttpResponseRuleType = "sc-set-gpt"
	HttpResponseRuleTypeScSetGpt0         HttpResponseRuleType = "sc-set-gpt0"
	HttpResponseRuleTypeSendSpoeGroup     HttpResponseRuleType = "send-spoe-group"
	HttpResponseRuleTypeSetBandwidthLimit HttpResponseRuleType = "set-bandwidth-limit"
	HttpResponseRuleTypeSetFcMark         HttpResponseRuleType = "set-fc-mark"
	HttpResponseRuleTypeSetFcTos          HttpResponseRuleType = "set-fc-tos"
	HttpResponseRuleTypeSetHeader         HttpResponseRuleType = "set-header"
	HttpResponseRuleTypeSetLogLevel       HttpResponseRuleType = "set-log-level"
	HttpResponseRuleTypeSetMap            HttpResponseRuleType = "set-map"
	HttpResponseRuleTypeSetMark           HttpResponseRuleType = "set-mark"
	HttpResponseRuleTypeSetNice           HttpResponseRuleType = "set-nice"
	HttpResponseRuleTypeSetStatus         HttpResponseRuleType = "set-status"
	HttpResponseRuleTypeSetTimeout        HttpResponseRuleType = "set-timeout"
	HttpResponseRuleTypeSetTos            HttpResponseRuleType = "set-tos"
	HttpResponseRuleTypeSetVar            HttpResponseRuleType = "set-var"
	HttpResponseRuleTypeSetVarFmt         HttpResponseRuleType = "set-var-fmt"
	HttpResponseRuleTypeSilentDrop        HttpResponseRuleType = "silent-drop"
	HttpResponseRuleTypeStrictMode        HttpResponseRuleType = "strict-mode"
	HttpResponseRuleTypeTrackSc           HttpResponseRuleType = "track-sc"
	HttpResponseRuleTypeUnsetVar          HttpResponseRuleType = "unset-var"
	HttpResponseRuleTypeWaitForBody       HttpResponseRuleType = "wait-for-body"
)

// Defines values for HttpchkParamsMethod.
const (
	HttpchkParamsMethodCONNECT HttpchkParamsMethod = "CONNECT"
	HttpchkParamsMethodDELETE  HttpchkParamsMethod = "DELETE"
	HttpchkParamsMethodGET     HttpchkParamsMethod = "GET"
	HttpchkParamsMethodHEAD    HttpchkParamsMethod = "HEAD"
	HttpchkParamsMethodOPTIONS HttpchkParamsMethod = "OPTIONS"
	HttpchkParamsMethodPATCH   HttpchkParamsMethod = "PATCH"
	HttpchkParamsMethodPOST    HttpchkParamsMethod = "POST"
	HttpchkParamsMethodPUT     HttpchkParamsMethod = "PUT"
	HttpchkParamsMethodTRACE   HttpchkParamsMethod = "TRACE"
)

// Defines values for LogProfileStepDrop.
const (
	LogProfileStepDropDisabled LogProfileStepDrop = "disabled"
	LogProfileStepDropEnabled  LogProfileStepDrop = "enabled"
)

// Defines values for LogProfileStepStep.
const (
	LogProfileStepStepAccept       LogProfileStepStep = "accept"
	LogProfileStepStepAny          LogProfileStepStep = "any"
	LogProfileStepStepClose        LogProfileStepStep = "close"
	LogProfileStepStepConnect      LogProfileStepStep = "connect"
	LogProfileStepStepError        LogProfileStepStep = "error"
	LogProfileStepStepHttpAfterRes LogProfileStepStep = "http-after-res"
	LogProfileStepStepHttpReq      LogProfileStepStep = "http-req"
	LogProfileStepStepHttpRes      LogProfileStepStep = "http-res"
	LogProfileStepStepQuicInit     LogProfileStepStep = "quic-init"
	LogProfileStepStepRequest      LogProfileStepStep = "request"
	LogProfileStepStepResponse     LogProfileStepStep = "response"
	LogProfileStepStepTcpReqConn   LogProfileStepStep = "tcp-req-conn"
	LogProfileStepStepTcpReqCont   LogProfileStepStep = "tcp-req-cont"
	LogProfileStepStepTcpReqSess   LogProfileStepStep = "tcp-req-sess"
)

// Defines values for LogTargetFacility.
const (
	LogTargetFacilityAlert  LogTargetFacility = "alert"
	LogTargetFacilityAudit  LogTargetFacility = "audit"
	LogTargetFacilityAuth   LogTargetFacility = "auth"
	LogTargetFacilityAuth2  LogTargetFacility = "auth2"
	LogTargetFacilityCron   LogTargetFacility = "cron"
	LogTargetFacilityCron2  LogTargetFacility = "cron2"
	LogTargetFacilityDaemon LogTargetFacility = "daemon"
	LogTargetFacilityFtp    LogTargetFacility = "ftp"
	LogTargetFacilityKern   LogTargetFacility = "kern"
	LogTargetFacilityLocal0 LogTargetFacility = "local0"
	LogTargetFacilityLocal1 LogTargetFacility = "local1"
	LogTargetFacilityLocal2 LogTargetFacility = "local2"
	LogTargetFacilityLocal3 LogTargetFacility = "local3"
	LogTargetFacilityLocal4 LogTargetFacility = "local4"
	LogTargetFacilityLocal5 LogTargetFacility = "local5"
	LogTargetFacilityLocal6 LogTargetFacility = "local6"
	LogTargetFacilityLocal7 LogTargetFacility = "local7"
	LogTargetFacilityLpr    LogTargetFacility = "lpr"
	LogTargetFacilityMail   LogTargetFacility = "mail"
	LogTargetFacilityNews   LogTargetFacility = "news"
	LogTargetFacilityNtp    LogTargetFacility = "ntp"
	LogTargetFacilitySyslog LogTargetFacility = "syslog"
	LogTargetFacilityUser   LogTargetFacility = "user"
	LogTargetFacilityUucp   LogTargetFacility = "uucp"
)

// Defines values for LogTargetFormat.
const (
	LogTargetFormatIso      LogTargetFormat = "iso"
	LogTargetFormatLocal    LogTargetFormat = "local"
	LogTargetFormatPriority LogTargetFormat = "priority"
	LogTargetFormatRaw      LogTargetFormat = "raw"
	LogTargetFormatRfc3164  LogTargetFormat = "rfc3164"
	LogTargetFormatRfc5424  LogTargetFormat = "rfc5424"
	LogTargetFormatShort    LogTargetFormat = "short"
	LogTargetFormatTimed    LogTargetFormat = "timed"
)

// Defines values for LogTargetLevel.
const (
	LogTargetLevelAlert   LogTargetLevel = "alert"
	LogTargetLevelCrit    LogTargetLevel = "crit"
	LogTargetLevelDebug   LogTargetLevel = "debug"
	LogTargetLevelEmerg   LogTargetLevel = "emerg"
	LogTargetLevelErr     LogTargetLevel = "err"
	LogTargetLevelInfo    LogTargetLevel = "info"
	LogTargetLevelNotice  LogTargetLevel = "notice"
	LogTargetLevelWarning LogTargetLevel = "warning"
)

// Defines values for LogTargetMinlevel.
const (
	LogTargetMinlevelAlert   LogTargetMinlevel = "alert"
	LogTargetMinlevelCrit    LogTargetMinlevel = "crit"
	LogTargetMinlevelDebug   LogTargetMinlevel = "debug"
	LogTargetMinlevelEmerg   LogTargetMinlevel = "emerg"
	LogTargetMinlevelErr     LogTargetMinlevel = "err"
	LogTargetMinlevelInfo    LogTargetMinlevel = "info"
	LogTargetMinlevelNotice  LogTargetMinlevel = "notice"
	LogTargetMinlevelWarning LogTargetMinlevel = "warning"
)

// Defines values for LuaOptionsPrependPathType.
const (
	LuaOptionsPrependPathTypeCpath LuaOptionsPrependPathType = "cpath"
	LuaOptionsPrependPathTypePath  LuaOptionsPrependPathType = "path"
)

// Defines values for MonitorFailCond.
const (
	MonitorFailCondIf     MonitorFailCond = "if"
	MonitorFailCondUnless MonitorFailCond = "unless"
)

// Defines values for MysqlCheckParamsClientVersion.
const (
	MysqlCheckParamsClientVersionPost41 MysqlCheckParamsClientVersion = "post-41"
	MysqlCheckParamsClientVersionPre41  MysqlCheckParamsClientVersion = "pre-41"
)

// Defines values for NativeStatType.
const (
	NativeStatTypeBackend  NativeStatType = "backend"
	NativeStatTypeFrontend NativeStatType = "frontend"
	NativeStatTypeServer   NativeStatType = "server"
)

// Defines values for NativeStatStatsAgentStatus.
const (
	NativeStatStatsAgentStatusINI     NativeStatStatsAgentStatus = "INI"
	NativeStatStatsAgentStatusL4CON   NativeStatStatsAgentStatus = "L4CON"
	NativeStatStatsAgentStatusL4OK    NativeStatStatsAgentStatus = "L4OK"
	NativeStatStatsAgentStatusL4TOUT  NativeStatStatsAgentStatus = "L4TOUT"
	NativeStatStatsAgentStatusL7OK    NativeStatStatsAgentStatus = "L7OK"
	NativeStatStatsAgentStatusL7STS   NativeStatStatsAgentStatus = "L7STS"
	NativeStatStatsAgentStatusSOCKERR NativeStatStatsAgentStatus = "SOCKERR"
	NativeStatStatsAgentStatusUNK     NativeStatStatsAgentStatus = "UNK"
)

// Defines values for NativeStatStatsCheckStatus.
const (
	NativeStatStatsCheckStatusINI     NativeStatStatsCheckStatus = "INI"
	NativeStatStatsCheckStatusL4CON   NativeStatStatsCheckStatus = "L4CON"
	NativeStatStatsCheckStatusL4OK    NativeStatStatsCheckStatus = "L4OK"
	NativeStatStatsCheckStatusL4TOUT  NativeStatStatsCheckStatus = "L4TOUT"
	NativeStatStatsCheckStatusL6OK    NativeStatStatsCheckStatus = "L6OK"
	NativeStatStatsCheckStatusL6RSP   NativeStatStatsCheckStatus = "L6RSP"
	NativeStatStatsCheckStatusL6TOUT  NativeStatStatsCheckStatus = "L6TOUT"
	NativeStatStatsCheckStatusL7OK    NativeStatStatsCheckStatus = "L7OK"
	NativeStatStatsCheckStatusL7OKC   NativeStatStatsCheckStatus = "L7OKC"
	NativeStatStatsCheckStatusL7RSP   NativeStatStatsCheckStatus = "L7RSP"
	NativeStatStatsCheckStatusL7STS   NativeStatStatsCheckStatus = "L7STS"
	NativeStatStatsCheckStatusL7TOUT  NativeStatStatsCheckStatus = "L7TOUT"
	NativeStatStatsCheckStatusSOCKERR NativeStatStatsCheckStatus = "SOCKERR"
	NativeStatStatsCheckStatusUNK     NativeStatStatsCheckStatus = "UNK"
)

// Defines values for NativeStatStatsMode.
const (
	NativeStatStatsModeHealth  NativeStatStatsMode = "health"
	NativeStatStatsModeHttp    NativeStatStatsMode = "http"
	NativeStatStatsModeTcp     NativeStatStatsMode = "tcp"
	NativeStatStatsModeUnknown NativeStatStatsMode = "unknown"
)

// Defines values for NativeStatStatsStatus.
const (
	NativeStatStatsStatusDOWN    NativeStatStatsStatus = "DOWN"
	NativeStatStatsStatusMAINT   NativeStatStatsStatus = "MAINT"
	NativeStatStatsStatusNOLB    NativeStatStatsStatus = "NOLB"
	NativeStatStatsStatusNoCheck NativeStatStatsStatus = "no check"
	NativeStatStatsStatusUP      NativeStatStatsStatus = "UP"
)

// Defines values for OcspUpdateOptionsMode.
const (
	OcspUpdateOptionsModeDisabled OcspUpdateOptionsMode = "disabled"
	OcspUpdateOptionsModeEnabled  OcspUpdateOptionsMode = "enabled"
)

// Defines values for OriginaltoEnabled.
const (
	OriginaltoEnabledEnabled OriginaltoEnabled = "enabled"
)

// Defines values for PerformanceOptionsProfilingMemory.
const (
	PerformanceOptionsProfilingMemoryDisabled PerformanceOptionsProfilingMemory = "disabled"
	PerformanceOptionsProfilingMemoryEnabled  PerformanceOptionsProfilingMemory = "enabled"
)

// Defines values for PerformanceOptionsProfilingTasks.
const (
	PerformanceOptionsProfilingTasksAuto     PerformanceOptionsProfilingTasks = "auto"
	PerformanceOptionsProfilingTasksDisabled PerformanceOptionsProfilingTasks = "disabled"
	PerformanceOptionsProfilingTasksEnabled  PerformanceOptionsProfilingTasks = "enabled"
)

// Defines values for PersistRuleType.
const (
	PersistRuleTypeRdpCookie PersistRuleType = "rdp-cookie"
)

// Defines values for ProgramStartOnReload.
const (
	ProgramStartOnReloadDisabled ProgramStartOnReload = "disabled"
	ProgramStartOnReloadEnabled  ProgramStartOnReload = "enabled"
)

// Defines values for QuicInitialRuleCond.
const (
	QuicInitialRuleCondIf     QuicInitialRuleCond = "if"
	QuicInitialRuleCondUnless QuicInitialRuleCond = "unless"
)

// Defines values for QuicInitialRuleType.
const (
	QuicInitialRuleTypeAccept    QuicInitialRuleType = "accept"
	QuicInitialRuleTypeDgramDrop QuicInitialRuleType = "dgram-drop"
	QuicInitialRuleTypeReject    QuicInitialRuleType = "reject"
	QuicInitialRuleTypeSendRetry QuicInitialRuleType = "send-retry"
)

// Defines values for RedispatchEnabled.
const (
	RedispatchEnabledDisabled RedispatchEnabled = "disabled"
	RedispatchEnabledEnabled  RedispatchEnabled = "enabled"
)

// Defines values for ReloadStatus.
const (
	ReloadStatusFailed     ReloadStatus = "failed"
	ReloadStatusInProgress ReloadStatus = "in_progress"
	ReloadStatusSucceeded  ReloadStatus = "succeeded"
)

// Defines values for RingFormat.
const (
	RingFormatIso      RingFormat = "iso"
	RingFormatLocal    RingFormat = "local"
	RingFormatPriority RingFormat = "priority"
	RingFormatRaw      RingFormat = "raw"
	RingFormatRfc3164  RingFormat = "rfc3164"
	RingFormatRfc5424  RingFormat = "rfc5424"
	RingFormatShort    RingFormat = "short"
	RingFormatTimed    RingFormat = "timed"
)

// Defines values for RingBaseFormat.
const (
	RingBaseFormatIso      RingBaseFormat = "iso"
	RingBaseFormatLocal    RingBaseFormat = "local"
	RingBaseFormatPriority RingBaseFormat = "priority"
	RingBaseFormatRaw      RingBaseFormat = "raw"
	RingBaseFormatRfc3164  RingBaseFormat = "rfc3164"
	RingBaseFormatRfc5424  RingBaseFormat = "rfc5424"
	RingBaseFormatShort    RingBaseFormat = "short"
	RingBaseFormatTimed    RingBaseFormat = "timed"
)

// Defines values for RuntimeAddServerAgentCheck.
const (
	RuntimeAddServerAgentCheckDisabled RuntimeAddServerAgentCheck = "disabled"
	RuntimeAddServerAgentCheckEnabled  RuntimeAddServerAgentCheck = "enabled"
)

// Defines values for RuntimeAddServerBackup.
const (
	RuntimeAddServerBackupDisabled RuntimeAddServerBackup = "disabled"
	RuntimeAddServerBackupEnabled  RuntimeAddServerBackup = "enabled"
)

// Defines values for RuntimeAddServerCheck.
const (
	RuntimeAddServerCheckDisabled RuntimeAddServerCheck = "disabled"
	RuntimeAddServerCheckEnabled  RuntimeAddServerCheck = "enabled"
)

// Defines values for RuntimeAddServerCheckSendProxy.
const (
	RuntimeAddServerCheckSendProxyDisabled RuntimeAddServerCheckSendProxy = "disabled"
	RuntimeAddServerCheckSendProxyEnabled  RuntimeAddServerCheckSendProxy = "enabled"
)

// Defines values for RuntimeAddServerCheckSsl.
const (
	RuntimeAddServerCheckSslDisabled RuntimeAddServerCheckSsl = "disabled"
	RuntimeAddServerCheckSslEnabled  RuntimeAddServerCheckSsl = "enabled"
)

// Defines values for RuntimeAddServerCheckViaSocks4.
const (
	RuntimeAddServerCheckViaSocks4Disabled RuntimeAddServerCheckViaSocks4 = "disabled"
	RuntimeAddServerCheckViaSocks4Enabled  RuntimeAddServerCheckViaSocks4 = "enabled"
)

// Defines values for RuntimeAddServerForceSslv3.
const (
	RuntimeAddServerForceSslv3Disabled RuntimeAddServerForceSslv3 = "disabled"
	RuntimeAddServerForceSslv3Enabled  RuntimeAddServerForceSslv3 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv10.
const (
	RuntimeAddServerForceTlsv10Disabled RuntimeAddServerForceTlsv10 = "disabled"
	RuntimeAddServerForceTlsv10Enabled  RuntimeAddServerForceTlsv10 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv11.
const (
	RuntimeAddServerForceTlsv11Disabled RuntimeAddServerForceTlsv11 = "disabled"
	RuntimeAddServerForceTlsv11Enabled  RuntimeAddServerForceTlsv11 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv12.
const (
	RuntimeAddServerForceTlsv12Disabled RuntimeAddServerForceTlsv12 = "disabled"
	RuntimeAddServerForceTlsv12Enabled  RuntimeAddServerForceTlsv12 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv13.
const (
	RuntimeAddServerForceTlsv13Disabled RuntimeAddServerForceTlsv13 = "disabled"
	RuntimeAddServerForceTlsv13Enabled  RuntimeAddServerForceTlsv13 = "enabled"
)

// Defines values for RuntimeAddServerMaintenance.
const (
	RuntimeAddServerMaintenanceDisabled RuntimeAddServerMaintenance = "disabled"
	RuntimeAddServerMaintenanceEnabled  RuntimeAddServerMaintenance = "enabled"
)

// Defines values for RuntimeAddServerNoSslv3.
const (
	RuntimeAddServerNoSslv3Disabled RuntimeAddServerNoSslv3 = "disabled"
	RuntimeAddServerNoSslv3Enabled  RuntimeAddServerNoSslv3 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv10.
const (
	RuntimeAddServerNoTlsv10Disabled RuntimeAddServerNoTlsv10 = "disabled"
	RuntimeAddServerNoTlsv10Enabled  RuntimeAddServerNoTlsv10 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv11.
const (
	RuntimeAddServerNoTlsv11Disabled RuntimeAddServerNoTlsv11 = "disabled"
	RuntimeAddServerNoTlsv11Enabled  RuntimeAddServerNoTlsv11 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv12.
const (
	RuntimeAddServerNoTlsv12Disabled RuntimeAddServerNoTlsv12 = "disabled"
	RuntimeAddServerNoTlsv12Enabled  RuntimeAddServerNoTlsv12 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv13.
const (
	RuntimeAddServerNoTlsv13Disabled RuntimeAddServerNoTlsv13 = "disabled"
	RuntimeAddServerNoTlsv13Enabled  RuntimeAddServerNoTlsv13 = "enabled"
)

// Defines values for RuntimeAddServerObserve.
const (
	RuntimeAddServerObserveLayer4 RuntimeAddServerObserve = "layer4"
	RuntimeAddServerObserveLayer7 RuntimeAddServerObserve = "layer7"
)

// Defines values for RuntimeAddServerOnError.
const (
	RuntimeAddServerOnErrorFailCheck   RuntimeAddServerOnError = "fail-check"
	RuntimeAddServerOnErrorFastinter   RuntimeAddServerOnError = "fastinter"
	RuntimeAddServerOnErrorMarkDown    RuntimeAddServerOnError = "mark-down"
	RuntimeAddServerOnErrorSuddenDeath RuntimeAddServerOnError = "sudden-death"
)

// Defines values for RuntimeAddServerOnMarkedDown.
const (
	RuntimeAddServerOnMarkedDownShutdownSessions RuntimeAddServerOnMarkedDown = "shutdown-sessions"
)

// Defines values for RuntimeAddServerOnMarkedUp.
const (
	RuntimeAddServerOnMarkedUpShutdownBackupSessions RuntimeAddServerOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for RuntimeAddServerProxyV2Options.
const (
	RuntimeAddServerProxyV2OptionsAuthority RuntimeAddServerProxyV2Options = "authority"
	RuntimeAddServerProxyV2OptionsCertCn    RuntimeAddServerProxyV2Options = "cert-cn"
	RuntimeAddServerProxyV2OptionsCertKey   RuntimeAddServerProxyV2Options = "cert-key"
	RuntimeAddServerProxyV2OptionsCertSig   RuntimeAddServerProxyV2Options = "cert-sig"
	RuntimeAddServerProxyV2OptionsCrc32c    RuntimeAddServerProxyV2Options = "crc32c"
	RuntimeAddServerProxyV2OptionsSsl       RuntimeAddServerProxyV2Options = "ssl"
	RuntimeAddServerProxyV2OptionsSslCipher RuntimeAddServerProxyV2Options = "ssl-cipher"
	RuntimeAddServerProxyV2OptionsUniqueId  RuntimeAddServerProxyV2Options = "unique-id"
)

// Defines values for RuntimeAddServerSendProxy.
const (
	RuntimeAddServerSendProxyDisabled RuntimeAddServerSendProxy = "disabled"
	RuntimeAddServerSendProxyEnabled  RuntimeAddServerSendProxy = "enabled"
)

// Defines values for RuntimeAddServerSendProxyV2.
const (
	RuntimeAddServerSendProxyV2Disabled RuntimeAddServerSendProxyV2 = "disabled"
	RuntimeAddServerSendProxyV2Enabled  RuntimeAddServerSendProxyV2 = "enabled"
)

// Defines values for RuntimeAddServerSendProxyV2Ssl.
const (
	RuntimeAddServerSendProxyV2SslDisabled RuntimeAddServerSendProxyV2Ssl = "disabled"
	RuntimeAddServerSendProxyV2SslEnabled  RuntimeAddServerSendProxyV2Ssl = "enabled"
)

// Defines values for RuntimeAddServerSendProxyV2SslCn.
const (
	RuntimeAddServerSendProxyV2SslCnDisabled RuntimeAddServerSendProxyV2SslCn = "disabled"
	RuntimeAddServerSendProxyV2SslCnEnabled  RuntimeAddServerSendProxyV2SslCn = "enabled"
)

// Defines values for RuntimeAddServerSsl.
const (
	RuntimeAddServerSslDisabled RuntimeAddServerSsl = "disabled"
	RuntimeAddServerSslEnabled  RuntimeAddServerSsl = "enabled"
)

// Defines values for RuntimeAddServerSslMaxVer.
const (
	RuntimeAddServerSslMaxVerSSLv3  RuntimeAddServerSslMaxVer = "SSLv3"
	RuntimeAddServerSslMaxVerTLSv10 RuntimeAddServerSslMaxVer = "TLSv1.0"
	RuntimeAddServerSslMaxVerTLSv11 RuntimeAddServerSslMaxVer = "TLSv1.1"
	RuntimeAddServerSslMaxVerTLSv12 RuntimeAddServerSslMaxVer = "TLSv1.2"
	RuntimeAddServerSslMaxVerTLSv13 RuntimeAddServerSslMaxVer = "TLSv1.3"
)

// Defines values for RuntimeAddServerSslMinVer.
const (
	RuntimeAddServerSslMinVerSSLv3  RuntimeAddServerSslMinVer = "SSLv3"
	RuntimeAddServerSslMinVerTLSv10 RuntimeAddServerSslMinVer = "TLSv1.0"
	RuntimeAddServerSslMinVerTLSv11 RuntimeAddServerSslMinVer = "TLSv1.1"
	RuntimeAddServerSslMinVerTLSv12 RuntimeAddServerSslMinVer = "TLSv1.2"
	RuntimeAddServerSslMinVerTLSv13 RuntimeAddServerSslMinVer = "TLSv1.3"
)

// Defines values for RuntimeAddServerSslReuse.
const (
	RuntimeAddServerSslReuseDisabled RuntimeAddServerSslReuse = "disabled"
	RuntimeAddServerSslReuseEnabled  RuntimeAddServerSslReuse = "enabled"
)

// Defines values for RuntimeAddServerTfo.
const (
	RuntimeAddServerTfoDisabled RuntimeAddServerTfo = "disabled"
	RuntimeAddServerTfoEnabled  RuntimeAddServerTfo = "enabled"
)

// Defines values for RuntimeAddServerTlsTickets.
const (
	RuntimeAddServerTlsTicketsDisabled RuntimeAddServerTlsTickets = "disabled"
	RuntimeAddServerTlsTicketsEnabled  RuntimeAddServerTlsTickets = "enabled"
)

// Defines values for RuntimeAddServerVerify.
const (
	RuntimeAddServerVerifyNone     RuntimeAddServerVerify = "none"
	RuntimeAddServerVerifyRequired RuntimeAddServerVerify = "required"
)

// Defines values for RuntimeAddServerWs.
const (
	RuntimeAddServerWsAuto RuntimeAddServerWs = "auto"
	RuntimeAddServerWsH1   RuntimeAddServerWs = "h1"
	RuntimeAddServerWsH2   RuntimeAddServerWs = "h2"
)

// Defines values for RuntimeServerAdminState.
const (
	RuntimeServerAdminStateDrain RuntimeServerAdminState = "drain"
	RuntimeServerAdminStateMaint RuntimeServerAdminState = "maint"
	RuntimeServerAdminStateReady RuntimeServerAdminState = "ready"
)

// Defines values for RuntimeServerOperationalState.
const (
	RuntimeServerOperationalStateDown     RuntimeServerOperationalState = "down"
	RuntimeServerOperationalStateStopping RuntimeServerOperationalState = "stopping"
	RuntimeServerOperationalStateUp       RuntimeServerOperationalState = "up"
)

// Defines values for ServerAgentCheck.
const (
	ServerAgentCheckDisabled ServerAgentCheck = "disabled"
	ServerAgentCheckEnabled  ServerAgentCheck = "enabled"
)

// Defines values for ServerBackup.
const (
	ServerBackupDisabled ServerBackup = "disabled"
	ServerBackupEnabled  ServerBackup = "enabled"
)

// Defines values for ServerCheck.
const (
	ServerCheckDisabled ServerCheck = "disabled"
	ServerCheckEnabled  ServerCheck = "enabled"
)

// Defines values for ServerCheckReusePool.
const (
	ServerCheckReusePoolDisabled ServerCheckReusePool = "disabled"
	ServerCheckReusePoolEnabled  ServerCheckReusePool = "enabled"
)

// Defines values for ServerCheckSendProxy.
const (
	ServerCheckSendProxyDisabled ServerCheckSendProxy = "disabled"
	ServerCheckSendProxyEnabled  ServerCheckSendProxy = "enabled"
)

// Defines values for ServerCheckSsl.
const (
	ServerCheckSslDisabled ServerCheckSsl = "disabled"
	ServerCheckSslEnabled  ServerCheckSsl = "enabled"
)

// Defines values for ServerCheckViaSocks4.
const (
	ServerCheckViaSocks4Disabled ServerCheckViaSocks4 = "disabled"
	ServerCheckViaSocks4Enabled  ServerCheckViaSocks4 = "enabled"
)

// Defines values for ServerForceSslv3.
const (
	ServerForceSslv3Disabled ServerForceSslv3 = "disabled"
	ServerForceSslv3Enabled  ServerForceSslv3 = "enabled"
)

// Defines values for ServerForceTlsv10.
const (
	ServerForceTlsv10Disabled ServerForceTlsv10 = "disabled"
	ServerForceTlsv10Enabled  ServerForceTlsv10 = "enabled"
)

// Defines values for ServerForceTlsv11.
const (
	ServerForceTlsv11Disabled ServerForceTlsv11 = "disabled"
	ServerForceTlsv11Enabled  ServerForceTlsv11 = "enabled"
)

// Defines values for ServerForceTlsv12.
const (
	ServerForceTlsv12Disabled ServerForceTlsv12 = "disabled"
	ServerForceTlsv12Enabled  ServerForceTlsv12 = "enabled"
)

// Defines values for ServerForceTlsv13.
const (
	ServerForceTlsv13Disabled ServerForceTlsv13 = "disabled"
	ServerForceTlsv13Enabled  ServerForceTlsv13 = "enabled"
)

// Defines values for ServerInitState.
const (
	ServerInitStateDown      ServerInitState = "down"
	ServerInitStateFullyDown ServerInitState = "fully-down"
	ServerInitStateFullyUp   ServerInitState = "fully-up"
	ServerInitStateUp        ServerInitState = "up"
)

// Defines values for ServerLogProto.
const (
	ServerLogProtoLegacy     ServerLogProto = "legacy"
	ServerLogProtoOctetCount ServerLogProto = "octet-count"
)

// Defines values for ServerMaintenance.
const (
	ServerMaintenanceDisabled ServerMaintenance = "disabled"
	ServerMaintenanceEnabled  ServerMaintenance = "enabled"
)

// Defines values for ServerNoSslv3.
const (
	ServerNoSslv3Disabled ServerNoSslv3 = "disabled"
	ServerNoSslv3Enabled  ServerNoSslv3 = "enabled"
)

// Defines values for ServerNoTlsv10.
const (
	ServerNoTlsv10Disabled ServerNoTlsv10 = "disabled"
	ServerNoTlsv10Enabled  ServerNoTlsv10 = "enabled"
)

// Defines values for ServerNoTlsv11.
const (
	ServerNoTlsv11Disabled ServerNoTlsv11 = "disabled"
	ServerNoTlsv11Enabled  ServerNoTlsv11 = "enabled"
)

// Defines values for ServerNoTlsv12.
const (
	ServerNoTlsv12Disabled ServerNoTlsv12 = "disabled"
	ServerNoTlsv12Enabled  ServerNoTlsv12 = "enabled"
)

// Defines values for ServerNoTlsv13.
const (
	ServerNoTlsv13Disabled ServerNoTlsv13 = "disabled"
	ServerNoTlsv13Enabled  ServerNoTlsv13 = "enabled"
)

// Defines values for ServerNoVerifyhost.
const (
	ServerNoVerifyhostDisabled ServerNoVerifyhost = "disabled"
	ServerNoVerifyhostEnabled  ServerNoVerifyhost = "enabled"
)

// Defines values for ServerObserve.
const (
	ServerObserveLayer4 ServerObserve = "layer4"
	ServerObserveLayer7 ServerObserve = "layer7"
)

// Defines values for ServerOnError.
const (
	ServerOnErrorFailCheck   ServerOnError = "fail-check"
	ServerOnErrorFastinter   ServerOnError = "fastinter"
	ServerOnErrorMarkDown    ServerOnError = "mark-down"
	ServerOnErrorSuddenDeath ServerOnError = "sudden-death"
)

// Defines values for ServerOnMarkedDown.
const (
	ServerOnMarkedDownShutdownSessions ServerOnMarkedDown = "shutdown-sessions"
)

// Defines values for ServerOnMarkedUp.
const (
	ServerOnMarkedUpShutdownBackupSessions ServerOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for ServerProxyV2Options.
const (
	ServerProxyV2OptionsAuthority ServerProxyV2Options = "authority"
	ServerProxyV2OptionsCertCn    ServerProxyV2Options = "cert-cn"
	ServerProxyV2OptionsCertKey   ServerProxyV2Options = "cert-key"
	ServerProxyV2OptionsCertSig   ServerProxyV2Options = "cert-sig"
	ServerProxyV2OptionsCrc32c    ServerProxyV2Options = "crc32c"
	ServerProxyV2OptionsSsl       ServerProxyV2Options = "ssl"
	ServerProxyV2OptionsSslCipher ServerProxyV2Options = "ssl-cipher"
	ServerProxyV2OptionsUniqueId  ServerProxyV2Options = "unique-id"
)

// Defines values for ServerResolvePrefer.
const (
	ServerResolvePreferIpv4 ServerResolvePrefer = "ipv4"
	ServerResolvePreferIpv6 ServerResolvePrefer = "ipv6"
)

// Defines values for ServerSendProxy.
const (
	ServerSendProxyDisabled ServerSendProxy = "disabled"
	ServerSendProxyEnabled  ServerSendProxy = "enabled"
)

// Defines values for ServerSendProxyV2.
const (
	ServerSendProxyV2Disabled ServerSendProxyV2 = "disabled"
	ServerSendProxyV2Enabled  ServerSendProxyV2 = "enabled"
)

// Defines values for ServerSendProxyV2Ssl.
const (
	ServerSendProxyV2SslDisabled ServerSendProxyV2Ssl = "disabled"
	ServerSendProxyV2SslEnabled  ServerSendProxyV2Ssl = "enabled"
)

// Defines values for ServerSendProxyV2SslCn.
const (
	ServerSendProxyV2SslCnDisabled ServerSendProxyV2SslCn = "disabled"
	ServerSendProxyV2SslCnEnabled  ServerSendProxyV2SslCn = "enabled"
)

// Defines values for ServerSsl.
const (
	ServerSslDisabled ServerSsl = "disabled"
	ServerSslEnabled  ServerSsl = "enabled"
)

// Defines values for ServerSslMaxVer.
const (
	ServerSslMaxVerSSLv3  ServerSslMaxVer = "SSLv3"
	ServerSslMaxVerTLSv10 ServerSslMaxVer = "TLSv1.0"
	ServerSslMaxVerTLSv11 ServerSslMaxVer = "TLSv1.1"
	ServerSslMaxVerTLSv12 ServerSslMaxVer = "TLSv1.2"
	ServerSslMaxVerTLSv13 ServerSslMaxVer = "TLSv1.3"
)

// Defines values for ServerSslMinVer.
const (
	ServerSslMinVerSSLv3  ServerSslMinVer = "SSLv3"
	ServerSslMinVerTLSv10 ServerSslMinVer = "TLSv1.0"
	ServerSslMinVerTLSv11 ServerSslMinVer = "TLSv1.1"
	ServerSslMinVerTLSv12 ServerSslMinVer = "TLSv1.2"
	ServerSslMinVerTLSv13 ServerSslMinVer = "TLSv1.3"
)

// Defines values for ServerSslReuse.
const (
	ServerSslReuseDisabled ServerSslReuse = "disabled"
	ServerSslReuseEnabled  ServerSslReuse = "enabled"
)

// Defines values for ServerSslv3.
const (
	ServerSslv3Disabled ServerSslv3 = "disabled"
	ServerSslv3Enabled  ServerSslv3 = "enabled"
)

// Defines values for ServerStick.
const (
	ServerStickDisabled ServerStick = "disabled"
	ServerStickEnabled  ServerStick = "enabled"
)

// Defines values for ServerTfo.
const (
	ServerTfoDisabled ServerTfo = "disabled"
	ServerTfoEnabled  ServerTfo = "enabled"
)

// Defines values for ServerTlsTickets.
const (
	ServerTlsTicketsDisabled ServerTlsTickets = "disabled"
	ServerTlsTicketsEnabled  ServerTlsTickets = "enabled"
)

// Defines values for ServerTlsv10.
const (
	ServerTlsv10Disabled ServerTlsv10 = "disabled"
	ServerTlsv10Enabled  ServerTlsv10 = "enabled"
)

// Defines values for ServerTlsv11.
const (
	ServerTlsv11Disabled ServerTlsv11 = "disabled"
	ServerTlsv11Enabled  ServerTlsv11 = "enabled"
)

// Defines values for ServerTlsv12.
const (
	ServerTlsv12Disabled ServerTlsv12 = "disabled"
	ServerTlsv12Enabled  ServerTlsv12 = "enabled"
)

// Defines values for ServerTlsv13.
const (
	ServerTlsv13Disabled ServerTlsv13 = "disabled"
	ServerTlsv13Enabled  ServerTlsv13 = "enabled"
)

// Defines values for ServerVerify.
const (
	ServerVerifyNone     ServerVerify = "none"
	ServerVerifyRequired ServerVerify = "required"
)

// Defines values for ServerWs.
const (
	ServerWsAuto ServerWs = "auto"
	ServerWsH1   ServerWs = "h1"
	ServerWsH2   ServerWs = "h2"
)

// Defines values for ServerParamsAgentCheck.
const (
	ServerParamsAgentCheckDisabled ServerParamsAgentCheck = "disabled"
	ServerParamsAgentCheckEnabled  ServerParamsAgentCheck = "enabled"
)

// Defines values for ServerParamsBackup.
const (
	ServerParamsBackupDisabled ServerParamsBackup = "disabled"
	ServerParamsBackupEnabled  ServerParamsBackup = "enabled"
)

// Defines values for ServerParamsCheck.
const (
	ServerParamsCheckDisabled ServerParamsCheck = "disabled"
	ServerParamsCheckEnabled  ServerParamsCheck = "enabled"
)

// Defines values for ServerParamsCheckReusePool.
const (
	ServerParamsCheckReusePoolDisabled ServerParamsCheckReusePool = "disabled"
	ServerParamsCheckReusePoolEnabled  ServerParamsCheckReusePool = "enabled"
)

// Defines values for ServerParamsCheckSendProxy.
const (
	ServerParamsCheckSendProxyDisabled ServerParamsCheckSendProxy = "disabled"
	ServerParamsCheckSendProxyEnabled  ServerParamsCheckSendProxy = "enabled"
)

// Defines values for ServerParamsCheckSsl.
const (
	ServerParamsCheckSslDisabled ServerParamsCheckSsl = "disabled"
	ServerParamsCheckSslEnabled  ServerParamsCheckSsl = "enabled"
)

// Defines values for ServerParamsCheckViaSocks4.
const (
	ServerParamsCheckViaSocks4Disabled ServerParamsCheckViaSocks4 = "disabled"
	ServerParamsCheckViaSocks4Enabled  ServerParamsCheckViaSocks4 = "enabled"
)

// Defines values for ServerParamsForceSslv3.
const (
	ServerParamsForceSslv3Disabled ServerParamsForceSslv3 = "disabled"
	ServerParamsForceSslv3Enabled  ServerParamsForceSslv3 = "enabled"
)

// Defines values for ServerParamsForceTlsv10.
const (
	ServerParamsForceTlsv10Disabled ServerParamsForceTlsv10 = "disabled"
	ServerParamsForceTlsv10Enabled  ServerParamsForceTlsv10 = "enabled"
)

// Defines values for ServerParamsForceTlsv11.
const (
	ServerParamsForceTlsv11Disabled ServerParamsForceTlsv11 = "disabled"
	ServerParamsForceTlsv11Enabled  ServerParamsForceTlsv11 = "enabled"
)

// Defines values for ServerParamsForceTlsv12.
const (
	ServerParamsForceTlsv12Disabled ServerParamsForceTlsv12 = "disabled"
	ServerParamsForceTlsv12Enabled  ServerParamsForceTlsv12 = "enabled"
)

// Defines values for ServerParamsForceTlsv13.
const (
	ServerParamsForceTlsv13Disabled ServerParamsForceTlsv13 = "disabled"
	ServerParamsForceTlsv13Enabled  ServerParamsForceTlsv13 = "enabled"
)

// Defines values for ServerParamsInitState.
const (
	ServerParamsInitStateDown      ServerParamsInitState = "down"
	ServerParamsInitStateFullyDown ServerParamsInitState = "fully-down"
	ServerParamsInitStateFullyUp   ServerParamsInitState = "fully-up"
	ServerParamsInitStateUp        ServerParamsInitState = "up"
)

// Defines values for ServerParamsLogProto.
const (
	ServerParamsLogProtoLegacy     ServerParamsLogProto = "legacy"
	ServerParamsLogProtoOctetCount ServerParamsLogProto = "octet-count"
)

// Defines values for ServerParamsMaintenance.
const (
	ServerParamsMaintenanceDisabled ServerParamsMaintenance = "disabled"
	ServerParamsMaintenanceEnabled  ServerParamsMaintenance = "enabled"
)

// Defines values for ServerParamsNoSslv3.
const (
	ServerParamsNoSslv3Disabled ServerParamsNoSslv3 = "disabled"
	ServerParamsNoSslv3Enabled  ServerParamsNoSslv3 = "enabled"
)

// Defines values for ServerParamsNoTlsv10.
const (
	ServerParamsNoTlsv10Disabled ServerParamsNoTlsv10 = "disabled"
	ServerParamsNoTlsv10Enabled  ServerParamsNoTlsv10 = "enabled"
)

// Defines values for ServerParamsNoTlsv11.
const (
	ServerParamsNoTlsv11Disabled ServerParamsNoTlsv11 = "disabled"
	ServerParamsNoTlsv11Enabled  ServerParamsNoTlsv11 = "enabled"
)

// Defines values for ServerParamsNoTlsv12.
const (
	ServerParamsNoTlsv12Disabled ServerParamsNoTlsv12 = "disabled"
	ServerParamsNoTlsv12Enabled  ServerParamsNoTlsv12 = "enabled"
)

// Defines values for ServerParamsNoTlsv13.
const (
	ServerParamsNoTlsv13Disabled ServerParamsNoTlsv13 = "disabled"
	ServerParamsNoTlsv13Enabled  ServerParamsNoTlsv13 = "enabled"
)

// Defines values for ServerParamsNoVerifyhost.
const (
	ServerParamsNoVerifyhostDisabled ServerParamsNoVerifyhost = "disabled"
	ServerParamsNoVerifyhostEnabled  ServerParamsNoVerifyhost = "enabled"
)

// Defines values for ServerParamsObserve.
const (
	ServerParamsObserveLayer4 ServerParamsObserve = "layer4"
	ServerParamsObserveLayer7 ServerParamsObserve = "layer7"
)

// Defines values for ServerParamsOnError.
const (
	ServerParamsOnErrorFailCheck   ServerParamsOnError = "fail-check"
	ServerParamsOnErrorFastinter   ServerParamsOnError = "fastinter"
	ServerParamsOnErrorMarkDown    ServerParamsOnError = "mark-down"
	ServerParamsOnErrorSuddenDeath ServerParamsOnError = "sudden-death"
)

// Defines values for ServerParamsOnMarkedDown.
const (
	ServerParamsOnMarkedDownShutdownSessions ServerParamsOnMarkedDown = "shutdown-sessions"
)

// Defines values for ServerParamsOnMarkedUp.
const (
	ServerParamsOnMarkedUpShutdownBackupSessions ServerParamsOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for ServerParamsProxyV2Options.
const (
	ServerParamsProxyV2OptionsAuthority ServerParamsProxyV2Options = "authority"
	ServerParamsProxyV2OptionsCertCn    ServerParamsProxyV2Options = "cert-cn"
	ServerParamsProxyV2OptionsCertKey   ServerParamsProxyV2Options = "cert-key"
	ServerParamsProxyV2OptionsCertSig   ServerParamsProxyV2Options = "cert-sig"
	ServerParamsProxyV2OptionsCrc32c    ServerParamsProxyV2Options = "crc32c"
	ServerParamsProxyV2OptionsSsl       ServerParamsProxyV2Options = "ssl"
	ServerParamsProxyV2OptionsSslCipher ServerParamsProxyV2Options = "ssl-cipher"
	ServerParamsProxyV2OptionsUniqueId  ServerParamsProxyV2Options = "unique-id"
)

// Defines values for ServerParamsResolvePrefer.
const (
	ServerParamsResolvePreferIpv4 ServerParamsResolvePrefer = "ipv4"
	ServerParamsResolvePreferIpv6 ServerParamsResolvePrefer = "ipv6"
)

// Defines values for ServerParamsSendProxy.
const (
	ServerParamsSendProxyDisabled ServerParamsSendProxy = "disabled"
	ServerParamsSendProxyEnabled  ServerParamsSendProxy = "enabled"
)

// Defines values for ServerParamsSendProxyV2.
const (
	ServerParamsSendProxyV2Disabled ServerParamsSendProxyV2 = "disabled"
	ServerParamsSendProxyV2Enabled  ServerParamsSendProxyV2 = "enabled"
)

// Defines values for ServerParamsSendProxyV2Ssl.
const (
	ServerParamsSendProxyV2SslDisabled ServerParamsSendProxyV2Ssl = "disabled"
	ServerParamsSendProxyV2SslEnabled  ServerParamsSendProxyV2Ssl = "enabled"
)

// Defines values for ServerParamsSendProxyV2SslCn.
const (
	ServerParamsSendProxyV2SslCnDisabled ServerParamsSendProxyV2SslCn = "disabled"
	ServerParamsSendProxyV2SslCnEnabled  ServerParamsSendProxyV2SslCn = "enabled"
)

// Defines values for ServerParamsSsl.
const (
	ServerParamsSslDisabled ServerParamsSsl = "disabled"
	ServerParamsSslEnabled  ServerParamsSsl = "enabled"
)

// Defines values for ServerParamsSslMaxVer.
const (
	ServerParamsSslMaxVerSSLv3  ServerParamsSslMaxVer = "SSLv3"
	ServerParamsSslMaxVerTLSv10 ServerParamsSslMaxVer = "TLSv1.0"
	ServerParamsSslMaxVerTLSv11 ServerParamsSslMaxVer = "TLSv1.1"
	ServerParamsSslMaxVerTLSv12 ServerParamsSslMaxVer = "TLSv1.2"
	ServerParamsSslMaxVerTLSv13 ServerParamsSslMaxVer = "TLSv1.3"
)

// Defines values for ServerParamsSslMinVer.
const (
	ServerParamsSslMinVerSSLv3  ServerParamsSslMinVer = "SSLv3"
	ServerParamsSslMinVerTLSv10 ServerParamsSslMinVer = "TLSv1.0"
	ServerParamsSslMinVerTLSv11 ServerParamsSslMinVer = "TLSv1.1"
	ServerParamsSslMinVerTLSv12 ServerParamsSslMinVer = "TLSv1.2"
	ServerParamsSslMinVerTLSv13 ServerParamsSslMinVer = "TLSv1.3"
)

// Defines values for ServerParamsSslReuse.
const (
	ServerParamsSslReuseDisabled ServerParamsSslReuse = "disabled"
	ServerParamsSslReuseEnabled  ServerParamsSslReuse = "enabled"
)

// Defines values for ServerParamsSslv3.
const (
	ServerParamsSslv3Disabled ServerParamsSslv3 = "disabled"
	ServerParamsSslv3Enabled  ServerParamsSslv3 = "enabled"
)

// Defines values for ServerParamsStick.
const (
	ServerParamsStickDisabled ServerParamsStick = "disabled"
	ServerParamsStickEnabled  ServerParamsStick = "enabled"
)

// Defines values for ServerParamsTfo.
const (
	ServerParamsTfoDisabled ServerParamsTfo = "disabled"
	ServerParamsTfoEnabled  ServerParamsTfo = "enabled"
)

// Defines values for ServerParamsTlsTickets.
const (
	ServerParamsTlsTicketsDisabled ServerParamsTlsTickets = "disabled"
	ServerParamsTlsTicketsEnabled  ServerParamsTlsTickets = "enabled"
)

// Defines values for ServerParamsTlsv10.
const (
	ServerParamsTlsv10Disabled ServerParamsTlsv10 = "disabled"
	ServerParamsTlsv10Enabled  ServerParamsTlsv10 = "enabled"
)

// Defines values for ServerParamsTlsv11.
const (
	ServerParamsTlsv11Disabled ServerParamsTlsv11 = "disabled"
	ServerParamsTlsv11Enabled  ServerParamsTlsv11 = "enabled"
)

// Defines values for ServerParamsTlsv12.
const (
	ServerParamsTlsv12Disabled ServerParamsTlsv12 = "disabled"
	ServerParamsTlsv12Enabled  ServerParamsTlsv12 = "enabled"
)

// Defines values for ServerParamsTlsv13.
const (
	ServerParamsTlsv13Disabled ServerParamsTlsv13 = "disabled"
	ServerParamsTlsv13Enabled  ServerParamsTlsv13 = "enabled"
)

// Defines values for ServerParamsVerify.
const (
	ServerParamsVerifyNone     ServerParamsVerify = "none"
	ServerParamsVerifyRequired ServerParamsVerify = "required"
)

// Defines values for ServerParamsWs.
const (
	ServerParamsWsAuto ServerParamsWs = "auto"
	ServerParamsWsH1   ServerParamsWs = "h1"
	ServerParamsWsH2   ServerParamsWs = "h2"
)

// Defines values for ServerSwitchingRuleCond.
const (
	ServerSwitchingRuleCondIf     ServerSwitchingRuleCond = "if"
	ServerSwitchingRuleCondUnless ServerSwitchingRuleCond = "unless"
)

// Defines values for ServerTemplateAgentCheck.
const (
	ServerTemplateAgentCheckDisabled ServerTemplateAgentCheck = "disabled"
	ServerTemplateAgentCheckEnabled  ServerTemplateAgentCheck = "enabled"
)

// Defines values for ServerTemplateBackup.
const (
	ServerTemplateBackupDisabled ServerTemplateBackup = "disabled"
	ServerTemplateBackupEnabled  ServerTemplateBackup = "enabled"
)

// Defines values for ServerTemplateCheck.
const (
	ServerTemplateCheckDisabled ServerTemplateCheck = "disabled"
	ServerTemplateCheckEnabled  ServerTemplateCheck = "enabled"
)

// Defines values for ServerTemplateCheckReusePool.
const (
	ServerTemplateCheckReusePoolDisabled ServerTemplateCheckReusePool = "disabled"
	ServerTemplateCheckReusePoolEnabled  ServerTemplateCheckReusePool = "enabled"
)

// Defines values for ServerTemplateCheckSendProxy.
const (
	ServerTemplateCheckSendProxyDisabled ServerTemplateCheckSendProxy = "disabled"
	ServerTemplateCheckSendProxyEnabled  ServerTemplateCheckSendProxy = "enabled"
)

// Defines values for ServerTemplateCheckSsl.
const (
	ServerTemplateCheckSslDisabled ServerTemplateCheckSsl = "disabled"
	ServerTemplateCheckSslEnabled  ServerTemplateCheckSsl = "enabled"
)

// Defines values for ServerTemplateCheckViaSocks4.
const (
	ServerTemplateCheckViaSocks4Disabled ServerTemplateCheckViaSocks4 = "disabled"
	ServerTemplateCheckViaSocks4Enabled  ServerTemplateCheckViaSocks4 = "enabled"
)

// Defines values for ServerTemplateForceSslv3.
const (
	ServerTemplateForceSslv3Disabled ServerTemplateForceSslv3 = "disabled"
	ServerTemplateForceSslv3Enabled  ServerTemplateForceSslv3 = "enabled"
)

// Defines values for ServerTemplateForceTlsv10.
const (
	ServerTemplateForceTlsv10Disabled ServerTemplateForceTlsv10 = "disabled"
	ServerTemplateForceTlsv10Enabled  ServerTemplateForceTlsv10 = "enabled"
)

// Defines values for ServerTemplateForceTlsv11.
const (
	ServerTemplateForceTlsv11Disabled ServerTemplateForceTlsv11 = "disabled"
	ServerTemplateForceTlsv11Enabled  ServerTemplateForceTlsv11 = "enabled"
)

// Defines values for ServerTemplateForceTlsv12.
const (
	ServerTemplateForceTlsv12Disabled ServerTemplateForceTlsv12 = "disabled"
	ServerTemplateForceTlsv12Enabled  ServerTemplateForceTlsv12 = "enabled"
)

// Defines values for ServerTemplateForceTlsv13.
const (
	ServerTemplateForceTlsv13Disabled ServerTemplateForceTlsv13 = "disabled"
	ServerTemplateForceTlsv13Enabled  ServerTemplateForceTlsv13 = "enabled"
)

// Defines values for ServerTemplateInitState.
const (
	ServerTemplateInitStateDown      ServerTemplateInitState = "down"
	ServerTemplateInitStateFullyDown ServerTemplateInitState = "fully-down"
	ServerTemplateInitStateFullyUp   ServerTemplateInitState = "fully-up"
	ServerTemplateInitStateUp        ServerTemplateInitState = "up"
)

// Defines values for ServerTemplateLogProto.
const (
	ServerTemplateLogProtoLegacy     ServerTemplateLogProto = "legacy"
	ServerTemplateLogProtoOctetCount ServerTemplateLogProto = "octet-count"
)

// Defines values for ServerTemplateMaintenance.
const (
	ServerTemplateMaintenanceDisabled ServerTemplateMaintenance = "disabled"
	ServerTemplateMaintenanceEnabled  ServerTemplateMaintenance = "enabled"
)

// Defines values for ServerTemplateNoSslv3.
const (
	ServerTemplateNoSslv3Disabled ServerTemplateNoSslv3 = "disabled"
	ServerTemplateNoSslv3Enabled  ServerTemplateNoSslv3 = "enabled"
)

// Defines values for ServerTemplateNoTlsv10.
const (
	ServerTemplateNoTlsv10Disabled ServerTemplateNoTlsv10 = "disabled"
	ServerTemplateNoTlsv10Enabled  ServerTemplateNoTlsv10 = "enabled"
)

// Defines values for ServerTemplateNoTlsv11.
const (
	ServerTemplateNoTlsv11Disabled ServerTemplateNoTlsv11 = "disabled"
	ServerTemplateNoTlsv11Enabled  ServerTemplateNoTlsv11 = "enabled"
)

// Defines values for ServerTemplateNoTlsv12.
const (
	ServerTemplateNoTlsv12Disabled ServerTemplateNoTlsv12 = "disabled"
	ServerTemplateNoTlsv12Enabled  ServerTemplateNoTlsv12 = "enabled"
)

// Defines values for ServerTemplateNoTlsv13.
const (
	ServerTemplateNoTlsv13Disabled ServerTemplateNoTlsv13 = "disabled"
	ServerTemplateNoTlsv13Enabled  ServerTemplateNoTlsv13 = "enabled"
)

// Defines values for ServerTemplateNoVerifyhost.
const (
	ServerTemplateNoVerifyhostDisabled ServerTemplateNoVerifyhost = "disabled"
	ServerTemplateNoVerifyhostEnabled  ServerTemplateNoVerifyhost = "enabled"
)

// Defines values for ServerTemplateObserve.
const (
	ServerTemplateObserveLayer4 ServerTemplateObserve = "layer4"
	ServerTemplateObserveLayer7 ServerTemplateObserve = "layer7"
)

// Defines values for ServerTemplateOnError.
const (
	ServerTemplateOnErrorFailCheck   ServerTemplateOnError = "fail-check"
	ServerTemplateOnErrorFastinter   ServerTemplateOnError = "fastinter"
	ServerTemplateOnErrorMarkDown    ServerTemplateOnError = "mark-down"
	ServerTemplateOnErrorSuddenDeath ServerTemplateOnError = "sudden-death"
)

// Defines values for ServerTemplateOnMarkedDown.
const (
	ServerTemplateOnMarkedDownShutdownSessions ServerTemplateOnMarkedDown = "shutdown-sessions"
)

// Defines values for ServerTemplateOnMarkedUp.
const (
	ServerTemplateOnMarkedUpShutdownBackupSessions ServerTemplateOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for ServerTemplateProxyV2Options.
const (
	ServerTemplateProxyV2OptionsAuthority ServerTemplateProxyV2Options = "authority"
	ServerTemplateProxyV2OptionsCertCn    ServerTemplateProxyV2Options = "cert-cn"
	ServerTemplateProxyV2OptionsCertKey   ServerTemplateProxyV2Options = "cert-key"
	ServerTemplateProxyV2OptionsCertSig   ServerTemplateProxyV2Options = "cert-sig"
	ServerTemplateProxyV2OptionsCrc32c    ServerTemplateProxyV2Options = "crc32c"
	ServerTemplateProxyV2OptionsSsl       ServerTemplateProxyV2Options = "ssl"
	ServerTemplateProxyV2OptionsSslCipher ServerTemplateProxyV2Options = "ssl-cipher"
	ServerTemplateProxyV2OptionsUniqueId  ServerTemplateProxyV2Options = "unique-id"
)

// Defines values for ServerTemplateResolvePrefer.
const (
	ServerTemplateResolvePreferIpv4 ServerTemplateResolvePrefer = "ipv4"
	ServerTemplateResolvePreferIpv6 ServerTemplateResolvePrefer = "ipv6"
)

// Defines values for ServerTemplateSendProxy.
const (
	ServerTemplateSendProxyDisabled ServerTemplateSendProxy = "disabled"
	ServerTemplateSendProxyEnabled  ServerTemplateSendProxy = "enabled"
)

// Defines values for ServerTemplateSendProxyV2.
const (
	ServerTemplateSendProxyV2Disabled ServerTemplateSendProxyV2 = "disabled"
	ServerTemplateSendProxyV2Enabled  ServerTemplateSendProxyV2 = "enabled"
)

// Defines values for ServerTemplateSendProxyV2Ssl.
const (
	ServerTemplateSendProxyV2SslDisabled ServerTemplateSendProxyV2Ssl = "disabled"
	ServerTemplateSendProxyV2SslEnabled  ServerTemplateSendProxyV2Ssl = "enabled"
)

// Defines values for ServerTemplateSendProxyV2SslCn.
const (
	ServerTemplateSendProxyV2SslCnDisabled ServerTemplateSendProxyV2SslCn = "disabled"
	ServerTemplateSendProxyV2SslCnEnabled  ServerTemplateSendProxyV2SslCn = "enabled"
)

// Defines values for ServerTemplateSsl.
const (
	ServerTemplateSslDisabled ServerTemplateSsl = "disabled"
	ServerTemplateSslEnabled  ServerTemplateSsl = "enabled"
)

// Defines values for ServerTemplateSslMaxVer.
const (
	ServerTemplateSslMaxVerSSLv3  ServerTemplateSslMaxVer = "SSLv3"
	ServerTemplateSslMaxVerTLSv10 ServerTemplateSslMaxVer = "TLSv1.0"
	ServerTemplateSslMaxVerTLSv11 ServerTemplateSslMaxVer = "TLSv1.1"
	ServerTemplateSslMaxVerTLSv12 ServerTemplateSslMaxVer = "TLSv1.2"
	ServerTemplateSslMaxVerTLSv13 ServerTemplateSslMaxVer = "TLSv1.3"
)

// Defines values for ServerTemplateSslMinVer.
const (
	ServerTemplateSslMinVerSSLv3  ServerTemplateSslMinVer = "SSLv3"
	ServerTemplateSslMinVerTLSv10 ServerTemplateSslMinVer = "TLSv1.0"
	ServerTemplateSslMinVerTLSv11 ServerTemplateSslMinVer = "TLSv1.1"
	ServerTemplateSslMinVerTLSv12 ServerTemplateSslMinVer = "TLSv1.2"
	ServerTemplateSslMinVerTLSv13 ServerTemplateSslMinVer = "TLSv1.3"
)

// Defines values for ServerTemplateSslReuse.
const (
	ServerTemplateSslReuseDisabled ServerTemplateSslReuse = "disabled"
	ServerTemplateSslReuseEnabled  ServerTemplateSslReuse = "enabled"
)

// Defines values for ServerTemplateSslv3.
const (
	ServerTemplateSslv3Disabled ServerTemplateSslv3 = "disabled"
	ServerTemplateSslv3Enabled  ServerTemplateSslv3 = "enabled"
)

// Defines values for ServerTemplateStick.
const (
	ServerTemplateStickDisabled ServerTemplateStick = "disabled"
	ServerTemplateStickEnabled  ServerTemplateStick = "enabled"
)

// Defines values for ServerTemplateTfo.
const (
	ServerTemplateTfoDisabled ServerTemplateTfo = "disabled"
	ServerTemplateTfoEnabled  ServerTemplateTfo = "enabled"
)

// Defines values for ServerTemplateTlsTickets.
const (
	ServerTemplateTlsTicketsDisabled ServerTemplateTlsTickets = "disabled"
	ServerTemplateTlsTicketsEnabled  ServerTemplateTlsTickets = "enabled"
)

// Defines values for ServerTemplateTlsv10.
const (
	ServerTemplateTlsv10Disabled ServerTemplateTlsv10 = "disabled"
	ServerTemplateTlsv10Enabled  ServerTemplateTlsv10 = "enabled"
)

// Defines values for ServerTemplateTlsv11.
const (
	ServerTemplateTlsv11Disabled ServerTemplateTlsv11 = "disabled"
	ServerTemplateTlsv11Enabled  ServerTemplateTlsv11 = "enabled"
)

// Defines values for ServerTemplateTlsv12.
const (
	ServerTemplateTlsv12Disabled ServerTemplateTlsv12 = "disabled"
	ServerTemplateTlsv12Enabled  ServerTemplateTlsv12 = "enabled"
)

// Defines values for ServerTemplateTlsv13.
const (
	ServerTemplateTlsv13Disabled ServerTemplateTlsv13 = "disabled"
	ServerTemplateTlsv13Enabled  ServerTemplateTlsv13 = "enabled"
)

// Defines values for ServerTemplateVerify.
const (
	ServerTemplateVerifyNone     ServerTemplateVerify = "none"
	ServerTemplateVerifyRequired ServerTemplateVerify = "required"
)

// Defines values for ServerTemplateWs.
const (
	ServerTemplateWsAuto ServerTemplateWs = "auto"
	ServerTemplateWsH1   ServerTemplateWs = "h1"
	ServerTemplateWsH2   ServerTemplateWs = "h2"
)

// Defines values for SiteFarmsCond.
const (
	SiteFarmsCondIf     SiteFarmsCond = "if"
	SiteFarmsCondUnless SiteFarmsCond = "unless"
)

// Defines values for SiteFarmsMode.
const (
	SiteFarmsModeHttp SiteFarmsMode = "http"
	SiteFarmsModeTcp  SiteFarmsMode = "tcp"
)

// Defines values for SiteFarmsUseAs.
const (
	SiteFarmsUseAsConditional SiteFarmsUseAs = "conditional"
	SiteFarmsUseAsDefault     SiteFarmsUseAs = "default"
)

// Defines values for SiteServiceHttpConnectionMode.
const (
	SiteServiceHttpConnectionModeForcedClose     SiteServiceHttpConnectionMode = "forced-close"
	SiteServiceHttpConnectionModeHttpKeepAlive   SiteServiceHttpConnectionMode = "http-keep-alive"
	SiteServiceHttpConnectionModeHttpServerClose SiteServiceHttpConnectionMode = "http-server-close"
	SiteServiceHttpConnectionModeHttpTunnel      SiteServiceHttpConnectionMode = "http-tunnel"
	SiteServiceHttpConnectionModeHttpclose       SiteServiceHttpConnectionMode = "httpclose"
)

// Defines values for SiteServiceMode.
const (
	SiteServiceModeHttp SiteServiceMode = "http"
	SiteServiceModeTcp  SiteServiceMode = "tcp"
)

// Defines values for SourceUsesrc.
const (
	SourceUsesrcAddress  SourceUsesrc = "address"
	SourceUsesrcClient   SourceUsesrc = "client"
	SourceUsesrcClientip SourceUsesrc = "clientip"
	SourceUsesrcHdrIp    SourceUsesrc = "hdr_ip"
)

// Defines values for SpoeAgentAsync.
const (
	SpoeAgentAsyncDisabled SpoeAgentAsync = "disabled"
	SpoeAgentAsyncEnabled  SpoeAgentAsync = "enabled"
)

// Defines values for SpoeAgentContinueOnError.
const (
	SpoeAgentContinueOnErrorEnabled SpoeAgentContinueOnError = "enabled"
)

// Defines values for SpoeAgentDontlogNormal.
const (
	SpoeAgentDontlogNormalDisabled SpoeAgentDontlogNormal = "disabled"
	SpoeAgentDontlogNormalEnabled  SpoeAgentDontlogNormal = "enabled"
)

// Defines values for SpoeAgentForceSetVar.
const (
	SpoeAgentForceSetVarEnabled SpoeAgentForceSetVar = "enabled"
)

// Defines values for SpoeAgentPipelining.
const (
	SpoeAgentPipeliningDisabled SpoeAgentPipelining = "disabled"
	SpoeAgentPipeliningEnabled  SpoeAgentPipelining = "enabled"
)

// Defines values for SpoeAgentSendFragPayload.
const (
	SpoeAgentSendFragPayloadDisabled SpoeAgentSendFragPayload = "disabled"
	SpoeAgentSendFragPayloadEnabled  SpoeAgentSendFragPayload = "enabled"
)

// Defines values for SpoeMessageEventCond.
const (
	SpoeMessageEventCondIf     SpoeMessageEventCond = "if"
	SpoeMessageEventCondUnless SpoeMessageEventCond = "unless"
)

// Defines values for SpoeMessageEventName.
const (
	SpoeMessageEventNameOnBackendHttpRequest  SpoeMessageEventName = "on-backend-http-request"
	SpoeMessageEventNameOnBackendTcpRequest   SpoeMessageEventName = "on-backend-tcp-request"
	SpoeMessageEventNameOnClientSession       SpoeMessageEventName = "on-client-session"
	SpoeMessageEventNameOnFrontendHttpRequest SpoeMessageEventName = "on-frontend-http-request"
	SpoeMessageEventNameOnFrontendTcpRequest  SpoeMessageEventName = "on-frontend-tcp-request"
	SpoeMessageEventNameOnHttpResponse        SpoeMessageEventName = "on-http-response"
	SpoeMessageEventNameOnServerSession       SpoeMessageEventName = "on-server-session"
	SpoeMessageEventNameOnTcpResponse         SpoeMessageEventName = "on-tcp-response"
)

// Defines values for SpoeTransactionStatus.
const (
	SpoeTransactionStatusFailed     SpoeTransactionStatus = "failed"
	SpoeTransactionStatusInProgress SpoeTransactionStatus = "in_progress"
	SpoeTransactionStatusSuccess    SpoeTransactionStatus = "success"
)

// Defines values for SslFrontUseOcspUpdate.
const (
	SslFrontUseOcspUpdateDisabled SslFrontUseOcspUpdate = "disabled"
	SslFrontUseOcspUpdateEnabled  SslFrontUseOcspUpdate = "enabled"
)

// Defines values for SslFrontUseSslMaxVer.
const (
	SslFrontUseSslMaxVerSSLv3  SslFrontUseSslMaxVer = "SSLv3"
	SslFrontUseSslMaxVerTLSv10 SslFrontUseSslMaxVer = "TLSv1.0"
	SslFrontUseSslMaxVerTLSv11 SslFrontUseSslMaxVer = "TLSv1.1"
	SslFrontUseSslMaxVerTLSv12 SslFrontUseSslMaxVer = "TLSv1.2"
	SslFrontUseSslMaxVerTLSv13 SslFrontUseSslMaxVer = "TLSv1.3"
)

// Defines values for SslFrontUseSslMinVer.
const (
	SslFrontUseSslMinVerSSLv3  SslFrontUseSslMinVer = "SSLv3"
	SslFrontUseSslMinVerTLSv10 SslFrontUseSslMinVer = "TLSv1.0"
	SslFrontUseSslMinVerTLSv11 SslFrontUseSslMinVer = "TLSv1.1"
	SslFrontUseSslMinVerTLSv12 SslFrontUseSslMinVer = "TLSv1.2"
	SslFrontUseSslMinVerTLSv13 SslFrontUseSslMinVer = "TLSv1.3"
)

// Defines values for SslFrontUseVerify.
const (
	SslFrontUseVerifyNone     SslFrontUseVerify = "none"
	SslFrontUseVerifyOptional SslFrontUseVerify = "optional"
	SslFrontUseVerifyRequired SslFrontUseVerify = "required"
)

// Defines values for SslOptionsAcmeScheduler.
const (
	SslOptionsAcmeSchedulerAuto SslOptionsAcmeScheduler = "auto"
	SslOptionsAcmeSchedulerOff  SslOptionsAcmeScheduler = "off"
)

// Defines values for SslOptionsModeAsync.
const (
	SslOptionsModeAsyncDisabled SslOptionsModeAsync = "disabled"
	SslOptionsModeAsyncEnabled  SslOptionsModeAsync = "enabled"
)

// Defines values for SslOptionsServerVerify.
const (
	SslOptionsServerVerifyNone     SslOptionsServerVerify = "none"
	SslOptionsServerVerifyRequired SslOptionsServerVerify = "required"
)

// Defines values for StatsHttpRequestType.
const (
	StatsHttpRequestTypeAllow StatsHttpRequestType = "allow"
	StatsHttpRequestTypeAuth  StatsHttpRequestType = "auth"
	StatsHttpRequestTypeDeny  StatsHttpRequestType = "deny"
)

// Defines values for StatsOptionsStatsAdminCond.
const (
	StatsOptionsStatsAdminCondIf     StatsOptionsStatsAdminCond = "if"
	StatsOptionsStatsAdminCondUnless StatsOptionsStatsAdminCond = "unless"
)

// Defines values for StickRuleCond.
const (
	StickRuleCondIf     StickRuleCond = "if"
	StickRuleCondUnless StickRuleCond = "unless"
)

// Defines values for StickRuleType.
const (
	StickRuleTypeMatch         StickRuleType = "match"
	StickRuleTypeOn            StickRuleType = "on"
	StickRuleTypeStoreRequest  StickRuleType = "store-request"
	StickRuleTypeStoreResponse StickRuleType = "store-response"
)

// Defines values for StickTableFieldsField.
const (
	StickTableFieldsFieldBytesInCnt   StickTableFieldsField = "bytes_in_cnt"
	StickTableFieldsFieldBytesInRate  StickTableFieldsField = "bytes_in_rate"
	StickTableFieldsFieldBytesOutCnt  StickTableFieldsField = "bytes_out_cnt"
	StickTableFieldsFieldBytesOutRate StickTableFieldsField = "bytes_out_rate"
	StickTableFieldsFieldConnCnt      StickTableFieldsField = "conn_cnt"
	StickTableFieldsFieldConnCur      StickTableFieldsField = "conn_cur"
	StickTableFieldsFieldConnRate     StickTableFieldsField = "conn_rate"
	StickTableFieldsFieldGlitchCnt    StickTableFieldsField = "glitch_cnt"
	StickTableFieldsFieldGlitchRate   StickTableFieldsField = "glitch_rate"
	StickTableFieldsFieldGpc          StickTableFieldsField = "gpc"
	StickTableFieldsFieldGpc0         StickTableFieldsField = "gpc0"
	StickTableFieldsFieldGpc0Rate     StickTableFieldsField = "gpc0_rate"
	StickTableFieldsFieldGpc1         StickTableFieldsField = "gpc1"
	StickTableFieldsFieldGpc1Rate     StickTableFieldsField = "gpc1_rate"
	StickTableFieldsFieldGpcRate      StickTableFieldsField = "gpc_rate"
	StickTableFieldsFieldGpt          StickTableFieldsField = "gpt"
	StickTableFieldsFieldGpt0         StickTableFieldsField = "gpt0"
	StickTableFieldsFieldHttpErrCnt   StickTableFieldsField = "http_err_cnt"
	StickTableFieldsFieldHttpErrRate  StickTableFieldsField = "http_err_rate"
	StickTableFieldsFieldHttpFailCnt  StickTableFieldsField = "http_fail_cnt"
	StickTableFieldsFieldHttpFailRate StickTableFieldsField = "http_fail_rate"
	StickTableFieldsFieldHttpReqCnt   StickTableFieldsField = "http_req_cnt"
	StickTableFieldsFieldHttpReqRate  StickTableFieldsField = "http_req_rate"
	StickTableFieldsFieldServerId     StickTableFieldsField = "server_id"
	StickTableFieldsFieldSessCnt      StickTableFieldsField = "sess_cnt"
	StickTableFieldsFieldSessRate     StickTableFieldsField = "sess_rate"
)

// Defines values for StickTableFieldsType.
const (
	StickTableFieldsTypeCounter StickTableFieldsType = "counter"
	StickTableFieldsTypeRate    StickTableFieldsType = "rate"
)

// Defines values for StickTableType.
const (
	StickTableTypeBinary  StickTableType = "binary"
	StickTableTypeInteger StickTableType = "integer"
	StickTableTypeIp      StickTableType = "ip"
	StickTableTypeIpv6    StickTableType = "ipv6"
	StickTableTypeString  StickTableType = "string"
)

// Defines values for TableType.
const (
	TableTypeBinary  TableType = "binary"
	TableTypeInteger TableType = "integer"
	TableTypeIp      TableType = "ip"
	TableTypeString  TableType = "string"
)

// Defines values for TcpCheckAction.
const (
	TcpCheckActionComment      TcpCheckAction = "comment"
	TcpCheckActionConnect      TcpCheckAction = "connect"
	TcpCheckActionExpect       TcpCheckAction = "expect"
	TcpCheckActionSend         TcpCheckAction = "send"
	TcpCheckActionSendBinary   TcpCheckAction = "send-binary"
	TcpCheckActionSendBinaryLf TcpCheckAction = "send-binary-lf"
	TcpCheckActionSendLf       TcpCheckAction = "send-lf"
	TcpCheckActionSetVar       TcpCheckAction = "set-var"
	TcpCheckActionSetVarFmt    TcpCheckAction = "set-var-fmt"
	TcpCheckActionUnsetVar     TcpCheckAction = "unset-var"
)

// Defines values for TcpCheckErrorStatus.
const (
	TcpCheckErrorStatusL4CON TcpCheckErrorStatus = "L4CON"
	TcpCheckErrorStatusL6RSP TcpCheckErrorStatus = "L6RSP"
	TcpCheckErrorStatusL7OKC TcpCheckErrorStatus = "L7OKC"
	TcpCheckErrorStatusL7RSP TcpCheckErrorStatus = "L7RSP"
	TcpCheckErrorStatusL7STS TcpCheckErrorStatus = "L7STS"
)

// Defines values for TcpCheckMatch.
const (
	TcpCheckMatchBinary   TcpCheckMatch = "binary"
	TcpCheckMatchBinaryLf TcpCheckMatch = "binary-lf"
	TcpCheckMatchRbinary  TcpCheckMatch = "rbinary"
	TcpCheckMatchRstring  TcpCheckMatch = "rstring"
	TcpCheckMatchString   TcpCheckMatch = "string"
	TcpCheckMatchStringLf TcpCheckMatch = "string-lf"
)

// Defines values for TcpCheckOkStatus.
const (
	TcpCheckOkStatusL4OK  TcpCheckOkStatus = "L4OK"
	TcpCheckOkStatusL6OK  TcpCheckOkStatus = "L6OK"
	TcpCheckOkStatusL7OK  TcpCheckOkStatus = "L7OK"
	TcpCheckOkStatusL7OKC TcpCheckOkStatus = "L7OKC"
)

// Defines values for TcpCheckToutStatus.
const (
	TcpCheckToutStatusL4TOUT TcpCheckToutStatus = "L4TOUT"
	TcpCheckToutStatusL6TOUT TcpCheckToutStatus = "L6TOUT"
	TcpCheckToutStatusL7TOUT TcpCheckToutStatus = "L7TOUT"
)

// Defines values for TcpRequestRuleAction.
const (
	TcpRequestRuleActionAccept             TcpRequestRuleAction = "accept"
	TcpRequestRuleActionAttachSrv          TcpRequestRuleAction = "attach-srv"
	TcpRequestRuleActionCapture            TcpRequestRuleAction = "capture"
	TcpRequestRuleActionDoLog              TcpRequestRuleAction = "do-log"
	TcpRequestRuleActionDoResolve          TcpRequestRuleAction = "do-resolve"
	TcpRequestRuleActionExpectNetscalerCip TcpRequestRuleAction = "expect-netscaler-cip"
	TcpRequestRuleActionExpectProxy        TcpRequestRuleAction = "expect-proxy"
	TcpRequestRuleActionLua                TcpRequestRuleAction = "lua"
	TcpRequestRuleActionReject             TcpRequestRuleAction = "reject"
	TcpRequestRuleActionScAddGpc           TcpRequestRuleAction = "sc-add-gpc"
	TcpRequestRuleActionScIncGpc           TcpRequestRuleAction = "sc-inc-gpc"
	TcpRequestRuleActionScIncGpc0          TcpRequestRuleAction = "sc-inc-gpc0"
	TcpRequestRuleActionScIncGpc1          TcpRequestRuleAction = "sc-inc-gpc1"
	TcpRequestRuleActionScSetGpt           TcpRequestRuleAction = "sc-set-gpt"
	TcpRequestRuleActionScSetGpt0          TcpRequestRuleAction = "sc-set-gpt0"
	TcpRequestRuleActionSendSpoeGroup      TcpRequestRuleAction = "send-spoe-group"
	TcpRequestRuleActionSetBandwidthLimit  TcpRequestRuleAction = "set-bandwidth-limit"
	TcpRequestRuleActionSetBcMark          TcpRequestRuleAction = "set-bc-mark"
	TcpRequestRuleActionSetBcTos           TcpRequestRuleAction = "set-bc-tos"
	TcpRequestRuleActionSetDst             TcpRequestRuleAction = "set-dst"
	TcpRequestRuleActionSetDstPort         TcpRequestRuleAction = "set-dst-port"
	TcpRequestRuleActionSetFcMark          TcpRequestRuleAction = "set-fc-mark"
	TcpRequestRuleActionSetFcTos           TcpRequestRuleAction = "set-fc-tos"
	TcpRequestRuleActionSetLogLevel        TcpRequestRuleAction = "set-log-level"
	TcpRequestRuleActionSetMark            TcpRequestRuleAction = "set-mark"
	TcpRequestRuleActionSetNice            TcpRequestRuleAction = "set-nice"
	TcpRequestRuleActionSetPriorityClass   TcpRequestRuleAction = "set-priority-class"
	TcpRequestRuleActionSetPriorityOffset  TcpRequestRuleAction = "set-priority-offset"
	TcpRequestRuleActionSetRetries         TcpRequestRuleAction = "set-retries"
	TcpRequestRuleActionSetSrc             TcpRequestRuleAction = "set-src"
	TcpRequestRuleActionSetSrcPort         TcpRequestRuleAction = "set-src-port"
	TcpRequestRuleActionSetTos             TcpRequestRuleAction = "set-tos"
	TcpRequestRuleActionSetVar             TcpRequestRuleAction = "set-var"
	TcpRequestRuleActionSetVarFmt          TcpRequestRuleAction = "set-var-fmt"
	TcpRequestRuleActionSilentDrop         TcpRequestRuleAction = "silent-drop"
	TcpRequestRuleActionSwitchMode         TcpRequestRuleAction = "switch-mode"
	TcpRequestRuleActionTrackSc            TcpRequestRuleAction = "track-sc"
	TcpRequestRuleActionUnsetVar           TcpRequestRuleAction = "unset-var"
	TcpRequestRuleActionUseService         TcpRequestRuleAction = "use-service"
)

// Defines values for TcpRequestRuleCond.
const (
	TcpRequestRuleCondIf     TcpRequestRuleCond = "if"
	TcpRequestRuleCondUnless TcpRequestRuleCond = "unless"
)

// Defines values for TcpRequestRuleLogLevel.
const (
	TcpRequestRuleLogLevelAlert   TcpRequestRuleLogLevel = "alert"
	TcpRequestRuleLogLevelCrit    TcpRequestRuleLogLevel = "crit"
	TcpRequestRuleLogLevelDebug   TcpRequestRuleLogLevel = "debug"
	TcpRequestRuleLogLevelEmerg   TcpRequestRuleLogLevel = "emerg"
	TcpRequestRuleLogLevelErr     TcpRequestRuleLogLevel = "err"
	TcpRequestRuleLogLevelInfo    TcpRequestRuleLogLevel = "info"
	TcpRequestRuleLogLevelNotice  TcpRequestRuleLogLevel = "notice"
	TcpRequestRuleLogLevelSilent  TcpRequestRuleLogLevel = "silent"
	TcpRequestRuleLogLevelWarning TcpRequestRuleLogLevel = "warning"
)

// Defines values for TcpRequestRuleResolveProtocol.
const (
	TcpRequestRuleResolveProtocolIpv4 TcpRequestRuleResolveProtocol = "ipv4"
	TcpRequestRuleResolveProtocolIpv6 TcpRequestRuleResolveProtocol = "ipv6"
)

// Defines values for TcpRequestRuleType.
const (
	TcpRequestRuleTypeConnection   TcpRequestRuleType = "connection"
	TcpRequestRuleTypeContent      TcpRequestRuleType = "content"
	TcpRequestRuleTypeInspectDelay TcpRequestRuleType = "inspect-delay"
	TcpRequestRuleTypeSession      TcpRequestRuleType = "session"
)

// Defines values for TcpResponseRuleAction.
const (
	TcpResponseRuleActionAccept            TcpResponseRuleAction = "accept"
	TcpResponseRuleActionClose             TcpResponseRuleAction = "close"
	TcpResponseRuleActionDoLog             TcpResponseRuleAction = "do-log"
	TcpResponseRuleActionLua               TcpResponseRuleAction = "lua"
	TcpResponseRuleActionReject            TcpResponseRuleAction = "reject"
	TcpResponseRuleActionScAddGpc          TcpResponseRuleAction = "sc-add-gpc"
	TcpResponseRuleActionScIncGpc          TcpResponseRuleAction = "sc-inc-gpc"
	TcpResponseRuleActionScIncGpc0         TcpResponseRuleAction = "sc-inc-gpc0"
	TcpResponseRuleActionScIncGpc1         TcpResponseRuleAction = "sc-inc-gpc1"
	TcpResponseRuleActionScSetGpt          TcpResponseRuleAction = "sc-set-gpt"
	TcpResponseRuleActionScSetGpt0         TcpResponseRuleAction = "sc-set-gpt0"
	TcpResponseRuleActionSendSpoeGroup     TcpResponseRuleAction = "send-spoe-group"
	TcpResponseRuleActionSetBandwidthLimit TcpResponseRuleAction = "set-bandwidth-limit"
	TcpResponseRuleActionSetFcMark         TcpResponseRuleAction = "set-fc-mark"
	TcpResponseRuleActionSetFcTos          TcpResponseRuleAction = "set-fc-tos"
	TcpResponseRuleActionSetLogLevel       TcpResponseRuleAction = "set-log-level"
	TcpResponseRuleActionSetMark           TcpResponseRuleAction = "set-mark"
	TcpResponseRuleActionSetNice           TcpResponseRuleAction = "set-nice"
	TcpResponseRuleActionSetTos            TcpResponseRuleAction = "set-tos"
	TcpResponseRuleActionSetVar            TcpResponseRuleAction = "set-var"
	TcpResponseRuleActionSetVarFmt         TcpResponseRuleAction = "set-var-fmt"
	TcpResponseRuleActionSilentDrop        TcpResponseRuleAction = "silent-drop"
	TcpResponseRuleActionUnsetVar          TcpResponseRuleAction = "unset-var"
)

// Defines values for TcpResponseRuleCond.
const (
	TcpResponseRuleCondIf     TcpResponseRuleCond = "if"
	TcpResponseRuleCondUnless TcpResponseRuleCond = "unless"
)

// Defines values for TcpResponseRuleLogLevel.
const (
	TcpResponseRuleLogLevelAlert   TcpResponseRuleLogLevel = "alert"
	TcpResponseRuleLogLevelCrit    TcpResponseRuleLogLevel = "crit"
	TcpResponseRuleLogLevelDebug   TcpResponseRuleLogLevel = "debug"
	TcpResponseRuleLogLevelEmerg   TcpResponseRuleLogLevel = "emerg"
	TcpResponseRuleLogLevelErr     TcpResponseRuleLogLevel = "err"
	TcpResponseRuleLogLevelInfo    TcpResponseRuleLogLevel = "info"
	TcpResponseRuleLogLevelNotice  TcpResponseRuleLogLevel = "notice"
	TcpResponseRuleLogLevelSilent  TcpResponseRuleLogLevel = "silent"
	TcpResponseRuleLogLevelWarning TcpResponseRuleLogLevel = "warning"
)

// Defines values for TcpResponseRuleType.
const (
	TcpResponseRuleTypeContent      TcpResponseRuleType = "content"
	TcpResponseRuleTypeInspectDelay TcpResponseRuleType = "inspect-delay"
)

// Defines values for TransactionStatus.
const (
	TransactionStatusFailed     TransactionStatus = "failed"
	TransactionStatusInProgress TransactionStatus = "in_progress"
	TransactionStatusOutdated   TransactionStatus = "outdated"
	TransactionStatusSuccess    TransactionStatus = "success"
)

// Defines values for TuneLuaOptionsBoolSampleConversion.
const (
	TuneLuaOptionsBoolSampleConversionNormal   TuneLuaOptionsBoolSampleConversion = "normal"
	TuneLuaOptionsBoolSampleConversionPre31Bug TuneLuaOptionsBoolSampleConversion = "pre-3.1-bug"
)

// Defines values for TuneLuaOptionsLogLoggers.
const (
	TuneLuaOptionsLogLoggersDisabled TuneLuaOptionsLogLoggers = "disabled"
	TuneLuaOptionsLogLoggersEnabled  TuneLuaOptionsLogLoggers = "enabled"
)

// Defines values for TuneLuaOptionsLogStderr.
const (
	TuneLuaOptionsLogStderrAuto     TuneLuaOptionsLogStderr = "auto"
	TuneLuaOptionsLogStderrDisabled TuneLuaOptionsLogStderr = "disabled"
	TuneLuaOptionsLogStderrEnabled  TuneLuaOptionsLogStderr = "enabled"
)

// Defines values for TuneOptionsAppletZeroCopyForwarding.
const (
	TuneOptionsAppletZeroCopyForwardingDisabled TuneOptionsAppletZeroCopyForwarding = "disabled"
	TuneOptionsAppletZeroCopyForwardingEnabled  TuneOptionsAppletZeroCopyForwarding = "enabled"
)

// Defines values for TuneOptionsEpollMaskEvents.
const (
	TuneOptionsEpollMaskEventsErr   TuneOptionsEpollMaskEvents = "err"
	TuneOptionsEpollMaskEventsHup   TuneOptionsEpollMaskEvents = "hup"
	TuneOptionsEpollMaskEventsRdhup TuneOptionsEpollMaskEvents = "rdhup"
)

// Defines values for TuneOptionsFdEdgeTriggered.
const (
	TuneOptionsFdEdgeTriggeredDisabled TuneOptionsFdEdgeTriggered = "disabled"
	TuneOptionsFdEdgeTriggeredEnabled  TuneOptionsFdEdgeTriggered = "enabled"
)

// Defines values for TuneOptionsH1ZeroCopyFwdRecv.
const (
	TuneOptionsH1ZeroCopyFwdRecvDisabled TuneOptionsH1ZeroCopyFwdRecv = "disabled"
	TuneOptionsH1ZeroCopyFwdRecvEnabled  TuneOptionsH1ZeroCopyFwdRecv = "enabled"
)

// Defines values for TuneOptionsH1ZeroCopyFwdSend.
const (
	TuneOptionsH1ZeroCopyFwdSendDisabled TuneOptionsH1ZeroCopyFwdSend = "disabled"
	TuneOptionsH1ZeroCopyFwdSendEnabled  TuneOptionsH1ZeroCopyFwdSend = "enabled"
)

// Defines values for TuneOptionsH2ZeroCopyFwdSend.
const (
	TuneOptionsH2ZeroCopyFwdSendDisabled TuneOptionsH2ZeroCopyFwdSend = "disabled"
	TuneOptionsH2ZeroCopyFwdSendEnabled  TuneOptionsH2ZeroCopyFwdSend = "enabled"
)

// Defines values for TuneOptionsIdlePoolShared.
const (
	TuneOptionsIdlePoolSharedDisabled TuneOptionsIdlePoolShared = "disabled"
	TuneOptionsIdlePoolSharedEnabled  TuneOptionsIdlePoolShared = "enabled"
)

// Defines values for TuneOptionsListenerDefaultShards.
const (
	TuneOptionsListenerDefaultShardsByGroup   TuneOptionsListenerDefaultShards = "by-group"
	TuneOptionsListenerDefaultShardsByProcess TuneOptionsListenerDefaultShards = "by-process"
	TuneOptionsListenerDefaultShardsByThread  TuneOptionsListenerDefaultShards = "by-thread"
)

// Defines values for TuneOptionsListenerMultiQueue.
const (
	TuneOptionsListenerMultiQueueDisabled TuneOptionsListenerMultiQueue = "disabled"
	TuneOptionsListenerMultiQueueEnabled  TuneOptionsListenerMultiQueue = "enabled"
)

// Defines values for TuneOptionsPtZeroCopyForwarding.
const (
	TuneOptionsPtZeroCopyForwardingDisabled TuneOptionsPtZeroCopyForwarding = "disabled"
	TuneOptionsPtZeroCopyForwardingEnabled  TuneOptionsPtZeroCopyForwarding = "enabled"
)

// Defines values for TuneOptionsSchedLowLatency.
const (
	TuneOptionsSchedLowLatencyDisabled TuneOptionsSchedLowLatency = "disabled"
	TuneOptionsSchedLowLatencyEnabled  TuneOptionsSchedLowLatency = "enabled"
)

// Defines values for TuneOptionsTakeoverOtherTgConnections.
const (
	TuneOptionsTakeoverOtherTgConnectionsFull       TuneOptionsTakeoverOtherTgConnections = "full"
	TuneOptionsTakeoverOtherTgConnectionsNone       TuneOptionsTakeoverOtherTgConnections = "none"
	TuneOptionsTakeoverOtherTgConnectionsRestricted TuneOptionsTakeoverOtherTgConnections = "restricted"
)

// Defines values for TuneQuicOptionsSocketOwner.
const (
	TuneQuicOptionsSocketOwnerConnection TuneQuicOptionsSocketOwner = "connection"
	TuneQuicOptionsSocketOwnerListener   TuneQuicOptionsSocketOwner = "listener"
)

// Defines values for TuneQuicOptionsZeroCopyFwdSend.
const (
	TuneQuicOptionsZeroCopyFwdSendDisabled TuneQuicOptionsZeroCopyFwdSend = "disabled"
	TuneQuicOptionsZeroCopyFwdSendEnabled  TuneQuicOptionsZeroCopyFwdSend = "enabled"
)

// Defines values for TuneSslOptionsKeylog.
const (
	TuneSslOptionsKeylogDisabled TuneSslOptionsKeylog = "disabled"
	TuneSslOptionsKeylogEnabled  TuneSslOptionsKeylog = "enabled"
)

// Defines values for DeleteClusterParamsConfiguration.
const (
	DeleteClusterParamsConfigurationKeep DeleteClusterParamsConfiguration = "keep"
)

// Defines values for PostClusterParamsConfiguration.
const (
	PostClusterParamsConfigurationKeep PostClusterParamsConfiguration = "keep"
)

// Defines values for GetAllSpoeTransactionParamsStatus.
const (
	GetAllSpoeTransactionParamsStatusFailed     GetAllSpoeTransactionParamsStatus = "failed"
	GetAllSpoeTransactionParamsStatusInProgress GetAllSpoeTransactionParamsStatus = "in_progress"
)

// Defines values for GetStatsParamsType.
const (
	GetStatsParamsTypeBackend  GetStatsParamsType = "backend"
	GetStatsParamsTypeFrontend GetStatsParamsType = "frontend"
	GetStatsParamsTypeServer   GetStatsParamsType = "server"
)

// Defines values for GetTransactionsParamsStatus.
const (
	GetTransactionsParamsStatusFailed     GetTransactionsParamsStatus = "failed"
	GetTransactionsParamsStatusInProgress GetTransactionsParamsStatus = "in_progress"
)

// Acl The use of Access Control Lists (ACL) provides a flexible solution to perform
// content switching and generally to take decisions based on content extracted
// from the request, the response or any environmental status.
type Acl struct {
	AclName   string                             `json:"acl_name"`
	Criterion string                             `json:"criterion"`
	Metadata  *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Value     *string                            `json:"value,omitempty"`
}

// AclFile ACL File
type AclFile struct {
	Description *string `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`
	StorageName *string `json:"storage_name,omitempty"`
}

// AclFileEntry One ACL File Entry
type AclFileEntry struct {
	Id    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

// AclFiles Array of runtime acl files
type AclFiles = []AclFile

// AclFilesEntries Array of entries of one runtime acl file
type AclFilesEntries = []AclFileEntry

// Acls HAProxy ACL lines array (corresponds to acl directives)
type Acls = []Acl

// AcmeCertificateStatus Status of a single ACME certificate from runtime.
type AcmeCertificateStatus struct {
	// AcmeSection ACME section which generated the certificate.
	AcmeSection *string `json:"acme_section,omitempty"`

	// Certificate Certificate name
	Certificate *string `json:"certificate,omitempty"`

	// ExpiriesIn Duration until certificate expiry.
	ExpiriesIn *string `json:"expiries_in,omitempty"`

	// ExpiryDate Certificate expiration date.
	ExpiryDate *time.Time `json:"expiry_date,omitempty"`

	// RenewalIn Duration until the next planned renewal.
	RenewalIn *string `json:"renewal_in,omitempty"`

	// ScheduledRenewal Planned date for certificate renewal.
	ScheduledRenewal *time.Time `json:"scheduled_renewal,omitempty"`

	// State State of the ACME task, either "Running" or "Scheduled".
	State *string `json:"state,omitempty"`
}

// AcmeProvider Define an ACME provider to generate certificates automatically
type AcmeProvider struct {
	// AccountKey Path where the the ACME account key is stored
	AccountKey *string `json:"account_key,omitempty"`

	// AcmeProvider DNS provider for the dns-01 challenge
	AcmeProvider *string `json:"acme_provider,omitempty"`

	// AcmeVars List of variables passed to the dns-01 provider (typically API keys)
	AcmeVars *map[string]string `json:"acme_vars,omitempty"`

	// Bits Number of bits to generate an RSA certificate
	Bits *int `json:"bits,omitempty"`

	// Challenge ACME challenge type. Only http-01 and dns-01 are supported.
	Challenge *AcmeProviderChallenge `json:"challenge,omitempty"`

	// Contact Contact email for the ACME account
	Contact *string `json:"contact,omitempty"`

	// Curves Curves used with the ECDSA key type
	Curves *string `json:"curves,omitempty"`

	// Directory URL to the ACME provider's directory. For example:
	// https://acme-staging-v02.api.letsencrypt.org/directory
	Directory string `json:"directory"`

	// Keytype Type of key to generate
	Keytype *AcmeProviderKeytype `json:"keytype,omitempty"`

	// Map The map which will be used to store the ACME token (key) and thumbprint
	Map      *string                            `json:"map,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`

	// Name ACME provider's name
	Name string `json:"name"`

	// ReuseKey Try to reuse the private key instead of generating a new one.
	ReuseKey *AcmeProviderReuseKey `json:"reuse_key,omitempty"`
}

// AcmeProviderChallenge ACME challenge type. Only http-01 and dns-01 are supported.
type AcmeProviderChallenge string

// AcmeProviderKeytype Type of key to generate
type AcmeProviderKeytype string

// AcmeProviderReuseKey Try to reuse the private key instead of generating a new one.
type AcmeProviderReuseKey string

// AcmeProviders List of ACME sections.
type AcmeProviders = []AcmeProvider

// AcmeStatus Status of all the ACME certificates from runtime.
type AcmeStatus = []AcmeCertificateStatus

// AwsFilters defines model for awsFilters.
type AwsFilters struct {
	// Key Key to use as filter, using the format specified at https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html#options
	Key string `json:"key"`

	// Value Value of the filter to use
	Value string `json:"value"`
}

// AwsRegion AWS region configuration
type AwsRegion struct {
	// AccessKeyId AWS Access Key ID.
	AccessKeyId *string `json:"access_key_id,omitempty"`

	// Allowlist Specify the AWS filters used to filter the EC2 instances to add
	Allowlist *[]AwsFilters `json:"allowlist,omitempty"`

	// Denylist Specify the AWS filters used to filter the EC2 instances to ignore
	Denylist    *[]AwsFilters `json:"denylist,omitempty"`
	Description *string       `json:"description,omitempty"`
	Enabled     bool          `json:"enabled"`

	// Id Auto generated ID.
	Id *string `json:"id"`

	// Ipv4Address Select which IPv4 address the Service Discovery has to use for the backend server entry
	Ipv4Address AwsRegionIpv4Address `json:"ipv4_address"`
	Name        string               `json:"name"`
	Region      string               `json:"region"`

	// RetryTimeout Duration in seconds in-between data pulling requests to the AWS region
	RetryTimeout int `json:"retry_timeout"`

	// SecretAccessKey AWS Secret Access Key.
	SecretAccessKey            *string                         `json:"secret_access_key,omitempty"`
	ServerSlotsBase            *int                            `json:"server_slots_base,omitempty"`
	ServerSlotsGrowthIncrement *int                            `json:"server_slots_growth_increment,omitempty"`
	ServerSlotsGrowthType      *AwsRegionServerSlotsGrowthType `json:"server_slots_growth_type,omitempty"`
}

// AwsRegionIpv4Address Select which IPv4 address the Service Discovery has to use for the backend server entry
type AwsRegionIpv4Address string

// AwsRegionServerSlotsGrowthType defines model for AwsRegion.ServerSlotsGrowthType.
type AwsRegionServerSlotsGrowthType string

// AwsRegions AWS regions array
type AwsRegions = []AwsRegion

// Backend defines model for backend.
type Backend struct {
	Abortonclose                         *BackendAbortonclose                         `json:"abortonclose,omitempty"`
	AcceptInvalidHttpResponse            *BackendAcceptInvalidHttpResponse            `json:"accept_invalid_http_response,omitempty"`
	AcceptUnsafeViolationsInHttpResponse *BackendAcceptUnsafeViolationsInHttpResponse `json:"accept_unsafe_violations_in_http_response,omitempty"`

	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList          *Acls              `json:"acl_list,omitempty"`
	AdvCheck         *BackendAdvCheck   `json:"adv_check,omitempty"`
	Allbackups       *BackendAllbackups `json:"allbackups,omitempty"`
	Balance          *Balance           `json:"balance,omitempty"`
	CheckTimeout     *int               `json:"check_timeout"`
	Checkcache       *BackendCheckcache `json:"checkcache,omitempty"`
	Compression      *Compression       `json:"compression,omitempty"`
	ConnectTimeout   *int               `json:"connect_timeout"`
	Cookie           *Cookie            `json:"cookie,omitempty"`
	DefaultServer    *DefaultServer     `json:"default_server,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Disabled         *bool              `json:"disabled,omitempty"`
	DynamicCookieKey *string            `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert           `json:"email_alert,omitempty"`
	Enabled                  *bool                 `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile          `json:"error_files,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles         `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc             `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc             `json:"errorloc303,omitempty"`
	ExternalCheck            *BackendExternalCheck `json:"external_check,omitempty"`
	ExternalCheckCommand     *string               `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string               `json:"external_check_path,omitempty"`

	// FilterList HAProxy filters array (corresponds to filter directive)
	FilterList *Filters `json:"filter_list,omitempty"`

	// BackendForcePersist This field is deprecated in favor of force_persist_list, and will be removed in a future release
	BackendForcePersist *struct {
		Cond     BackendForcePersistCond `json:"cond"`
		CondTest string                  `json:"cond_test"`
	} `json:"force_persist,omitempty"`
	ForcePersistList *[]struct {
		Cond     BackendForcePersistListCond `json:"cond"`
		CondTest string                      `json:"cond_test"`
	} `json:"force_persist_list,omitempty"`
	Forwardfor              *Forwardfor                     `json:"forwardfor,omitempty"`
	From                    *string                         `json:"from,omitempty"`
	Fullconn                *int                            `json:"fullconn"`
	Guid                    *string                         `json:"guid,omitempty"`
	H1CaseAdjustBogusServer *BackendH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor       *int                            `json:"hash_balance_factor"`
	HashPreserveAffinity    *BackendHashPreserveAffinity    `json:"hash_preserve_affinity,omitempty"`
	HashType                *HashType                       `json:"hash_type,omitempty"`
	HttpBufferRequest       *BackendHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpDropRequestTrailers *BackendHttpDropRequestTrailers `json:"http-drop-request-trailers,omitempty"`
	HttpNoDelay             *BackendHttpNoDelay             `json:"http-no-delay,omitempty"`
	HttpUseHtx              *BackendHttpUseHtx              `json:"http-use-htx,omitempty"`

	// HttpAfterResponseRuleList HAProxy HTTP after response rules array (corresponds to http-after-response directives)
	HttpAfterResponseRuleList *HttpAfterResponseRules    `json:"http_after_response_rule_list,omitempty"`
	HttpCheckList             *HttpChecks                `json:"http_check_list,omitempty"`
	HttpConnectionMode        *BackendHttpConnectionMode `json:"http_connection_mode,omitempty"`

	// HttpErrorRuleList HAProxy HTTP error rules array (corresponds to http-error directives)
	HttpErrorRuleList    *HttpErrorRules              `json:"http_error_rule_list,omitempty"`
	HttpKeepAliveTimeout *int                         `json:"http_keep_alive_timeout"`
	HttpPretendKeepalive *BackendHttpPretendKeepalive `json:"http_pretend_keepalive,omitempty"`
	HttpProxy            *BackendHttpProxy            `json:"http_proxy,omitempty"`

	// HttpRequestRuleList HAProxy HTTP request rules array (corresponds to http-request directives)
	HttpRequestRuleList *HttpRequestRules `json:"http_request_rule_list,omitempty"`
	HttpRequestTimeout  *int              `json:"http_request_timeout"`

	// HttpResponseRuleList HAProxy HTTP response rules array (corresponds to http-response directives)
	HttpResponseRuleList    *HttpResponseRules              `json:"http_response_rule_list,omitempty"`
	HttpRestrictReqHdrNames *BackendHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse               *BackendHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader      *string                         `json:"http_send_name_header"`
	HttpchkParams           *HttpchkParams                  `json:"httpchk_params,omitempty"`
	Id                      *int                            `json:"id"`

	// BackendIgnorePersist This field is deprecated in favor of ignore_persist_list, and will be removed in a future release
	BackendIgnorePersist *struct {
		Cond     BackendIgnorePersistCond `json:"cond"`
		CondTest string                   `json:"cond_test"`
	} `json:"ignore_persist,omitempty"`
	IgnorePersistList *[]struct {
		Cond     BackendIgnorePersistListCond `json:"cond"`
		CondTest string                       `json:"cond_test"`
	} `json:"ignore_persist_list,omitempty"`
	IndependentStreams      *BackendIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile *BackendLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogHealthChecks         *BackendLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogTag                  *string                         `json:"log_tag,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList       *LogTargets                        `json:"log_target_list,omitempty"`
	MaxKeepAliveQueue   *int                               `json:"max_keep_alive_queue"`
	Metadata            *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Mode                *BackendMode                       `json:"mode,omitempty"`
	MysqlCheckParams    *MysqlCheckParams                  `json:"mysql_check_params,omitempty"`
	Name                string                             `json:"name"`
	Nolinger            *BackendNolinger                   `json:"nolinger,omitempty"`
	Originalto          *Originalto                        `json:"originalto,omitempty"`
	Persist             *BackendPersist                    `json:"persist,omitempty"`
	PersistRule         *PersistRule                       `json:"persist_rule,omitempty"`
	PgsqlCheckParams    *PgsqlCheckParams                  `json:"pgsql_check_params,omitempty"`
	PreferLastServer    *BackendPreferLastServer           `json:"prefer_last_server,omitempty"`
	QueueTimeout        *int                               `json:"queue_timeout"`
	Redispatch          *Redispatch                        `json:"redispatch,omitempty"`
	Retries             *int                               `json:"retries"`
	RetryOn             *string                            `json:"retry_on,omitempty"`
	ServerFinTimeout    *int                               `json:"server_fin_timeout"`
	ServerStateFileName *string                            `json:"server_state_file_name,omitempty"`

	// ServerSwitchingRuleList HAProxy backend server switching rules array (corresponds to use-server directives)
	ServerSwitchingRuleList *ServerSwitchingRules      `json:"server_switching_rule_list,omitempty"`
	ServerTemplates         *map[string]ServerTemplate `json:"server_templates,omitempty"`
	ServerTimeout           *int                       `json:"server_timeout"`
	Servers                 *map[string]Server         `json:"servers,omitempty"`
	SmtpchkParams           *SmtpchkParams             `json:"smtpchk_params,omitempty"`
	Source                  *Source                    `json:"source,omitempty"`
	SpliceAuto              *BackendSpliceAuto         `json:"splice_auto,omitempty"`
	SpliceRequest           *BackendSpliceRequest      `json:"splice_request,omitempty"`
	SpliceResponse          *BackendSpliceResponse     `json:"splice_response,omitempty"`
	SpopCheck               *BackendSpopCheck          `json:"spop_check,omitempty"`
	Srvtcpka                *BackendSrvtcpka           `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt             *int                       `json:"srvtcpka_cnt"`
	SrvtcpkaIdle            *int                       `json:"srvtcpka_idle"`
	SrvtcpkaIntvl           *int                       `json:"srvtcpka_intvl"`
	StatsOptions            *StatsOptions              `json:"stats_options,omitempty"`

	// StickRuleList HAProxy backend stick rules array (corresponds to stick store-request, stick match, stick on, stick store-response)
	StickRuleList    *StickRules       `json:"stick_rule_list,omitempty"`
	StickTable       *ConfigStickTable `json:"stick_table,omitempty"`
	TarpitTimeout    *int              `json:"tarpit_timeout"`
	TcpCheckRuleList *TcpChecks        `json:"tcp_check_rule_list,omitempty"`

	// TcpRequestRuleList HAProxy TCP request rules array (corresponds to tcp-request directive)
	TcpRequestRuleList *TcpRequestRules `json:"tcp_request_rule_list,omitempty"`

	// TcpResponseRuleList HAProxy TCP response rules array (corresponds to tcp-response directive)
	TcpResponseRuleList *TcpResponseRules       `json:"tcp_response_rule_list,omitempty"`
	TcpSmartConnect     *BackendTcpSmartConnect `json:"tcp_smart_connect,omitempty"`
	Tcpka               *BackendTcpka           `json:"tcpka,omitempty"`
	Transparent         *BackendTransparent     `json:"transparent,omitempty"`
	TunnelTimeout       *int                    `json:"tunnel_timeout"`
	UseFcgiApp          *string                 `json:"use_fcgi_app,omitempty"`
}

// BackendAbortonclose defines model for Backend.Abortonclose.
type BackendAbortonclose string

// BackendAcceptInvalidHttpResponse defines model for Backend.AcceptInvalidHttpResponse.
type BackendAcceptInvalidHttpResponse string

// BackendAcceptUnsafeViolationsInHttpResponse defines model for Backend.AcceptUnsafeViolationsInHttpResponse.
type BackendAcceptUnsafeViolationsInHttpResponse string

// BackendAdvCheck defines model for Backend.AdvCheck.
type BackendAdvCheck string

// BackendAllbackups defines model for Backend.Allbackups.
type BackendAllbackups string

// BackendCheckcache defines model for Backend.Checkcache.
type BackendCheckcache string

// BackendExternalCheck defines model for Backend.ExternalCheck.
type BackendExternalCheck string

// BackendForcePersistCond defines model for Backend.ForcePersist.Cond.
type BackendForcePersistCond string

// BackendForcePersistListCond defines model for Backend.ForcePersistList.Cond.
type BackendForcePersistListCond string

// BackendH1CaseAdjustBogusServer defines model for Backend.H1CaseAdjustBogusServer.
type BackendH1CaseAdjustBogusServer string

// BackendHashPreserveAffinity defines model for Backend.HashPreserveAffinity.
type BackendHashPreserveAffinity string

// BackendHttpBufferRequest defines model for Backend.HttpBufferRequest.
type BackendHttpBufferRequest string

// BackendHttpDropRequestTrailers defines model for Backend.HttpDropRequestTrailers.
type BackendHttpDropRequestTrailers string

// BackendHttpNoDelay defines model for Backend.HttpNoDelay.
type BackendHttpNoDelay string

// BackendHttpUseHtx defines model for Backend.HttpUseHtx.
type BackendHttpUseHtx string

// BackendHttpConnectionMode defines model for Backend.HttpConnectionMode.
type BackendHttpConnectionMode string

// BackendHttpPretendKeepalive defines model for Backend.HttpPretendKeepalive.
type BackendHttpPretendKeepalive string

// BackendHttpProxy defines model for Backend.HttpProxy.
type BackendHttpProxy string

// BackendHttpRestrictReqHdrNames defines model for Backend.HttpRestrictReqHdrNames.
type BackendHttpRestrictReqHdrNames string

// BackendHttpReuse defines model for Backend.HttpReuse.
type BackendHttpReuse string

// BackendIgnorePersistCond defines model for Backend.IgnorePersist.Cond.
type BackendIgnorePersistCond string

// BackendIgnorePersistListCond defines model for Backend.IgnorePersistList.Cond.
type BackendIgnorePersistListCond string

// BackendIndependentStreams defines model for Backend.IndependentStreams.
type BackendIndependentStreams string

// BackendLoadServerStateFromFile defines model for Backend.LoadServerStateFromFile.
type BackendLoadServerStateFromFile string

// BackendLogHealthChecks defines model for Backend.LogHealthChecks.
type BackendLogHealthChecks string

// BackendMode defines model for Backend.Mode.
type BackendMode string

// BackendNolinger defines model for Backend.Nolinger.
type BackendNolinger string

// BackendPersist defines model for Backend.Persist.
type BackendPersist string

// BackendPreferLastServer defines model for Backend.PreferLastServer.
type BackendPreferLastServer string

// BackendSpliceAuto defines model for Backend.SpliceAuto.
type BackendSpliceAuto string

// BackendSpliceRequest defines model for Backend.SpliceRequest.
type BackendSpliceRequest string

// BackendSpliceResponse defines model for Backend.SpliceResponse.
type BackendSpliceResponse string

// BackendSpopCheck defines model for Backend.SpopCheck.
type BackendSpopCheck string

// BackendSrvtcpka defines model for Backend.Srvtcpka.
type BackendSrvtcpka string

// BackendTcpSmartConnect defines model for Backend.TcpSmartConnect.
type BackendTcpSmartConnect string

// BackendTcpka defines model for Backend.Tcpka.
type BackendTcpka string

// BackendTransparent defines model for Backend.Transparent.
type BackendTransparent string

// BackendBase HAProxy backend configuration
type BackendBase struct {
	Abortonclose                         *BackendBaseAbortonclose                         `json:"abortonclose,omitempty"`
	AcceptInvalidHttpResponse            *BackendBaseAcceptInvalidHttpResponse            `json:"accept_invalid_http_response,omitempty"`
	AcceptUnsafeViolationsInHttpResponse *BackendBaseAcceptUnsafeViolationsInHttpResponse `json:"accept_unsafe_violations_in_http_response,omitempty"`
	AdvCheck                             *BackendBaseAdvCheck                             `json:"adv_check,omitempty"`
	Allbackups                           *BackendBaseAllbackups                           `json:"allbackups,omitempty"`
	Balance                              *Balance                                         `json:"balance,omitempty"`
	CheckTimeout                         *int                                             `json:"check_timeout"`
	Checkcache                           *BackendBaseCheckcache                           `json:"checkcache,omitempty"`
	Compression                          *Compression                                     `json:"compression,omitempty"`
	ConnectTimeout                       *int                                             `json:"connect_timeout"`
	Cookie                               *Cookie                                          `json:"cookie,omitempty"`
	DefaultServer                        *DefaultServer                                   `json:"default_server,omitempty"`
	Description                          *string                                          `json:"description,omitempty"`
	Disabled                             *bool                                            `json:"disabled,omitempty"`
	DynamicCookieKey                     *string                                          `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert               `json:"email_alert,omitempty"`
	Enabled                  *bool                     `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile              `json:"error_files,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles             `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                 `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                 `json:"errorloc303,omitempty"`
	ExternalCheck            *BackendBaseExternalCheck `json:"external_check,omitempty"`
	ExternalCheckCommand     *string                   `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string                   `json:"external_check_path,omitempty"`

	// BackendForcePersist This field is deprecated in favor of force_persist_list, and will be removed in a future release
	BackendForcePersist *struct {
		Cond     BackendBaseForcePersistCond `json:"cond"`
		CondTest string                      `json:"cond_test"`
	} `json:"force_persist,omitempty"`
	ForcePersistList *[]struct {
		Cond     BackendBaseForcePersistListCond `json:"cond"`
		CondTest string                          `json:"cond_test"`
	} `json:"force_persist_list,omitempty"`
	Forwardfor              *Forwardfor                         `json:"forwardfor,omitempty"`
	From                    *string                             `json:"from,omitempty"`
	Fullconn                *int                                `json:"fullconn"`
	Guid                    *string                             `json:"guid,omitempty"`
	H1CaseAdjustBogusServer *BackendBaseH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor       *int                                `json:"hash_balance_factor"`
	HashPreserveAffinity    *BackendBaseHashPreserveAffinity    `json:"hash_preserve_affinity,omitempty"`
	HashType                *HashType                           `json:"hash_type,omitempty"`
	HttpBufferRequest       *BackendBaseHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpDropRequestTrailers *BackendBaseHttpDropRequestTrailers `json:"http-drop-request-trailers,omitempty"`
	HttpNoDelay             *BackendBaseHttpNoDelay             `json:"http-no-delay,omitempty"`
	HttpUseHtx              *BackendBaseHttpUseHtx              `json:"http-use-htx,omitempty"`
	HttpConnectionMode      *BackendBaseHttpConnectionMode      `json:"http_connection_mode,omitempty"`
	HttpKeepAliveTimeout    *int                                `json:"http_keep_alive_timeout"`
	HttpPretendKeepalive    *BackendBaseHttpPretendKeepalive    `json:"http_pretend_keepalive,omitempty"`
	HttpProxy               *BackendBaseHttpProxy               `json:"http_proxy,omitempty"`
	HttpRequestTimeout      *int                                `json:"http_request_timeout"`
	HttpRestrictReqHdrNames *BackendBaseHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse               *BackendBaseHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader      *string                             `json:"http_send_name_header"`
	HttpchkParams           *HttpchkParams                      `json:"httpchk_params,omitempty"`
	Id                      *int                                `json:"id"`

	// BackendIgnorePersist This field is deprecated in favor of ignore_persist_list, and will be removed in a future release
	BackendIgnorePersist *struct {
		Cond     BackendBaseIgnorePersistCond `json:"cond"`
		CondTest string                       `json:"cond_test"`
	} `json:"ignore_persist,omitempty"`
	IgnorePersistList *[]struct {
		Cond     BackendBaseIgnorePersistListCond `json:"cond"`
		CondTest string                           `json:"cond_test"`
	} `json:"ignore_persist_list,omitempty"`
	IndependentStreams      *BackendBaseIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile *BackendBaseLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogHealthChecks         *BackendBaseLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogTag                  *string                             `json:"log_tag,omitempty"`
	MaxKeepAliveQueue       *int                                `json:"max_keep_alive_queue"`
	Metadata                *map[string]map[string]interface{}  `json:"metadata,omitempty"`
	Mode                    *BackendBaseMode                    `json:"mode,omitempty"`
	MysqlCheckParams        *MysqlCheckParams                   `json:"mysql_check_params,omitempty"`
	Name                    string                              `json:"name"`
	Nolinger                *BackendBaseNolinger                `json:"nolinger,omitempty"`
	Originalto              *Originalto                         `json:"originalto,omitempty"`
	Persist                 *BackendBasePersist                 `json:"persist,omitempty"`
	PersistRule             *PersistRule                        `json:"persist_rule,omitempty"`
	PgsqlCheckParams        *PgsqlCheckParams                   `json:"pgsql_check_params,omitempty"`
	PreferLastServer        *BackendBasePreferLastServer        `json:"prefer_last_server,omitempty"`
	QueueTimeout            *int                                `json:"queue_timeout"`
	Redispatch              *Redispatch                         `json:"redispatch,omitempty"`
	Retries                 *int                                `json:"retries"`
	RetryOn                 *string                             `json:"retry_on,omitempty"`
	ServerFinTimeout        *int                                `json:"server_fin_timeout"`
	ServerStateFileName     *string                             `json:"server_state_file_name,omitempty"`
	ServerTimeout           *int                                `json:"server_timeout"`
	SmtpchkParams           *SmtpchkParams                      `json:"smtpchk_params,omitempty"`
	Source                  *Source                             `json:"source,omitempty"`
	SpliceAuto              *BackendBaseSpliceAuto              `json:"splice_auto,omitempty"`
	SpliceRequest           *BackendBaseSpliceRequest           `json:"splice_request,omitempty"`
	SpliceResponse          *BackendBaseSpliceResponse          `json:"splice_response,omitempty"`
	SpopCheck               *BackendBaseSpopCheck               `json:"spop_check,omitempty"`
	Srvtcpka                *BackendBaseSrvtcpka                `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt             *int                                `json:"srvtcpka_cnt"`
	SrvtcpkaIdle            *int                                `json:"srvtcpka_idle"`
	SrvtcpkaIntvl           *int                                `json:"srvtcpka_intvl"`
	StatsOptions            *StatsOptions                       `json:"stats_options,omitempty"`
	StickTable              *ConfigStickTable                   `json:"stick_table,omitempty"`
	TarpitTimeout           *int                                `json:"tarpit_timeout"`
	TcpSmartConnect         *BackendBaseTcpSmartConnect         `json:"tcp_smart_connect,omitempty"`
	Tcpka                   *BackendBaseTcpka                   `json:"tcpka,omitempty"`
	Transparent             *BackendBaseTransparent             `json:"transparent,omitempty"`
	TunnelTimeout           *int                                `json:"tunnel_timeout"`
	UseFcgiApp              *string                             `json:"use_fcgi_app,omitempty"`
}

// BackendBaseAbortonclose defines model for BackendBase.Abortonclose.
type BackendBaseAbortonclose string

// BackendBaseAcceptInvalidHttpResponse defines model for BackendBase.AcceptInvalidHttpResponse.
type BackendBaseAcceptInvalidHttpResponse string

// BackendBaseAcceptUnsafeViolationsInHttpResponse defines model for BackendBase.AcceptUnsafeViolationsInHttpResponse.
type BackendBaseAcceptUnsafeViolationsInHttpResponse string

// BackendBaseAdvCheck defines model for BackendBase.AdvCheck.
type BackendBaseAdvCheck string

// BackendBaseAllbackups defines model for BackendBase.Allbackups.
type BackendBaseAllbackups string

// BackendBaseCheckcache defines model for BackendBase.Checkcache.
type BackendBaseCheckcache string

// BackendBaseExternalCheck defines model for BackendBase.ExternalCheck.
type BackendBaseExternalCheck string

// BackendBaseForcePersistCond defines model for BackendBase.ForcePersist.Cond.
type BackendBaseForcePersistCond string

// BackendBaseForcePersistListCond defines model for BackendBase.ForcePersistList.Cond.
type BackendBaseForcePersistListCond string

// BackendBaseH1CaseAdjustBogusServer defines model for BackendBase.H1CaseAdjustBogusServer.
type BackendBaseH1CaseAdjustBogusServer string

// BackendBaseHashPreserveAffinity defines model for BackendBase.HashPreserveAffinity.
type BackendBaseHashPreserveAffinity string

// BackendBaseHttpBufferRequest defines model for BackendBase.HttpBufferRequest.
type BackendBaseHttpBufferRequest string

// BackendBaseHttpDropRequestTrailers defines model for BackendBase.HttpDropRequestTrailers.
type BackendBaseHttpDropRequestTrailers string

// BackendBaseHttpNoDelay defines model for BackendBase.HttpNoDelay.
type BackendBaseHttpNoDelay string

// BackendBaseHttpUseHtx defines model for BackendBase.HttpUseHtx.
type BackendBaseHttpUseHtx string

// BackendBaseHttpConnectionMode defines model for BackendBase.HttpConnectionMode.
type BackendBaseHttpConnectionMode string

// BackendBaseHttpPretendKeepalive defines model for BackendBase.HttpPretendKeepalive.
type BackendBaseHttpPretendKeepalive string

// BackendBaseHttpProxy defines model for BackendBase.HttpProxy.
type BackendBaseHttpProxy string

// BackendBaseHttpRestrictReqHdrNames defines model for BackendBase.HttpRestrictReqHdrNames.
type BackendBaseHttpRestrictReqHdrNames string

// BackendBaseHttpReuse defines model for BackendBase.HttpReuse.
type BackendBaseHttpReuse string

// BackendBaseIgnorePersistCond defines model for BackendBase.IgnorePersist.Cond.
type BackendBaseIgnorePersistCond string

// BackendBaseIgnorePersistListCond defines model for BackendBase.IgnorePersistList.Cond.
type BackendBaseIgnorePersistListCond string

// BackendBaseIndependentStreams defines model for BackendBase.IndependentStreams.
type BackendBaseIndependentStreams string

// BackendBaseLoadServerStateFromFile defines model for BackendBase.LoadServerStateFromFile.
type BackendBaseLoadServerStateFromFile string

// BackendBaseLogHealthChecks defines model for BackendBase.LogHealthChecks.
type BackendBaseLogHealthChecks string

// BackendBaseMode defines model for BackendBase.Mode.
type BackendBaseMode string

// BackendBaseNolinger defines model for BackendBase.Nolinger.
type BackendBaseNolinger string

// BackendBasePersist defines model for BackendBase.Persist.
type BackendBasePersist string

// BackendBasePreferLastServer defines model for BackendBase.PreferLastServer.
type BackendBasePreferLastServer string

// BackendBaseSpliceAuto defines model for BackendBase.SpliceAuto.
type BackendBaseSpliceAuto string

// BackendBaseSpliceRequest defines model for BackendBase.SpliceRequest.
type BackendBaseSpliceRequest string

// BackendBaseSpliceResponse defines model for BackendBase.SpliceResponse.
type BackendBaseSpliceResponse string

// BackendBaseSpopCheck defines model for BackendBase.SpopCheck.
type BackendBaseSpopCheck string

// BackendBaseSrvtcpka defines model for BackendBase.Srvtcpka.
type BackendBaseSrvtcpka string

// BackendBaseTcpSmartConnect defines model for BackendBase.TcpSmartConnect.
type BackendBaseTcpSmartConnect string

// BackendBaseTcpka defines model for BackendBase.Tcpka.
type BackendBaseTcpka string

// BackendBaseTransparent defines model for BackendBase.Transparent.
type BackendBaseTransparent string

// BackendSwitchingRule HAProxy backend switching rule configuration (corresponds to use_backend directive)
type BackendSwitchingRule struct {
	Cond     *BackendSwitchingRuleCond          `json:"cond,omitempty"`
	CondTest *string                            `json:"cond_test,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`
}

// BackendSwitchingRuleCond defines model for BackendSwitchingRule.Cond.
type BackendSwitchingRuleCond string

// BackendSwitchingRules HAProxy backend switching rules array (corresponds to use_backend directives)
type BackendSwitchingRules = []BackendSwitchingRule

// Backends HAProxy backends array
type Backends = []Backend

// Balance defines model for balance.
type Balance struct {
	Algorithm         BalanceAlgorithm `json:"algorithm"`
	HashExpression    *string          `json:"hash_expression,omitempty"`
	HdrName           *string          `json:"hdr_name,omitempty"`
	HdrUseDomainOnly  *bool            `json:"hdr_use_domain_only,omitempty"`
	RandomDraws       *int             `json:"random_draws,omitempty"`
	RdpCookieName     *string          `json:"rdp_cookie_name,omitempty"`
	UriDepth          *int             `json:"uri_depth,omitempty"`
	UriLen            *int             `json:"uri_len,omitempty"`
	UriPathOnly       *bool            `json:"uri_path_only,omitempty"`
	UriWhole          *bool            `json:"uri_whole,omitempty"`
	UrlParam          *string          `json:"url_param,omitempty"`
	UrlParamCheckPost *int             `json:"url_param_check_post,omitempty"`
	UrlParamMaxWait   *int             `json:"url_param_max_wait,omitempty"`
}

// BalanceAlgorithm defines model for Balance.Algorithm.
type BalanceAlgorithm string

// Bind defines model for bind.
type Bind struct {
	AcceptNetscalerCip *int      `json:"accept_netscaler_cip,omitempty"`
	AcceptProxy        *bool     `json:"accept_proxy,omitempty"`
	Address            *string   `json:"address,omitempty"`
	Allow0rtt          *bool     `json:"allow_0rtt,omitempty"`
	Alpn               *string   `json:"alpn,omitempty"`
	Backlog            *string   `json:"backlog,omitempty"`
	CaIgnoreErr        *string   `json:"ca_ignore_err,omitempty"`
	CaSignFile         *string   `json:"ca_sign_file,omitempty"`
	CaSignPass         *string   `json:"ca_sign_pass,omitempty"`
	CaVerifyFile       *string   `json:"ca_verify_file,omitempty"`
	Ciphers            *string   `json:"ciphers,omitempty"`
	Ciphersuites       *string   `json:"ciphersuites,omitempty"`
	ClientSigalgs      *string   `json:"client_sigalgs,omitempty"`
	CrlFile            *string   `json:"crl_file,omitempty"`
	CrtIgnoreErr       *string   `json:"crt_ignore_err,omitempty"`
	CrtList            *string   `json:"crt_list,omitempty"`
	Curves             *string   `json:"curves,omitempty"`
	DefaultCrtList     *[]string `json:"default_crt_list,omitempty"`
	DeferAccept        *bool     `json:"defer_accept,omitempty"`
	Ecdhe              *string   `json:"ecdhe,omitempty"`
	ExposeFdListeners  *bool     `json:"expose_fd_listeners,omitempty"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3     *bool               `json:"force_sslv3,omitempty"`
	ForceStrictSni *BindForceStrictSni `json:"force_strict_sni,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *bool `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *bool `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *bool `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13          *bool                              `json:"force_tlsv13,omitempty"`
	GenerateCertificates *bool                              `json:"generate_certificates,omitempty"`
	Gid                  *int                               `json:"gid,omitempty"`
	Group                *string                            `json:"group,omitempty"`
	GuidPrefix           *string                            `json:"guid_prefix,omitempty"`
	Id                   *string                            `json:"id,omitempty"`
	IdlePing             *int                               `json:"idle_ping"`
	Interface            *string                            `json:"interface,omitempty"`
	Level                *BindLevel                         `json:"level,omitempty"`
	Maxconn              *int                               `json:"maxconn,omitempty"`
	Metadata             *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Mode                 *string                            `json:"mode,omitempty"`
	Mss                  *string                            `json:"mss,omitempty"`
	Name                 *string                            `json:"name,omitempty"`
	Namespace            *string                            `json:"namespace,omitempty"`
	Nbconn               *int                               `json:"nbconn,omitempty"`
	Nice                 *int                               `json:"nice,omitempty"`
	NoAlpn               *bool                              `json:"no_alpn,omitempty"`
	NoCaNames            *bool                              `json:"no_ca_names,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3     *bool `json:"no_sslv3,omitempty"`
	NoStrictSni *bool `json:"no_strict_sni,omitempty"`

	// NoTlsTickets This field is deprecated in favor of tls_tickets, and will be removed in a future release
	NoTlsTickets *bool `json:"no_tls_tickets,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *bool `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *bool `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *bool `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	NoTlsv13            *bool               `json:"no_tlsv13,omitempty"`
	Npn                 *string             `json:"npn,omitempty"`
	Port                *int                `json:"port"`
	PortRangeEnd        *int                `json:"port-range-end"`
	PreferClientCiphers *bool               `json:"prefer_client_ciphers,omitempty"`
	Proto               *string             `json:"proto,omitempty"`
	QuicCcAlgo          *BindQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
	QuicForceRetry      *bool               `json:"quic-force-retry,omitempty"`
	QuicSocket          *BindQuicSocket     `json:"quic-socket,omitempty"`
	QuicCcAlgoBurstSize *int                `json:"quic_cc_algo_burst_size"`
	QuicCcAlgoMaxWindow *int                `json:"quic_cc_algo_max_window"`
	SeverityOutput      *BindSeverityOutput `json:"severity_output,omitempty"`
	Sigalgs             *string             `json:"sigalgs,omitempty"`
	Ssl                 *bool               `json:"ssl,omitempty"`
	SslCafile           *string             `json:"ssl_cafile,omitempty"`
	SslCertificate      *string             `json:"ssl_certificate,omitempty"`
	SslMaxVer           *BindSslMaxVer      `json:"ssl_max_ver,omitempty"`
	SslMinVer           *BindSslMinVer      `json:"ssl_min_ver,omitempty"`
	Sslv3               *BindSslv3          `json:"sslv3,omitempty"`
	StrictSni           *bool               `json:"strict_sni,omitempty"`
	TcpUserTimeout      *int                `json:"tcp_user_timeout"`
	Tfo                 *bool               `json:"tfo,omitempty"`
	Thread              *string             `json:"thread,omitempty"`
	TlsTicketKeys       *string             `json:"tls_ticket_keys,omitempty"`
	TlsTickets          *BindTlsTickets     `json:"tls_tickets,omitempty"`
	Tlsv10              *BindTlsv10         `json:"tlsv10,omitempty"`
	Tlsv11              *BindTlsv11         `json:"tlsv11,omitempty"`
	Tlsv12              *BindTlsv12         `json:"tlsv12,omitempty"`
	Tlsv13              *BindTlsv13         `json:"tlsv13,omitempty"`
	Transparent         *bool               `json:"transparent,omitempty"`
	Uid                 *string             `json:"uid,omitempty"`
	User                *string             `json:"user,omitempty"`
	V4v6                *bool               `json:"v4v6,omitempty"`
	V6only              *bool               `json:"v6only,omitempty"`
	Verify              *BindVerify         `json:"verify,omitempty"`
}

// BindForceStrictSni defines model for Bind.ForceStrictSni.
type BindForceStrictSni string

// BindLevel defines model for Bind.Level.
type BindLevel string

// BindQuicCcAlgo defines model for Bind.QuicCcAlgo.
type BindQuicCcAlgo string

// BindQuicSocket defines model for Bind.QuicSocket.
type BindQuicSocket string

// BindSeverityOutput defines model for Bind.SeverityOutput.
type BindSeverityOutput string

// BindSslMaxVer defines model for Bind.SslMaxVer.
type BindSslMaxVer string

// BindSslMinVer defines model for Bind.SslMinVer.
type BindSslMinVer string

// BindSslv3 defines model for Bind.Sslv3.
type BindSslv3 string

// BindTlsTickets defines model for Bind.TlsTickets.
type BindTlsTickets string

// BindTlsv10 defines model for Bind.Tlsv10.
type BindTlsv10 string

// BindTlsv11 defines model for Bind.Tlsv11.
type BindTlsv11 string

// BindTlsv12 defines model for Bind.Tlsv12.
type BindTlsv12 string

// BindTlsv13 defines model for Bind.Tlsv13.
type BindTlsv13 string

// BindVerify defines model for Bind.Verify.
type BindVerify string

// BindParams defines model for bind_params.
type BindParams struct {
	AcceptNetscalerCip *int      `json:"accept_netscaler_cip,omitempty"`
	AcceptProxy        *bool     `json:"accept_proxy,omitempty"`
	Allow0rtt          *bool     `json:"allow_0rtt,omitempty"`
	Alpn               *string   `json:"alpn,omitempty"`
	Backlog            *string   `json:"backlog,omitempty"`
	CaIgnoreErr        *string   `json:"ca_ignore_err,omitempty"`
	CaSignFile         *string   `json:"ca_sign_file,omitempty"`
	CaSignPass         *string   `json:"ca_sign_pass,omitempty"`
	CaVerifyFile       *string   `json:"ca_verify_file,omitempty"`
	Ciphers            *string   `json:"ciphers,omitempty"`
	Ciphersuites       *string   `json:"ciphersuites,omitempty"`
	ClientSigalgs      *string   `json:"client_sigalgs,omitempty"`
	CrlFile            *string   `json:"crl_file,omitempty"`
	CrtIgnoreErr       *string   `json:"crt_ignore_err,omitempty"`
	CrtList            *string   `json:"crt_list,omitempty"`
	Curves             *string   `json:"curves,omitempty"`
	DefaultCrtList     *[]string `json:"default_crt_list,omitempty"`
	DeferAccept        *bool     `json:"defer_accept,omitempty"`
	Ecdhe              *string   `json:"ecdhe,omitempty"`
	ExposeFdListeners  *bool     `json:"expose_fd_listeners,omitempty"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3     *bool                     `json:"force_sslv3,omitempty"`
	ForceStrictSni *BindParamsForceStrictSni `json:"force_strict_sni,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *bool `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *bool `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *bool `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13          *bool            `json:"force_tlsv13,omitempty"`
	GenerateCertificates *bool            `json:"generate_certificates,omitempty"`
	Gid                  *int             `json:"gid,omitempty"`
	Group                *string          `json:"group,omitempty"`
	GuidPrefix           *string          `json:"guid_prefix,omitempty"`
	Id                   *string          `json:"id,omitempty"`
	IdlePing             *int             `json:"idle_ping"`
	Interface            *string          `json:"interface,omitempty"`
	Level                *BindParamsLevel `json:"level,omitempty"`
	Maxconn              *int             `json:"maxconn,omitempty"`
	Mode                 *string          `json:"mode,omitempty"`
	Mss                  *string          `json:"mss,omitempty"`
	Name                 *string          `json:"name,omitempty"`
	Namespace            *string          `json:"namespace,omitempty"`
	Nbconn               *int             `json:"nbconn,omitempty"`
	Nice                 *int             `json:"nice,omitempty"`
	NoAlpn               *bool            `json:"no_alpn,omitempty"`
	NoCaNames            *bool            `json:"no_ca_names,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3     *bool `json:"no_sslv3,omitempty"`
	NoStrictSni *bool `json:"no_strict_sni,omitempty"`

	// NoTlsTickets This field is deprecated in favor of tls_tickets, and will be removed in a future release
	NoTlsTickets *bool `json:"no_tls_tickets,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *bool `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *bool `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *bool `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	NoTlsv13            *bool                     `json:"no_tlsv13,omitempty"`
	Npn                 *string                   `json:"npn,omitempty"`
	PreferClientCiphers *bool                     `json:"prefer_client_ciphers,omitempty"`
	Proto               *string                   `json:"proto,omitempty"`
	QuicCcAlgo          *BindParamsQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
	QuicForceRetry      *bool                     `json:"quic-force-retry,omitempty"`
	QuicSocket          *BindParamsQuicSocket     `json:"quic-socket,omitempty"`
	QuicCcAlgoBurstSize *int                      `json:"quic_cc_algo_burst_size"`
	QuicCcAlgoMaxWindow *int                      `json:"quic_cc_algo_max_window"`
	SeverityOutput      *BindParamsSeverityOutput `json:"severity_output,omitempty"`
	Sigalgs             *string                   `json:"sigalgs,omitempty"`
	Ssl                 *bool                     `json:"ssl,omitempty"`
	SslCafile           *string                   `json:"ssl_cafile,omitempty"`
	SslCertificate      *string                   `json:"ssl_certificate,omitempty"`
	SslMaxVer           *BindParamsSslMaxVer      `json:"ssl_max_ver,omitempty"`
	SslMinVer           *BindParamsSslMinVer      `json:"ssl_min_ver,omitempty"`
	Sslv3               *BindParamsSslv3          `json:"sslv3,omitempty"`
	StrictSni           *bool                     `json:"strict_sni,omitempty"`
	TcpUserTimeout      *int                      `json:"tcp_user_timeout"`
	Tfo                 *bool                     `json:"tfo,omitempty"`
	Thread              *string                   `json:"thread,omitempty"`
	TlsTicketKeys       *string                   `json:"tls_ticket_keys,omitempty"`
	TlsTickets          *BindParamsTlsTickets     `json:"tls_tickets,omitempty"`
	Tlsv10              *BindParamsTlsv10         `json:"tlsv10,omitempty"`
	Tlsv11              *BindParamsTlsv11         `json:"tlsv11,omitempty"`
	Tlsv12              *BindParamsTlsv12         `json:"tlsv12,omitempty"`
	Tlsv13              *BindParamsTlsv13         `json:"tlsv13,omitempty"`
	Transparent         *bool                     `json:"transparent,omitempty"`
	Uid                 *string                   `json:"uid,omitempty"`
	User                *string                   `json:"user,omitempty"`
	V4v6                *bool                     `json:"v4v6,omitempty"`
	V6only              *bool                     `json:"v6only,omitempty"`
	Verify              *BindParamsVerify         `json:"verify,omitempty"`
}

// BindParamsForceStrictSni defines model for BindParams.ForceStrictSni.
type BindParamsForceStrictSni string

// BindParamsLevel defines model for BindParams.Level.
type BindParamsLevel string

// BindParamsQuicCcAlgo defines model for BindParams.QuicCcAlgo.
type BindParamsQuicCcAlgo string

// BindParamsQuicSocket defines model for BindParams.QuicSocket.
type BindParamsQuicSocket string

// BindParamsSeverityOutput defines model for BindParams.SeverityOutput.
type BindParamsSeverityOutput string

// BindParamsSslMaxVer defines model for BindParams.SslMaxVer.
type BindParamsSslMaxVer string

// BindParamsSslMinVer defines model for BindParams.SslMinVer.
type BindParamsSslMinVer string

// BindParamsSslv3 defines model for BindParams.Sslv3.
type BindParamsSslv3 string

// BindParamsTlsTickets defines model for BindParams.TlsTickets.
type BindParamsTlsTickets string

// BindParamsTlsv10 defines model for BindParams.Tlsv10.
type BindParamsTlsv10 string

// BindParamsTlsv11 defines model for BindParams.Tlsv11.
type BindParamsTlsv11 string

// BindParamsTlsv12 defines model for BindParams.Tlsv12.
type BindParamsTlsv12 string

// BindParamsTlsv13 defines model for BindParams.Tlsv13.
type BindParamsTlsv13 string

// BindParamsVerify defines model for BindParams.Verify.
type BindParamsVerify string

// Binds HAProxy frontend binds array (corresponds to bind directives)
type Binds = []Bind

// Cache HAPRoxy Cache section
type Cache struct {
	MaxAge              *int                               `json:"max_age,omitempty"`
	MaxObjectSize       *int                               `json:"max_object_size,omitempty"`
	MaxSecondaryEntries *int                               `json:"max_secondary_entries,omitempty"`
	Metadata            *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name                string                             `json:"name"`
	ProcessVary         *bool                              `json:"process_vary"`
	TotalMaxSize        *int                               `json:"total_max_size,omitempty"`
}

// Caches HAProxy caches array
type Caches = []Cache

// Capture defines model for capture.
type Capture struct {
	Length   int                                `json:"length"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Type     CaptureType                        `json:"type"`
}

// CaptureType defines model for Capture.Type.
type CaptureType string

// Captures defines model for captures.
type Captures = []Capture

// ClusterSettings Settings related to a cluster.
type ClusterSettings struct {
	BootstrapKey *string `json:"bootstrap_key,omitempty"`
	Cluster      *struct {
		Address           *string `json:"address,omitempty"`
		ApiBasePath       *string `json:"api_base_path,omitempty"`
		ClusterId         *string `json:"cluster_id,omitempty"`
		Description       *string `json:"description,omitempty"`
		ClusterLogTargets *[]struct {
			Address   string                                   `json:"address"`
			LogFormat *string                                  `json:"log_format,omitempty"`
			Port      int                                      `json:"port"`
			Protocol  ClusterSettingsClusterLogTargetsProtocol `json:"protocol"`
		} `json:"log_targets,omitempty"`
		Name *string `json:"name,omitempty"`
		Port *int    `json:"port"`
	} `json:"cluster,omitempty"`
	Mode   *ClusterSettingsMode   `json:"mode,omitempty"`
	Status *ClusterSettingsStatus `json:"status,omitempty"`
}

// ClusterSettingsClusterLogTargetsProtocol defines model for ClusterSettings.Cluster.LogTargets.Protocol.
type ClusterSettingsClusterLogTargetsProtocol string

// ClusterSettingsMode defines model for ClusterSettings.Mode.
type ClusterSettingsMode string

// ClusterSettingsStatus defines model for ClusterSettings.Status.
type ClusterSettingsStatus string

// Compression defines model for compression.
type Compression struct {
	AlgoReq    *CompressionAlgoReq      `json:"algo-req,omitempty"`
	Algorithms *[]CompressionAlgorithms `json:"algorithms,omitempty"`
	AlgosRes   *[]CompressionAlgosRes   `json:"algos-res,omitempty"`
	Direction  *CompressionDirection    `json:"direction,omitempty"`
	MinsizeReq *int                     `json:"minsize_req,omitempty"`
	MinsizeRes *int                     `json:"minsize_res,omitempty"`
	Offload    *bool                    `json:"offload,omitempty"`
	Types      *[]string                `json:"types,omitempty"`
	TypesReq   *[]string                `json:"types-req,omitempty"`
	TypesRes   *[]string                `json:"types-res,omitempty"`
}

// CompressionAlgoReq defines model for Compression.AlgoReq.
type CompressionAlgoReq string

// CompressionAlgorithms defines model for Compression.Algorithms.
type CompressionAlgorithms string

// CompressionAlgosRes defines model for Compression.AlgosRes.
type CompressionAlgosRes string

// CompressionDirection defines model for Compression.Direction.
type CompressionDirection string

// ConfigStickTable defines model for config_stick_table.
type ConfigStickTable struct {
	Expire   *int                               `json:"expire"`
	Keylen   *int                               `json:"keylen"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Nopurge  *bool                              `json:"nopurge,omitempty"`
	Peers    *string                            `json:"peers,omitempty"`
	RecvOnly *bool                              `json:"recv_only,omitempty"`
	Size     *int                               `json:"size"`
	Srvkey   *ConfigStickTableSrvkey            `json:"srvkey"`
	Store    *string                            `json:"store,omitempty"`
	Type     *ConfigStickTableType              `json:"type,omitempty"`
	WriteTo  *string                            `json:"write_to"`
}

// ConfigStickTableSrvkey defines model for ConfigStickTable.Srvkey.
type ConfigStickTableSrvkey string

// ConfigStickTableType defines model for ConfigStickTable.Type.
type ConfigStickTableType string

// Consul Consul server configuration
type Consul struct {
	Address string `json:"address"`

	// Defaults Name of the defaults section to be used in backends created by this service
	Defaults    *string `json:"defaults,omitempty"`
	Description *string `json:"description,omitempty"`
	Enabled     bool    `json:"enabled"`

	// HealthCheckPolicy Defines the health check conditions required for each node to be considered valid for the service.
	//   none: all nodes are considered valid
	//   any: a node is considered valid if any one health check is 'passing'
	//   all: a node is considered valid if all health checks are 'passing'
	//   min: a node is considered valid if the number of 'passing' checks is greater or equal to the 'health_check_policy_min' value.
	//     If the node has less health checks configured then 'health_check_policy_min' it is considered invalid.
	HealthCheckPolicy    *ConsulHealthCheckPolicy `json:"health_check_policy,omitempty"`
	HealthCheckPolicyMin *int                     `json:"health_check_policy_min,omitempty"`

	// Id Auto generated ID.
	Id        *string     `json:"id"`
	Mode      *ConsulMode `json:"mode,omitempty"`
	Name      *string     `json:"name,omitempty"`
	Namespace *string     `json:"namespace,omitempty"`
	Port      int         `json:"port"`

	// RetryTimeout Duration in seconds in-between data pulling requests to the consul server
	RetryTimeout               int                          `json:"retry_timeout"`
	ServerSlotsBase            *int                         `json:"server_slots_base,omitempty"`
	ServerSlotsGrowthIncrement *int                         `json:"server_slots_growth_increment,omitempty"`
	ServerSlotsGrowthType      *ConsulServerSlotsGrowthType `json:"server_slots_growth_type,omitempty"`
	ServiceAllowlist           *[]string                    `json:"service_allowlist,omitempty"`
	ServiceDenylist            *[]string                    `json:"service_denylist,omitempty"`

	// ServiceNameRegexp Regular expression used to filter services by name.
	ServiceNameRegexp *string `json:"service_name_regexp,omitempty"`
	Token             *string `json:"token,omitempty"`
}

// ConsulHealthCheckPolicy Defines the health check conditions required for each node to be considered valid for the service.
//
//	none: all nodes are considered valid
//	any: a node is considered valid if any one health check is 'passing'
//	all: a node is considered valid if all health checks are 'passing'
//	min: a node is considered valid if the number of 'passing' checks is greater or equal to the 'health_check_policy_min' value.
//	  If the node has less health checks configured then 'health_check_policy_min' it is considered invalid.
type ConsulHealthCheckPolicy string

// ConsulMode defines model for Consul.Mode.
type ConsulMode string

// ConsulServerSlotsGrowthType defines model for Consul.ServerSlotsGrowthType.
type ConsulServerSlotsGrowthType string

// Consuls Consuls array
type Consuls = []Consul

// Cookie defines model for cookie.
type Cookie struct {
	Attrs *[]struct {
		Value *string `json:"value,omitempty"`
	} `json:"attr,omitempty"`
	Domains *[]struct {
		Value *string `json:"value,omitempty"`
	} `json:"domain,omitempty"`
	Dynamic  *bool       `json:"dynamic,omitempty"`
	Httponly *bool       `json:"httponly,omitempty"`
	Indirect *bool       `json:"indirect,omitempty"`
	Maxidle  *int        `json:"maxidle,omitempty"`
	Maxlife  *int        `json:"maxlife,omitempty"`
	Name     string      `json:"name"`
	Nocache  *bool       `json:"nocache,omitempty"`
	Postonly *bool       `json:"postonly,omitempty"`
	Preserve *bool       `json:"preserve,omitempty"`
	Secure   *bool       `json:"secure,omitempty"`
	Type     *CookieType `json:"type,omitempty"`
}

// CookieType defines model for Cookie.Type.
type CookieType string

// CrtLoad Loads a certificate from a store with options
type CrtLoad struct {
	// Acme ACME section name to use
	Acme *string `json:"acme,omitempty"`

	// Alias Certificate alias
	Alias *string `json:"alias,omitempty"`

	// Certificate Certificate filename
	Certificate string `json:"certificate"`

	// Domains List of domains used to generate the certificate with ACME
	Domains *[]string `json:"domains,omitempty"`

	// Issuer OCSP issuer filename
	Issuer *string `json:"issuer,omitempty"`

	// Key Private key filename
	Key      *string                            `json:"key,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`

	// Ocsp OCSP response filename
	Ocsp *string `json:"ocsp,omitempty"`

	// OcspUpdate Automatic OCSP response update
	OcspUpdate *CrtLoadOcspUpdate `json:"ocsp_update,omitempty"`

	// Sctl Signed Certificate Timestamp List filename
	Sctl *string `json:"sctl,omitempty"`
}

// CrtLoadOcspUpdate Automatic OCSP response update
type CrtLoadOcspUpdate string

// CrtLoads List of certificates to load from a Certificate Store
type CrtLoads = []CrtLoad

// CrtStore Storage mechanism to load and store certificates used in the configuration
type CrtStore struct {
	// CrtBase Default directory to fetch SSL certificates from
	CrtBase *string `json:"crt_base,omitempty"`

	// KeyBase Default directory to fetch SSL private keys from
	KeyBase *string `json:"key_base,omitempty"`

	// Loads List of certificates to load from a Certificate Store
	Loads    *CrtLoads                          `json:"loads,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`
}

// CrtStores List of Certificate Stores
type CrtStores = []CrtStore

// DebugOptions defines model for debug_options.
type DebugOptions struct {
	Anonkey     *int  `json:"anonkey"`
	Quiet       *bool `json:"quiet,omitempty"`
	StressLevel *int  `json:"stress_level"`
	ZeroWarning *bool `json:"zero_warning,omitempty"`
}

// DefaultBind defines model for default_bind.
type DefaultBind struct {
	AcceptNetscalerCip *int      `json:"accept_netscaler_cip,omitempty"`
	AcceptProxy        *bool     `json:"accept_proxy,omitempty"`
	Allow0rtt          *bool     `json:"allow_0rtt,omitempty"`
	Alpn               *string   `json:"alpn,omitempty"`
	Backlog            *string   `json:"backlog,omitempty"`
	CaIgnoreErr        *string   `json:"ca_ignore_err,omitempty"`
	CaSignFile         *string   `json:"ca_sign_file,omitempty"`
	CaSignPass         *string   `json:"ca_sign_pass,omitempty"`
	CaVerifyFile       *string   `json:"ca_verify_file,omitempty"`
	Ciphers            *string   `json:"ciphers,omitempty"`
	Ciphersuites       *string   `json:"ciphersuites,omitempty"`
	ClientSigalgs      *string   `json:"client_sigalgs,omitempty"`
	CrlFile            *string   `json:"crl_file,omitempty"`
	CrtIgnoreErr       *string   `json:"crt_ignore_err,omitempty"`
	CrtList            *string   `json:"crt_list,omitempty"`
	Curves             *string   `json:"curves,omitempty"`
	DefaultCrtList     *[]string `json:"default_crt_list,omitempty"`
	DeferAccept        *bool     `json:"defer_accept,omitempty"`
	Ecdhe              *string   `json:"ecdhe,omitempty"`
	ExposeFdListeners  *bool     `json:"expose_fd_listeners,omitempty"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3     *bool                      `json:"force_sslv3,omitempty"`
	ForceStrictSni *DefaultBindForceStrictSni `json:"force_strict_sni,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *bool `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *bool `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *bool `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13          *bool                              `json:"force_tlsv13,omitempty"`
	GenerateCertificates *bool                              `json:"generate_certificates,omitempty"`
	Gid                  *int                               `json:"gid,omitempty"`
	Group                *string                            `json:"group,omitempty"`
	GuidPrefix           *string                            `json:"guid_prefix,omitempty"`
	Id                   *string                            `json:"id,omitempty"`
	IdlePing             *int                               `json:"idle_ping"`
	Interface            *string                            `json:"interface,omitempty"`
	Level                *DefaultBindLevel                  `json:"level,omitempty"`
	Maxconn              *int                               `json:"maxconn,omitempty"`
	Metadata             *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Mode                 *string                            `json:"mode,omitempty"`
	Mss                  *string                            `json:"mss,omitempty"`
	Name                 *string                            `json:"name,omitempty"`
	Namespace            *string                            `json:"namespace,omitempty"`
	Nbconn               *int                               `json:"nbconn,omitempty"`
	Nice                 *int                               `json:"nice,omitempty"`
	NoAlpn               *bool                              `json:"no_alpn,omitempty"`
	NoCaNames            *bool                              `json:"no_ca_names,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3     *bool `json:"no_sslv3,omitempty"`
	NoStrictSni *bool `json:"no_strict_sni,omitempty"`

	// NoTlsTickets This field is deprecated in favor of tls_tickets, and will be removed in a future release
	NoTlsTickets *bool `json:"no_tls_tickets,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *bool `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *bool `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *bool `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	NoTlsv13            *bool                      `json:"no_tlsv13,omitempty"`
	Npn                 *string                    `json:"npn,omitempty"`
	PreferClientCiphers *bool                      `json:"prefer_client_ciphers,omitempty"`
	Proto               *string                    `json:"proto,omitempty"`
	QuicCcAlgo          *DefaultBindQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
	QuicForceRetry      *bool                      `json:"quic-force-retry,omitempty"`
	QuicSocket          *DefaultBindQuicSocket     `json:"quic-socket,omitempty"`
	QuicCcAlgoBurstSize *int                       `json:"quic_cc_algo_burst_size"`
	QuicCcAlgoMaxWindow *int                       `json:"quic_cc_algo_max_window"`
	SeverityOutput      *DefaultBindSeverityOutput `json:"severity_output,omitempty"`
	Sigalgs             *string                    `json:"sigalgs,omitempty"`
	Ssl                 *bool                      `json:"ssl,omitempty"`
	SslCafile           *string                    `json:"ssl_cafile,omitempty"`
	SslCertificate      *string                    `json:"ssl_certificate,omitempty"`
	SslMaxVer           *DefaultBindSslMaxVer      `json:"ssl_max_ver,omitempty"`
	SslMinVer           *DefaultBindSslMinVer      `json:"ssl_min_ver,omitempty"`
	Sslv3               *DefaultBindSslv3          `json:"sslv3,omitempty"`
	StrictSni           *bool                      `json:"strict_sni,omitempty"`
	TcpUserTimeout      *int                       `json:"tcp_user_timeout"`
	Tfo                 *bool                      `json:"tfo,omitempty"`
	Thread              *string                    `json:"thread,omitempty"`
	TlsTicketKeys       *string                    `json:"tls_ticket_keys,omitempty"`
	TlsTickets          *DefaultBindTlsTickets     `json:"tls_tickets,omitempty"`
	Tlsv10              *DefaultBindTlsv10         `json:"tlsv10,omitempty"`
	Tlsv11              *DefaultBindTlsv11         `json:"tlsv11,omitempty"`
	Tlsv12              *DefaultBindTlsv12         `json:"tlsv12,omitempty"`
	Tlsv13              *DefaultBindTlsv13         `json:"tlsv13,omitempty"`
	Transparent         *bool                      `json:"transparent,omitempty"`
	Uid                 *string                    `json:"uid,omitempty"`
	User                *string                    `json:"user,omitempty"`
	V4v6                *bool                      `json:"v4v6,omitempty"`
	V6only              *bool                      `json:"v6only,omitempty"`
	Verify              *DefaultBindVerify         `json:"verify,omitempty"`
}

// DefaultBindForceStrictSni defines model for DefaultBind.ForceStrictSni.
type DefaultBindForceStrictSni string

// DefaultBindLevel defines model for DefaultBind.Level.
type DefaultBindLevel string

// DefaultBindQuicCcAlgo defines model for DefaultBind.QuicCcAlgo.
type DefaultBindQuicCcAlgo string

// DefaultBindQuicSocket defines model for DefaultBind.QuicSocket.
type DefaultBindQuicSocket string

// DefaultBindSeverityOutput defines model for DefaultBind.SeverityOutput.
type DefaultBindSeverityOutput string

// DefaultBindSslMaxVer defines model for DefaultBind.SslMaxVer.
type DefaultBindSslMaxVer string

// DefaultBindSslMinVer defines model for DefaultBind.SslMinVer.
type DefaultBindSslMinVer string

// DefaultBindSslv3 defines model for DefaultBind.Sslv3.
type DefaultBindSslv3 string

// DefaultBindTlsTickets defines model for DefaultBind.TlsTickets.
type DefaultBindTlsTickets string

// DefaultBindTlsv10 defines model for DefaultBind.Tlsv10.
type DefaultBindTlsv10 string

// DefaultBindTlsv11 defines model for DefaultBind.Tlsv11.
type DefaultBindTlsv11 string

// DefaultBindTlsv12 defines model for DefaultBind.Tlsv12.
type DefaultBindTlsv12 string

// DefaultBindTlsv13 defines model for DefaultBind.Tlsv13.
type DefaultBindTlsv13 string

// DefaultBindVerify defines model for DefaultBind.Verify.
type DefaultBindVerify string

// DefaultServer defines model for default_server.
type DefaultServer = ServerParams

// Defaults defines model for defaults.
type Defaults struct {
	Abortonclose                         *DefaultsAbortonclose                         `json:"abortonclose,omitempty"`
	AcceptInvalidHttpRequest             *DefaultsAcceptInvalidHttpRequest             `json:"accept_invalid_http_request,omitempty"`
	AcceptInvalidHttpResponse            *DefaultsAcceptInvalidHttpResponse            `json:"accept_invalid_http_response,omitempty"`
	AcceptUnsafeViolationsInHttpRequest  *DefaultsAcceptUnsafeViolationsInHttpRequest  `json:"accept_unsafe_violations_in_http_request,omitempty"`
	AcceptUnsafeViolationsInHttpResponse *DefaultsAcceptUnsafeViolationsInHttpResponse `json:"accept_unsafe_violations_in_http_response,omitempty"`

	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList          *Acls                     `json:"acl_list,omitempty"`
	AdvCheck         *DefaultsAdvCheck         `json:"adv_check,omitempty"`
	Allbackups       *DefaultsAllbackups       `json:"allbackups,omitempty"`
	Backlog          *int                      `json:"backlog"`
	Balance          *Balance                  `json:"balance,omitempty"`
	CheckTimeout     *int                      `json:"check_timeout"`
	Checkcache       *DefaultsCheckcache       `json:"checkcache,omitempty"`
	Clflog           *bool                     `json:"clflog,omitempty"`
	ClientFinTimeout *int                      `json:"client_fin_timeout"`
	ClientTimeout    *int                      `json:"client_timeout"`
	Clitcpka         *DefaultsClitcpka         `json:"clitcpka,omitempty"`
	ClitcpkaCnt      *int                      `json:"clitcpka_cnt"`
	ClitcpkaIdle     *int                      `json:"clitcpka_idle"`
	ClitcpkaIntvl    *int                      `json:"clitcpka_intvl"`
	Compression      *Compression              `json:"compression,omitempty"`
	ConnectTimeout   *int                      `json:"connect_timeout"`
	Contstats        *DefaultsContstats        `json:"contstats,omitempty"`
	Cookie           *Cookie                   `json:"cookie,omitempty"`
	DefaultBackend   *string                   `json:"default_backend,omitempty"`
	DefaultServer    *DefaultServer            `json:"default_server,omitempty"`
	DisableH2Upgrade *DefaultsDisableH2Upgrade `json:"disable_h2_upgrade,omitempty"`
	Disabled         *bool                     `json:"disabled,omitempty"`
	DontlogNormal    *DefaultsDontlogNormal    `json:"dontlog_normal,omitempty"`
	Dontlognull      *DefaultsDontlognull      `json:"dontlognull,omitempty"`
	DynamicCookieKey *string                   `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert                       `json:"email_alert,omitempty"`
	Enabled                  *bool                             `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile                      `json:"error_files,omitempty"`
	ErrorLogFormat           *string                           `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles                     `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                         `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                         `json:"errorloc303,omitempty"`
	ExternalCheck            *DefaultsExternalCheck            `json:"external_check,omitempty"`
	ExternalCheckCommand     *string                           `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string                           `json:"external_check_path,omitempty"`
	Forwardfor               *Forwardfor                       `json:"forwardfor,omitempty"`
	From                     *string                           `json:"from,omitempty"`
	Fullconn                 *int                              `json:"fullconn"`
	H1CaseAdjustBogusClient  *DefaultsH1CaseAdjustBogusClient  `json:"h1_case_adjust_bogus_client,omitempty"`
	H1CaseAdjustBogusServer  *DefaultsH1CaseAdjustBogusServer  `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor        *int                              `json:"hash_balance_factor"`
	HashPreserveAffinity     *DefaultsHashPreserveAffinity     `json:"hash_preserve_affinity,omitempty"`
	HashType                 *HashType                         `json:"hash_type,omitempty"`
	HttpBufferRequest        *DefaultsHttpBufferRequest        `json:"http-buffer-request,omitempty"`
	HttpDropRequestTrailers  *DefaultsHttpDropRequestTrailers  `json:"http-drop-request-trailers,omitempty"`
	HttpDropResponseTrailers *DefaultsHttpDropResponseTrailers `json:"http-drop-response-trailers,omitempty"`
	HttpUseHtx               *DefaultsHttpUseHtx               `json:"http-use-htx,omitempty"`

	// HttpAfterResponseRuleList HAProxy HTTP after response rules array (corresponds to http-after-response directives)
	HttpAfterResponseRuleList *HttpAfterResponseRules     `json:"http_after_response_rule_list,omitempty"`
	HttpCheckList             *HttpChecks                 `json:"http_check_list,omitempty"`
	HttpConnectionMode        *DefaultsHttpConnectionMode `json:"http_connection_mode,omitempty"`

	// HttpErrorRuleList HAProxy HTTP error rules array (corresponds to http-error directives)
	HttpErrorRuleList    *HttpErrorRules               `json:"http_error_rule_list,omitempty"`
	HttpIgnoreProbes     *DefaultsHttpIgnoreProbes     `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout *int                          `json:"http_keep_alive_timeout"`
	HttpNoDelay          *DefaultsHttpNoDelay          `json:"http_no_delay,omitempty"`
	HttpPretendKeepalive *DefaultsHttpPretendKeepalive `json:"http_pretend_keepalive,omitempty"`

	// HttpRequestRuleList HAProxy HTTP request rules array (corresponds to http-request directives)
	HttpRequestRuleList *HttpRequestRules `json:"http_request_rule_list,omitempty"`
	HttpRequestTimeout  *int              `json:"http_request_timeout"`

	// HttpResponseRuleList HAProxy HTTP response rules array (corresponds to http-response directives)
	HttpResponseRuleList    *HttpResponseRules               `json:"http_response_rule_list,omitempty"`
	HttpRestrictReqHdrNames *DefaultsHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse               *DefaultsHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader      *string                          `json:"http_send_name_header"`
	HttpUseProxyHeader      *DefaultsHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	HttpchkParams           *HttpchkParams                   `json:"httpchk_params,omitempty"`
	Httplog                 *bool                            `json:"httplog,omitempty"`
	Httpslog                *DefaultsHttpslog                `json:"httpslog,omitempty"`
	IdleCloseOnResponse     *DefaultsIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams      *DefaultsIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile *DefaultsLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogFormat               *string                          `json:"log_format,omitempty"`
	LogFormatSd             *string                          `json:"log_format_sd,omitempty"`
	LogHealthChecks         *DefaultsLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogSeparateErrors       *DefaultsLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogSteps                *[]DefaultsLogSteps              `json:"log_steps,omitempty"`
	LogTag                  *string                          `json:"log_tag,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList     *LogTargets                        `json:"log_target_list,omitempty"`
	Logasap           *DefaultsLogasap                   `json:"logasap,omitempty"`
	MaxKeepAliveQueue *int                               `json:"max_keep_alive_queue"`
	Maxconn           *int                               `json:"maxconn"`
	Metadata          *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Mode              *DefaultsMode                      `json:"mode,omitempty"`
	MonitorUri        *MonitorUri                        `json:"monitor_uri,omitempty"`
	MysqlCheckParams  *MysqlCheckParams                  `json:"mysql_check_params,omitempty"`
	Name              *string                            `json:"name,omitempty"`
	Nolinger          *DefaultsNolinger                  `json:"nolinger,omitempty"`
	Originalto        *Originalto                        `json:"originalto,omitempty"`
	Persist           *DefaultsPersist                   `json:"persist,omitempty"`
	PersistRule       *PersistRule                       `json:"persist_rule,omitempty"`
	PgsqlCheckParams  *PgsqlCheckParams                  `json:"pgsql_check_params,omitempty"`
	PreferLastServer  *DefaultsPreferLastServer          `json:"prefer_last_server,omitempty"`
	QueueTimeout      *int                               `json:"queue_timeout"`
	QUICInitialRules  *QUICInitialRules                  `json:"quic_initial_rule_list,omitempty"`
	Redispatch        *Redispatch                        `json:"redispatch,omitempty"`
	Retries           *int                               `json:"retries"`
	RetryOn           *string                            `json:"retry_on,omitempty"`
	ServerFinTimeout  *int                               `json:"server_fin_timeout"`
	ServerTimeout     *int                               `json:"server_timeout"`
	SmtpchkParams     *SmtpchkParams                     `json:"smtpchk_params,omitempty"`
	SocketStats       *DefaultsSocketStats               `json:"socket_stats,omitempty"`
	Source            *Source                            `json:"source,omitempty"`
	SpliceAuto        *DefaultsSpliceAuto                `json:"splice_auto,omitempty"`
	SpliceRequest     *DefaultsSpliceRequest             `json:"splice_request,omitempty"`
	SpliceResponse    *DefaultsSpliceResponse            `json:"splice_response,omitempty"`
	Srvtcpka          *DefaultsSrvtcpka                  `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt       *int                               `json:"srvtcpka_cnt"`
	SrvtcpkaIdle      *int                               `json:"srvtcpka_idle"`
	SrvtcpkaIntvl     *int                               `json:"srvtcpka_intvl"`
	StatsOptions      *StatsOptions                      `json:"stats_options,omitempty"`
	TarpitTimeout     *int                               `json:"tarpit_timeout"`
	TcpCheckRuleList  *TcpChecks                         `json:"tcp_check_rule_list,omitempty"`

	// TcpRequestRuleList HAProxy TCP request rules array (corresponds to tcp-request directive)
	TcpRequestRuleList *TcpRequestRules `json:"tcp_request_rule_list,omitempty"`

	// TcpResponseRuleList HAProxy TCP response rules array (corresponds to tcp-response directive)
	TcpResponseRuleList *TcpResponseRules        `json:"tcp_response_rule_list,omitempty"`
	TcpSmartAccept      *DefaultsTcpSmartAccept  `json:"tcp_smart_accept,omitempty"`
	TcpSmartConnect     *DefaultsTcpSmartConnect `json:"tcp_smart_connect,omitempty"`
	Tcpka               *DefaultsTcpka           `json:"tcpka,omitempty"`
	Tcplog              *bool                    `json:"tcplog,omitempty"`
	Transparent         *DefaultsTransparent     `json:"transparent,omitempty"`
	TunnelTimeout       *int                     `json:"tunnel_timeout"`
	UniqueIdFormat      *string                  `json:"unique_id_format,omitempty"`
	UniqueIdHeader      *string                  `json:"unique_id_header,omitempty"`
}

// DefaultsAbortonclose defines model for Defaults.Abortonclose.
type DefaultsAbortonclose string

// DefaultsAcceptInvalidHttpRequest defines model for Defaults.AcceptInvalidHttpRequest.
type DefaultsAcceptInvalidHttpRequest string

// DefaultsAcceptInvalidHttpResponse defines model for Defaults.AcceptInvalidHttpResponse.
type DefaultsAcceptInvalidHttpResponse string

// DefaultsAcceptUnsafeViolationsInHttpRequest defines model for Defaults.AcceptUnsafeViolationsInHttpRequest.
type DefaultsAcceptUnsafeViolationsInHttpRequest string

// DefaultsAcceptUnsafeViolationsInHttpResponse defines model for Defaults.AcceptUnsafeViolationsInHttpResponse.
type DefaultsAcceptUnsafeViolationsInHttpResponse string

// DefaultsAdvCheck defines model for Defaults.AdvCheck.
type DefaultsAdvCheck string

// DefaultsAllbackups defines model for Defaults.Allbackups.
type DefaultsAllbackups string

// DefaultsCheckcache defines model for Defaults.Checkcache.
type DefaultsCheckcache string

// DefaultsClitcpka defines model for Defaults.Clitcpka.
type DefaultsClitcpka string

// DefaultsContstats defines model for Defaults.Contstats.
type DefaultsContstats string

// DefaultsDisableH2Upgrade defines model for Defaults.DisableH2Upgrade.
type DefaultsDisableH2Upgrade string

// DefaultsDontlogNormal defines model for Defaults.DontlogNormal.
type DefaultsDontlogNormal string

// DefaultsDontlognull defines model for Defaults.Dontlognull.
type DefaultsDontlognull string

// DefaultsExternalCheck defines model for Defaults.ExternalCheck.
type DefaultsExternalCheck string

// DefaultsH1CaseAdjustBogusClient defines model for Defaults.H1CaseAdjustBogusClient.
type DefaultsH1CaseAdjustBogusClient string

// DefaultsH1CaseAdjustBogusServer defines model for Defaults.H1CaseAdjustBogusServer.
type DefaultsH1CaseAdjustBogusServer string

// DefaultsHashPreserveAffinity defines model for Defaults.HashPreserveAffinity.
type DefaultsHashPreserveAffinity string

// DefaultsHttpBufferRequest defines model for Defaults.HttpBufferRequest.
type DefaultsHttpBufferRequest string

// DefaultsHttpDropRequestTrailers defines model for Defaults.HttpDropRequestTrailers.
type DefaultsHttpDropRequestTrailers string

// DefaultsHttpDropResponseTrailers defines model for Defaults.HttpDropResponseTrailers.
type DefaultsHttpDropResponseTrailers string

// DefaultsHttpUseHtx defines model for Defaults.HttpUseHtx.
type DefaultsHttpUseHtx string

// DefaultsHttpConnectionMode defines model for Defaults.HttpConnectionMode.
type DefaultsHttpConnectionMode string

// DefaultsHttpIgnoreProbes defines model for Defaults.HttpIgnoreProbes.
type DefaultsHttpIgnoreProbes string

// DefaultsHttpNoDelay defines model for Defaults.HttpNoDelay.
type DefaultsHttpNoDelay string

// DefaultsHttpPretendKeepalive defines model for Defaults.HttpPretendKeepalive.
type DefaultsHttpPretendKeepalive string

// DefaultsHttpRestrictReqHdrNames defines model for Defaults.HttpRestrictReqHdrNames.
type DefaultsHttpRestrictReqHdrNames string

// DefaultsHttpReuse defines model for Defaults.HttpReuse.
type DefaultsHttpReuse string

// DefaultsHttpUseProxyHeader defines model for Defaults.HttpUseProxyHeader.
type DefaultsHttpUseProxyHeader string

// DefaultsHttpslog defines model for Defaults.Httpslog.
type DefaultsHttpslog string

// DefaultsIdleCloseOnResponse defines model for Defaults.IdleCloseOnResponse.
type DefaultsIdleCloseOnResponse string

// DefaultsIndependentStreams defines model for Defaults.IndependentStreams.
type DefaultsIndependentStreams string

// DefaultsLoadServerStateFromFile defines model for Defaults.LoadServerStateFromFile.
type DefaultsLoadServerStateFromFile string

// DefaultsLogHealthChecks defines model for Defaults.LogHealthChecks.
type DefaultsLogHealthChecks string

// DefaultsLogSeparateErrors defines model for Defaults.LogSeparateErrors.
type DefaultsLogSeparateErrors string

// DefaultsLogSteps defines model for Defaults.LogSteps.
type DefaultsLogSteps string

// DefaultsLogasap defines model for Defaults.Logasap.
type DefaultsLogasap string

// DefaultsMode defines model for Defaults.Mode.
type DefaultsMode string

// DefaultsNolinger defines model for Defaults.Nolinger.
type DefaultsNolinger string

// DefaultsPersist defines model for Defaults.Persist.
type DefaultsPersist string

// DefaultsPreferLastServer defines model for Defaults.PreferLastServer.
type DefaultsPreferLastServer string

// DefaultsSocketStats defines model for Defaults.SocketStats.
type DefaultsSocketStats string

// DefaultsSpliceAuto defines model for Defaults.SpliceAuto.
type DefaultsSpliceAuto string

// DefaultsSpliceRequest defines model for Defaults.SpliceRequest.
type DefaultsSpliceRequest string

// DefaultsSpliceResponse defines model for Defaults.SpliceResponse.
type DefaultsSpliceResponse string

// DefaultsSrvtcpka defines model for Defaults.Srvtcpka.
type DefaultsSrvtcpka string

// DefaultsTcpSmartAccept defines model for Defaults.TcpSmartAccept.
type DefaultsTcpSmartAccept string

// DefaultsTcpSmartConnect defines model for Defaults.TcpSmartConnect.
type DefaultsTcpSmartConnect string

// DefaultsTcpka defines model for Defaults.Tcpka.
type DefaultsTcpka string

// DefaultsTransparent defines model for Defaults.Transparent.
type DefaultsTransparent string

// DefaultsBase HAProxy defaults configuration
type DefaultsBase struct {
	Abortonclose                         *DefaultsBaseAbortonclose                         `json:"abortonclose,omitempty"`
	AcceptInvalidHttpRequest             *DefaultsBaseAcceptInvalidHttpRequest             `json:"accept_invalid_http_request,omitempty"`
	AcceptInvalidHttpResponse            *DefaultsBaseAcceptInvalidHttpResponse            `json:"accept_invalid_http_response,omitempty"`
	AcceptUnsafeViolationsInHttpRequest  *DefaultsBaseAcceptUnsafeViolationsInHttpRequest  `json:"accept_unsafe_violations_in_http_request,omitempty"`
	AcceptUnsafeViolationsInHttpResponse *DefaultsBaseAcceptUnsafeViolationsInHttpResponse `json:"accept_unsafe_violations_in_http_response,omitempty"`
	AdvCheck                             *DefaultsBaseAdvCheck                             `json:"adv_check,omitempty"`
	Allbackups                           *DefaultsBaseAllbackups                           `json:"allbackups,omitempty"`
	Backlog                              *int                                              `json:"backlog"`
	Balance                              *Balance                                          `json:"balance,omitempty"`
	CheckTimeout                         *int                                              `json:"check_timeout"`
	Checkcache                           *DefaultsBaseCheckcache                           `json:"checkcache,omitempty"`
	Clflog                               *bool                                             `json:"clflog,omitempty"`
	ClientFinTimeout                     *int                                              `json:"client_fin_timeout"`
	ClientTimeout                        *int                                              `json:"client_timeout"`
	Clitcpka                             *DefaultsBaseClitcpka                             `json:"clitcpka,omitempty"`
	ClitcpkaCnt                          *int                                              `json:"clitcpka_cnt"`
	ClitcpkaIdle                         *int                                              `json:"clitcpka_idle"`
	ClitcpkaIntvl                        *int                                              `json:"clitcpka_intvl"`
	Compression                          *Compression                                      `json:"compression,omitempty"`
	ConnectTimeout                       *int                                              `json:"connect_timeout"`
	Contstats                            *DefaultsBaseContstats                            `json:"contstats,omitempty"`
	Cookie                               *Cookie                                           `json:"cookie,omitempty"`
	DefaultBackend                       *string                                           `json:"default_backend,omitempty"`
	DefaultServer                        *DefaultServer                                    `json:"default_server,omitempty"`
	DisableH2Upgrade                     *DefaultsBaseDisableH2Upgrade                     `json:"disable_h2_upgrade,omitempty"`
	Disabled                             *bool                                             `json:"disabled,omitempty"`
	DontlogNormal                        *DefaultsBaseDontlogNormal                        `json:"dontlog_normal,omitempty"`
	Dontlognull                          *DefaultsBaseDontlognull                          `json:"dontlognull,omitempty"`
	DynamicCookieKey                     *string                                           `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert                           `json:"email_alert,omitempty"`
	Enabled                  *bool                                 `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile                          `json:"error_files,omitempty"`
	ErrorLogFormat           *string                               `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles                         `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                             `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                             `json:"errorloc303,omitempty"`
	ExternalCheck            *DefaultsBaseExternalCheck            `json:"external_check,omitempty"`
	ExternalCheckCommand     *string                               `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string                               `json:"external_check_path,omitempty"`
	Forwardfor               *Forwardfor                           `json:"forwardfor,omitempty"`
	From                     *string                               `json:"from,omitempty"`
	Fullconn                 *int                                  `json:"fullconn"`
	H1CaseAdjustBogusClient  *DefaultsBaseH1CaseAdjustBogusClient  `json:"h1_case_adjust_bogus_client,omitempty"`
	H1CaseAdjustBogusServer  *DefaultsBaseH1CaseAdjustBogusServer  `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor        *int                                  `json:"hash_balance_factor"`
	HashPreserveAffinity     *DefaultsBaseHashPreserveAffinity     `json:"hash_preserve_affinity,omitempty"`
	HashType                 *HashType                             `json:"hash_type,omitempty"`
	HttpBufferRequest        *DefaultsBaseHttpBufferRequest        `json:"http-buffer-request,omitempty"`
	HttpDropRequestTrailers  *DefaultsBaseHttpDropRequestTrailers  `json:"http-drop-request-trailers,omitempty"`
	HttpDropResponseTrailers *DefaultsBaseHttpDropResponseTrailers `json:"http-drop-response-trailers,omitempty"`
	HttpUseHtx               *DefaultsBaseHttpUseHtx               `json:"http-use-htx,omitempty"`
	HttpConnectionMode       *DefaultsBaseHttpConnectionMode       `json:"http_connection_mode,omitempty"`
	HttpIgnoreProbes         *DefaultsBaseHttpIgnoreProbes         `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout     *int                                  `json:"http_keep_alive_timeout"`
	HttpNoDelay              *DefaultsBaseHttpNoDelay              `json:"http_no_delay,omitempty"`
	HttpPretendKeepalive     *DefaultsBaseHttpPretendKeepalive     `json:"http_pretend_keepalive,omitempty"`
	HttpRequestTimeout       *int                                  `json:"http_request_timeout"`
	HttpRestrictReqHdrNames  *DefaultsBaseHttpRestrictReqHdrNames  `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse                *DefaultsBaseHttpReuse                `json:"http_reuse,omitempty"`
	HttpSendNameHeader       *string                               `json:"http_send_name_header"`
	HttpUseProxyHeader       *DefaultsBaseHttpUseProxyHeader       `json:"http_use_proxy_header,omitempty"`
	HttpchkParams            *HttpchkParams                        `json:"httpchk_params,omitempty"`
	Httplog                  *bool                                 `json:"httplog,omitempty"`
	Httpslog                 *DefaultsBaseHttpslog                 `json:"httpslog,omitempty"`
	IdleCloseOnResponse      *DefaultsBaseIdleCloseOnResponse      `json:"idle_close_on_response,omitempty"`
	IndependentStreams       *DefaultsBaseIndependentStreams       `json:"independent_streams,omitempty"`
	LoadServerStateFromFile  *DefaultsBaseLoadServerStateFromFile  `json:"load_server_state_from_file,omitempty"`
	LogFormat                *string                               `json:"log_format,omitempty"`
	LogFormatSd              *string                               `json:"log_format_sd,omitempty"`
	LogHealthChecks          *DefaultsBaseLogHealthChecks          `json:"log_health_checks,omitempty"`
	LogSeparateErrors        *DefaultsBaseLogSeparateErrors        `json:"log_separate_errors,omitempty"`
	LogSteps                 *[]DefaultsBaseLogSteps               `json:"log_steps,omitempty"`
	LogTag                   *string                               `json:"log_tag,omitempty"`
	Logasap                  *DefaultsBaseLogasap                  `json:"logasap,omitempty"`
	MaxKeepAliveQueue        *int                                  `json:"max_keep_alive_queue"`
	Maxconn                  *int                                  `json:"maxconn"`
	Metadata                 *map[string]map[string]interface{}    `json:"metadata,omitempty"`
	Mode                     *DefaultsBaseMode                     `json:"mode,omitempty"`
	MonitorUri               *MonitorUri                           `json:"monitor_uri,omitempty"`
	MysqlCheckParams         *MysqlCheckParams                     `json:"mysql_check_params,omitempty"`
	Name                     *string                               `json:"name,omitempty"`
	Nolinger                 *DefaultsBaseNolinger                 `json:"nolinger,omitempty"`
	Originalto               *Originalto                           `json:"originalto,omitempty"`
	Persist                  *DefaultsBasePersist                  `json:"persist,omitempty"`
	PersistRule              *PersistRule                          `json:"persist_rule,omitempty"`
	PgsqlCheckParams         *PgsqlCheckParams                     `json:"pgsql_check_params,omitempty"`
	PreferLastServer         *DefaultsBasePreferLastServer         `json:"prefer_last_server,omitempty"`
	QueueTimeout             *int                                  `json:"queue_timeout"`
	Redispatch               *Redispatch                           `json:"redispatch,omitempty"`
	Retries                  *int                                  `json:"retries"`
	RetryOn                  *string                               `json:"retry_on,omitempty"`
	ServerFinTimeout         *int                                  `json:"server_fin_timeout"`
	ServerTimeout            *int                                  `json:"server_timeout"`
	SmtpchkParams            *SmtpchkParams                        `json:"smtpchk_params,omitempty"`
	SocketStats              *DefaultsBaseSocketStats              `json:"socket_stats,omitempty"`
	Source                   *Source                               `json:"source,omitempty"`
	SpliceAuto               *DefaultsBaseSpliceAuto               `json:"splice_auto,omitempty"`
	SpliceRequest            *DefaultsBaseSpliceRequest            `json:"splice_request,omitempty"`
	SpliceResponse           *DefaultsBaseSpliceResponse           `json:"splice_response,omitempty"`
	Srvtcpka                 *DefaultsBaseSrvtcpka                 `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt              *int                                  `json:"srvtcpka_cnt"`
	SrvtcpkaIdle             *int                                  `json:"srvtcpka_idle"`
	SrvtcpkaIntvl            *int                                  `json:"srvtcpka_intvl"`
	StatsOptions             *StatsOptions                         `json:"stats_options,omitempty"`
	TarpitTimeout            *int                                  `json:"tarpit_timeout"`
	TcpSmartAccept           *DefaultsBaseTcpSmartAccept           `json:"tcp_smart_accept,omitempty"`
	TcpSmartConnect          *DefaultsBaseTcpSmartConnect          `json:"tcp_smart_connect,omitempty"`
	Tcpka                    *DefaultsBaseTcpka                    `json:"tcpka,omitempty"`
	Tcplog                   *bool                                 `json:"tcplog,omitempty"`
	Transparent              *DefaultsBaseTransparent              `json:"transparent,omitempty"`
	TunnelTimeout            *int                                  `json:"tunnel_timeout"`
	UniqueIdFormat           *string                               `json:"unique_id_format,omitempty"`
	UniqueIdHeader           *string                               `json:"unique_id_header,omitempty"`
}

// DefaultsBaseAbortonclose defines model for DefaultsBase.Abortonclose.
type DefaultsBaseAbortonclose string

// DefaultsBaseAcceptInvalidHttpRequest defines model for DefaultsBase.AcceptInvalidHttpRequest.
type DefaultsBaseAcceptInvalidHttpRequest string

// DefaultsBaseAcceptInvalidHttpResponse defines model for DefaultsBase.AcceptInvalidHttpResponse.
type DefaultsBaseAcceptInvalidHttpResponse string

// DefaultsBaseAcceptUnsafeViolationsInHttpRequest defines model for DefaultsBase.AcceptUnsafeViolationsInHttpRequest.
type DefaultsBaseAcceptUnsafeViolationsInHttpRequest string

// DefaultsBaseAcceptUnsafeViolationsInHttpResponse defines model for DefaultsBase.AcceptUnsafeViolationsInHttpResponse.
type DefaultsBaseAcceptUnsafeViolationsInHttpResponse string

// DefaultsBaseAdvCheck defines model for DefaultsBase.AdvCheck.
type DefaultsBaseAdvCheck string

// DefaultsBaseAllbackups defines model for DefaultsBase.Allbackups.
type DefaultsBaseAllbackups string

// DefaultsBaseCheckcache defines model for DefaultsBase.Checkcache.
type DefaultsBaseCheckcache string

// DefaultsBaseClitcpka defines model for DefaultsBase.Clitcpka.
type DefaultsBaseClitcpka string

// DefaultsBaseContstats defines model for DefaultsBase.Contstats.
type DefaultsBaseContstats string

// DefaultsBaseDisableH2Upgrade defines model for DefaultsBase.DisableH2Upgrade.
type DefaultsBaseDisableH2Upgrade string

// DefaultsBaseDontlogNormal defines model for DefaultsBase.DontlogNormal.
type DefaultsBaseDontlogNormal string

// DefaultsBaseDontlognull defines model for DefaultsBase.Dontlognull.
type DefaultsBaseDontlognull string

// DefaultsBaseExternalCheck defines model for DefaultsBase.ExternalCheck.
type DefaultsBaseExternalCheck string

// DefaultsBaseH1CaseAdjustBogusClient defines model for DefaultsBase.H1CaseAdjustBogusClient.
type DefaultsBaseH1CaseAdjustBogusClient string

// DefaultsBaseH1CaseAdjustBogusServer defines model for DefaultsBase.H1CaseAdjustBogusServer.
type DefaultsBaseH1CaseAdjustBogusServer string

// DefaultsBaseHashPreserveAffinity defines model for DefaultsBase.HashPreserveAffinity.
type DefaultsBaseHashPreserveAffinity string

// DefaultsBaseHttpBufferRequest defines model for DefaultsBase.HttpBufferRequest.
type DefaultsBaseHttpBufferRequest string

// DefaultsBaseHttpDropRequestTrailers defines model for DefaultsBase.HttpDropRequestTrailers.
type DefaultsBaseHttpDropRequestTrailers string

// DefaultsBaseHttpDropResponseTrailers defines model for DefaultsBase.HttpDropResponseTrailers.
type DefaultsBaseHttpDropResponseTrailers string

// DefaultsBaseHttpUseHtx defines model for DefaultsBase.HttpUseHtx.
type DefaultsBaseHttpUseHtx string

// DefaultsBaseHttpConnectionMode defines model for DefaultsBase.HttpConnectionMode.
type DefaultsBaseHttpConnectionMode string

// DefaultsBaseHttpIgnoreProbes defines model for DefaultsBase.HttpIgnoreProbes.
type DefaultsBaseHttpIgnoreProbes string

// DefaultsBaseHttpNoDelay defines model for DefaultsBase.HttpNoDelay.
type DefaultsBaseHttpNoDelay string

// DefaultsBaseHttpPretendKeepalive defines model for DefaultsBase.HttpPretendKeepalive.
type DefaultsBaseHttpPretendKeepalive string

// DefaultsBaseHttpRestrictReqHdrNames defines model for DefaultsBase.HttpRestrictReqHdrNames.
type DefaultsBaseHttpRestrictReqHdrNames string

// DefaultsBaseHttpReuse defines model for DefaultsBase.HttpReuse.
type DefaultsBaseHttpReuse string

// DefaultsBaseHttpUseProxyHeader defines model for DefaultsBase.HttpUseProxyHeader.
type DefaultsBaseHttpUseProxyHeader string

// DefaultsBaseHttpslog defines model for DefaultsBase.Httpslog.
type DefaultsBaseHttpslog string

// DefaultsBaseIdleCloseOnResponse defines model for DefaultsBase.IdleCloseOnResponse.
type DefaultsBaseIdleCloseOnResponse string

// DefaultsBaseIndependentStreams defines model for DefaultsBase.IndependentStreams.
type DefaultsBaseIndependentStreams string

// DefaultsBaseLoadServerStateFromFile defines model for DefaultsBase.LoadServerStateFromFile.
type DefaultsBaseLoadServerStateFromFile string

// DefaultsBaseLogHealthChecks defines model for DefaultsBase.LogHealthChecks.
type DefaultsBaseLogHealthChecks string

// DefaultsBaseLogSeparateErrors defines model for DefaultsBase.LogSeparateErrors.
type DefaultsBaseLogSeparateErrors string

// DefaultsBaseLogSteps defines model for DefaultsBase.LogSteps.
type DefaultsBaseLogSteps string

// DefaultsBaseLogasap defines model for DefaultsBase.Logasap.
type DefaultsBaseLogasap string

// DefaultsBaseMode defines model for DefaultsBase.Mode.
type DefaultsBaseMode string

// DefaultsBaseNolinger defines model for DefaultsBase.Nolinger.
type DefaultsBaseNolinger string

// DefaultsBasePersist defines model for DefaultsBase.Persist.
type DefaultsBasePersist string

// DefaultsBasePreferLastServer defines model for DefaultsBase.PreferLastServer.
type DefaultsBasePreferLastServer string

// DefaultsBaseSocketStats defines model for DefaultsBase.SocketStats.
type DefaultsBaseSocketStats string

// DefaultsBaseSpliceAuto defines model for DefaultsBase.SpliceAuto.
type DefaultsBaseSpliceAuto string

// DefaultsBaseSpliceRequest defines model for DefaultsBase.SpliceRequest.
type DefaultsBaseSpliceRequest string

// DefaultsBaseSpliceResponse defines model for DefaultsBase.SpliceResponse.
type DefaultsBaseSpliceResponse string

// DefaultsBaseSrvtcpka defines model for DefaultsBase.Srvtcpka.
type DefaultsBaseSrvtcpka string

// DefaultsBaseTcpSmartAccept defines model for DefaultsBase.TcpSmartAccept.
type DefaultsBaseTcpSmartAccept string

// DefaultsBaseTcpSmartConnect defines model for DefaultsBase.TcpSmartConnect.
type DefaultsBaseTcpSmartConnect string

// DefaultsBaseTcpka defines model for DefaultsBase.Tcpka.
type DefaultsBaseTcpka string

// DefaultsBaseTransparent defines model for DefaultsBase.Transparent.
type DefaultsBaseTransparent string

// DefaultsSections HAProxy defaults sections array
type DefaultsSections = []Defaults

// DeviceAtlasOptions defines model for device_atlas_options.
type DeviceAtlasOptions struct {
	JsonFile         *string `json:"json_file,omitempty"`
	LogLevel         *string `json:"log_level,omitempty"`
	PropertiesCookie *string `json:"properties_cookie,omitempty"`
	Separator        *string `json:"separator,omitempty"`
}

// DgramBind HAProxy log forward dgram bind configuration
type DgramBind struct {
	Address      *string                            `json:"address,omitempty"`
	Interface    *string                            `json:"interface,omitempty"`
	Metadata     *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	Namespace    *string                            `json:"namespace,omitempty"`
	Port         *int                               `json:"port"`
	PortRangeEnd *int                               `json:"port-range-end"`
	Transparent  *bool                              `json:"transparent,omitempty"`
}

// DgramBinds HAProxy dgram bind array
type DgramBinds = []DgramBind

// EmailAlert Send emails for important log messages.
type EmailAlert struct {
	From       string                             `json:"from"`
	Level      *EmailAlertLevel                   `json:"level,omitempty"`
	Mailers    string                             `json:"mailers"`
	Metadata   *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Myhostname *string                            `json:"myhostname,omitempty"`
	To         string                             `json:"to"`
}

// EmailAlertLevel defines model for EmailAlert.Level.
type EmailAlertLevel string

// Endpoint Endpoint definition
type Endpoint struct {
	// Description Endpoint description
	Description *string `json:"description,omitempty"`

	// Title Endpoint title
	Title *string `json:"title,omitempty"`

	// Url Path to the endpoint
	Url *string `json:"url,omitempty"`
}

// Endpoints Collection of endpoints
type Endpoints = []Endpoint

// EnvironmentOptions defines model for environment_options.
type EnvironmentOptions struct {
	PresetEnvs *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"presetenv,omitempty"`
	Resetenv *string `json:"resetenv,omitempty"`
	SetEnvs  *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"setenv,omitempty"`
	Unsetenv *string `json:"unsetenv,omitempty"`
}

// Error API Error
type Error struct {
	Code                 *int              `json:"code"`
	Message              *string           `json:"message"`
	AdditionalProperties map[string]string `json:"-"`
}

// Errorfile defines model for errorfile.
type Errorfile struct {
	Code *ErrorfileCode `json:"code,omitempty"`
	File *string        `json:"file,omitempty"`
}

// ErrorfileCode defines model for Errorfile.Code.
type ErrorfileCode int

// Errorfiles defines model for errorfiles.
type Errorfiles struct {
	Codes    *[]ErrorfilesCodes                 `json:"codes,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     *string                            `json:"name,omitempty"`
}

// ErrorfilesCodes defines model for Errorfiles.Codes.
type ErrorfilesCodes int

// Errorloc defines model for errorloc.
type Errorloc struct {
	Code     ErrorlocCode                       `json:"code"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Url      string                             `json:"url"`
}

// ErrorlocCode defines model for Errorloc.Code.
type ErrorlocCode int

// FCGIApp defines model for fcgiApp.
type FCGIApp struct {
	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList *Acls `json:"acl_list,omitempty"`

	// Docroot Defines the document root on the remote host. The parameter serves to build the default value of FastCGI parameters SCRIPT_FILENAME and PATH_TRANSLATED. It is a mandatory setting.
	Docroot string `json:"docroot"`

	// GetValues Enables or disables the retrieval of variables related to connection management.
	GetValues *FcgiAppGetValues `json:"get_values,omitempty"`

	// Index Defines the script name to append after a URI that ends with a slash ("/") to set the default value for the FastCGI parameter SCRIPT_NAME. It is an optional setting.
	Index *string `json:"index,omitempty"`

	// KeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
	KeepConn   *FcgiAppKeepConn `json:"keep_conn,omitempty"`
	LogStderrs *[]FcgiLogStderr `json:"log_stderrs,omitempty"`

	// MaxReqs Defines the maximum number of concurrent requests this application can accept. If the FastCGI application retrieves the variable FCGI_MAX_REQS during connection establishment, it can override this option. Furthermore, if the application does not do multiplexing, it will ignore this option.
	MaxReqs  *int                               `json:"max_reqs,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`

	// MpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
	MpxsConns *FcgiAppMpxsConns `json:"mpxs_conns,omitempty"`

	// Name Declares a FastCGI application
	Name        string            `json:"name"`
	PassHeaders *[]FcgiPassHeader `json:"pass_headers,omitempty"`

	// PathInfo Defines a regular expression to extract the script-name and the path-info from the URI.
	// Thus, <regex> must have two captures: the first to capture the script name, and the second to capture the path- info.
	// If not defined, it does not perform matching on the URI, and does not fill the FastCGI parameters PATH_INFO and PATH_TRANSLATED.
	PathInfo  *string         `json:"path_info,omitempty"`
	SetParams *[]FcgiSetParam `json:"set_params,omitempty"`
}

// FcgiAppGetValues Enables or disables the retrieval of variables related to connection management.
type FcgiAppGetValues string

// FcgiAppKeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
type FcgiAppKeepConn string

// FcgiAppMpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
type FcgiAppMpxsConns string

// FcgiAppBase HAProxy FastCGI application configuration
type FcgiAppBase struct {
	// Docroot Defines the document root on the remote host. The parameter serves to build the default value of FastCGI parameters SCRIPT_FILENAME and PATH_TRANSLATED. It is a mandatory setting.
	Docroot string `json:"docroot"`

	// GetValues Enables or disables the retrieval of variables related to connection management.
	GetValues *FcgiAppBaseGetValues `json:"get_values,omitempty"`

	// Index Defines the script name to append after a URI that ends with a slash ("/") to set the default value for the FastCGI parameter SCRIPT_NAME. It is an optional setting.
	Index *string `json:"index,omitempty"`

	// KeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
	KeepConn   *FcgiAppBaseKeepConn `json:"keep_conn,omitempty"`
	LogStderrs *[]FcgiLogStderr     `json:"log_stderrs,omitempty"`

	// MaxReqs Defines the maximum number of concurrent requests this application can accept. If the FastCGI application retrieves the variable FCGI_MAX_REQS during connection establishment, it can override this option. Furthermore, if the application does not do multiplexing, it will ignore this option.
	MaxReqs  *int                               `json:"max_reqs,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`

	// MpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
	MpxsConns *FcgiAppBaseMpxsConns `json:"mpxs_conns,omitempty"`

	// Name Declares a FastCGI application
	Name        string            `json:"name"`
	PassHeaders *[]FcgiPassHeader `json:"pass_headers,omitempty"`

	// PathInfo Defines a regular expression to extract the script-name and the path-info from the URI.
	// Thus, <regex> must have two captures: the first to capture the script name, and the second to capture the path- info.
	// If not defined, it does not perform matching on the URI, and does not fill the FastCGI parameters PATH_INFO and PATH_TRANSLATED.
	PathInfo  *string         `json:"path_info,omitempty"`
	SetParams *[]FcgiSetParam `json:"set_params,omitempty"`
}

// FcgiAppBaseGetValues Enables or disables the retrieval of variables related to connection management.
type FcgiAppBaseGetValues string

// FcgiAppBaseKeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
type FcgiAppBaseKeepConn string

// FcgiAppBaseMpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
type FcgiAppBaseMpxsConns string

// FcgiApps defines model for fcgiApps.
type FcgiApps = []FCGIApp

// FcgiLogStderr Enables logging of STDERR messages that the FastCGI application reports.
// It is an optional setting. By default, HAProxy Enterprise ignores STDERR messages.
type FcgiLogStderr struct {
	Address  *string `json:"address,omitempty"`
	Facility *string `json:"facility,omitempty"`
	Format   *string `json:"format,omitempty"`
	Global   *bool   `json:"global,omitempty"`
	Len      *int    `json:"len,omitempty"`
	Level    *string `json:"level,omitempty"`
	Minlevel *string `json:"minlevel,omitempty"`
	Sample   *struct {
		Ranges string `json:"ranges"`
		Size   int    `json:"size"`
	} `json:"sample,omitempty"`
}

// FcgiPassHeader Specifies the name of a request header to pass to the FastCGI application.
// Optionally, you can follow it with an ACL-based condition, in which case the FastCGI application evaluates it only if the condition is true.
// Most request headers are already available to the FastCGI application with the prefix "HTTP".
// Thus, you only need this directive to pass headers that are purposefully omitted.
// Currently, the headers "Authorization", "Proxy-Authorization", and hop-by-hop headers are omitted.
// Note that the headers "Content-type" and "Content-length" never pass to the FastCGI application because they are already converted into parameters.
type FcgiPassHeader struct {
	Cond     *FcgiPassHeaderCond `json:"cond,omitempty"`
	CondTest *string             `json:"cond_test,omitempty"`
	Name     *string             `json:"name,omitempty"`
}

// FcgiPassHeaderCond defines model for FcgiPassHeader.Cond.
type FcgiPassHeaderCond string

// FcgiSetParam Sets a FastCGI parameter to pass to this application.
// Its value, defined by <format> can take a formatted string, the same as the log directive.
// Optionally, you can follow it with an ACL-based condition, in which case the FastCGI application evaluates it only if the condition is true.
type FcgiSetParam struct {
	Cond     *FcgiSetParamCond `json:"cond,omitempty"`
	CondTest *string           `json:"cond_test,omitempty"`
	Format   *string           `json:"format,omitempty"`
	Name     *string           `json:"name,omitempty"`
}

// FcgiSetParamCond defines model for FcgiSetParam.Cond.
type FcgiSetParamCond string

// FiftyOneDegreesOptions defines model for fifty_one_degrees_options.
type FiftyOneDegreesOptions struct {
	CacheSize         *int    `json:"cache_size,omitempty"`
	DataFile          *string `json:"data_file,omitempty"`
	PropertyNameList  *string `json:"property_name_list,omitempty"`
	PropertySeparator *string `json:"property_separator,omitempty"`
}

// Filter HAProxy filters
type Filter struct {
	// AppName Name of the fcgi-app section this filter will use.
	AppName *string `json:"app_name,omitempty"`

	// BandwidthLimitName Filter name that will be used by 'set-bandwidth-limit' actions to reference a specific bandwidth limitation filter
	BandwidthLimitName *string `json:"bandwidth_limit_name,omitempty"`
	CacheName          *string `json:"cache_name,omitempty"`

	// DefaultLimit The max number of bytes that can be forwarded over the period.
	// The value must be specified for per-stream and shared bandwidth limitation filters.
	// It follows the HAProxy size format and is expressed in bytes.
	DefaultLimit *int `json:"default_limit,omitempty"`

	// DefaultPeriod The default time period used to evaluate the bandwidth limitation rate.
	// It can be specified for per-stream bandwidth limitation filters only.
	// It follows the HAProxy time format and is expressed in milliseconds.
	DefaultPeriod *int `json:"default_period,omitempty"`

	// Key A sample expression rule.
	// It describes what elements will be analyzed, extracted, combined, and used to select which table entry to update the counters.
	// It must be specified for shared bandwidth limitation filters only.
	Key *string `json:"key,omitempty"`

	// Limit The max number of bytes that can be forwarded over the period.
	// The value must be specified for per-stream and shared bandwidth limitation filters.
	// It follows the HAProxy size format and is expressed in bytes.
	Limit    *int                               `json:"limit,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`

	// MinSize The optional minimum number of bytes forwarded at a time by a stream excluding the last packet that may be smaller.
	// This value can be specified for per-stream and shared bandwidth limitation filters.
	// It follows the HAProxy size format and is expressed in bytes.
	MinSize    *int    `json:"min_size,omitempty"`
	SpoeConfig *string `json:"spoe_config,omitempty"`
	SpoeEngine *string `json:"spoe_engine,omitempty"`

	// Table An optional table to be used instead of the default one, which is the stick-table declared in the current proxy.
	// It can be specified for shared bandwidth limitation filters only.
	Table              *string    `json:"table,omitempty"`
	TraceHexdump       *bool      `json:"trace_hexdump,omitempty"`
	TraceName          *string    `json:"trace_name,omitempty"`
	TraceRndForwarding *bool      `json:"trace_rnd_forwarding,omitempty"`
	TraceRndParsing    *bool      `json:"trace_rnd_parsing,omitempty"`
	Type               FilterType `json:"type"`
}

// FilterType defines model for Filter.Type.
type FilterType string

// Filters HAProxy filters array (corresponds to filter directive)
type Filters = []Filter

// Forwardfor defines model for forwardfor.
type Forwardfor struct {
	Enabled ForwardforEnabled `json:"enabled"`
	Except  *string           `json:"except,omitempty"`
	Header  *string           `json:"header,omitempty"`
	Ifnone  *bool             `json:"ifnone,omitempty"`
}

// ForwardforEnabled defines model for Forwardfor.Enabled.
type ForwardforEnabled string

// Frontend defines model for frontend.
type Frontend struct {
	AcceptInvalidHttpRequest            *FrontendAcceptInvalidHttpRequest            `json:"accept_invalid_http_request,omitempty"`
	AcceptUnsafeViolationsInHttpRequest *FrontendAcceptUnsafeViolationsInHttpRequest `json:"accept_unsafe_violations_in_http_request,omitempty"`

	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList *Acls `json:"acl_list,omitempty"`

	// BackendSwitchingRuleList HAProxy backend switching rules array (corresponds to use_backend directives)
	BackendSwitchingRuleList *BackendSwitchingRules    `json:"backend_switching_rule_list,omitempty"`
	Backlog                  *int                      `json:"backlog"`
	Binds                    *map[string]Bind          `json:"binds,omitempty"`
	CaptureList              *Captures                 `json:"capture_list,omitempty"`
	Clflog                   *bool                     `json:"clflog,omitempty"`
	ClientFinTimeout         *int                      `json:"client_fin_timeout"`
	ClientTimeout            *int                      `json:"client_timeout"`
	Clitcpka                 *FrontendClitcpka         `json:"clitcpka,omitempty"`
	ClitcpkaCnt              *int                      `json:"clitcpka_cnt"`
	ClitcpkaIdle             *int                      `json:"clitcpka_idle"`
	ClitcpkaIntvl            *int                      `json:"clitcpka_intvl"`
	Compression              *Compression              `json:"compression,omitempty"`
	Contstats                *FrontendContstats        `json:"contstats,omitempty"`
	DefaultBackend           *string                   `json:"default_backend,omitempty"`
	Description              *string                   `json:"description,omitempty"`
	DisableH2Upgrade         *FrontendDisableH2Upgrade `json:"disable_h2_upgrade,omitempty"`
	Disabled                 *bool                     `json:"disabled,omitempty"`
	DontlogNormal            *FrontendDontlogNormal    `json:"dontlog_normal,omitempty"`
	Dontlognull              *FrontendDontlognull      `json:"dontlognull,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert   `json:"email_alert,omitempty"`
	Enabled                  *bool         `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile  `json:"error_files,omitempty"`
	ErrorLogFormat           *string       `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc     `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc     `json:"errorloc303,omitempty"`

	// FilterList HAProxy filters array (corresponds to filter directive)
	FilterList               *Filters                          `json:"filter_list,omitempty"`
	Forwardfor               *Forwardfor                       `json:"forwardfor,omitempty"`
	From                     *string                           `json:"from,omitempty"`
	Guid                     *string                           `json:"guid,omitempty"`
	H1CaseAdjustBogusClient  *FrontendH1CaseAdjustBogusClient  `json:"h1_case_adjust_bogus_client,omitempty"`
	HttpBufferRequest        *FrontendHttpBufferRequest        `json:"http-buffer-request,omitempty"`
	HttpDropResponseTrailers *FrontendHttpDropResponseTrailers `json:"http-drop-response-trailers,omitempty"`
	HttpUseHtx               *FrontendHttpUseHtx               `json:"http-use-htx,omitempty"`

	// HttpAfterResponseRuleList HAProxy HTTP after response rules array (corresponds to http-after-response directives)
	HttpAfterResponseRuleList *HttpAfterResponseRules     `json:"http_after_response_rule_list,omitempty"`
	HttpConnectionMode        *FrontendHttpConnectionMode `json:"http_connection_mode,omitempty"`

	// HttpErrorRuleList HAProxy HTTP error rules array (corresponds to http-error directives)
	HttpErrorRuleList    *HttpErrorRules           `json:"http_error_rule_list,omitempty"`
	HttpIgnoreProbes     *FrontendHttpIgnoreProbes `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout *int                      `json:"http_keep_alive_timeout"`
	HttpNoDelay          *FrontendHttpNoDelay      `json:"http_no_delay,omitempty"`

	// HttpRequestRuleList HAProxy HTTP request rules array (corresponds to http-request directives)
	HttpRequestRuleList *HttpRequestRules `json:"http_request_rule_list,omitempty"`
	HttpRequestTimeout  *int              `json:"http_request_timeout"`

	// HttpResponseRuleList HAProxy HTTP response rules array (corresponds to http-response directives)
	HttpResponseRuleList    *HttpResponseRules               `json:"http_response_rule_list,omitempty"`
	HttpRestrictReqHdrNames *FrontendHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpUseProxyHeader      *FrontendHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	Httplog                 *bool                            `json:"httplog,omitempty"`
	Httpslog                *FrontendHttpslog                `json:"httpslog,omitempty"`
	Id                      *int                             `json:"id"`
	IdleCloseOnResponse     *FrontendIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams      *FrontendIndependentStreams      `json:"independent_streams,omitempty"`
	LogFormat               *string                          `json:"log_format,omitempty"`
	LogFormatSd             *string                          `json:"log_format_sd,omitempty"`
	LogSeparateErrors       *FrontendLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogSteps                *[]FrontendLogSteps              `json:"log_steps,omitempty"`
	LogTag                  *string                          `json:"log_tag,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList    *LogTargets                        `json:"log_target_list,omitempty"`
	Logasap          *FrontendLogasap                   `json:"logasap,omitempty"`
	Maxconn          *int                               `json:"maxconn"`
	Metadata         *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Mode             *FrontendMode                      `json:"mode,omitempty"`
	MonitorFail      *MonitorFail                       `json:"monitor_fail,omitempty"`
	MonitorUri       *MonitorUri                        `json:"monitor_uri,omitempty"`
	Name             string                             `json:"name"`
	Nolinger         *FrontendNolinger                  `json:"nolinger,omitempty"`
	Originalto       *Originalto                        `json:"originalto,omitempty"`
	QUICInitialRules *QUICInitialRules                  `json:"quic_initial_rule_list,omitempty"`
	SocketStats      *FrontendSocketStats               `json:"socket_stats,omitempty"`
	SpliceAuto       *FrontendSpliceAuto                `json:"splice_auto,omitempty"`
	SpliceRequest    *FrontendSpliceRequest             `json:"splice_request,omitempty"`
	SpliceResponse   *FrontendSpliceResponse            `json:"splice_response,omitempty"`
	SSLFrontUses     *SSLFrontUses                      `json:"ssl_front_use_list,omitempty"`
	StatsOptions     *StatsOptions                      `json:"stats_options,omitempty"`
	StickTable       *ConfigStickTable                  `json:"stick_table,omitempty"`
	TarpitTimeout    *int                               `json:"tarpit_timeout"`

	// TcpRequestRuleList HAProxy TCP request rules array (corresponds to tcp-request directive)
	TcpRequestRuleList *TcpRequestRules        `json:"tcp_request_rule_list,omitempty"`
	TcpSmartAccept     *FrontendTcpSmartAccept `json:"tcp_smart_accept,omitempty"`
	Tcpka              *FrontendTcpka          `json:"tcpka,omitempty"`
	Tcplog             *bool                   `json:"tcplog,omitempty"`
	UniqueIdFormat     *string                 `json:"unique_id_format,omitempty"`
	UniqueIdHeader     *string                 `json:"unique_id_header,omitempty"`
}

// FrontendAcceptInvalidHttpRequest defines model for Frontend.AcceptInvalidHttpRequest.
type FrontendAcceptInvalidHttpRequest string

// FrontendAcceptUnsafeViolationsInHttpRequest defines model for Frontend.AcceptUnsafeViolationsInHttpRequest.
type FrontendAcceptUnsafeViolationsInHttpRequest string

// FrontendClitcpka defines model for Frontend.Clitcpka.
type FrontendClitcpka string

// FrontendContstats defines model for Frontend.Contstats.
type FrontendContstats string

// FrontendDisableH2Upgrade defines model for Frontend.DisableH2Upgrade.
type FrontendDisableH2Upgrade string

// FrontendDontlogNormal defines model for Frontend.DontlogNormal.
type FrontendDontlogNormal string

// FrontendDontlognull defines model for Frontend.Dontlognull.
type FrontendDontlognull string

// FrontendH1CaseAdjustBogusClient defines model for Frontend.H1CaseAdjustBogusClient.
type FrontendH1CaseAdjustBogusClient string

// FrontendHttpBufferRequest defines model for Frontend.HttpBufferRequest.
type FrontendHttpBufferRequest string

// FrontendHttpDropResponseTrailers defines model for Frontend.HttpDropResponseTrailers.
type FrontendHttpDropResponseTrailers string

// FrontendHttpUseHtx defines model for Frontend.HttpUseHtx.
type FrontendHttpUseHtx string

// FrontendHttpConnectionMode defines model for Frontend.HttpConnectionMode.
type FrontendHttpConnectionMode string

// FrontendHttpIgnoreProbes defines model for Frontend.HttpIgnoreProbes.
type FrontendHttpIgnoreProbes string

// FrontendHttpNoDelay defines model for Frontend.HttpNoDelay.
type FrontendHttpNoDelay string

// FrontendHttpRestrictReqHdrNames defines model for Frontend.HttpRestrictReqHdrNames.
type FrontendHttpRestrictReqHdrNames string

// FrontendHttpUseProxyHeader defines model for Frontend.HttpUseProxyHeader.
type FrontendHttpUseProxyHeader string

// FrontendHttpslog defines model for Frontend.Httpslog.
type FrontendHttpslog string

// FrontendIdleCloseOnResponse defines model for Frontend.IdleCloseOnResponse.
type FrontendIdleCloseOnResponse string

// FrontendIndependentStreams defines model for Frontend.IndependentStreams.
type FrontendIndependentStreams string

// FrontendLogSeparateErrors defines model for Frontend.LogSeparateErrors.
type FrontendLogSeparateErrors string

// FrontendLogSteps defines model for Frontend.LogSteps.
type FrontendLogSteps string

// FrontendLogasap defines model for Frontend.Logasap.
type FrontendLogasap string

// FrontendMode defines model for Frontend.Mode.
type FrontendMode string

// FrontendNolinger defines model for Frontend.Nolinger.
type FrontendNolinger string

// FrontendSocketStats defines model for Frontend.SocketStats.
type FrontendSocketStats string

// FrontendSpliceAuto defines model for Frontend.SpliceAuto.
type FrontendSpliceAuto string

// FrontendSpliceRequest defines model for Frontend.SpliceRequest.
type FrontendSpliceRequest string

// FrontendSpliceResponse defines model for Frontend.SpliceResponse.
type FrontendSpliceResponse string

// FrontendTcpSmartAccept defines model for Frontend.TcpSmartAccept.
type FrontendTcpSmartAccept string

// FrontendTcpka defines model for Frontend.Tcpka.
type FrontendTcpka string

// FrontendBase HAProxy frontend configuration
type FrontendBase struct {
	AcceptInvalidHttpRequest            *FrontendBaseAcceptInvalidHttpRequest            `json:"accept_invalid_http_request,omitempty"`
	AcceptUnsafeViolationsInHttpRequest *FrontendBaseAcceptUnsafeViolationsInHttpRequest `json:"accept_unsafe_violations_in_http_request,omitempty"`
	Backlog                             *int                                             `json:"backlog"`
	Clflog                              *bool                                            `json:"clflog,omitempty"`
	ClientFinTimeout                    *int                                             `json:"client_fin_timeout"`
	ClientTimeout                       *int                                             `json:"client_timeout"`
	Clitcpka                            *FrontendBaseClitcpka                            `json:"clitcpka,omitempty"`
	ClitcpkaCnt                         *int                                             `json:"clitcpka_cnt"`
	ClitcpkaIdle                        *int                                             `json:"clitcpka_idle"`
	ClitcpkaIntvl                       *int                                             `json:"clitcpka_intvl"`
	Compression                         *Compression                                     `json:"compression,omitempty"`
	Contstats                           *FrontendBaseContstats                           `json:"contstats,omitempty"`
	DefaultBackend                      *string                                          `json:"default_backend,omitempty"`
	Description                         *string                                          `json:"description,omitempty"`
	DisableH2Upgrade                    *FrontendBaseDisableH2Upgrade                    `json:"disable_h2_upgrade,omitempty"`
	Disabled                            *bool                                            `json:"disabled,omitempty"`
	DontlogNormal                       *FrontendBaseDontlogNormal                       `json:"dontlog_normal,omitempty"`
	Dontlognull                         *FrontendBaseDontlognull                         `json:"dontlognull,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert                           `json:"email_alert,omitempty"`
	Enabled                  *bool                                 `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile                          `json:"error_files,omitempty"`
	ErrorLogFormat           *string                               `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles                         `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                             `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                             `json:"errorloc303,omitempty"`
	Forwardfor               *Forwardfor                           `json:"forwardfor,omitempty"`
	From                     *string                               `json:"from,omitempty"`
	Guid                     *string                               `json:"guid,omitempty"`
	H1CaseAdjustBogusClient  *FrontendBaseH1CaseAdjustBogusClient  `json:"h1_case_adjust_bogus_client,omitempty"`
	HttpBufferRequest        *FrontendBaseHttpBufferRequest        `json:"http-buffer-request,omitempty"`
	HttpDropResponseTrailers *FrontendBaseHttpDropResponseTrailers `json:"http-drop-response-trailers,omitempty"`
	HttpUseHtx               *FrontendBaseHttpUseHtx               `json:"http-use-htx,omitempty"`
	HttpConnectionMode       *FrontendBaseHttpConnectionMode       `json:"http_connection_mode,omitempty"`
	HttpIgnoreProbes         *FrontendBaseHttpIgnoreProbes         `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout     *int                                  `json:"http_keep_alive_timeout"`
	HttpNoDelay              *FrontendBaseHttpNoDelay              `json:"http_no_delay,omitempty"`
	HttpRequestTimeout       *int                                  `json:"http_request_timeout"`
	HttpRestrictReqHdrNames  *FrontendBaseHttpRestrictReqHdrNames  `json:"http_restrict_req_hdr_names,omitempty"`
	HttpUseProxyHeader       *FrontendBaseHttpUseProxyHeader       `json:"http_use_proxy_header,omitempty"`
	Httplog                  *bool                                 `json:"httplog,omitempty"`
	Httpslog                 *FrontendBaseHttpslog                 `json:"httpslog,omitempty"`
	Id                       *int                                  `json:"id"`
	IdleCloseOnResponse      *FrontendBaseIdleCloseOnResponse      `json:"idle_close_on_response,omitempty"`
	IndependentStreams       *FrontendBaseIndependentStreams       `json:"independent_streams,omitempty"`
	LogFormat                *string                               `json:"log_format,omitempty"`
	LogFormatSd              *string                               `json:"log_format_sd,omitempty"`
	LogSeparateErrors        *FrontendBaseLogSeparateErrors        `json:"log_separate_errors,omitempty"`
	LogSteps                 *[]FrontendBaseLogSteps               `json:"log_steps,omitempty"`
	LogTag                   *string                               `json:"log_tag,omitempty"`
	Logasap                  *FrontendBaseLogasap                  `json:"logasap,omitempty"`
	Maxconn                  *int                                  `json:"maxconn"`
	Metadata                 *map[string]map[string]interface{}    `json:"metadata,omitempty"`
	Mode                     *FrontendBaseMode                     `json:"mode,omitempty"`
	MonitorFail              *MonitorFail                          `json:"monitor_fail,omitempty"`
	MonitorUri               *MonitorUri                           `json:"monitor_uri,omitempty"`
	Name                     string                                `json:"name"`
	Nolinger                 *FrontendBaseNolinger                 `json:"nolinger,omitempty"`
	Originalto               *Originalto                           `json:"originalto,omitempty"`
	SocketStats              *FrontendBaseSocketStats              `json:"socket_stats,omitempty"`
	SpliceAuto               *FrontendBaseSpliceAuto               `json:"splice_auto,omitempty"`
	SpliceRequest            *FrontendBaseSpliceRequest            `json:"splice_request,omitempty"`
	SpliceResponse           *FrontendBaseSpliceResponse           `json:"splice_response,omitempty"`
	StatsOptions             *StatsOptions                         `json:"stats_options,omitempty"`
	StickTable               *ConfigStickTable                     `json:"stick_table,omitempty"`
	TarpitTimeout            *int                                  `json:"tarpit_timeout"`
	TcpSmartAccept           *FrontendBaseTcpSmartAccept           `json:"tcp_smart_accept,omitempty"`
	Tcpka                    *FrontendBaseTcpka                    `json:"tcpka,omitempty"`
	Tcplog                   *bool                                 `json:"tcplog,omitempty"`
	UniqueIdFormat           *string                               `json:"unique_id_format,omitempty"`
	UniqueIdHeader           *string                               `json:"unique_id_header,omitempty"`
}

// FrontendBaseAcceptInvalidHttpRequest defines model for FrontendBase.AcceptInvalidHttpRequest.
type FrontendBaseAcceptInvalidHttpRequest string

// FrontendBaseAcceptUnsafeViolationsInHttpRequest defines model for FrontendBase.AcceptUnsafeViolationsInHttpRequest.
type FrontendBaseAcceptUnsafeViolationsInHttpRequest string

// FrontendBaseClitcpka defines model for FrontendBase.Clitcpka.
type FrontendBaseClitcpka string

// FrontendBaseContstats defines model for FrontendBase.Contstats.
type FrontendBaseContstats string

// FrontendBaseDisableH2Upgrade defines model for FrontendBase.DisableH2Upgrade.
type FrontendBaseDisableH2Upgrade string

// FrontendBaseDontlogNormal defines model for FrontendBase.DontlogNormal.
type FrontendBaseDontlogNormal string

// FrontendBaseDontlognull defines model for FrontendBase.Dontlognull.
type FrontendBaseDontlognull string

// FrontendBaseH1CaseAdjustBogusClient defines model for FrontendBase.H1CaseAdjustBogusClient.
type FrontendBaseH1CaseAdjustBogusClient string

// FrontendBaseHttpBufferRequest defines model for FrontendBase.HttpBufferRequest.
type FrontendBaseHttpBufferRequest string

// FrontendBaseHttpDropResponseTrailers defines model for FrontendBase.HttpDropResponseTrailers.
type FrontendBaseHttpDropResponseTrailers string

// FrontendBaseHttpUseHtx defines model for FrontendBase.HttpUseHtx.
type FrontendBaseHttpUseHtx string

// FrontendBaseHttpConnectionMode defines model for FrontendBase.HttpConnectionMode.
type FrontendBaseHttpConnectionMode string

// FrontendBaseHttpIgnoreProbes defines model for FrontendBase.HttpIgnoreProbes.
type FrontendBaseHttpIgnoreProbes string

// FrontendBaseHttpNoDelay defines model for FrontendBase.HttpNoDelay.
type FrontendBaseHttpNoDelay string

// FrontendBaseHttpRestrictReqHdrNames defines model for FrontendBase.HttpRestrictReqHdrNames.
type FrontendBaseHttpRestrictReqHdrNames string

// FrontendBaseHttpUseProxyHeader defines model for FrontendBase.HttpUseProxyHeader.
type FrontendBaseHttpUseProxyHeader string

// FrontendBaseHttpslog defines model for FrontendBase.Httpslog.
type FrontendBaseHttpslog string

// FrontendBaseIdleCloseOnResponse defines model for FrontendBase.IdleCloseOnResponse.
type FrontendBaseIdleCloseOnResponse string

// FrontendBaseIndependentStreams defines model for FrontendBase.IndependentStreams.
type FrontendBaseIndependentStreams string

// FrontendBaseLogSeparateErrors defines model for FrontendBase.LogSeparateErrors.
type FrontendBaseLogSeparateErrors string

// FrontendBaseLogSteps defines model for FrontendBase.LogSteps.
type FrontendBaseLogSteps string

// FrontendBaseLogasap defines model for FrontendBase.Logasap.
type FrontendBaseLogasap string

// FrontendBaseMode defines model for FrontendBase.Mode.
type FrontendBaseMode string

// FrontendBaseNolinger defines model for FrontendBase.Nolinger.
type FrontendBaseNolinger string

// FrontendBaseSocketStats defines model for FrontendBase.SocketStats.
type FrontendBaseSocketStats string

// FrontendBaseSpliceAuto defines model for FrontendBase.SpliceAuto.
type FrontendBaseSpliceAuto string

// FrontendBaseSpliceRequest defines model for FrontendBase.SpliceRequest.
type FrontendBaseSpliceRequest string

// FrontendBaseSpliceResponse defines model for FrontendBase.SpliceResponse.
type FrontendBaseSpliceResponse string

// FrontendBaseTcpSmartAccept defines model for FrontendBase.TcpSmartAccept.
type FrontendBaseTcpSmartAccept string

// FrontendBaseTcpka defines model for FrontendBase.Tcpka.
type FrontendBaseTcpka string

// Frontends HAProxy frontends array
type Frontends = []Frontend

// GeneralFile General use file
type GeneralFile struct {
	Description *string `json:"description,omitempty"`
	File        *string `json:"file,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Size File size in bytes.
	Size        *int    `json:"size"`
	StorageName *string `json:"storage_name,omitempty"`
}

// GeneralFiles Array of general use files
type GeneralFiles = []GeneralFile

// Global defines model for global.
type Global struct {
	Chroot          *string `json:"chroot,omitempty"`
	CloseSpreadTime *int    `json:"close_spread_time"`
	ClusterSecret   *string `json:"cluster_secret,omitempty"`
	CPUMaps         *[]struct {
		CpuSet  string `json:"cpu_set"`
		Process string `json:"process"`
	} `json:"cpu_maps,omitempty"`
	CpuPolicy *GlobalCpuPolicy `json:"cpu_policy,omitempty"`
	CPUSets   *[]struct {
		Directive GlobalCpuSetDirective `json:"directive"`
		Set       *string               `json:"set,omitempty"`
	} `json:"cpu_set,omitempty"`
	Daemon            *bool         `json:"daemon,omitempty"`
	DebugOptions      *DebugOptions `json:"debug_options,omitempty"`
	GlobalDefaultPath *struct {
		Path *string               `json:"path,omitempty"`
		Type GlobalDefaultPathType `json:"type"`
	} `json:"default_path,omitempty"`
	Description                  *string                 `json:"description,omitempty"`
	DeviceAtlasOptions           *DeviceAtlasOptions     `json:"device_atlas_options,omitempty"`
	DnsAcceptFamily              *string                 `json:"dns_accept_family,omitempty"`
	EnvironmentOptions           *EnvironmentOptions     `json:"environment_options,omitempty"`
	ExposeDeprecatedDirectives   *bool                   `json:"expose_deprecated_directives,omitempty"`
	ExposeExperimentalDirectives *bool                   `json:"expose_experimental_directives,omitempty"`
	ExternalCheck                *bool                   `json:"external_check,omitempty"`
	FiftyOneDegreesOptions       *FiftyOneDegreesOptions `json:"fifty_one_degrees_options,omitempty"`
	ForceCfgParserPause          *int                    `json:"force_cfg_parser_pause"`
	Gid                          *int                    `json:"gid,omitempty"`
	Grace                        *int                    `json:"grace"`
	Group                        *string                 `json:"group,omitempty"`
	H1AcceptPayloadWithAnyMethod *bool                   `json:"h1_accept_payload_with_any_method,omitempty"`
	H1CaseAdjusts                *[]struct {
		From string `json:"from"`
		To   string `json:"to"`
	} `json:"h1_case_adjust,omitempty"`
	H1CaseAdjustFile                       *string `json:"h1_case_adjust_file,omitempty"`
	H1DoNotCloseOnInsecureTransferEncoding *bool   `json:"h1_do_not_close_on_insecure_transfer_encoding,omitempty"`
	H2WorkaroundBogusWebsocketClients      *bool   `json:"h2_workaround_bogus_websocket_clients,omitempty"`
	HardStopAfter                          *int    `json:"hard_stop_after"`
	GlobalHarden                           *struct {
		GlobalHardenRejectPrivilegedPorts *struct {
			Quic *GlobalHardenRejectPrivilegedPortsQuic `json:"quic,omitempty"`
			Tcp  *GlobalHardenRejectPrivilegedPortsTcp  `json:"tcp,omitempty"`
		} `json:"reject_privileged_ports,omitempty"`
	} `json:"harden,omitempty"`
	HttpClientOptions     *HttpClientOptions `json:"http_client_options,omitempty"`
	HttpErrCodes          *[]HTTPCodes       `json:"http_err_codes,omitempty"`
	HttpFailCodes         *[]HTTPCodes       `json:"http_fail_codes,omitempty"`
	InsecureForkWanted    *bool              `json:"insecure_fork_wanted,omitempty"`
	InsecureSetuidWanted  *bool              `json:"insecure_setuid_wanted,omitempty"`
	LimitedQuic           *bool              `json:"limited_quic,omitempty"`
	Localpeer             *string            `json:"localpeer,omitempty"`
	GlobalLogSendHostname *struct {
		Enabled GlobalLogSendHostnameEnabled `json:"enabled"`
		Param   *string                      `json:"param,omitempty"`
	} `json:"log_send_hostname,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList      *LogTargets                        `json:"log_target_list,omitempty"`
	LuaOptions         *LuaOptions                        `json:"lua_options,omitempty"`
	MasterWorker       *bool                              `json:"master-worker,omitempty"`
	Metadata           *map[string]map[string]interface{} `json:"metadata,omitempty"`
	MworkerMaxReloads  *int                               `json:"mworker_max_reloads"`
	Nbthread           *int                               `json:"nbthread,omitempty"`
	NoQuic             *bool                              `json:"no_quic,omitempty"`
	Node               *string                            `json:"node,omitempty"`
	NumaCpuMapping     *GlobalNumaCpuMapping              `json:"numa_cpu_mapping,omitempty"`
	OcspUpdateOptions  *OcspUpdateOptions                 `json:"ocsp_update_options,omitempty"`
	PerformanceOptions *PerformanceOptions                `json:"performance_options,omitempty"`
	Pidfile            *string                            `json:"pidfile,omitempty"`
	Pp2NeverSendLocal  *bool                              `json:"pp2_never_send_local,omitempty"`
	PreallocFd         *bool                              `json:"prealloc_fd,omitempty"`
	RuntimeAPIs        *[]struct {
		AcceptNetscalerCip *int      `json:"accept_netscaler_cip,omitempty"`
		AcceptProxy        *bool     `json:"accept_proxy,omitempty"`
		Address            string    `json:"address"`
		Allow0rtt          *bool     `json:"allow_0rtt,omitempty"`
		Alpn               *string   `json:"alpn,omitempty"`
		Backlog            *string   `json:"backlog,omitempty"`
		CaIgnoreErr        *string   `json:"ca_ignore_err,omitempty"`
		CaSignFile         *string   `json:"ca_sign_file,omitempty"`
		CaSignPass         *string   `json:"ca_sign_pass,omitempty"`
		CaVerifyFile       *string   `json:"ca_verify_file,omitempty"`
		Ciphers            *string   `json:"ciphers,omitempty"`
		Ciphersuites       *string   `json:"ciphersuites,omitempty"`
		ClientSigalgs      *string   `json:"client_sigalgs,omitempty"`
		CrlFile            *string   `json:"crl_file,omitempty"`
		CrtIgnoreErr       *string   `json:"crt_ignore_err,omitempty"`
		CrtList            *string   `json:"crt_list,omitempty"`
		Curves             *string   `json:"curves,omitempty"`
		DefaultCrtList     *[]string `json:"default_crt_list,omitempty"`
		DeferAccept        *bool     `json:"defer_accept,omitempty"`
		Ecdhe              *string   `json:"ecdhe,omitempty"`
		ExposeFdListeners  *bool     `json:"expose_fd_listeners,omitempty"`

		// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
		ForceSslv3     *bool                            `json:"force_sslv3,omitempty"`
		ForceStrictSni *GlobalRuntimeApisForceStrictSni `json:"force_strict_sni,omitempty"`

		// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
		ForceTlsv10 *bool `json:"force_tlsv10,omitempty"`

		// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
		ForceTlsv11 *bool `json:"force_tlsv11,omitempty"`

		// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
		ForceTlsv12 *bool `json:"force_tlsv12,omitempty"`

		// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
		ForceTlsv13          *bool                   `json:"force_tlsv13,omitempty"`
		GenerateCertificates *bool                   `json:"generate_certificates,omitempty"`
		Gid                  *int                    `json:"gid,omitempty"`
		Group                *string                 `json:"group,omitempty"`
		GuidPrefix           *string                 `json:"guid_prefix,omitempty"`
		Id                   *string                 `json:"id,omitempty"`
		IdlePing             *int                    `json:"idle_ping"`
		Interface            *string                 `json:"interface,omitempty"`
		Level                *GlobalRuntimeApisLevel `json:"level,omitempty"`
		Maxconn              *int                    `json:"maxconn,omitempty"`
		Mode                 *string                 `json:"mode,omitempty"`
		Mss                  *string                 `json:"mss,omitempty"`
		Name                 *string                 `json:"name,omitempty"`
		Namespace            *string                 `json:"namespace,omitempty"`
		Nbconn               *int                    `json:"nbconn,omitempty"`
		Nice                 *int                    `json:"nice,omitempty"`
		NoAlpn               *bool                   `json:"no_alpn,omitempty"`
		NoCaNames            *bool                   `json:"no_ca_names,omitempty"`

		// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
		NoSslv3     *bool `json:"no_sslv3,omitempty"`
		NoStrictSni *bool `json:"no_strict_sni,omitempty"`

		// NoTlsTickets This field is deprecated in favor of tls_tickets, and will be removed in a future release
		NoTlsTickets *bool `json:"no_tls_tickets,omitempty"`

		// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
		NoTlsv10 *bool `json:"no_tlsv10,omitempty"`

		// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
		NoTlsv11 *bool `json:"no_tlsv11,omitempty"`

		// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
		NoTlsv12 *bool `json:"no_tlsv12,omitempty"`

		// NoTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
		NoTlsv13            *bool                            `json:"no_tlsv13,omitempty"`
		Npn                 *string                          `json:"npn,omitempty"`
		PreferClientCiphers *bool                            `json:"prefer_client_ciphers,omitempty"`
		Proto               *string                          `json:"proto,omitempty"`
		QuicCcAlgo          *GlobalRuntimeApisQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
		QuicForceRetry      *bool                            `json:"quic-force-retry,omitempty"`
		QuicSocket          *GlobalRuntimeApisQuicSocket     `json:"quic-socket,omitempty"`
		QuicCcAlgoBurstSize *int                             `json:"quic_cc_algo_burst_size"`
		QuicCcAlgoMaxWindow *int                             `json:"quic_cc_algo_max_window"`
		SeverityOutput      *GlobalRuntimeApisSeverityOutput `json:"severity_output,omitempty"`
		Sigalgs             *string                          `json:"sigalgs,omitempty"`
		Ssl                 *bool                            `json:"ssl,omitempty"`
		SslCafile           *string                          `json:"ssl_cafile,omitempty"`
		SslCertificate      *string                          `json:"ssl_certificate,omitempty"`
		SslMaxVer           *GlobalRuntimeApisSslMaxVer      `json:"ssl_max_ver,omitempty"`
		SslMinVer           *GlobalRuntimeApisSslMinVer      `json:"ssl_min_ver,omitempty"`
		Sslv3               *GlobalRuntimeApisSslv3          `json:"sslv3,omitempty"`
		StrictSni           *bool                            `json:"strict_sni,omitempty"`
		TcpUserTimeout      *int                             `json:"tcp_user_timeout"`
		Tfo                 *bool                            `json:"tfo,omitempty"`
		Thread              *string                          `json:"thread,omitempty"`
		TlsTicketKeys       *string                          `json:"tls_ticket_keys,omitempty"`
		TlsTickets          *GlobalRuntimeApisTlsTickets     `json:"tls_tickets,omitempty"`
		Tlsv10              *GlobalRuntimeApisTlsv10         `json:"tlsv10,omitempty"`
		Tlsv11              *GlobalRuntimeApisTlsv11         `json:"tlsv11,omitempty"`
		Tlsv12              *GlobalRuntimeApisTlsv12         `json:"tlsv12,omitempty"`
		Tlsv13              *GlobalRuntimeApisTlsv13         `json:"tlsv13,omitempty"`
		Transparent         *bool                            `json:"transparent,omitempty"`
		Uid                 *string                          `json:"uid,omitempty"`
		User                *string                          `json:"user,omitempty"`
		V4v6                *bool                            `json:"v4v6,omitempty"`
		V6only              *bool                            `json:"v6only,omitempty"`
		Verify              *GlobalRuntimeApisVerify         `json:"verify,omitempty"`
	} `json:"runtime_apis,omitempty"`
	SetDumpable *bool `json:"set_dumpable,omitempty"`
	SetVars     *[]struct {
		Expr string `json:"expr"`
		Name string `json:"name"`
	} `json:"set_var,omitempty"`
	SetVarFmts *[]struct {
		Format string `json:"format"`
		Name   string `json:"name"`
	} `json:"set_var_fmt,omitempty"`
	Setcap           *string     `json:"setcap,omitempty"`
	SslOptions       *SslOptions `json:"ssl_options,omitempty"`
	StatsFile        *string     `json:"stats_file,omitempty"`
	StatsMaxconn     *int        `json:"stats_maxconn"`
	StatsTimeout     *int        `json:"stats_timeout"`
	StrictLimits     *bool       `json:"strict_limits,omitempty"`
	ThreadGroupLines *[]struct {
		Group      string `json:"group"`
		NumOrRange string `json:"num_or_range"`
	} `json:"thread_group_lines,omitempty"`
	ThreadGroups            *int               `json:"thread_groups,omitempty"`
	TuneBufferOptions       *TuneBufferOptions `json:"tune_buffer_options,omitempty"`
	TuneLuaOptions          *TuneLuaOptions    `json:"tune_lua_options,omitempty"`
	TuneOptions             *TuneOptions       `json:"tune_options,omitempty"`
	TuneQuicOptions         *TuneQuicOptions   `json:"tune_quic_options,omitempty"`
	TuneSslOptions          *TuneSslOptions    `json:"tune_ssl_options,omitempty"`
	TuneVarsOptions         *TuneVarsOptions   `json:"tune_vars_options,omitempty"`
	TuneZlibOptions         *TuneZlibOptions   `json:"tune_zlib_options,omitempty"`
	Uid                     *int               `json:"uid,omitempty"`
	UlimitN                 *int               `json:"ulimit_n,omitempty"`
	User                    *string            `json:"user,omitempty"`
	WarnBlockedTrafficAfter *int               `json:"warn_blocked_traffic_after"`
	WurflOptions            *WurflOptions      `json:"wurfl_options,omitempty"`
}

// GlobalCpuPolicy defines model for Global.CpuPolicy.
type GlobalCpuPolicy string

// GlobalCpuSetDirective defines model for Global.CpuSet.Directive.
type GlobalCpuSetDirective string

// GlobalDefaultPathType defines model for Global.DefaultPath.Type.
type GlobalDefaultPathType string

// GlobalHardenRejectPrivilegedPortsQuic defines model for Global.Harden.RejectPrivilegedPorts.Quic.
type GlobalHardenRejectPrivilegedPortsQuic string

// GlobalHardenRejectPrivilegedPortsTcp defines model for Global.Harden.RejectPrivilegedPorts.Tcp.
type GlobalHardenRejectPrivilegedPortsTcp string

// GlobalLogSendHostnameEnabled defines model for Global.LogSendHostname.Enabled.
type GlobalLogSendHostnameEnabled string

// GlobalNumaCpuMapping defines model for Global.NumaCpuMapping.
type GlobalNumaCpuMapping string

// GlobalRuntimeApisForceStrictSni defines model for Global.RuntimeApis.ForceStrictSni.
type GlobalRuntimeApisForceStrictSni string

// GlobalRuntimeApisLevel defines model for Global.RuntimeApis.Level.
type GlobalRuntimeApisLevel string

// GlobalRuntimeApisQuicCcAlgo defines model for Global.RuntimeApis.QuicCcAlgo.
type GlobalRuntimeApisQuicCcAlgo string

// GlobalRuntimeApisQuicSocket defines model for Global.RuntimeApis.QuicSocket.
type GlobalRuntimeApisQuicSocket string

// GlobalRuntimeApisSeverityOutput defines model for Global.RuntimeApis.SeverityOutput.
type GlobalRuntimeApisSeverityOutput string

// GlobalRuntimeApisSslMaxVer defines model for Global.RuntimeApis.SslMaxVer.
type GlobalRuntimeApisSslMaxVer string

// GlobalRuntimeApisSslMinVer defines model for Global.RuntimeApis.SslMinVer.
type GlobalRuntimeApisSslMinVer string

// GlobalRuntimeApisSslv3 defines model for Global.RuntimeApis.Sslv3.
type GlobalRuntimeApisSslv3 string

// GlobalRuntimeApisTlsTickets defines model for Global.RuntimeApis.TlsTickets.
type GlobalRuntimeApisTlsTickets string

// GlobalRuntimeApisTlsv10 defines model for Global.RuntimeApis.Tlsv10.
type GlobalRuntimeApisTlsv10 string

// GlobalRuntimeApisTlsv11 defines model for Global.RuntimeApis.Tlsv11.
type GlobalRuntimeApisTlsv11 string

// GlobalRuntimeApisTlsv12 defines model for Global.RuntimeApis.Tlsv12.
type GlobalRuntimeApisTlsv12 string

// GlobalRuntimeApisTlsv13 defines model for Global.RuntimeApis.Tlsv13.
type GlobalRuntimeApisTlsv13 string

// GlobalRuntimeApisVerify defines model for Global.RuntimeApis.Verify.
type GlobalRuntimeApisVerify string

// GlobalBase HAProxy global configuration
type GlobalBase struct {
	Chroot          *string `json:"chroot,omitempty"`
	CloseSpreadTime *int    `json:"close_spread_time"`
	ClusterSecret   *string `json:"cluster_secret,omitempty"`
	CPUMaps         *[]struct {
		CpuSet  string `json:"cpu_set"`
		Process string `json:"process"`
	} `json:"cpu_maps,omitempty"`
	CpuPolicy *GlobalBaseCpuPolicy `json:"cpu_policy,omitempty"`
	CPUSets   *[]struct {
		Directive GlobalBaseCpuSetDirective `json:"directive"`
		Set       *string                   `json:"set,omitempty"`
	} `json:"cpu_set,omitempty"`
	Daemon            *bool         `json:"daemon,omitempty"`
	DebugOptions      *DebugOptions `json:"debug_options,omitempty"`
	GlobalDefaultPath *struct {
		Path *string                   `json:"path,omitempty"`
		Type GlobalBaseDefaultPathType `json:"type"`
	} `json:"default_path,omitempty"`
	Description                  *string                 `json:"description,omitempty"`
	DeviceAtlasOptions           *DeviceAtlasOptions     `json:"device_atlas_options,omitempty"`
	DnsAcceptFamily              *string                 `json:"dns_accept_family,omitempty"`
	EnvironmentOptions           *EnvironmentOptions     `json:"environment_options,omitempty"`
	ExposeDeprecatedDirectives   *bool                   `json:"expose_deprecated_directives,omitempty"`
	ExposeExperimentalDirectives *bool                   `json:"expose_experimental_directives,omitempty"`
	ExternalCheck                *bool                   `json:"external_check,omitempty"`
	FiftyOneDegreesOptions       *FiftyOneDegreesOptions `json:"fifty_one_degrees_options,omitempty"`
	ForceCfgParserPause          *int                    `json:"force_cfg_parser_pause"`
	Gid                          *int                    `json:"gid,omitempty"`
	Grace                        *int                    `json:"grace"`
	Group                        *string                 `json:"group,omitempty"`
	H1AcceptPayloadWithAnyMethod *bool                   `json:"h1_accept_payload_with_any_method,omitempty"`
	H1CaseAdjusts                *[]struct {
		From string `json:"from"`
		To   string `json:"to"`
	} `json:"h1_case_adjust,omitempty"`
	H1CaseAdjustFile                       *string `json:"h1_case_adjust_file,omitempty"`
	H1DoNotCloseOnInsecureTransferEncoding *bool   `json:"h1_do_not_close_on_insecure_transfer_encoding,omitempty"`
	H2WorkaroundBogusWebsocketClients      *bool   `json:"h2_workaround_bogus_websocket_clients,omitempty"`
	HardStopAfter                          *int    `json:"hard_stop_after"`
	GlobalHarden                           *struct {
		GlobalHardenRejectPrivilegedPorts *struct {
			Quic *GlobalBaseHardenRejectPrivilegedPortsQuic `json:"quic,omitempty"`
			Tcp  *GlobalBaseHardenRejectPrivilegedPortsTcp  `json:"tcp,omitempty"`
		} `json:"reject_privileged_ports,omitempty"`
	} `json:"harden,omitempty"`
	HttpClientOptions     *HttpClientOptions `json:"http_client_options,omitempty"`
	HttpErrCodes          *[]HTTPCodes       `json:"http_err_codes,omitempty"`
	HttpFailCodes         *[]HTTPCodes       `json:"http_fail_codes,omitempty"`
	InsecureForkWanted    *bool              `json:"insecure_fork_wanted,omitempty"`
	InsecureSetuidWanted  *bool              `json:"insecure_setuid_wanted,omitempty"`
	LimitedQuic           *bool              `json:"limited_quic,omitempty"`
	Localpeer             *string            `json:"localpeer,omitempty"`
	GlobalLogSendHostname *struct {
		Enabled GlobalBaseLogSendHostnameEnabled `json:"enabled"`
		Param   *string                          `json:"param,omitempty"`
	} `json:"log_send_hostname,omitempty"`
	LuaOptions         *LuaOptions                        `json:"lua_options,omitempty"`
	MasterWorker       *bool                              `json:"master-worker,omitempty"`
	Metadata           *map[string]map[string]interface{} `json:"metadata,omitempty"`
	MworkerMaxReloads  *int                               `json:"mworker_max_reloads"`
	Nbthread           *int                               `json:"nbthread,omitempty"`
	NoQuic             *bool                              `json:"no_quic,omitempty"`
	Node               *string                            `json:"node,omitempty"`
	NumaCpuMapping     *GlobalBaseNumaCpuMapping          `json:"numa_cpu_mapping,omitempty"`
	OcspUpdateOptions  *OcspUpdateOptions                 `json:"ocsp_update_options,omitempty"`
	PerformanceOptions *PerformanceOptions                `json:"performance_options,omitempty"`
	Pidfile            *string                            `json:"pidfile,omitempty"`
	Pp2NeverSendLocal  *bool                              `json:"pp2_never_send_local,omitempty"`
	PreallocFd         *bool                              `json:"prealloc_fd,omitempty"`
	RuntimeAPIs        *[]struct {
		AcceptNetscalerCip *int      `json:"accept_netscaler_cip,omitempty"`
		AcceptProxy        *bool     `json:"accept_proxy,omitempty"`
		Address            string    `json:"address"`
		Allow0rtt          *bool     `json:"allow_0rtt,omitempty"`
		Alpn               *string   `json:"alpn,omitempty"`
		Backlog            *string   `json:"backlog,omitempty"`
		CaIgnoreErr        *string   `json:"ca_ignore_err,omitempty"`
		CaSignFile         *string   `json:"ca_sign_file,omitempty"`
		CaSignPass         *string   `json:"ca_sign_pass,omitempty"`
		CaVerifyFile       *string   `json:"ca_verify_file,omitempty"`
		Ciphers            *string   `json:"ciphers,omitempty"`
		Ciphersuites       *string   `json:"ciphersuites,omitempty"`
		ClientSigalgs      *string   `json:"client_sigalgs,omitempty"`
		CrlFile            *string   `json:"crl_file,omitempty"`
		CrtIgnoreErr       *string   `json:"crt_ignore_err,omitempty"`
		CrtList            *string   `json:"crt_list,omitempty"`
		Curves             *string   `json:"curves,omitempty"`
		DefaultCrtList     *[]string `json:"default_crt_list,omitempty"`
		DeferAccept        *bool     `json:"defer_accept,omitempty"`
		Ecdhe              *string   `json:"ecdhe,omitempty"`
		ExposeFdListeners  *bool     `json:"expose_fd_listeners,omitempty"`

		// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
		ForceSslv3     *bool                                `json:"force_sslv3,omitempty"`
		ForceStrictSni *GlobalBaseRuntimeApisForceStrictSni `json:"force_strict_sni,omitempty"`

		// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
		ForceTlsv10 *bool `json:"force_tlsv10,omitempty"`

		// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
		ForceTlsv11 *bool `json:"force_tlsv11,omitempty"`

		// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
		ForceTlsv12 *bool `json:"force_tlsv12,omitempty"`

		// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
		ForceTlsv13          *bool                       `json:"force_tlsv13,omitempty"`
		GenerateCertificates *bool                       `json:"generate_certificates,omitempty"`
		Gid                  *int                        `json:"gid,omitempty"`
		Group                *string                     `json:"group,omitempty"`
		GuidPrefix           *string                     `json:"guid_prefix,omitempty"`
		Id                   *string                     `json:"id,omitempty"`
		IdlePing             *int                        `json:"idle_ping"`
		Interface            *string                     `json:"interface,omitempty"`
		Level                *GlobalBaseRuntimeApisLevel `json:"level,omitempty"`
		Maxconn              *int                        `json:"maxconn,omitempty"`
		Mode                 *string                     `json:"mode,omitempty"`
		Mss                  *string                     `json:"mss,omitempty"`
		Name                 *string                     `json:"name,omitempty"`
		Namespace            *string                     `json:"namespace,omitempty"`
		Nbconn               *int                        `json:"nbconn,omitempty"`
		Nice                 *int                        `json:"nice,omitempty"`
		NoAlpn               *bool                       `json:"no_alpn,omitempty"`
		NoCaNames            *bool                       `json:"no_ca_names,omitempty"`

		// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
		NoSslv3     *bool `json:"no_sslv3,omitempty"`
		NoStrictSni *bool `json:"no_strict_sni,omitempty"`

		// NoTlsTickets This field is deprecated in favor of tls_tickets, and will be removed in a future release
		NoTlsTickets *bool `json:"no_tls_tickets,omitempty"`

		// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
		NoTlsv10 *bool `json:"no_tlsv10,omitempty"`

		// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
		NoTlsv11 *bool `json:"no_tlsv11,omitempty"`

		// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
		NoTlsv12 *bool `json:"no_tlsv12,omitempty"`

		// NoTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
		NoTlsv13            *bool                                `json:"no_tlsv13,omitempty"`
		Npn                 *string                              `json:"npn,omitempty"`
		PreferClientCiphers *bool                                `json:"prefer_client_ciphers,omitempty"`
		Proto               *string                              `json:"proto,omitempty"`
		QuicCcAlgo          *GlobalBaseRuntimeApisQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
		QuicForceRetry      *bool                                `json:"quic-force-retry,omitempty"`
		QuicSocket          *GlobalBaseRuntimeApisQuicSocket     `json:"quic-socket,omitempty"`
		QuicCcAlgoBurstSize *int                                 `json:"quic_cc_algo_burst_size"`
		QuicCcAlgoMaxWindow *int                                 `json:"quic_cc_algo_max_window"`
		SeverityOutput      *GlobalBaseRuntimeApisSeverityOutput `json:"severity_output,omitempty"`
		Sigalgs             *string                              `json:"sigalgs,omitempty"`
		Ssl                 *bool                                `json:"ssl,omitempty"`
		SslCafile           *string                              `json:"ssl_cafile,omitempty"`
		SslCertificate      *string                              `json:"ssl_certificate,omitempty"`
		SslMaxVer           *GlobalBaseRuntimeApisSslMaxVer      `json:"ssl_max_ver,omitempty"`
		SslMinVer           *GlobalBaseRuntimeApisSslMinVer      `json:"ssl_min_ver,omitempty"`
		Sslv3               *GlobalBaseRuntimeApisSslv3          `json:"sslv3,omitempty"`
		StrictSni           *bool                                `json:"strict_sni,omitempty"`
		TcpUserTimeout      *int                                 `json:"tcp_user_timeout"`
		Tfo                 *bool                                `json:"tfo,omitempty"`
		Thread              *string                              `json:"thread,omitempty"`
		TlsTicketKeys       *string                              `json:"tls_ticket_keys,omitempty"`
		TlsTickets          *GlobalBaseRuntimeApisTlsTickets     `json:"tls_tickets,omitempty"`
		Tlsv10              *GlobalBaseRuntimeApisTlsv10         `json:"tlsv10,omitempty"`
		Tlsv11              *GlobalBaseRuntimeApisTlsv11         `json:"tlsv11,omitempty"`
		Tlsv12              *GlobalBaseRuntimeApisTlsv12         `json:"tlsv12,omitempty"`
		Tlsv13              *GlobalBaseRuntimeApisTlsv13         `json:"tlsv13,omitempty"`
		Transparent         *bool                                `json:"transparent,omitempty"`
		Uid                 *string                              `json:"uid,omitempty"`
		User                *string                              `json:"user,omitempty"`
		V4v6                *bool                                `json:"v4v6,omitempty"`
		V6only              *bool                                `json:"v6only,omitempty"`
		Verify              *GlobalBaseRuntimeApisVerify         `json:"verify,omitempty"`
	} `json:"runtime_apis,omitempty"`
	SetDumpable *bool `json:"set_dumpable,omitempty"`
	SetVars     *[]struct {
		Expr string `json:"expr"`
		Name string `json:"name"`
	} `json:"set_var,omitempty"`
	SetVarFmts *[]struct {
		Format string `json:"format"`
		Name   string `json:"name"`
	} `json:"set_var_fmt,omitempty"`
	Setcap           *string     `json:"setcap,omitempty"`
	SslOptions       *SslOptions `json:"ssl_options,omitempty"`
	StatsFile        *string     `json:"stats_file,omitempty"`
	StatsMaxconn     *int        `json:"stats_maxconn"`
	StatsTimeout     *int        `json:"stats_timeout"`
	StrictLimits     *bool       `json:"strict_limits,omitempty"`
	ThreadGroupLines *[]struct {
		Group      string `json:"group"`
		NumOrRange string `json:"num_or_range"`
	} `json:"thread_group_lines,omitempty"`
	ThreadGroups            *int               `json:"thread_groups,omitempty"`
	TuneBufferOptions       *TuneBufferOptions `json:"tune_buffer_options,omitempty"`
	TuneLuaOptions          *TuneLuaOptions    `json:"tune_lua_options,omitempty"`
	TuneOptions             *TuneOptions       `json:"tune_options,omitempty"`
	TuneQuicOptions         *TuneQuicOptions   `json:"tune_quic_options,omitempty"`
	TuneSslOptions          *TuneSslOptions    `json:"tune_ssl_options,omitempty"`
	TuneVarsOptions         *TuneVarsOptions   `json:"tune_vars_options,omitempty"`
	TuneZlibOptions         *TuneZlibOptions   `json:"tune_zlib_options,omitempty"`
	Uid                     *int               `json:"uid,omitempty"`
	UlimitN                 *int               `json:"ulimit_n,omitempty"`
	User                    *string            `json:"user,omitempty"`
	WarnBlockedTrafficAfter *int               `json:"warn_blocked_traffic_after"`
	WurflOptions            *WurflOptions      `json:"wurfl_options,omitempty"`
}

// GlobalBaseCpuPolicy defines model for GlobalBase.CpuPolicy.
type GlobalBaseCpuPolicy string

// GlobalBaseCpuSetDirective defines model for GlobalBase.CpuSet.Directive.
type GlobalBaseCpuSetDirective string

// GlobalBaseDefaultPathType defines model for GlobalBase.DefaultPath.Type.
type GlobalBaseDefaultPathType string

// GlobalBaseHardenRejectPrivilegedPortsQuic defines model for GlobalBase.Harden.RejectPrivilegedPorts.Quic.
type GlobalBaseHardenRejectPrivilegedPortsQuic string

// GlobalBaseHardenRejectPrivilegedPortsTcp defines model for GlobalBase.Harden.RejectPrivilegedPorts.Tcp.
type GlobalBaseHardenRejectPrivilegedPortsTcp string

// GlobalBaseLogSendHostnameEnabled defines model for GlobalBase.LogSendHostname.Enabled.
type GlobalBaseLogSendHostnameEnabled string

// GlobalBaseNumaCpuMapping defines model for GlobalBase.NumaCpuMapping.
type GlobalBaseNumaCpuMapping string

// GlobalBaseRuntimeApisForceStrictSni defines model for GlobalBase.RuntimeApis.ForceStrictSni.
type GlobalBaseRuntimeApisForceStrictSni string

// GlobalBaseRuntimeApisLevel defines model for GlobalBase.RuntimeApis.Level.
type GlobalBaseRuntimeApisLevel string

// GlobalBaseRuntimeApisQuicCcAlgo defines model for GlobalBase.RuntimeApis.QuicCcAlgo.
type GlobalBaseRuntimeApisQuicCcAlgo string

// GlobalBaseRuntimeApisQuicSocket defines model for GlobalBase.RuntimeApis.QuicSocket.
type GlobalBaseRuntimeApisQuicSocket string

// GlobalBaseRuntimeApisSeverityOutput defines model for GlobalBase.RuntimeApis.SeverityOutput.
type GlobalBaseRuntimeApisSeverityOutput string

// GlobalBaseRuntimeApisSslMaxVer defines model for GlobalBase.RuntimeApis.SslMaxVer.
type GlobalBaseRuntimeApisSslMaxVer string

// GlobalBaseRuntimeApisSslMinVer defines model for GlobalBase.RuntimeApis.SslMinVer.
type GlobalBaseRuntimeApisSslMinVer string

// GlobalBaseRuntimeApisSslv3 defines model for GlobalBase.RuntimeApis.Sslv3.
type GlobalBaseRuntimeApisSslv3 string

// GlobalBaseRuntimeApisTlsTickets defines model for GlobalBase.RuntimeApis.TlsTickets.
type GlobalBaseRuntimeApisTlsTickets string

// GlobalBaseRuntimeApisTlsv10 defines model for GlobalBase.RuntimeApis.Tlsv10.
type GlobalBaseRuntimeApisTlsv10 string

// GlobalBaseRuntimeApisTlsv11 defines model for GlobalBase.RuntimeApis.Tlsv11.
type GlobalBaseRuntimeApisTlsv11 string

// GlobalBaseRuntimeApisTlsv12 defines model for GlobalBase.RuntimeApis.Tlsv12.
type GlobalBaseRuntimeApisTlsv12 string

// GlobalBaseRuntimeApisTlsv13 defines model for GlobalBase.RuntimeApis.Tlsv13.
type GlobalBaseRuntimeApisTlsv13 string

// GlobalBaseRuntimeApisVerify defines model for GlobalBase.RuntimeApis.Verify.
type GlobalBaseRuntimeApisVerify string

// Group HAProxy userlist group
type Group struct {
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`
	Users    *string                            `json:"users,omitempty"`
}

// Groups HAProxy userlist groups array
type Groups = []Group

// HashType defines model for hash_type.
type HashType struct {
	Function *HashTypeFunction `json:"function,omitempty"`
	Method   *HashTypeMethod   `json:"method,omitempty"`
	Modifier *HashTypeModifier `json:"modifier,omitempty"`
}

// HashTypeFunction defines model for HashType.Function.
type HashTypeFunction string

// HashTypeMethod defines model for HashType.Method.
type HashTypeMethod string

// HashTypeModifier defines model for HashType.Modifier.
type HashTypeModifier string

// Health defines model for health.
type Health struct {
	Haproxy *HealthHaproxy `json:"haproxy,omitempty"`
}

// HealthHaproxy defines model for Health.Haproxy.
type HealthHaproxy string

// HttpAfterResponseRule HAProxy HTTP after response rule configuration (corresponds to http-after-response directives)
type HttpAfterResponseRule struct {
	AclFile       *string                            `json:"acl_file,omitempty"`
	AclKeyfmt     *string                            `json:"acl_keyfmt,omitempty"`
	CaptureId     *int                               `json:"capture_id"`
	CaptureLen    *int                               `json:"capture_len,omitempty"`
	CaptureSample *string                            `json:"capture_sample,omitempty"`
	Cond          *HttpAfterResponseRuleCond         `json:"cond,omitempty"`
	CondTest      *string                            `json:"cond_test,omitempty"`
	HdrFormat     *string                            `json:"hdr_format,omitempty"`
	HdrMatch      *string                            `json:"hdr_match,omitempty"`
	HdrMethod     *string                            `json:"hdr_method,omitempty"`
	HdrName       *string                            `json:"hdr_name,omitempty"`
	LogLevel      *HttpAfterResponseRuleLogLevel     `json:"log_level,omitempty"`
	MapFile       *string                            `json:"map_file,omitempty"`
	MapKeyfmt     *string                            `json:"map_keyfmt,omitempty"`
	MapValuefmt   *string                            `json:"map_valuefmt,omitempty"`
	Metadata      *map[string]map[string]interface{} `json:"metadata,omitempty"`
	ScExpr        *string                            `json:"sc_expr,omitempty"`
	ScId          *int                               `json:"sc_id,omitempty"`
	ScIdx         *int                               `json:"sc_idx,omitempty"`
	ScInt         *int                               `json:"sc_int"`
	Status        *int                               `json:"status,omitempty"`
	StatusReason  *string                            `json:"status_reason,omitempty"`
	StrictMode    *HttpAfterResponseRuleStrictMode   `json:"strict_mode,omitempty"`
	Type          HttpAfterResponseRuleType          `json:"type"`
	VarExpr       *string                            `json:"var_expr,omitempty"`
	VarFormat     *string                            `json:"var_format,omitempty"`
	VarName       *string                            `json:"var_name,omitempty"`
	VarScope      *string                            `json:"var_scope,omitempty"`
}

// HttpAfterResponseRuleCond defines model for HttpAfterResponseRule.Cond.
type HttpAfterResponseRuleCond string

// HttpAfterResponseRuleLogLevel defines model for HttpAfterResponseRule.LogLevel.
type HttpAfterResponseRuleLogLevel string

// HttpAfterResponseRuleStrictMode defines model for HttpAfterResponseRule.StrictMode.
type HttpAfterResponseRuleStrictMode string

// HttpAfterResponseRuleType defines model for HttpAfterResponseRule.Type.
type HttpAfterResponseRuleType string

// HttpAfterResponseRules HAProxy HTTP after response rules array (corresponds to http-after-response directives)
type HttpAfterResponseRules = []HttpAfterResponseRule

// HttpCheck defines model for http_check.
type HttpCheck struct {
	Addr            *string                            `json:"addr,omitempty"`
	Alpn            *string                            `json:"alpn,omitempty"`
	Body            *string                            `json:"body,omitempty"`
	BodyLogFormat   *string                            `json:"body_log_format,omitempty"`
	CheckComment    *string                            `json:"check_comment,omitempty"`
	Default         *bool                              `json:"default,omitempty"`
	ErrorStatus     *HttpCheckErrorStatus              `json:"error_status,omitempty"`
	ExclamationMark *bool                              `json:"exclamation_mark,omitempty"`
	CheckHeaders    *[]ReturnHeader                    `json:"headers,omitempty"`
	Linger          *bool                              `json:"linger,omitempty"`
	Match           *HttpCheckMatch                    `json:"match,omitempty"`
	Metadata        *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Method          *HttpCheckMethod                   `json:"method,omitempty"`
	MinRecv         *int                               `json:"min_recv"`
	OkStatus        *HttpCheckOkStatus                 `json:"ok_status,omitempty"`
	OnError         *string                            `json:"on_error,omitempty"`
	OnSuccess       *string                            `json:"on_success,omitempty"`
	Pattern         *string                            `json:"pattern,omitempty"`
	Port            *int                               `json:"port"`
	PortString      *string                            `json:"port_string,omitempty"`
	Proto           *string                            `json:"proto,omitempty"`
	SendProxy       *bool                              `json:"send_proxy,omitempty"`
	Sni             *string                            `json:"sni,omitempty"`
	Ssl             *bool                              `json:"ssl,omitempty"`
	StatusCode      *string                            `json:"status-code,omitempty"`
	ToutStatus      *HttpCheckToutStatus               `json:"tout_status,omitempty"`
	Type            HttpCheckType                      `json:"type"`
	Uri             *string                            `json:"uri,omitempty"`
	UriLogFormat    *string                            `json:"uri_log_format,omitempty"`
	VarExpr         *string                            `json:"var_expr,omitempty"`
	VarFormat       *string                            `json:"var_format,omitempty"`
	VarName         *string                            `json:"var_name,omitempty"`
	VarScope        *string                            `json:"var_scope,omitempty"`
	Version         *string                            `json:"version,omitempty"`
	ViaSocks4       *bool                              `json:"via_socks4,omitempty"`
}

// HttpCheckErrorStatus defines model for HttpCheck.ErrorStatus.
type HttpCheckErrorStatus string

// HttpCheckMatch defines model for HttpCheck.Match.
type HttpCheckMatch string

// HttpCheckMethod defines model for HttpCheck.Method.
type HttpCheckMethod string

// HttpCheckOkStatus defines model for HttpCheck.OkStatus.
type HttpCheckOkStatus string

// HttpCheckToutStatus defines model for HttpCheck.ToutStatus.
type HttpCheckToutStatus string

// HttpCheckType defines model for HttpCheck.Type.
type HttpCheckType string

// HttpChecks defines model for http_checks.
type HttpChecks = []HttpCheck

// HttpClientOptions defines model for http_client_options.
type HttpClientOptions struct {
	ResolversDisabled *HttpClientOptionsResolversDisabled `json:"resolvers_disabled,omitempty"`
	ResolversId       *string                             `json:"resolvers_id,omitempty"`
	ResolversPrefer   *HttpClientOptionsResolversPrefer   `json:"resolvers_prefer,omitempty"`
	Retries           *int                                `json:"retries,omitempty"`
	SslCaFile         *string                             `json:"ssl_ca_file,omitempty"`
	SslVerify         *HttpClientOptionsSslVerify         `json:"ssl_verify"`
	TimeoutConnect    *int                                `json:"timeout_connect"`
}

// HttpClientOptionsResolversDisabled defines model for HttpClientOptions.ResolversDisabled.
type HttpClientOptionsResolversDisabled string

// HttpClientOptionsResolversPrefer defines model for HttpClientOptions.ResolversPrefer.
type HttpClientOptionsResolversPrefer string

// HttpClientOptionsSslVerify defines model for HttpClientOptions.SslVerify.
type HttpClientOptionsSslVerify string

// HTTPCodes defines model for http_codes.
type HTTPCodes struct {
	Value string `json:"value"`
}

// HttpErrorRule HAProxy HTTP error rule configuration (corresponds to http-error directives)
type HttpErrorRule struct {
	Metadata            *map[string]map[string]interface{} `json:"metadata,omitempty"`
	ReturnContent       *string                            `json:"return_content,omitempty"`
	ReturnContentFormat *HttpErrorRuleReturnContentFormat  `json:"return_content_format,omitempty"`
	ReturnContentType   *string                            `json:"return_content_type"`
	ReturnHeaders       *[]ReturnHeader                    `json:"return_hdrs,omitempty"`
	Status              HttpErrorRuleStatus                `json:"status"`
	Type                HttpErrorRuleType                  `json:"type"`
}

// HttpErrorRuleReturnContentFormat defines model for HttpErrorRule.ReturnContentFormat.
type HttpErrorRuleReturnContentFormat string

// HttpErrorRuleStatus defines model for HttpErrorRule.Status.
type HttpErrorRuleStatus int

// HttpErrorRuleType defines model for HttpErrorRule.Type.
type HttpErrorRuleType string

// HttpErrorRules HAProxy HTTP error rules array (corresponds to http-error directives)
type HttpErrorRules = []HttpErrorRule

// HttpErrorsSection A globally declared group of HTTP errors
type HttpErrorsSection struct {
	ErrorFiles []Errorfile                        `json:"error_files"`
	Metadata   *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name       string                             `json:"name"`
}

// HttpErrorsSections An array of HAProxy http-error sections
type HttpErrorsSections = []HttpErrorsSection

// HttpRequestRule HAProxy HTTP request rule configuration (corresponds to http-request directives)
type HttpRequestRule struct {
	AclFile              *string                             `json:"acl_file,omitempty"`
	AclKeyfmt            *string                             `json:"acl_keyfmt,omitempty"`
	AuthRealm            *string                             `json:"auth_realm,omitempty"`
	BandwidthLimitLimit  *string                             `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                             `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                             `json:"bandwidth_limit_period,omitempty"`
	CacheName            *string                             `json:"cache_name,omitempty"`
	CaptureId            *int                                `json:"capture_id"`
	CaptureLen           *int                                `json:"capture_len,omitempty"`
	CaptureSample        *string                             `json:"capture_sample,omitempty"`
	Cond                 *HttpRequestRuleCond                `json:"cond,omitempty"`
	CondTest             *string                             `json:"cond_test,omitempty"`
	DenyStatus           *int                                `json:"deny_status"`
	Expr                 *string                             `json:"expr,omitempty"`
	HdrFormat            *string                             `json:"hdr_format,omitempty"`
	HdrMatch             *string                             `json:"hdr_match,omitempty"`
	HdrMethod            *string                             `json:"hdr_method,omitempty"`
	HdrName              *string                             `json:"hdr_name,omitempty"`
	HintFormat           *string                             `json:"hint_format,omitempty"`
	HintName             *string                             `json:"hint_name,omitempty"`
	LogLevel             *HttpRequestRuleLogLevel            `json:"log_level,omitempty"`
	LuaAction            *string                             `json:"lua_action,omitempty"`
	LuaParams            *string                             `json:"lua_params,omitempty"`
	MapFile              *string                             `json:"map_file,omitempty"`
	MapKeyfmt            *string                             `json:"map_keyfmt,omitempty"`
	MapValuefmt          *string                             `json:"map_valuefmt,omitempty"`
	MarkValue            *string                             `json:"mark_value,omitempty"`
	Metadata             *map[string]map[string]interface{}  `json:"metadata,omitempty"`
	MethodFmt            *string                             `json:"method_fmt,omitempty"`
	NiceValue            *int                                `json:"nice_value,omitempty"`
	Normalizer           *HttpRequestRuleNormalizer          `json:"normalizer,omitempty"`
	NormalizerFull       *bool                               `json:"normalizer_full,omitempty"`
	NormalizerStrict     *bool                               `json:"normalizer_strict,omitempty"`
	PathFmt              *string                             `json:"path_fmt,omitempty"`
	PathMatch            *string                             `json:"path_match,omitempty"`
	Protocol             *HttpRequestRuleProtocol            `json:"protocol,omitempty"`
	QueryFmt             *string                             `json:"query-fmt,omitempty"`
	RedirCode            *HttpRequestRuleRedirCode           `json:"redir_code"`
	RedirOption          *string                             `json:"redir_option,omitempty"`
	RedirType            *HttpRequestRuleRedirType           `json:"redir_type,omitempty"`
	RedirValue           *string                             `json:"redir_value,omitempty"`
	Resolvers            *string                             `json:"resolvers,omitempty"`
	ReturnContent        *string                             `json:"return_content,omitempty"`
	ReturnContentFormat  *HttpRequestRuleReturnContentFormat `json:"return_content_format,omitempty"`
	ReturnContentType    *string                             `json:"return_content_type"`
	ReturnHeaders        *[]ReturnHeader                     `json:"return_hdrs,omitempty"`
	ReturnStatusCode     *int                                `json:"return_status_code"`
	RstTtl               *int                                `json:"rst_ttl,omitempty"`
	ScExpr               *string                             `json:"sc_expr,omitempty"`
	ScId                 *int                                `json:"sc_id,omitempty"`
	ScIdx                *int                                `json:"sc_idx,omitempty"`
	ScInt                *int                                `json:"sc_int"`
	ServiceName          *string                             `json:"service_name,omitempty"`
	SpoeEngine           *string                             `json:"spoe_engine,omitempty"`
	SpoeGroup            *string                             `json:"spoe_group,omitempty"`
	StrictMode           *HttpRequestRuleStrictMode          `json:"strict_mode,omitempty"`
	Timeout              *string                             `json:"timeout,omitempty"`
	TimeoutType          *HttpRequestRuleTimeoutType         `json:"timeout_type,omitempty"`
	TosValue             *string                             `json:"tos_value,omitempty"`
	TrackScKey           *string                             `json:"track_sc_key,omitempty"`
	TrackScStickCounter  *int                                `json:"track_sc_stick_counter"`
	TrackScTable         *string                             `json:"track_sc_table,omitempty"`
	Type                 HttpRequestRuleType                 `json:"type"`
	UriFmt               *string                             `json:"uri-fmt,omitempty"`
	UriMatch             *string                             `json:"uri-match,omitempty"`
	VarExpr              *string                             `json:"var_expr,omitempty"`
	VarFormat            *string                             `json:"var_format,omitempty"`
	VarName              *string                             `json:"var_name,omitempty"`
	VarScope             *string                             `json:"var_scope,omitempty"`
	WaitAtLeast          *int                                `json:"wait_at_least"`
	WaitTime             *int                                `json:"wait_time"`
}

// HttpRequestRuleCond defines model for HttpRequestRule.Cond.
type HttpRequestRuleCond string

// HttpRequestRuleLogLevel defines model for HttpRequestRule.LogLevel.
type HttpRequestRuleLogLevel string

// HttpRequestRuleNormalizer defines model for HttpRequestRule.Normalizer.
type HttpRequestRuleNormalizer string

// HttpRequestRuleProtocol defines model for HttpRequestRule.Protocol.
type HttpRequestRuleProtocol string

// HttpRequestRuleRedirCode defines model for HttpRequestRule.RedirCode.
type HttpRequestRuleRedirCode int

// HttpRequestRuleRedirType defines model for HttpRequestRule.RedirType.
type HttpRequestRuleRedirType string

// HttpRequestRuleReturnContentFormat defines model for HttpRequestRule.ReturnContentFormat.
type HttpRequestRuleReturnContentFormat string

// HttpRequestRuleStrictMode defines model for HttpRequestRule.StrictMode.
type HttpRequestRuleStrictMode string

// HttpRequestRuleTimeoutType defines model for HttpRequestRule.TimeoutType.
type HttpRequestRuleTimeoutType string

// HttpRequestRuleType defines model for HttpRequestRule.Type.
type HttpRequestRuleType string

// HttpRequestRules HAProxy HTTP request rules array (corresponds to http-request directives)
type HttpRequestRules = []HttpRequestRule

// HttpResponseRule HAProxy HTTP response rule configuration (corresponds to http-response directives)
type HttpResponseRule struct {
	AclFile              *string                              `json:"acl_file,omitempty"`
	AclKeyfmt            *string                              `json:"acl_keyfmt,omitempty"`
	BandwidthLimitLimit  *string                              `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                              `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                              `json:"bandwidth_limit_period,omitempty"`
	CacheName            *string                              `json:"cache_name,omitempty"`
	CaptureId            *int                                 `json:"capture_id"`
	CaptureSample        *string                              `json:"capture_sample,omitempty"`
	Cond                 *HttpResponseRuleCond                `json:"cond,omitempty"`
	CondTest             *string                              `json:"cond_test,omitempty"`
	DenyStatus           *int                                 `json:"deny_status"`
	Expr                 *string                              `json:"expr,omitempty"`
	HdrFormat            *string                              `json:"hdr_format,omitempty"`
	HdrMatch             *string                              `json:"hdr_match,omitempty"`
	HdrMethod            *string                              `json:"hdr_method,omitempty"`
	HdrName              *string                              `json:"hdr_name,omitempty"`
	LogLevel             *HttpResponseRuleLogLevel            `json:"log_level,omitempty"`
	LuaAction            *string                              `json:"lua_action,omitempty"`
	LuaParams            *string                              `json:"lua_params,omitempty"`
	MapFile              *string                              `json:"map_file,omitempty"`
	MapKeyfmt            *string                              `json:"map_keyfmt,omitempty"`
	MapValuefmt          *string                              `json:"map_valuefmt,omitempty"`
	MarkValue            *string                              `json:"mark_value,omitempty"`
	Metadata             *map[string]map[string]interface{}   `json:"metadata,omitempty"`
	NiceValue            *int                                 `json:"nice_value,omitempty"`
	RedirCode            *HttpResponseRuleRedirCode           `json:"redir_code"`
	RedirOption          *string                              `json:"redir_option,omitempty"`
	RedirType            *HttpResponseRuleRedirType           `json:"redir_type,omitempty"`
	RedirValue           *string                              `json:"redir_value,omitempty"`
	ReturnContent        *string                              `json:"return_content,omitempty"`
	ReturnContentFormat  *HttpResponseRuleReturnContentFormat `json:"return_content_format,omitempty"`
	ReturnContentType    *string                              `json:"return_content_type"`
	ReturnHeaders        *[]ReturnHeader                      `json:"return_hdrs,omitempty"`
	ReturnStatusCode     *int                                 `json:"return_status_code"`
	RstTtl               *int                                 `json:"rst_ttl,omitempty"`
	ScExpr               *string                              `json:"sc_expr,omitempty"`
	ScId                 *int                                 `json:"sc_id,omitempty"`
	ScIdx                *int                                 `json:"sc_idx,omitempty"`
	ScInt                *int                                 `json:"sc_int"`
	SpoeEngine           *string                              `json:"spoe_engine,omitempty"`
	SpoeGroup            *string                              `json:"spoe_group,omitempty"`
	Status               *int                                 `json:"status,omitempty"`
	StatusReason         *string                              `json:"status_reason,omitempty"`
	StrictMode           *HttpResponseRuleStrictMode          `json:"strict_mode,omitempty"`
	Timeout              *string                              `json:"timeout,omitempty"`
	TimeoutType          *HttpResponseRuleTimeoutType         `json:"timeout_type,omitempty"`
	TosValue             *string                              `json:"tos_value,omitempty"`
	TrackScKey           *string                              `json:"track_sc_key,omitempty"`
	TrackScStickCounter  *int                                 `json:"track_sc_stick_counter"`
	TrackScTable         *string                              `json:"track_sc_table,omitempty"`
	Type                 HttpResponseRuleType                 `json:"type"`
	VarExpr              *string                              `json:"var_expr,omitempty"`
	VarFormat            *string                              `json:"var_format,omitempty"`
	VarName              *string                              `json:"var_name,omitempty"`
	VarScope             *string                              `json:"var_scope,omitempty"`
	WaitAtLeast          *int                                 `json:"wait_at_least"`
	WaitTime             *int                                 `json:"wait_time"`
}

// HttpResponseRuleCond defines model for HttpResponseRule.Cond.
type HttpResponseRuleCond string

// HttpResponseRuleLogLevel defines model for HttpResponseRule.LogLevel.
type HttpResponseRuleLogLevel string

// HttpResponseRuleRedirCode defines model for HttpResponseRule.RedirCode.
type HttpResponseRuleRedirCode int

// HttpResponseRuleRedirType defines model for HttpResponseRule.RedirType.
type HttpResponseRuleRedirType string

// HttpResponseRuleReturnContentFormat defines model for HttpResponseRule.ReturnContentFormat.
type HttpResponseRuleReturnContentFormat string

// HttpResponseRuleStrictMode defines model for HttpResponseRule.StrictMode.
type HttpResponseRuleStrictMode string

// HttpResponseRuleTimeoutType defines model for HttpResponseRule.TimeoutType.
type HttpResponseRuleTimeoutType string

// HttpResponseRuleType defines model for HttpResponseRule.Type.
type HttpResponseRuleType string

// HttpResponseRules HAProxy HTTP response rules array (corresponds to http-response directives)
type HttpResponseRules = []HttpResponseRule

// HttpchkParams defines model for httpchk_params.
type HttpchkParams struct {
	Host    *string              `json:"host,omitempty"`
	Method  *HttpchkParamsMethod `json:"method,omitempty"`
	Uri     *string              `json:"uri,omitempty"`
	Version *string              `json:"version,omitempty"`
}

// HttpchkParamsMethod defines model for HttpchkParams.Method.
type HttpchkParamsMethod string

// Info General API, OS and hardware information
type Info struct {
	Api *struct {
		// BuildDate HAProxy Dataplane API build date
		BuildDate *time.Time `json:"build_date,omitempty"`

		// Version HAProxy Dataplane API version string
		Version *string `json:"version,omitempty"`
	} `json:"api,omitempty"`
	System *struct {
		CpuInfo *struct {
			Model *string `json:"model,omitempty"`

			// NumCpus Number of logical CPUs
			NumCpus *int `json:"num_cpus,omitempty"`
		} `json:"cpu_info,omitempty"`

		// Hostname Hostname where the HAProxy is running
		Hostname *string `json:"hostname,omitempty"`
		MemInfo  *struct {
			DataplaneapiMemory *int `json:"dataplaneapi_memory,omitempty"`
			FreeMemory         *int `json:"free_memory,omitempty"`
			TotalMemory        *int `json:"total_memory,omitempty"`
		} `json:"mem_info,omitempty"`

		// OsString OS string
		OsString *string `json:"os_string,omitempty"`

		// Time Current time in milliseconds since Epoch.
		Time *int `json:"time,omitempty"`

		// Uptime System uptime
		Uptime *int `json:"uptime"`
	} `json:"system,omitempty"`
}

// LogForward defines model for log_forward.
type LogForward struct {
	AssumeRfc6587Ntf *bool                 `json:"assume-rfc6587-ntf,omitempty"`
	Backlog          *int                  `json:"backlog"`
	Binds            *map[string]Bind      `json:"binds,omitempty"`
	DgramBinds       *map[string]DgramBind `json:"dgram_binds,omitempty"`
	DontParseLog     *bool                 `json:"dont-parse-log,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList *LogTargets                        `json:"log_target_list,omitempty"`
	Maxconn       *int                               `json:"maxconn"`
	Metadata      *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name          string                             `json:"name"`
	TimeoutClient *int                               `json:"timeout_client"`
}

// LogForwardBase HAProxy log forward configuration
type LogForwardBase struct {
	AssumeRfc6587Ntf *bool                              `json:"assume-rfc6587-ntf,omitempty"`
	Backlog          *int                               `json:"backlog"`
	DontParseLog     *bool                              `json:"dont-parse-log,omitempty"`
	Maxconn          *int                               `json:"maxconn"`
	Metadata         *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name             string                             `json:"name"`
	TimeoutClient    *int                               `json:"timeout_client"`
}

// LogForwards HAProxy log forwards array
type LogForwards = []LogForward

// LogProfile Defines a logging profile for one or more steps.
type LogProfile struct {
	// LogTag Override syslog log tag set by other "log-tag" directives.
	LogTag   *string                            `json:"log_tag,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`

	// Name Name of the logging profile.
	Name string `json:"name"`

	// Steps List of steps where to override the logging.
	Steps *LogProfileSteps `json:"steps,omitempty"`
}

// LogProfileStep Defines what to log for a given step.
type LogProfileStep struct {
	// Drop If enabled, no log shall be emitted for the given step.
	Drop *LogProfileStepDrop `json:"drop,omitempty"`

	// Format Override "log-format" or "error-log-format" strings depending on the step.
	Format   *string                            `json:"format,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`

	// Sd Override the "log-format-sd" string.
	Sd *string `json:"sd,omitempty"`

	// Step Logging step name.
	Step LogProfileStepStep `json:"step"`
}

// LogProfileStepDrop If enabled, no log shall be emitted for the given step.
type LogProfileStepDrop string

// LogProfileStepStep Logging step name.
type LogProfileStepStep string

// LogProfileSteps List of steps where to override the logging.
type LogProfileSteps = []LogProfileStep

// LogProfiles List of Logging Profiles
type LogProfiles = []LogProfile

// LogTarget Per-instance logging of events and traffic.
type LogTarget struct {
	Address     *string                            `json:"address,omitempty"`
	Facility    *LogTargetFacility                 `json:"facility,omitempty"`
	Format      *LogTargetFormat                   `json:"format,omitempty"`
	Global      *bool                              `json:"global,omitempty"`
	Length      *int                               `json:"length,omitempty"`
	Level       *LogTargetLevel                    `json:"level,omitempty"`
	Metadata    *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Minlevel    *LogTargetMinlevel                 `json:"minlevel,omitempty"`
	Nolog       *bool                              `json:"nolog,omitempty"`
	Profile     *string                            `json:"profile,omitempty"`
	SampleRange *string                            `json:"sample_range,omitempty"`
	SampleSize  *int                               `json:"sample_size,omitempty"`
}

// LogTargetFacility defines model for LogTarget.Facility.
type LogTargetFacility string

// LogTargetFormat defines model for LogTarget.Format.
type LogTargetFormat string

// LogTargetLevel defines model for LogTarget.Level.
type LogTargetLevel string

// LogTargetMinlevel defines model for LogTarget.Minlevel.
type LogTargetMinlevel string

// LogTargets HAProxy log target array (corresponds to log directives)
type LogTargets = []LogTarget

// LuaOptions defines model for lua_options.
type LuaOptions struct {
	LoadPerThread *string `json:"load_per_thread,omitempty"`
	Loads         *[]struct {
		File string `json:"file"`
	} `json:"loads,omitempty"`
	PrependPath *[]struct {
		Path string                     `json:"path"`
		Type *LuaOptionsPrependPathType `json:"type,omitempty"`
	} `json:"prepend_path,omitempty"`
}

// LuaOptionsPrependPathType defines model for LuaOptions.PrependPath.Type.
type LuaOptionsPrependPathType string

// MailerEntries HAProxy mailer entries
type MailerEntries = []MailerEntry

// MailerEntry Mailer entry of a Mailers section
type MailerEntry struct {
	Address  string                             `json:"address"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`
	Port     int                                `json:"port"`
}

// MailersSection defines model for mailers_section.
type MailersSection struct {
	MailerEntries *map[string]MailerEntry            `json:"mailer_entries,omitempty"`
	Metadata      *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name          string                             `json:"name"`
	Timeout       *int                               `json:"timeout"`
}

// MailersSectionBase A list of SMTP servers used by HAProxy to send emails.
type MailersSectionBase struct {
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`
	Timeout  *int                               `json:"timeout"`
}

// MailersSections HAProxy mailers_section array
type MailersSections = []MailersSection

// Map Map File
type Map struct {
	Description *string `json:"description,omitempty"`
	File        *string `json:"file,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Size File size in bytes.
	Size        *int    `json:"size"`
	StorageName *string `json:"storage_name,omitempty"`
}

// MapEntries Entries of one runtime map
type MapEntries = []MapEntry

// MapEntry One Map Entry
type MapEntry struct {
	Id    *string `json:"id,omitempty"`
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Maps Array of runtime map files
type Maps = []Map

// MonitorFail defines model for monitor_fail.
type MonitorFail struct {
	Cond     MonitorFailCond `json:"cond"`
	CondTest string          `json:"cond_test"`
}

// MonitorFailCond defines model for MonitorFail.Cond.
type MonitorFailCond string

// MonitorUri defines model for monitor_uri.
type MonitorUri = string

// MysqlCheckParams defines model for mysql_check_params.
type MysqlCheckParams struct {
	ClientVersion *MysqlCheckParamsClientVersion `json:"client_version,omitempty"`
	Username      *string                        `json:"username,omitempty"`
}

// MysqlCheckParamsClientVersion defines model for MysqlCheckParams.ClientVersion.
type MysqlCheckParamsClientVersion string

// Nameserver Nameserver used in Runtime DNS configuration
type Nameserver struct {
	Address  string                             `json:"address"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`
	Port     *int                               `json:"port"`
}

// Nameservers Nameservers array
type Nameservers = []Nameserver

// NativeStat Current stats for one object.
type NativeStat struct {
	BackendName *string          `json:"backend_name,omitempty"`
	Name        *string          `json:"name,omitempty"`
	Stats       *NativeStatStats `json:"stats,omitempty"`
	Type        *NativeStatType  `json:"type,omitempty"`
}

// NativeStatType defines model for NativeStat.Type.
type NativeStatType string

// NativeStatStats defines model for native_stat_stats.
type NativeStatStats struct {
	Act           *int                        `json:"act"`
	Addr          *string                     `json:"addr,omitempty"`
	AgentCode     *int                        `json:"agent_code"`
	AgentDesc     *string                     `json:"agent_desc,omitempty"`
	AgentDuration *int                        `json:"agent_duration"`
	AgentFall     *int                        `json:"agent_fall"`
	AgentHealth   *int                        `json:"agent_health"`
	AgentRise     *int                        `json:"agent_rise"`
	AgentStatus   *NativeStatStatsAgentStatus `json:"agent_status,omitempty"`
	Algo          *string                     `json:"algo,omitempty"`
	Bck           *int                        `json:"bck"`
	Bin           *int                        `json:"bin"`
	Bout          *int                        `json:"bout"`
	CheckCode     *int                        `json:"check_code"`
	CheckDesc     *string                     `json:"check_desc,omitempty"`
	CheckDuration *int                        `json:"check_duration"`
	CheckFall     *int                        `json:"check_fall"`
	CheckHealth   *int                        `json:"check_health"`
	CheckRise     *int                        `json:"check_rise"`
	CheckStatus   *NativeStatStatsCheckStatus `json:"check_status,omitempty"`
	Chkdown       *int                        `json:"chkdown"`
	Chkfail       *int                        `json:"chkfail"`
	CliAbrt       *int                        `json:"cli_abrt"`
	CompByp       *int                        `json:"comp_byp"`
	CompIn        *int                        `json:"comp_in"`
	CompOut       *int                        `json:"comp_out"`
	CompRsp       *int                        `json:"comp_rsp"`
	ConnRate      *int                        `json:"conn_rate"`
	ConnRateMax   *int                        `json:"conn_rate_max"`
	ConnTot       *int                        `json:"conn_tot"`
	Cookie        *string                     `json:"cookie,omitempty"`
	Ctime         *int                        `json:"ctime"`
	Dcon          *int                        `json:"dcon"`
	Downtime      *int                        `json:"downtime"`
	Dreq          *int                        `json:"dreq"`
	Dresp         *int                        `json:"dresp"`
	Dses          *int                        `json:"dses"`
	Econ          *int                        `json:"econ"`
	Ereq          *int                        `json:"ereq"`
	Eresp         *int                        `json:"eresp"`
	Hanafail      *string                     `json:"hanafail,omitempty"`
	Hrsp1xx       *int                        `json:"hrsp_1xx"`
	Hrsp2xx       *int                        `json:"hrsp_2xx"`
	Hrsp3xx       *int                        `json:"hrsp_3xx"`
	Hrsp4xx       *int                        `json:"hrsp_4xx"`
	Hrsp5xx       *int                        `json:"hrsp_5xx"`
	HrspOther     *int                        `json:"hrsp_other"`
	Iid           *int                        `json:"iid"`
	Intercepted   *int                        `json:"intercepted"`
	LastAgt       *string                     `json:"last_agt"`
	LastChk       *string                     `json:"last_chk"`
	Lastchg       *int                        `json:"lastchg"`
	Lastsess      *int                        `json:"lastsess"`
	Lbtot         *int                        `json:"lbtot"`
	Mode          *NativeStatStatsMode        `json:"mode,omitempty"`
	Pid           *int                        `json:"pid"`
	Qcur          *int                        `json:"qcur"`
	Qlimit        *int                        `json:"qlimit"`
	Qmax          *int                        `json:"qmax"`
	Qtime         *int                        `json:"qtime"`
	Rate          *int                        `json:"rate"`
	RateLim       *int                        `json:"rate_lim"`
	RateMax       *int                        `json:"rate_max"`
	ReqRate       *int                        `json:"req_rate"`
	ReqRateMax    *int                        `json:"req_rate_max"`
	ReqTot        *int                        `json:"req_tot"`
	Rtime         *int                        `json:"rtime"`
	Scur          *int                        `json:"scur"`
	Sid           *int                        `json:"sid"`
	Slim          *int                        `json:"slim"`
	Smax          *int                        `json:"smax"`
	SrvAbrt       *int                        `json:"srv_abrt"`
	Status        *NativeStatStatsStatus      `json:"status,omitempty"`
	Stot          *int                        `json:"stot"`
	Throttle      *int                        `json:"throttle"`
	Tracked       *string                     `json:"tracked,omitempty"`
	Ttime         *int                        `json:"ttime"`
	Weight        *int                        `json:"weight"`
	Wredis        *int                        `json:"wredis"`
	Wretr         *int                        `json:"wretr"`
}

// NativeStatStatsAgentStatus defines model for NativeStatStats.AgentStatus.
type NativeStatStatsAgentStatus string

// NativeStatStatsCheckStatus defines model for NativeStatStats.CheckStatus.
type NativeStatStatsCheckStatus string

// NativeStatStatsMode defines model for NativeStatStats.Mode.
type NativeStatStatsMode string

// NativeStatStatsStatus defines model for NativeStatStats.Status.
type NativeStatStatsStatus string

// NativeStats HAProxy stats array
type NativeStats struct {
	Error      *string       `json:"error,omitempty"`
	RuntimeAPI *string       `json:"runtimeAPI,omitempty"`
	Stats      *[]NativeStat `json:"stats,omitempty"`
}

// OcspUpdateOptions defines model for ocsp_update_options.
type OcspUpdateOptions struct {
	Disable   *bool `json:"disable"`
	Httpproxy *struct {
		Address *string `json:"address,omitempty"`
		Port    *int    `json:"port"`
	} `json:"httpproxy,omitempty"`

	// Maxdelay Sets the maximum interval between two automatic updates of the same OCSP response.This time is expressed in seconds
	Maxdelay *int `json:"maxdelay"`

	// Mindelay Sets the minimum interval between two automatic updates of the same OCSP response. This time is expressed in seconds
	Mindelay *int                   `json:"mindelay"`
	Mode     *OcspUpdateOptionsMode `json:"mode,omitempty"`
}

// OcspUpdateOptionsMode defines model for OcspUpdateOptions.Mode.
type OcspUpdateOptionsMode string

// Originalto defines model for originalto.
type Originalto struct {
	Enabled OriginaltoEnabled `json:"enabled"`
	Except  *string           `json:"except,omitempty"`
	Header  *string           `json:"header,omitempty"`
}

// OriginaltoEnabled defines model for Originalto.Enabled.
type OriginaltoEnabled string

// PeerEntries HAProxy peer entries array
type PeerEntries = []PeerEntry

// PeerEntry Peer Entry from peers table
type PeerEntry struct {
	Address  string                             `json:"address"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`
	Port     *int                               `json:"port"`
	Shard    *int                               `json:"shard,omitempty"`
}

// PeerSection defines model for peer_section.
type PeerSection struct {
	Binds *map[string]Bind `json:"binds,omitempty"`

	// DefaultBind HAProxy default bind configuration
	DefaultBind   *DefaultBind   `json:"default_bind,omitempty"`
	DefaultServer *DefaultServer `json:"default_server,omitempty"`
	Disabled      *bool          `json:"disabled,omitempty"`
	Enabled       *bool          `json:"enabled,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList *LogTargets                        `json:"log_target_list,omitempty"`
	Metadata      *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name          string                             `json:"name"`
	PeerEntries   *map[string]PeerEntry              `json:"peer_entries,omitempty"`
	Servers       *map[string]Server                 `json:"servers,omitempty"`

	// Shards In some configurations, one would like to distribute the stick-table contents
	// to some peers in place of sending all the stick-table contents to each peer
	// declared in the "peers" section. In such cases, "shards" specifies the
	// number of peer involved in this stick-table contents distribution.
	Shards *int              `json:"shards,omitempty"`
	Tables *map[string]Table `json:"tables,omitempty"`
}

// PeerSectionBase HAProxy peer_section configuration
type PeerSectionBase struct {
	// DefaultBind HAProxy default bind configuration
	DefaultBind   *DefaultBind                       `json:"default_bind,omitempty"`
	DefaultServer *DefaultServer                     `json:"default_server,omitempty"`
	Disabled      *bool                              `json:"disabled,omitempty"`
	Enabled       *bool                              `json:"enabled,omitempty"`
	Metadata      *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name          string                             `json:"name"`

	// Shards In some configurations, one would like to distribute the stick-table contents
	// to some peers in place of sending all the stick-table contents to each peer
	// declared in the "peers" section. In such cases, "shards" specifies the
	// number of peer involved in this stick-table contents distribution.
	Shards *int `json:"shards,omitempty"`
}

// PeerSections HAProxy peer_section array
type PeerSections = []PeerSection

// PerformanceOptions defines model for performance_options.
type PerformanceOptions struct {
	BusyPolling     *bool                              `json:"busy_polling,omitempty"`
	MaxSpreadChecks *int                               `json:"max_spread_checks"`
	Maxcompcpuusage *int                               `json:"maxcompcpuusage,omitempty"`
	Maxcomprate     *int                               `json:"maxcomprate,omitempty"`
	Maxconn         *int                               `json:"maxconn,omitempty"`
	Maxconnrate     *int                               `json:"maxconnrate,omitempty"`
	Maxpipes        *int                               `json:"maxpipes,omitempty"`
	Maxsessrate     *int                               `json:"maxsessrate,omitempty"`
	Maxzlibmem      *int                               `json:"maxzlibmem,omitempty"`
	Noepoll         *bool                              `json:"noepoll,omitempty"`
	Noevports       *bool                              `json:"noevports,omitempty"`
	Nogetaddrinfo   *bool                              `json:"nogetaddrinfo,omitempty"`
	Nokqueue        *bool                              `json:"nokqueue,omitempty"`
	Nopoll          *bool                              `json:"nopoll,omitempty"`
	Noreuseport     *bool                              `json:"noreuseport,omitempty"`
	Nosplice        *bool                              `json:"nosplice,omitempty"`
	ProfilingMemory *PerformanceOptionsProfilingMemory `json:"profiling_memory,omitempty"`
	ProfilingTasks  *PerformanceOptionsProfilingTasks  `json:"profiling_tasks,omitempty"`
	ServerStateBase *string                            `json:"server_state_base,omitempty"`
	ServerStateFile *string                            `json:"server_state_file,omitempty"`
	SpreadChecks    *int                               `json:"spread_checks,omitempty"`
	ThreadHardLimit *int                               `json:"thread_hard_limit"`
}

// PerformanceOptionsProfilingMemory defines model for PerformanceOptions.ProfilingMemory.
type PerformanceOptionsProfilingMemory string

// PerformanceOptionsProfilingTasks defines model for PerformanceOptions.ProfilingTasks.
type PerformanceOptionsProfilingTasks string

// PersistRule defines model for persist_rule.
type PersistRule struct {
	RdpCookieName *string         `json:"rdp_cookie_name,omitempty"`
	Type          PersistRuleType `json:"type"`
}

// PersistRuleType defines model for PersistRule.Type.
type PersistRuleType string

// PgsqlCheckParams defines model for pgsql_check_params.
type PgsqlCheckParams struct {
	Username *string `json:"username,omitempty"`
}

// ProcessInfo General HAProxy process information
type ProcessInfo struct {
	Error      *string          `json:"error,omitempty"`
	Info       *ProcessInfoItem `json:"info,omitempty"`
	RuntimeAPI *string          `json:"runtimeAPI,omitempty"`
}

// ProcessInfoItem defines model for process_info_item.
type ProcessInfoItem struct {
	ActivePeers        *int `json:"active_peers"`
	BusyPolling        *int `json:"busy_polling"`
	BytesOutRate       *int `json:"bytes_out_rate"`
	CompressBpsIn      *int `json:"compress_bps_in"`
	CompressBpsOut     *int `json:"compress_bps_out"`
	CompressBpsRateLim *int `json:"compress_bps_rate_lim"`
	ConnRate           *int `json:"conn_rate"`
	ConnRateLimit      *int `json:"conn_rate_limit"`
	ConnectedPeers     *int `json:"connected_peers"`
	CumConns           *int `json:"cum_conns"`
	CumReq             *int `json:"cum_req"`
	CumSslConns        *int `json:"cum_ssl_conns"`
	CurrConns          *int `json:"curr_conns"`
	CurrSslConns       *int `json:"curr_ssl_conns"`
	DroppedLogs        *int `json:"dropped_logs"`
	FailedResolutions  *int `json:"failed_resolutions"`
	HardMaxConn        *int `json:"hard_max_conn"`
	IdlePct            *int `json:"idle_pct"`
	Jobs               *int `json:"jobs"`
	Listeners          *int `json:"listeners"`
	MaxConn            *int `json:"max_conn"`
	MaxConnRate        *int `json:"max_conn_rate"`
	MaxPipes           *int `json:"max_pipes"`
	MaxSessRate        *int `json:"max_sess_rate"`
	MaxSock            *int `json:"max_sock"`
	MaxSslConns        *int `json:"max_ssl_conns"`
	MaxSslRate         *int `json:"max_ssl_rate"`
	MaxZlibMemUsage    *int `json:"max_zlib_mem_usage"`
	MemMaxMb           *int `json:"mem_max_mb"`

	// Nbthread Number of threads
	Nbthread *int    `json:"nbthread"`
	Node     *string `json:"node,omitempty"`

	// Pid Process id of the replying worker process
	Pid         *int `json:"pid"`
	PipesFree   *int `json:"pipes_free"`
	PipesUsed   *int `json:"pipes_used"`
	PoolAllocMb *int `json:"pool_alloc_mb"`
	PoolFailed  *int `json:"pool_failed"`
	PoolUsedMb  *int `json:"pool_used_mb"`

	// ProcessNum Process number
	ProcessNum *int `json:"process_num"`

	// Processes Number of spawned processes
	Processes *int `json:"processes"`

	// ReleaseDate HAProxy version release date
	ReleaseDate             *openapi_types.Date `json:"release_date,omitempty"`
	RunQueue                *int                `json:"run_queue"`
	SessRate                *int                `json:"sess_rate"`
	SessRateLimit           *int                `json:"sess_rate_limit"`
	SslBackendKeyRate       *int                `json:"ssl_backend_key_rate"`
	SslBackendMaxKeyRate    *int                `json:"ssl_backend_max_key_rate"`
	SslCacheLookups         *int                `json:"ssl_cache_lookups"`
	SslCacheMisses          *int                `json:"ssl_cache_misses"`
	SslFrontendKeyRate      *int                `json:"ssl_frontend_key_rate"`
	SslFrontendMaxKeyRate   *int                `json:"ssl_frontend_max_key_rate"`
	SslFrontendSessionReuse *int                `json:"ssl_frontend_session_reuse"`
	SslRate                 *int                `json:"ssl_rate"`
	SslRateLimit            *int                `json:"ssl_rate_limit"`
	Stopping                *int                `json:"stopping"`
	Tasks                   *int                `json:"tasks"`
	TotalBytesOut           *int                `json:"total_bytes_out"`
	UlimitN                 *int                `json:"ulimit_n"`
	Unstoppable             *int                `json:"unstoppable"`

	// Uptime HAProxy uptime in s
	Uptime *int `json:"uptime"`

	// Version HAProxy version string
	Version      *string `json:"version,omitempty"`
	ZlibMemUsage *int    `json:"zlib_mem_usage"`
}

// Program HAProxy program configuration
type Program struct {
	// Command The command to be run, with flags and options.
	Command string `json:"command"`

	// Group The group to run the command as, if different than the HAProxy group.
	Group    *string                            `json:"group,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`

	// StartOnReload HAProxy stops and recreates child programs at reload.
	StartOnReload *ProgramStartOnReload `json:"start-on-reload,omitempty"`

	// User The user to run the command as, if different than the HAProxy user.
	User *string `json:"user,omitempty"`
}

// ProgramStartOnReload HAProxy stops and recreates child programs at reload.
type ProgramStartOnReload string

// Programs defines model for programs.
type Programs = []Program

// QUICInitialRule QUIC Initial configuration
type QUICInitialRule struct {
	Cond     *QuicInitialRuleCond               `json:"cond,omitempty"`
	CondTest *string                            `json:"cond_test,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Type     QuicInitialRuleType                `json:"type"`
}

// QuicInitialRuleCond defines model for QuicInitialRule.Cond.
type QuicInitialRuleCond string

// QuicInitialRuleType defines model for QuicInitialRule.Type.
type QuicInitialRuleType string

// QUICInitialRules defines model for quic_initial_rules.
type QUICInitialRules = []QUICInitialRule

// Redispatch defines model for redispatch.
type Redispatch struct {
	Enabled  RedispatchEnabled `json:"enabled"`
	Interval *int              `json:"interval"`
}

// RedispatchEnabled defines model for Redispatch.Enabled.
type RedispatchEnabled string

// Reload HAProxy reload
type Reload struct {
	Id              *string       `json:"id,omitempty"`
	ReloadTimestamp *int          `json:"reload_timestamp,omitempty"`
	Response        *string       `json:"response,omitempty"`
	Status          *ReloadStatus `json:"status,omitempty"`
}

// ReloadStatus defines model for Reload.Status.
type ReloadStatus string

// Reloads HAProxy reloads array
type Reloads = []Reload

// Resolver defines model for resolver.
type Resolver struct {
	AcceptedPayloadSize *int                               `json:"accepted_payload_size,omitempty"`
	HoldNx              *int                               `json:"hold_nx"`
	HoldObsolete        *int                               `json:"hold_obsolete"`
	HoldOther           *int                               `json:"hold_other"`
	HoldRefused         *int                               `json:"hold_refused"`
	HoldTimeout         *int                               `json:"hold_timeout"`
	HoldValid           *int                               `json:"hold_valid"`
	Metadata            *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name                string                             `json:"name"`
	Nameservers         *map[string]Nameserver             `json:"nameservers,omitempty"`
	ParseResolvConf     *bool                              `json:"parse-resolv-conf,omitempty"`
	ResolveRetries      *int                               `json:"resolve_retries,omitempty"`
	TimeoutResolve      *int                               `json:"timeout_resolve,omitempty"`
	TimeoutRetry        *int                               `json:"timeout_retry,omitempty"`
}

// ResolverBase Runtime DNS configuration
type ResolverBase struct {
	AcceptedPayloadSize *int                               `json:"accepted_payload_size,omitempty"`
	HoldNx              *int                               `json:"hold_nx"`
	HoldObsolete        *int                               `json:"hold_obsolete"`
	HoldOther           *int                               `json:"hold_other"`
	HoldRefused         *int                               `json:"hold_refused"`
	HoldTimeout         *int                               `json:"hold_timeout"`
	HoldValid           *int                               `json:"hold_valid"`
	Metadata            *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name                string                             `json:"name"`
	ParseResolvConf     *bool                              `json:"parse-resolv-conf,omitempty"`
	ResolveRetries      *int                               `json:"resolve_retries,omitempty"`
	TimeoutResolve      *int                               `json:"timeout_resolve,omitempty"`
	TimeoutRetry        *int                               `json:"timeout_retry,omitempty"`
}

// Resolvers HAProxy resolvers array
type Resolvers = []Resolver

// ReturnHeader defines model for return_header.
type ReturnHeader struct {
	Fmt  string `json:"fmt"`
	Name string `json:"name"`
}

// Ring defines model for ring.
type Ring struct {
	Description    *string                            `json:"description,omitempty"`
	Format         *RingFormat                        `json:"format,omitempty"`
	Maxlen         *int                               `json:"maxlen"`
	Metadata       *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name           string                             `json:"name"`
	Servers        *map[string]Server                 `json:"servers,omitempty"`
	Size           *int                               `json:"size"`
	TimeoutConnect *int                               `json:"timeout_connect"`
	TimeoutServer  *int                               `json:"timeout_server"`
}

// RingFormat defines model for Ring.Format.
type RingFormat string

// RingBase HAProxy ring configuration
type RingBase struct {
	Description    *string                            `json:"description,omitempty"`
	Format         *RingBaseFormat                    `json:"format,omitempty"`
	Maxlen         *int                               `json:"maxlen"`
	Metadata       *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name           string                             `json:"name"`
	Size           *int                               `json:"size"`
	TimeoutConnect *int                               `json:"timeout_connect"`
	TimeoutServer  *int                               `json:"timeout_server"`
}

// RingBaseFormat defines model for RingBase.Format.
type RingBaseFormat string

// Rings HAProxy rings array
type Rings = []Ring

// RuntimeAddServer Settable properties when adding a new server using HAProxy's runtime.
type RuntimeAddServer struct {
	Address            *string                           `json:"address,omitempty"`
	AgentAddr          *string                           `json:"agent-addr,omitempty"`
	AgentCheck         *RuntimeAddServerAgentCheck       `json:"agent-check,omitempty"`
	AgentInter         *int                              `json:"agent-inter"`
	AgentPort          *int                              `json:"agent-port"`
	AgentSend          *string                           `json:"agent-send,omitempty"`
	Allow0rtt          *bool                             `json:"allow_0rtt,omitempty"`
	Alpn               *string                           `json:"alpn,omitempty"`
	Backup             *RuntimeAddServerBackup           `json:"backup,omitempty"`
	Check              *RuntimeAddServerCheck            `json:"check,omitempty"`
	CheckSendProxy     *RuntimeAddServerCheckSendProxy   `json:"check-send-proxy,omitempty"`
	CheckSni           *string                           `json:"check-sni,omitempty"`
	CheckSsl           *RuntimeAddServerCheckSsl         `json:"check-ssl,omitempty"`
	CheckAlpn          *string                           `json:"check_alpn,omitempty"`
	CheckProto         *string                           `json:"check_proto,omitempty"`
	CheckViaSocks4     *RuntimeAddServerCheckViaSocks4   `json:"check_via_socks4,omitempty"`
	Ciphers            *string                           `json:"ciphers,omitempty"`
	Ciphersuites       *string                           `json:"ciphersuites,omitempty"`
	CrlFile            *string                           `json:"crl_file,omitempty"`
	Downinter          *int                              `json:"downinter"`
	ErrorLimit         *int                              `json:"error_limit"`
	Fall               *int                              `json:"fall"`
	Fastinter          *int                              `json:"fastinter"`
	ForceSslv3         *RuntimeAddServerForceSslv3       `json:"force_sslv3,omitempty"`
	ForceTlsv10        *RuntimeAddServerForceTlsv10      `json:"force_tlsv10,omitempty"`
	ForceTlsv11        *RuntimeAddServerForceTlsv11      `json:"force_tlsv11,omitempty"`
	ForceTlsv12        *RuntimeAddServerForceTlsv12      `json:"force_tlsv12,omitempty"`
	ForceTlsv13        *RuntimeAddServerForceTlsv13      `json:"force_tlsv13,omitempty"`
	HealthCheckAddress *string                           `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                              `json:"health_check_port"`
	Id                 *string                           `json:"id,omitempty"`
	Inter              *int                              `json:"inter"`
	Maintenance        *RuntimeAddServerMaintenance      `json:"maintenance,omitempty"`
	Maxconn            *int                              `json:"maxconn"`
	Maxqueue           *int                              `json:"maxqueue"`
	Minconn            *int                              `json:"minconn"`
	Name               *string                           `json:"name,omitempty"`
	NoSslv3            *RuntimeAddServerNoSslv3          `json:"no_sslv3,omitempty"`
	NoTlsv10           *RuntimeAddServerNoTlsv10         `json:"no_tlsv10,omitempty"`
	NoTlsv11           *RuntimeAddServerNoTlsv11         `json:"no_tlsv11,omitempty"`
	NoTlsv12           *RuntimeAddServerNoTlsv12         `json:"no_tlsv12,omitempty"`
	NoTlsv13           *RuntimeAddServerNoTlsv13         `json:"no_tlsv13,omitempty"`
	Npn                *string                           `json:"npn,omitempty"`
	Observe            *RuntimeAddServerObserve          `json:"observe,omitempty"`
	OnError            *RuntimeAddServerOnError          `json:"on-error,omitempty"`
	OnMarkedDown       *RuntimeAddServerOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp         *RuntimeAddServerOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolLowConn        *int                              `json:"pool_low_conn"`
	PoolMaxConn        *int                              `json:"pool_max_conn"`
	PoolPurgeDelay     *int                              `json:"pool_purge_delay"`
	Port               *int                              `json:"port"`
	Proto              *string                           `json:"proto,omitempty"`
	ProxyV2Options     *[]RuntimeAddServerProxyV2Options `json:"proxy-v2-options,omitempty"`
	Rise               *int                              `json:"rise"`
	SendProxy          *RuntimeAddServerSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2        *RuntimeAddServerSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl     *RuntimeAddServerSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn   *RuntimeAddServerSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	Slowstart          *int                              `json:"slowstart"`
	Sni                *string                           `json:"sni,omitempty"`
	Source             *string                           `json:"source,omitempty"`
	Ssl                *RuntimeAddServerSsl              `json:"ssl,omitempty"`
	SslCafile          *string                           `json:"ssl_cafile,omitempty"`
	SslCertificate     *string                           `json:"ssl_certificate,omitempty"`
	SslMaxVer          *RuntimeAddServerSslMaxVer        `json:"ssl_max_ver,omitempty"`
	SslMinVer          *RuntimeAddServerSslMinVer        `json:"ssl_min_ver,omitempty"`
	SslReuse           *RuntimeAddServerSslReuse         `json:"ssl_reuse,omitempty"`
	Tfo                *RuntimeAddServerTfo              `json:"tfo,omitempty"`
	TlsTickets         *RuntimeAddServerTlsTickets       `json:"tls_tickets,omitempty"`
	Track              *string                           `json:"track,omitempty"`
	Verify             *RuntimeAddServerVerify           `json:"verify,omitempty"`
	Verifyhost         *string                           `json:"verifyhost,omitempty"`
	Weight             *int                              `json:"weight"`
	Ws                 *RuntimeAddServerWs               `json:"ws,omitempty"`
}

// RuntimeAddServerAgentCheck defines model for RuntimeAddServer.AgentCheck.
type RuntimeAddServerAgentCheck string

// RuntimeAddServerBackup defines model for RuntimeAddServer.Backup.
type RuntimeAddServerBackup string

// RuntimeAddServerCheck defines model for RuntimeAddServer.Check.
type RuntimeAddServerCheck string

// RuntimeAddServerCheckSendProxy defines model for RuntimeAddServer.CheckSendProxy.
type RuntimeAddServerCheckSendProxy string

// RuntimeAddServerCheckSsl defines model for RuntimeAddServer.CheckSsl.
type RuntimeAddServerCheckSsl string

// RuntimeAddServerCheckViaSocks4 defines model for RuntimeAddServer.CheckViaSocks4.
type RuntimeAddServerCheckViaSocks4 string

// RuntimeAddServerForceSslv3 defines model for RuntimeAddServer.ForceSslv3.
type RuntimeAddServerForceSslv3 string

// RuntimeAddServerForceTlsv10 defines model for RuntimeAddServer.ForceTlsv10.
type RuntimeAddServerForceTlsv10 string

// RuntimeAddServerForceTlsv11 defines model for RuntimeAddServer.ForceTlsv11.
type RuntimeAddServerForceTlsv11 string

// RuntimeAddServerForceTlsv12 defines model for RuntimeAddServer.ForceTlsv12.
type RuntimeAddServerForceTlsv12 string

// RuntimeAddServerForceTlsv13 defines model for RuntimeAddServer.ForceTlsv13.
type RuntimeAddServerForceTlsv13 string

// RuntimeAddServerMaintenance defines model for RuntimeAddServer.Maintenance.
type RuntimeAddServerMaintenance string

// RuntimeAddServerNoSslv3 defines model for RuntimeAddServer.NoSslv3.
type RuntimeAddServerNoSslv3 string

// RuntimeAddServerNoTlsv10 defines model for RuntimeAddServer.NoTlsv10.
type RuntimeAddServerNoTlsv10 string

// RuntimeAddServerNoTlsv11 defines model for RuntimeAddServer.NoTlsv11.
type RuntimeAddServerNoTlsv11 string

// RuntimeAddServerNoTlsv12 defines model for RuntimeAddServer.NoTlsv12.
type RuntimeAddServerNoTlsv12 string

// RuntimeAddServerNoTlsv13 defines model for RuntimeAddServer.NoTlsv13.
type RuntimeAddServerNoTlsv13 string

// RuntimeAddServerObserve defines model for RuntimeAddServer.Observe.
type RuntimeAddServerObserve string

// RuntimeAddServerOnError defines model for RuntimeAddServer.OnError.
type RuntimeAddServerOnError string

// RuntimeAddServerOnMarkedDown defines model for RuntimeAddServer.OnMarkedDown.
type RuntimeAddServerOnMarkedDown string

// RuntimeAddServerOnMarkedUp defines model for RuntimeAddServer.OnMarkedUp.
type RuntimeAddServerOnMarkedUp string

// RuntimeAddServerProxyV2Options defines model for RuntimeAddServer.ProxyV2Options.
type RuntimeAddServerProxyV2Options string

// RuntimeAddServerSendProxy defines model for RuntimeAddServer.SendProxy.
type RuntimeAddServerSendProxy string

// RuntimeAddServerSendProxyV2 defines model for RuntimeAddServer.SendProxyV2.
type RuntimeAddServerSendProxyV2 string

// RuntimeAddServerSendProxyV2Ssl defines model for RuntimeAddServer.SendProxyV2Ssl.
type RuntimeAddServerSendProxyV2Ssl string

// RuntimeAddServerSendProxyV2SslCn defines model for RuntimeAddServer.SendProxyV2SslCn.
type RuntimeAddServerSendProxyV2SslCn string

// RuntimeAddServerSsl defines model for RuntimeAddServer.Ssl.
type RuntimeAddServerSsl string

// RuntimeAddServerSslMaxVer defines model for RuntimeAddServer.SslMaxVer.
type RuntimeAddServerSslMaxVer string

// RuntimeAddServerSslMinVer defines model for RuntimeAddServer.SslMinVer.
type RuntimeAddServerSslMinVer string

// RuntimeAddServerSslReuse defines model for RuntimeAddServer.SslReuse.
type RuntimeAddServerSslReuse string

// RuntimeAddServerTfo defines model for RuntimeAddServer.Tfo.
type RuntimeAddServerTfo string

// RuntimeAddServerTlsTickets defines model for RuntimeAddServer.TlsTickets.
type RuntimeAddServerTlsTickets string

// RuntimeAddServerVerify defines model for RuntimeAddServer.Verify.
type RuntimeAddServerVerify string

// RuntimeAddServerWs defines model for RuntimeAddServer.Ws.
type RuntimeAddServerWs string

// RuntimeServer Runtime transient server properties
type RuntimeServer struct {
	Address          *string                        `json:"address,omitempty"`
	AdminState       *RuntimeServerAdminState       `json:"admin_state,omitempty"`
	Id               *string                        `json:"id,omitempty"`
	Name             *string                        `json:"name,omitempty"`
	OperationalState *RuntimeServerOperationalState `json:"operational_state,omitempty"`
	Port             *int                           `json:"port"`
}

// RuntimeServerAdminState defines model for RuntimeServer.AdminState.
type RuntimeServerAdminState string

// RuntimeServerOperationalState defines model for RuntimeServer.OperationalState.
type RuntimeServerOperationalState string

// RuntimeServers HAProxy runtime servers array
type RuntimeServers = []RuntimeServer

// Server defines model for server.
type Server struct {
	Address           string                `json:"address"`
	AgentAddr         *string               `json:"agent-addr,omitempty"`
	AgentCheck        *ServerAgentCheck     `json:"agent-check,omitempty"`
	AgentInter        *int                  `json:"agent-inter"`
	AgentPort         *int                  `json:"agent-port"`
	AgentSend         *string               `json:"agent-send,omitempty"`
	Allow0rtt         *bool                 `json:"allow_0rtt,omitempty"`
	Alpn              *string               `json:"alpn,omitempty"`
	Backup            *ServerBackup         `json:"backup,omitempty"`
	Check             *ServerCheck          `json:"check,omitempty"`
	CheckPoolConnName *string               `json:"check-pool-conn-name,omitempty"`
	CheckReusePool    *ServerCheckReusePool `json:"check-reuse-pool,omitempty"`
	CheckSendProxy    *ServerCheckSendProxy `json:"check-send-proxy,omitempty"`
	CheckSni          *string               `json:"check-sni,omitempty"`
	CheckSsl          *ServerCheckSsl       `json:"check-ssl,omitempty"`
	CheckAlpn         *string               `json:"check_alpn,omitempty"`
	CheckProto        *string               `json:"check_proto,omitempty"`
	CheckViaSocks4    *ServerCheckViaSocks4 `json:"check_via_socks4,omitempty"`
	Ciphers           *string               `json:"ciphers,omitempty"`
	Ciphersuites      *string               `json:"ciphersuites,omitempty"`
	ClientSigalgs     *string               `json:"client_sigalgs,omitempty"`
	Cookie            *string               `json:"cookie,omitempty"`
	CrlFile           *string               `json:"crl_file,omitempty"`
	Curves            *string               `json:"curves,omitempty"`
	Downinter         *int                  `json:"downinter"`
	ErrorLimit        *int                  `json:"error_limit,omitempty"`
	Fall              *int                  `json:"fall"`
	Fastinter         *int                  `json:"fastinter"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3 *ServerForceSslv3 `json:"force_sslv3,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *ServerForceTlsv10 `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *ServerForceTlsv11 `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *ServerForceTlsv12 `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13        *ServerForceTlsv13                 `json:"force_tlsv13,omitempty"`
	Guid               *string                            `json:"guid,omitempty"`
	HashKey            *string                            `json:"hash_key,omitempty"`
	HealthCheckAddress *string                            `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                               `json:"health_check_port"`
	Id                 *int                               `json:"id"`
	IdlePing           *int                               `json:"idle_ping"`
	InitAddr           *string                            `json:"init-addr"`
	InitState          *ServerInitState                   `json:"init-state,omitempty"`
	Inter              *int                               `json:"inter"`
	LogBufsize         *int                               `json:"log-bufsize"`
	LogProto           *ServerLogProto                    `json:"log_proto,omitempty"`
	Maintenance        *ServerMaintenance                 `json:"maintenance,omitempty"`
	MaxReuse           *int                               `json:"max_reuse"`
	Maxconn            *int                               `json:"maxconn"`
	Maxqueue           *int                               `json:"maxqueue"`
	Metadata           *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Minconn            *int                               `json:"minconn"`
	Name               string                             `json:"name"`
	Namespace          *string                            `json:"namespace,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3 *ServerNoSslv3 `json:"no_sslv3,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *ServerNoTlsv10 `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *ServerNoTlsv11 `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *ServerNoTlsv12 `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
	NoTlsv13         *ServerNoTlsv13         `json:"no_tlsv13,omitempty"`
	NoVerifyhost     *ServerNoVerifyhost     `json:"no_verifyhost,omitempty"`
	Npn              *string                 `json:"npn,omitempty"`
	Observe          *ServerObserve          `json:"observe,omitempty"`
	OnError          *ServerOnError          `json:"on-error,omitempty"`
	OnMarkedDown     *ServerOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp       *ServerOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolConnName     *string                 `json:"pool_conn_name,omitempty"`
	PoolLowConn      *int                    `json:"pool_low_conn"`
	PoolMaxConn      *int                    `json:"pool_max_conn"`
	PoolPurgeDelay   *int                    `json:"pool_purge_delay"`
	Port             *int                    `json:"port"`
	Proto            *string                 `json:"proto,omitempty"`
	ProxyV2Options   *[]ServerProxyV2Options `json:"proxy-v2-options,omitempty"`
	Redir            *string                 `json:"redir,omitempty"`
	ResolveNet       *string                 `json:"resolve-net,omitempty"`
	ResolvePrefer    *ServerResolvePrefer    `json:"resolve-prefer,omitempty"`
	ResolveOpts      *string                 `json:"resolve_opts,omitempty"`
	Resolvers        *string                 `json:"resolvers,omitempty"`
	Rise             *int                    `json:"rise"`
	SendProxy        *ServerSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2      *ServerSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl   *ServerSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn *ServerSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int              `json:"shard,omitempty"`
	Sigalgs        *string           `json:"sigalgs,omitempty"`
	Slowstart      *int              `json:"slowstart"`
	Sni            *string           `json:"sni,omitempty"`
	Socks4         *string           `json:"socks4,omitempty"`
	Source         *string           `json:"source,omitempty"`
	Ssl            *ServerSsl        `json:"ssl,omitempty"`
	SslCafile      *string           `json:"ssl_cafile,omitempty"`
	SslCertificate *string           `json:"ssl_certificate,omitempty"`
	SslMaxVer      *ServerSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *ServerSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *ServerSslReuse   `json:"ssl_reuse,omitempty"`
	Sslv3          *ServerSslv3      `json:"sslv3,omitempty"`
	Stick          *ServerStick      `json:"stick,omitempty"`
	StrictMaxconn  *bool             `json:"strict-maxconn,omitempty"`
	TcpUt          *int              `json:"tcp_ut"`
	Tfo            *ServerTfo        `json:"tfo,omitempty"`
	TlsTickets     *ServerTlsTickets `json:"tls_tickets,omitempty"`
	Tlsv10         *ServerTlsv10     `json:"tlsv10,omitempty"`
	Tlsv11         *ServerTlsv11     `json:"tlsv11,omitempty"`
	Tlsv12         *ServerTlsv12     `json:"tlsv12,omitempty"`
	Tlsv13         *ServerTlsv13     `json:"tlsv13,omitempty"`
	Track          *string           `json:"track,omitempty"`
	Verify         *ServerVerify     `json:"verify,omitempty"`
	Verifyhost     *string           `json:"verifyhost,omitempty"`
	Weight         *int              `json:"weight"`
	Ws             *ServerWs         `json:"ws,omitempty"`
}

// ServerAgentCheck defines model for Server.AgentCheck.
type ServerAgentCheck string

// ServerBackup defines model for Server.Backup.
type ServerBackup string

// ServerCheck defines model for Server.Check.
type ServerCheck string

// ServerCheckReusePool defines model for Server.CheckReusePool.
type ServerCheckReusePool string

// ServerCheckSendProxy defines model for Server.CheckSendProxy.
type ServerCheckSendProxy string

// ServerCheckSsl defines model for Server.CheckSsl.
type ServerCheckSsl string

// ServerCheckViaSocks4 defines model for Server.CheckViaSocks4.
type ServerCheckViaSocks4 string

// ServerForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerForceSslv3 string

// ServerForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerForceTlsv10 string

// ServerForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerForceTlsv11 string

// ServerForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerForceTlsv12 string

// ServerForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
type ServerForceTlsv13 string

// ServerInitState defines model for Server.InitState.
type ServerInitState string

// ServerLogProto defines model for Server.LogProto.
type ServerLogProto string

// ServerMaintenance defines model for Server.Maintenance.
type ServerMaintenance string

// ServerNoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerNoSslv3 string

// ServerNoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerNoTlsv10 string

// ServerNoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerNoTlsv11 string

// ServerNoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerNoTlsv12 string

// ServerNoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
type ServerNoTlsv13 string

// ServerNoVerifyhost defines model for Server.NoVerifyhost.
type ServerNoVerifyhost string

// ServerObserve defines model for Server.Observe.
type ServerObserve string

// ServerOnError defines model for Server.OnError.
type ServerOnError string

// ServerOnMarkedDown defines model for Server.OnMarkedDown.
type ServerOnMarkedDown string

// ServerOnMarkedUp defines model for Server.OnMarkedUp.
type ServerOnMarkedUp string

// ServerProxyV2Options defines model for Server.ProxyV2Options.
type ServerProxyV2Options string

// ServerResolvePrefer defines model for Server.ResolvePrefer.
type ServerResolvePrefer string

// ServerSendProxy defines model for Server.SendProxy.
type ServerSendProxy string

// ServerSendProxyV2 defines model for Server.SendProxyV2.
type ServerSendProxyV2 string

// ServerSendProxyV2Ssl defines model for Server.SendProxyV2Ssl.
type ServerSendProxyV2Ssl string

// ServerSendProxyV2SslCn defines model for Server.SendProxyV2SslCn.
type ServerSendProxyV2SslCn string

// ServerSsl defines model for Server.Ssl.
type ServerSsl string

// ServerSslMaxVer defines model for Server.SslMaxVer.
type ServerSslMaxVer string

// ServerSslMinVer defines model for Server.SslMinVer.
type ServerSslMinVer string

// ServerSslReuse defines model for Server.SslReuse.
type ServerSslReuse string

// ServerSslv3 defines model for Server.Sslv3.
type ServerSslv3 string

// ServerStick defines model for Server.Stick.
type ServerStick string

// ServerTfo defines model for Server.Tfo.
type ServerTfo string

// ServerTlsTickets defines model for Server.TlsTickets.
type ServerTlsTickets string

// ServerTlsv10 defines model for Server.Tlsv10.
type ServerTlsv10 string

// ServerTlsv11 defines model for Server.Tlsv11.
type ServerTlsv11 string

// ServerTlsv12 defines model for Server.Tlsv12.
type ServerTlsv12 string

// ServerTlsv13 defines model for Server.Tlsv13.
type ServerTlsv13 string

// ServerVerify defines model for Server.Verify.
type ServerVerify string

// ServerWs defines model for Server.Ws.
type ServerWs string

// ServerParams defines model for server_params.
type ServerParams struct {
	AgentAddr         *string                     `json:"agent-addr,omitempty"`
	AgentCheck        *ServerParamsAgentCheck     `json:"agent-check,omitempty"`
	AgentInter        *int                        `json:"agent-inter"`
	AgentPort         *int                        `json:"agent-port"`
	AgentSend         *string                     `json:"agent-send,omitempty"`
	Allow0rtt         *bool                       `json:"allow_0rtt,omitempty"`
	Alpn              *string                     `json:"alpn,omitempty"`
	Backup            *ServerParamsBackup         `json:"backup,omitempty"`
	Check             *ServerParamsCheck          `json:"check,omitempty"`
	CheckPoolConnName *string                     `json:"check-pool-conn-name,omitempty"`
	CheckReusePool    *ServerParamsCheckReusePool `json:"check-reuse-pool,omitempty"`
	CheckSendProxy    *ServerParamsCheckSendProxy `json:"check-send-proxy,omitempty"`
	CheckSni          *string                     `json:"check-sni,omitempty"`
	CheckSsl          *ServerParamsCheckSsl       `json:"check-ssl,omitempty"`
	CheckAlpn         *string                     `json:"check_alpn,omitempty"`
	CheckProto        *string                     `json:"check_proto,omitempty"`
	CheckViaSocks4    *ServerParamsCheckViaSocks4 `json:"check_via_socks4,omitempty"`
	Ciphers           *string                     `json:"ciphers,omitempty"`
	Ciphersuites      *string                     `json:"ciphersuites,omitempty"`
	ClientSigalgs     *string                     `json:"client_sigalgs,omitempty"`
	Cookie            *string                     `json:"cookie,omitempty"`
	CrlFile           *string                     `json:"crl_file,omitempty"`
	Curves            *string                     `json:"curves,omitempty"`
	Downinter         *int                        `json:"downinter"`
	ErrorLimit        *int                        `json:"error_limit,omitempty"`
	Fall              *int                        `json:"fall"`
	Fastinter         *int                        `json:"fastinter"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3 *ServerParamsForceSslv3 `json:"force_sslv3,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *ServerParamsForceTlsv10 `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *ServerParamsForceTlsv11 `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *ServerParamsForceTlsv12 `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13        *ServerParamsForceTlsv13 `json:"force_tlsv13,omitempty"`
	Guid               *string                  `json:"guid,omitempty"`
	HashKey            *string                  `json:"hash_key,omitempty"`
	HealthCheckAddress *string                  `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                     `json:"health_check_port"`
	IdlePing           *int                     `json:"idle_ping"`
	InitAddr           *string                  `json:"init-addr"`
	InitState          *ServerParamsInitState   `json:"init-state,omitempty"`
	Inter              *int                     `json:"inter"`
	LogBufsize         *int                     `json:"log-bufsize"`
	LogProto           *ServerParamsLogProto    `json:"log_proto,omitempty"`
	Maintenance        *ServerParamsMaintenance `json:"maintenance,omitempty"`
	MaxReuse           *int                     `json:"max_reuse"`
	Maxconn            *int                     `json:"maxconn"`
	Maxqueue           *int                     `json:"maxqueue"`
	Minconn            *int                     `json:"minconn"`
	Namespace          *string                  `json:"namespace,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3 *ServerParamsNoSslv3 `json:"no_sslv3,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *ServerParamsNoTlsv10 `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *ServerParamsNoTlsv11 `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *ServerParamsNoTlsv12 `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
	NoTlsv13         *ServerParamsNoTlsv13         `json:"no_tlsv13,omitempty"`
	NoVerifyhost     *ServerParamsNoVerifyhost     `json:"no_verifyhost,omitempty"`
	Npn              *string                       `json:"npn,omitempty"`
	Observe          *ServerParamsObserve          `json:"observe,omitempty"`
	OnError          *ServerParamsOnError          `json:"on-error,omitempty"`
	OnMarkedDown     *ServerParamsOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp       *ServerParamsOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolConnName     *string                       `json:"pool_conn_name,omitempty"`
	PoolLowConn      *int                          `json:"pool_low_conn"`
	PoolMaxConn      *int                          `json:"pool_max_conn"`
	PoolPurgeDelay   *int                          `json:"pool_purge_delay"`
	Proto            *string                       `json:"proto,omitempty"`
	ProxyV2Options   *[]ServerParamsProxyV2Options `json:"proxy-v2-options,omitempty"`
	Redir            *string                       `json:"redir,omitempty"`
	ResolveNet       *string                       `json:"resolve-net,omitempty"`
	ResolvePrefer    *ServerParamsResolvePrefer    `json:"resolve-prefer,omitempty"`
	ResolveOpts      *string                       `json:"resolve_opts,omitempty"`
	Resolvers        *string                       `json:"resolvers,omitempty"`
	Rise             *int                          `json:"rise"`
	SendProxy        *ServerParamsSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2      *ServerParamsSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl   *ServerParamsSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn *ServerParamsSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int                    `json:"shard,omitempty"`
	Sigalgs        *string                 `json:"sigalgs,omitempty"`
	Slowstart      *int                    `json:"slowstart"`
	Sni            *string                 `json:"sni,omitempty"`
	Socks4         *string                 `json:"socks4,omitempty"`
	Source         *string                 `json:"source,omitempty"`
	Ssl            *ServerParamsSsl        `json:"ssl,omitempty"`
	SslCafile      *string                 `json:"ssl_cafile,omitempty"`
	SslCertificate *string                 `json:"ssl_certificate,omitempty"`
	SslMaxVer      *ServerParamsSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *ServerParamsSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *ServerParamsSslReuse   `json:"ssl_reuse,omitempty"`
	Sslv3          *ServerParamsSslv3      `json:"sslv3,omitempty"`
	Stick          *ServerParamsStick      `json:"stick,omitempty"`
	StrictMaxconn  *bool                   `json:"strict-maxconn,omitempty"`
	TcpUt          *int                    `json:"tcp_ut"`
	Tfo            *ServerParamsTfo        `json:"tfo,omitempty"`
	TlsTickets     *ServerParamsTlsTickets `json:"tls_tickets,omitempty"`
	Tlsv10         *ServerParamsTlsv10     `json:"tlsv10,omitempty"`
	Tlsv11         *ServerParamsTlsv11     `json:"tlsv11,omitempty"`
	Tlsv12         *ServerParamsTlsv12     `json:"tlsv12,omitempty"`
	Tlsv13         *ServerParamsTlsv13     `json:"tlsv13,omitempty"`
	Track          *string                 `json:"track,omitempty"`
	Verify         *ServerParamsVerify     `json:"verify,omitempty"`
	Verifyhost     *string                 `json:"verifyhost,omitempty"`
	Weight         *int                    `json:"weight"`
	Ws             *ServerParamsWs         `json:"ws,omitempty"`
}

// ServerParamsAgentCheck defines model for ServerParams.AgentCheck.
type ServerParamsAgentCheck string

// ServerParamsBackup defines model for ServerParams.Backup.
type ServerParamsBackup string

// ServerParamsCheck defines model for ServerParams.Check.
type ServerParamsCheck string

// ServerParamsCheckReusePool defines model for ServerParams.CheckReusePool.
type ServerParamsCheckReusePool string

// ServerParamsCheckSendProxy defines model for ServerParams.CheckSendProxy.
type ServerParamsCheckSendProxy string

// ServerParamsCheckSsl defines model for ServerParams.CheckSsl.
type ServerParamsCheckSsl string

// ServerParamsCheckViaSocks4 defines model for ServerParams.CheckViaSocks4.
type ServerParamsCheckViaSocks4 string

// ServerParamsForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerParamsForceSslv3 string

// ServerParamsForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerParamsForceTlsv10 string

// ServerParamsForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerParamsForceTlsv11 string

// ServerParamsForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerParamsForceTlsv12 string

// ServerParamsForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
type ServerParamsForceTlsv13 string

// ServerParamsInitState defines model for ServerParams.InitState.
type ServerParamsInitState string

// ServerParamsLogProto defines model for ServerParams.LogProto.
type ServerParamsLogProto string

// ServerParamsMaintenance defines model for ServerParams.Maintenance.
type ServerParamsMaintenance string

// ServerParamsNoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerParamsNoSslv3 string

// ServerParamsNoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerParamsNoTlsv10 string

// ServerParamsNoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerParamsNoTlsv11 string

// ServerParamsNoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerParamsNoTlsv12 string

// ServerParamsNoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
type ServerParamsNoTlsv13 string

// ServerParamsNoVerifyhost defines model for ServerParams.NoVerifyhost.
type ServerParamsNoVerifyhost string

// ServerParamsObserve defines model for ServerParams.Observe.
type ServerParamsObserve string

// ServerParamsOnError defines model for ServerParams.OnError.
type ServerParamsOnError string

// ServerParamsOnMarkedDown defines model for ServerParams.OnMarkedDown.
type ServerParamsOnMarkedDown string

// ServerParamsOnMarkedUp defines model for ServerParams.OnMarkedUp.
type ServerParamsOnMarkedUp string

// ServerParamsProxyV2Options defines model for ServerParams.ProxyV2Options.
type ServerParamsProxyV2Options string

// ServerParamsResolvePrefer defines model for ServerParams.ResolvePrefer.
type ServerParamsResolvePrefer string

// ServerParamsSendProxy defines model for ServerParams.SendProxy.
type ServerParamsSendProxy string

// ServerParamsSendProxyV2 defines model for ServerParams.SendProxyV2.
type ServerParamsSendProxyV2 string

// ServerParamsSendProxyV2Ssl defines model for ServerParams.SendProxyV2Ssl.
type ServerParamsSendProxyV2Ssl string

// ServerParamsSendProxyV2SslCn defines model for ServerParams.SendProxyV2SslCn.
type ServerParamsSendProxyV2SslCn string

// ServerParamsSsl defines model for ServerParams.Ssl.
type ServerParamsSsl string

// ServerParamsSslMaxVer defines model for ServerParams.SslMaxVer.
type ServerParamsSslMaxVer string

// ServerParamsSslMinVer defines model for ServerParams.SslMinVer.
type ServerParamsSslMinVer string

// ServerParamsSslReuse defines model for ServerParams.SslReuse.
type ServerParamsSslReuse string

// ServerParamsSslv3 defines model for ServerParams.Sslv3.
type ServerParamsSslv3 string

// ServerParamsStick defines model for ServerParams.Stick.
type ServerParamsStick string

// ServerParamsTfo defines model for ServerParams.Tfo.
type ServerParamsTfo string

// ServerParamsTlsTickets defines model for ServerParams.TlsTickets.
type ServerParamsTlsTickets string

// ServerParamsTlsv10 defines model for ServerParams.Tlsv10.
type ServerParamsTlsv10 string

// ServerParamsTlsv11 defines model for ServerParams.Tlsv11.
type ServerParamsTlsv11 string

// ServerParamsTlsv12 defines model for ServerParams.Tlsv12.
type ServerParamsTlsv12 string

// ServerParamsTlsv13 defines model for ServerParams.Tlsv13.
type ServerParamsTlsv13 string

// ServerParamsVerify defines model for ServerParams.Verify.
type ServerParamsVerify string

// ServerParamsWs defines model for ServerParams.Ws.
type ServerParamsWs string

// ServerSwitchingRule HAProxy server switching rule configuration (corresponds to use-server directive)
type ServerSwitchingRule struct {
	Cond         *ServerSwitchingRuleCond           `json:"cond,omitempty"`
	CondTest     *string                            `json:"cond_test,omitempty"`
	Metadata     *map[string]map[string]interface{} `json:"metadata,omitempty"`
	TargetServer string                             `json:"target_server"`
}

// ServerSwitchingRuleCond defines model for ServerSwitchingRule.Cond.
type ServerSwitchingRuleCond string

// ServerSwitchingRules HAProxy backend server switching rules array (corresponds to use-server directives)
type ServerSwitchingRules = []ServerSwitchingRule

// ServerTemplate defines model for server_template.
type ServerTemplate struct {
	AgentAddr         *string                       `json:"agent-addr,omitempty"`
	AgentCheck        *ServerTemplateAgentCheck     `json:"agent-check,omitempty"`
	AgentInter        *int                          `json:"agent-inter"`
	AgentPort         *int                          `json:"agent-port"`
	AgentSend         *string                       `json:"agent-send,omitempty"`
	Allow0rtt         *bool                         `json:"allow_0rtt,omitempty"`
	Alpn              *string                       `json:"alpn,omitempty"`
	Backup            *ServerTemplateBackup         `json:"backup,omitempty"`
	Check             *ServerTemplateCheck          `json:"check,omitempty"`
	CheckPoolConnName *string                       `json:"check-pool-conn-name,omitempty"`
	CheckReusePool    *ServerTemplateCheckReusePool `json:"check-reuse-pool,omitempty"`
	CheckSendProxy    *ServerTemplateCheckSendProxy `json:"check-send-proxy,omitempty"`
	CheckSni          *string                       `json:"check-sni,omitempty"`
	CheckSsl          *ServerTemplateCheckSsl       `json:"check-ssl,omitempty"`
	CheckAlpn         *string                       `json:"check_alpn,omitempty"`
	CheckProto        *string                       `json:"check_proto,omitempty"`
	CheckViaSocks4    *ServerTemplateCheckViaSocks4 `json:"check_via_socks4,omitempty"`
	Ciphers           *string                       `json:"ciphers,omitempty"`
	Ciphersuites      *string                       `json:"ciphersuites,omitempty"`
	ClientSigalgs     *string                       `json:"client_sigalgs,omitempty"`
	Cookie            *string                       `json:"cookie,omitempty"`
	CrlFile           *string                       `json:"crl_file,omitempty"`
	Curves            *string                       `json:"curves,omitempty"`
	Downinter         *int                          `json:"downinter"`
	ErrorLimit        *int                          `json:"error_limit,omitempty"`
	Fall              *int                          `json:"fall"`
	Fastinter         *int                          `json:"fastinter"`

	// ForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	ForceSslv3 *ServerTemplateForceSslv3 `json:"force_sslv3,omitempty"`

	// ForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	ForceTlsv10 *ServerTemplateForceTlsv10 `json:"force_tlsv10,omitempty"`

	// ForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	ForceTlsv11 *ServerTemplateForceTlsv11 `json:"force_tlsv11,omitempty"`

	// ForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	ForceTlsv12 *ServerTemplateForceTlsv12 `json:"force_tlsv12,omitempty"`

	// ForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
	ForceTlsv13        *ServerTemplateForceTlsv13         `json:"force_tlsv13,omitempty"`
	Fqdn               string                             `json:"fqdn"`
	Guid               *string                            `json:"guid,omitempty"`
	HashKey            *string                            `json:"hash_key,omitempty"`
	HealthCheckAddress *string                            `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                               `json:"health_check_port"`
	Id                 *int                               `json:"id"`
	IdlePing           *int                               `json:"idle_ping"`
	InitAddr           *string                            `json:"init-addr"`
	InitState          *ServerTemplateInitState           `json:"init-state,omitempty"`
	Inter              *int                               `json:"inter"`
	LogBufsize         *int                               `json:"log-bufsize"`
	LogProto           *ServerTemplateLogProto            `json:"log_proto,omitempty"`
	Maintenance        *ServerTemplateMaintenance         `json:"maintenance,omitempty"`
	MaxReuse           *int                               `json:"max_reuse"`
	Maxconn            *int                               `json:"maxconn"`
	Maxqueue           *int                               `json:"maxqueue"`
	Metadata           *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Minconn            *int                               `json:"minconn"`
	Namespace          *string                            `json:"namespace,omitempty"`

	// NoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
	NoSslv3 *ServerTemplateNoSslv3 `json:"no_sslv3,omitempty"`

	// NoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
	NoTlsv10 *ServerTemplateNoTlsv10 `json:"no_tlsv10,omitempty"`

	// NoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
	NoTlsv11 *ServerTemplateNoTlsv11 `json:"no_tlsv11,omitempty"`

	// NoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
	NoTlsv12 *ServerTemplateNoTlsv12 `json:"no_tlsv12,omitempty"`

	// NoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
	NoTlsv13         *ServerTemplateNoTlsv13         `json:"no_tlsv13,omitempty"`
	NoVerifyhost     *ServerTemplateNoVerifyhost     `json:"no_verifyhost,omitempty"`
	Npn              *string                         `json:"npn,omitempty"`
	NumOrRange       string                          `json:"num_or_range"`
	Observe          *ServerTemplateObserve          `json:"observe,omitempty"`
	OnError          *ServerTemplateOnError          `json:"on-error,omitempty"`
	OnMarkedDown     *ServerTemplateOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp       *ServerTemplateOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolConnName     *string                         `json:"pool_conn_name,omitempty"`
	PoolLowConn      *int                            `json:"pool_low_conn"`
	PoolMaxConn      *int                            `json:"pool_max_conn"`
	PoolPurgeDelay   *int                            `json:"pool_purge_delay"`
	Port             *int                            `json:"port"`
	Prefix           string                          `json:"prefix"`
	Proto            *string                         `json:"proto,omitempty"`
	ProxyV2Options   *[]ServerTemplateProxyV2Options `json:"proxy-v2-options,omitempty"`
	Redir            *string                         `json:"redir,omitempty"`
	ResolveNet       *string                         `json:"resolve-net,omitempty"`
	ResolvePrefer    *ServerTemplateResolvePrefer    `json:"resolve-prefer,omitempty"`
	ResolveOpts      *string                         `json:"resolve_opts,omitempty"`
	Resolvers        *string                         `json:"resolvers,omitempty"`
	Rise             *int                            `json:"rise"`
	SendProxy        *ServerTemplateSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2      *ServerTemplateSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl   *ServerTemplateSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn *ServerTemplateSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int                      `json:"shard,omitempty"`
	Sigalgs        *string                   `json:"sigalgs,omitempty"`
	Slowstart      *int                      `json:"slowstart"`
	Sni            *string                   `json:"sni,omitempty"`
	Socks4         *string                   `json:"socks4,omitempty"`
	Source         *string                   `json:"source,omitempty"`
	Ssl            *ServerTemplateSsl        `json:"ssl,omitempty"`
	SslCafile      *string                   `json:"ssl_cafile,omitempty"`
	SslCertificate *string                   `json:"ssl_certificate,omitempty"`
	SslMaxVer      *ServerTemplateSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *ServerTemplateSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *ServerTemplateSslReuse   `json:"ssl_reuse,omitempty"`
	Sslv3          *ServerTemplateSslv3      `json:"sslv3,omitempty"`
	Stick          *ServerTemplateStick      `json:"stick,omitempty"`
	StrictMaxconn  *bool                     `json:"strict-maxconn,omitempty"`
	TcpUt          *int                      `json:"tcp_ut"`
	Tfo            *ServerTemplateTfo        `json:"tfo,omitempty"`
	TlsTickets     *ServerTemplateTlsTickets `json:"tls_tickets,omitempty"`
	Tlsv10         *ServerTemplateTlsv10     `json:"tlsv10,omitempty"`
	Tlsv11         *ServerTemplateTlsv11     `json:"tlsv11,omitempty"`
	Tlsv12         *ServerTemplateTlsv12     `json:"tlsv12,omitempty"`
	Tlsv13         *ServerTemplateTlsv13     `json:"tlsv13,omitempty"`
	Track          *string                   `json:"track,omitempty"`
	Verify         *ServerTemplateVerify     `json:"verify,omitempty"`
	Verifyhost     *string                   `json:"verifyhost,omitempty"`
	Weight         *int                      `json:"weight"`
	Ws             *ServerTemplateWs         `json:"ws,omitempty"`
}

// ServerTemplateAgentCheck defines model for ServerTemplate.AgentCheck.
type ServerTemplateAgentCheck string

// ServerTemplateBackup defines model for ServerTemplate.Backup.
type ServerTemplateBackup string

// ServerTemplateCheck defines model for ServerTemplate.Check.
type ServerTemplateCheck string

// ServerTemplateCheckReusePool defines model for ServerTemplate.CheckReusePool.
type ServerTemplateCheckReusePool string

// ServerTemplateCheckSendProxy defines model for ServerTemplate.CheckSendProxy.
type ServerTemplateCheckSendProxy string

// ServerTemplateCheckSsl defines model for ServerTemplate.CheckSsl.
type ServerTemplateCheckSsl string

// ServerTemplateCheckViaSocks4 defines model for ServerTemplate.CheckViaSocks4.
type ServerTemplateCheckViaSocks4 string

// ServerTemplateForceSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerTemplateForceSslv3 string

// ServerTemplateForceTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerTemplateForceTlsv10 string

// ServerTemplateForceTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerTemplateForceTlsv11 string

// ServerTemplateForceTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerTemplateForceTlsv12 string

// ServerTemplateForceTlsv13 This field is deprecated in favor of tlsv13, and will be removed in a future release
type ServerTemplateForceTlsv13 string

// ServerTemplateInitState defines model for ServerTemplate.InitState.
type ServerTemplateInitState string

// ServerTemplateLogProto defines model for ServerTemplate.LogProto.
type ServerTemplateLogProto string

// ServerTemplateMaintenance defines model for ServerTemplate.Maintenance.
type ServerTemplateMaintenance string

// ServerTemplateNoSslv3 This field is deprecated in favor of sslv3, and will be removed in a future release
type ServerTemplateNoSslv3 string

// ServerTemplateNoTlsv10 This field is deprecated in favor of tlsv10, and will be removed in a future release
type ServerTemplateNoTlsv10 string

// ServerTemplateNoTlsv11 This field is deprecated in favor of tlsv11, and will be removed in a future release
type ServerTemplateNoTlsv11 string

// ServerTemplateNoTlsv12 This field is deprecated in favor of tlsv12, and will be removed in a future release
type ServerTemplateNoTlsv12 string

// ServerTemplateNoTlsv13 This field is deprecated in favor of force_tlsv13, and will be removed in a future release
type ServerTemplateNoTlsv13 string

// ServerTemplateNoVerifyhost defines model for ServerTemplate.NoVerifyhost.
type ServerTemplateNoVerifyhost string

// ServerTemplateObserve defines model for ServerTemplate.Observe.
type ServerTemplateObserve string

// ServerTemplateOnError defines model for ServerTemplate.OnError.
type ServerTemplateOnError string

// ServerTemplateOnMarkedDown defines model for ServerTemplate.OnMarkedDown.
type ServerTemplateOnMarkedDown string

// ServerTemplateOnMarkedUp defines model for ServerTemplate.OnMarkedUp.
type ServerTemplateOnMarkedUp string

// ServerTemplateProxyV2Options defines model for ServerTemplate.ProxyV2Options.
type ServerTemplateProxyV2Options string

// ServerTemplateResolvePrefer defines model for ServerTemplate.ResolvePrefer.
type ServerTemplateResolvePrefer string

// ServerTemplateSendProxy defines model for ServerTemplate.SendProxy.
type ServerTemplateSendProxy string

// ServerTemplateSendProxyV2 defines model for ServerTemplate.SendProxyV2.
type ServerTemplateSendProxyV2 string

// ServerTemplateSendProxyV2Ssl defines model for ServerTemplate.SendProxyV2Ssl.
type ServerTemplateSendProxyV2Ssl string

// ServerTemplateSendProxyV2SslCn defines model for ServerTemplate.SendProxyV2SslCn.
type ServerTemplateSendProxyV2SslCn string

// ServerTemplateSsl defines model for ServerTemplate.Ssl.
type ServerTemplateSsl string

// ServerTemplateSslMaxVer defines model for ServerTemplate.SslMaxVer.
type ServerTemplateSslMaxVer string

// ServerTemplateSslMinVer defines model for ServerTemplate.SslMinVer.
type ServerTemplateSslMinVer string

// ServerTemplateSslReuse defines model for ServerTemplate.SslReuse.
type ServerTemplateSslReuse string

// ServerTemplateSslv3 defines model for ServerTemplate.Sslv3.
type ServerTemplateSslv3 string

// ServerTemplateStick defines model for ServerTemplate.Stick.
type ServerTemplateStick string

// ServerTemplateTfo defines model for ServerTemplate.Tfo.
type ServerTemplateTfo string

// ServerTemplateTlsTickets defines model for ServerTemplate.TlsTickets.
type ServerTemplateTlsTickets string

// ServerTemplateTlsv10 defines model for ServerTemplate.Tlsv10.
type ServerTemplateTlsv10 string

// ServerTemplateTlsv11 defines model for ServerTemplate.Tlsv11.
type ServerTemplateTlsv11 string

// ServerTemplateTlsv12 defines model for ServerTemplate.Tlsv12.
type ServerTemplateTlsv12 string

// ServerTemplateTlsv13 defines model for ServerTemplate.Tlsv13.
type ServerTemplateTlsv13 string

// ServerTemplateVerify defines model for ServerTemplate.Verify.
type ServerTemplateVerify string

// ServerTemplateWs defines model for ServerTemplate.Ws.
type ServerTemplateWs string

// ServerTemplates HAProxy backend server templates array
type ServerTemplates = []ServerTemplate

// Servers HAProxy backend servers array
type Servers = []Server

// Site Site configuration. Sites are considered as one service and all farms connected to that service.
// Farms are connected to service using use-backend and default_backend directives. Sites let you
// configure simple HAProxy configurations, for more advanced options use /haproxy/configuration
// endpoints.
type Site struct {
	Farms *[]struct {
		Balance    *Balance       `json:"balance,omitempty"`
		Cond       *SiteFarmsCond `json:"cond,omitempty"`
		CondTest   *string        `json:"cond_test,omitempty"`
		Forwardfor *Forwardfor    `json:"forwardfor,omitempty"`
		Mode       *SiteFarmsMode `json:"mode,omitempty"`
		Name       string         `json:"name"`
		Servers    *[]Server      `json:"servers,omitempty"`
		UseAs      SiteFarmsUseAs `json:"use_as"`
	} `json:"farms,omitempty"`
	Name    string `json:"name"`
	Service *struct {
		HttpConnectionMode *SiteServiceHttpConnectionMode `json:"http_connection_mode,omitempty"`
		Listeners          *[]Bind                        `json:"listeners,omitempty"`
		Maxconn            *int                           `json:"maxconn"`
		Mode               *SiteServiceMode               `json:"mode,omitempty"`
	} `json:"service,omitempty"`
}

// SiteFarmsCond defines model for Site.Farms.Cond.
type SiteFarmsCond string

// SiteFarmsMode defines model for Site.Farms.Mode.
type SiteFarmsMode string

// SiteFarmsUseAs defines model for Site.Farms.UseAs.
type SiteFarmsUseAs string

// SiteServiceHttpConnectionMode defines model for Site.Service.HttpConnectionMode.
type SiteServiceHttpConnectionMode string

// SiteServiceMode defines model for Site.Service.Mode.
type SiteServiceMode string

// Sites Sites array. Sites are considered as one service and all farms connected to that service.
// Farms are connected to service using use-backend and default_backend directives. Sites let you
// configure simple HAProxy configurations, for more advanced options use /haproxy/configuration
// endpoints.
type Sites = []Site

// SmtpchkParams defines model for smtpchk_params.
type SmtpchkParams struct {
	Domain *string `json:"domain,omitempty"`
	Hello  *string `json:"hello,omitempty"`
}

// Source defines model for source.
type Source struct {
	Address       string        `json:"address"`
	AddressSecond *string       `json:"address_second,omitempty"`
	Hdr           *string       `json:"hdr,omitempty"`
	Interface     *string       `json:"interface,omitempty"`
	Occ           *string       `json:"occ,omitempty"`
	Port          *int          `json:"port,omitempty"`
	PortSecond    *int          `json:"port_second,omitempty"`
	Usesrc        *SourceUsesrc `json:"usesrc,omitempty"`
}

// SourceUsesrc defines model for Source.Usesrc.
type SourceUsesrc string

// SpoeAgent SPOE agent configuration
type SpoeAgent struct {
	Async           *SpoeAgentAsync           `json:"async,omitempty"`
	ContinueOnError *SpoeAgentContinueOnError `json:"continue-on-error,omitempty"`
	DontlogNormal   *SpoeAgentDontlogNormal   `json:"dontlog-normal,omitempty"`
	EngineName      *string                   `json:"engine-name,omitempty"`
	ForceSetVar     *SpoeAgentForceSetVar     `json:"force-set-var,omitempty"`
	Groups          *string                   `json:"groups,omitempty"`
	HelloTimeout    *int                      `json:"hello_timeout,omitempty"`
	IdleTimeout     *int                      `json:"idle_timeout,omitempty"`

	// Log HAProxy log target array (corresponds to log directives)
	Log                  *LogTargets               `json:"log,omitempty"`
	MaxFrameSize         *int                      `json:"max-frame-size,omitempty"`
	MaxWaitingFrames     *int                      `json:"max-waiting-frames,omitempty"`
	Maxconnrate          *int                      `json:"maxconnrate,omitempty"`
	Maxerrrate           *int                      `json:"maxerrrate,omitempty"`
	Messages             *string                   `json:"messages,omitempty"`
	Name                 string                    `json:"name"`
	OptionSetOnError     *string                   `json:"option_set-on-error,omitempty"`
	OptionSetProcessTime *string                   `json:"option_set-process-time,omitempty"`
	OptionSetTotalTime   *string                   `json:"option_set-total-time,omitempty"`
	OptionVarPrefix      *string                   `json:"option_var-prefix,omitempty"`
	Pipelining           *SpoeAgentPipelining      `json:"pipelining,omitempty"`
	ProcessingTimeout    *int                      `json:"processing_timeout,omitempty"`
	RegisterVarNames     *string                   `json:"register-var-names,omitempty"`
	SendFragPayload      *SpoeAgentSendFragPayload `json:"send-frag-payload,omitempty"`
	UseBackend           *string                   `json:"use-backend,omitempty"`
}

// SpoeAgentAsync defines model for SpoeAgent.Async.
type SpoeAgentAsync string

// SpoeAgentContinueOnError defines model for SpoeAgent.ContinueOnError.
type SpoeAgentContinueOnError string

// SpoeAgentDontlogNormal defines model for SpoeAgent.DontlogNormal.
type SpoeAgentDontlogNormal string

// SpoeAgentForceSetVar defines model for SpoeAgent.ForceSetVar.
type SpoeAgentForceSetVar string

// SpoeAgentPipelining defines model for SpoeAgent.Pipelining.
type SpoeAgentPipelining string

// SpoeAgentSendFragPayload defines model for SpoeAgent.SendFragPayload.
type SpoeAgentSendFragPayload string

// SpoeAgents SPOE Agents of one scope in SPOE file
type SpoeAgents = []SpoeAgent

// SpoeFiles SPOE files
type SpoeFiles = []string

// SpoeGroup SPOE group section configuration
type SpoeGroup struct {
	Messages *string `json:"messages,omitempty"`
	Name     string  `json:"name"`
}

// SpoeGroups SPOE Groups of one scope in SPOE file
type SpoeGroups = []SpoeGroup

// SpoeMessage SPOE message section configuration
type SpoeMessage struct {
	// Acl HAProxy ACL lines array (corresponds to acl directives)
	Acl   *Acls   `json:"acl,omitempty"`
	Args  *string `json:"args,omitempty"`
	Event *struct {
		Cond     *SpoeMessageEventCond `json:"cond,omitempty"`
		CondTest *string               `json:"cond_test,omitempty"`
		Name     SpoeMessageEventName  `json:"name"`
	} `json:"event,omitempty"`
	Name string `json:"name"`
}

// SpoeMessageEventCond defines model for SpoeMessage.Event.Cond.
type SpoeMessageEventCond string

// SpoeMessageEventName defines model for SpoeMessage.Event.Name.
type SpoeMessageEventName string

// SpoeMessages SPOE Messages of one scope in SPOE file
type SpoeMessages = []SpoeMessage

// SpoeScope SPOE scope name
type SpoeScope = string

// SpoeScopes All SPOE Scopes
type SpoeScopes = []SpoeScope

// SpoeTransaction SPOE configuration transaction
type SpoeTransaction struct {
	UnderscoreVersion *int                   `json:"_version,omitempty"`
	Id                *string                `json:"id,omitempty"`
	Status            *SpoeTransactionStatus `json:"status,omitempty"`
}

// SpoeTransactionStatus defines model for SpoeTransaction.Status.
type SpoeTransactionStatus string

// SpoeTransactions SPOE Configuration transactions array
type SpoeTransactions = []SpoeTransaction

// SslCaFile A file containing one or more SSL/TLS certificates and keys
type SslCaFile struct {
	Count       *string `json:"count,omitempty"`
	File        *string `json:"file,omitempty"`
	StorageName *string `json:"storage_name,omitempty"`
}

// SslCaFiles Array of SSL CA files
type SslCaFiles = []SslCaFile

// SslCertificate A file containing one or more SSL/TLS certificates and keys
type SslCertificate struct {
	Algorithm         *string    `json:"algorithm,omitempty"`
	AuthorityKeyId    *string    `json:"authority_key_id,omitempty"`
	ChainIssuer       *string    `json:"chain_issuer,omitempty"`
	ChainSubject      *string    `json:"chain_subject,omitempty"`
	Description       *string    `json:"description,omitempty"`
	Domains           *string    `json:"domains,omitempty"`
	File              *string    `json:"file,omitempty"`
	IpAddresses       *string    `json:"ip_addresses,omitempty"`
	Issuers           *string    `json:"issuers,omitempty"`
	NotAfter          *time.Time `json:"not_after"`
	NotBefore         *time.Time `json:"not_before"`
	Serial            *string    `json:"serial,omitempty"`
	Sha1FingerPrint   *string    `json:"sha1_finger_print,omitempty"`
	Sha256FingerPrint *string    `json:"sha256_finger_print,omitempty"`

	// Size File size in bytes.
	Size *int `json:"size"`

	// Status Only set when using the runtime API.
	Status                  *string `json:"status,omitempty"`
	StorageName             *string `json:"storage_name,omitempty"`
	Subject                 *string `json:"subject,omitempty"`
	SubjectAlternativeNames *string `json:"subject_alternative_names,omitempty"`
	SubjectKeyId            *string `json:"subject_key_id,omitempty"`
}

// SslCertificates Array of ssl certificate files
type SslCertificates = []SslCertificate

// SslCrl A file containing one or more SSL/TLS CRLs
type SslCrl struct {
	Description *string `json:"description,omitempty"`
	File        *string `json:"file,omitempty"`
	StorageName *string `json:"storage_name,omitempty"`
}

// SslCrlEntries defines model for ssl_crl_entries.
type SslCrlEntries = []SslCrlEntry

// SslCrlEntry A certificate revocation list entry.
type SslCrlEntry struct {
	Issuer              *string             `json:"issuer,omitempty"`
	LastUpdate          *openapi_types.Date `json:"last_update,omitempty"`
	NextUpdate          *openapi_types.Date `json:"next_update,omitempty"`
	RevokedCertificates *[]struct {
		RevocationDate *openapi_types.Date `json:"revocation_date,omitempty"`
		SerialNumber   *string             `json:"serial_number,omitempty"`
	} `json:"revoked_certificates,omitempty"`
	SignatureAlgorithm *string `json:"signature_algorithm,omitempty"`
	Status             *string `json:"status,omitempty"`
	StorageName        *string `json:"storage_name,omitempty"`
	Version            *string `json:"version,omitempty"`
}

// SslCrls Array of ssl crl files
type SslCrls = []SslCrl

// SslCrtList SSL Crt List file
type SslCrtList struct {
	File *string `json:"file,omitempty"`
}

// SslCrtListEntries Array of SSL Crt List Entry
type SslCrtListEntries = []SslCrtListEntry

// SslCrtListEntry SSL Crt List Entry
type SslCrtListEntry struct {
	File          *string   `json:"file,omitempty"`
	LineNumber    *int      `json:"line_number,omitempty"`
	SNIFilter     *[]string `json:"sni_filter,omitempty"`
	SSLBindConfig *string   `json:"ssl_bind_config,omitempty"`
}

// SslCrtListFile A file referencing one or more certificates with their configuration.
type SslCrtListFile struct {
	Description *string `json:"description,omitempty"`
	File        *string `json:"file,omitempty"`

	// Size File size in bytes.
	Size        *int    `json:"size"`
	StorageName *string `json:"storage_name,omitempty"`
}

// SslCrtListFiles List of SSL certificate list files (crt-list)
type SslCrtListFiles = []SslCrtListFile

// SslCrtLists Array of SSL Crt List
type SslCrtLists = []SslCrtList

// SSLFrontUse Assign a certificate to the current frontend
type SSLFrontUse struct {
	Allow0rtt *bool   `json:"allow_0rtt,omitempty"`
	Alpn      *string `json:"alpn,omitempty"`
	CaFile    *string `json:"ca_file,omitempty"`

	// Certificate Certificate filename
	Certificate   string  `json:"certificate"`
	Ciphers       *string `json:"ciphers,omitempty"`
	Ciphersuites  *string `json:"ciphersuites,omitempty"`
	ClientSigalgs *string `json:"client_sigalgs,omitempty"`
	CrlFile       *string `json:"crl_file,omitempty"`
	Curves        *string `json:"curves,omitempty"`
	Ecdhe         *string `json:"ecdhe,omitempty"`

	// Issuer OCSP issuer filename
	Issuer *string `json:"issuer,omitempty"`

	// Key Private key filename
	Key       *string                            `json:"key,omitempty"`
	Metadata  *map[string]map[string]interface{} `json:"metadata,omitempty"`
	NoAlpn    *bool                              `json:"no_alpn,omitempty"`
	NoCaNames *bool                              `json:"no_ca_names,omitempty"`
	Npn       *string                            `json:"npn,omitempty"`

	// Ocsp OCSP response filename
	Ocsp *string `json:"ocsp,omitempty"`

	// OcspUpdate Automatic OCSP response update
	OcspUpdate *SslFrontUseOcspUpdate `json:"ocsp_update,omitempty"`

	// Sctl Signed Certificate Timestamp List filename
	Sctl      *string               `json:"sctl,omitempty"`
	Sigalgs   *string               `json:"sigalgs,omitempty"`
	SslMaxVer *SslFrontUseSslMaxVer `json:"ssl_max_ver,omitempty"`
	SslMinVer *SslFrontUseSslMinVer `json:"ssl_min_ver,omitempty"`
	Verify    *SslFrontUseVerify    `json:"verify,omitempty"`
}

// SslFrontUseOcspUpdate Automatic OCSP response update
type SslFrontUseOcspUpdate string

// SslFrontUseSslMaxVer defines model for SslFrontUse.SslMaxVer.
type SslFrontUseSslMaxVer string

// SslFrontUseSslMinVer defines model for SslFrontUse.SslMinVer.
type SslFrontUseSslMinVer string

// SslFrontUseVerify defines model for SslFrontUse.Verify.
type SslFrontUseVerify string

// SSLFrontUses defines model for ssl_front_uses.
type SSLFrontUses = []SSLFrontUse

// SslOptions defines model for ssl_options.
type SslOptions struct {
	AcmeScheduler              *SslOptionsAcmeScheduler `json:"acme_scheduler,omitempty"`
	CaBase                     *string                  `json:"ca_base,omitempty"`
	CrtBase                    *string                  `json:"crt_base,omitempty"`
	DefaultBindCiphers         *string                  `json:"default_bind_ciphers,omitempty"`
	DefaultBindCiphersuites    *string                  `json:"default_bind_ciphersuites,omitempty"`
	DefaultBindClientSigalgs   *string                  `json:"default_bind_client_sigalgs,omitempty"`
	DefaultBindCurves          *string                  `json:"default_bind_curves,omitempty"`
	DefaultBindOptions         *string                  `json:"default_bind_options,omitempty"`
	DefaultBindSigalgs         *string                  `json:"default_bind_sigalgs,omitempty"`
	DefaultServerCiphers       *string                  `json:"default_server_ciphers,omitempty"`
	DefaultServerCiphersuites  *string                  `json:"default_server_ciphersuites,omitempty"`
	DefaultServerClientSigalgs *string                  `json:"default_server_client_sigalgs,omitempty"`
	DefaultServerCurves        *string                  `json:"default_server_curves,omitempty"`
	DefaultServerOptions       *string                  `json:"default_server_options,omitempty"`
	DefaultServerSigalgs       *string                  `json:"default_server_sigalgs,omitempty"`
	DhParamFile                *string                  `json:"dh_param_file,omitempty"`
	SslEngines                 *[]struct {
		Algorithms *string `json:"algorithms"`
		Name       string  `json:"name"`
	} `json:"engines,omitempty"`
	IssuersChainPath *string                 `json:"issuers_chain_path,omitempty"`
	LoadExtraFiles   *string                 `json:"load_extra_files,omitempty"`
	Maxsslconn       *int                    `json:"maxsslconn,omitempty"`
	Maxsslrate       *int                    `json:"maxsslrate,omitempty"`
	ModeAsync        *SslOptionsModeAsync    `json:"mode_async,omitempty"`
	Propquery        *string                 `json:"propquery,omitempty"`
	Provider         *string                 `json:"provider,omitempty"`
	ProviderPath     *string                 `json:"provider_path,omitempty"`
	SecurityLevel    *int                    `json:"security_level"`
	ServerVerify     *SslOptionsServerVerify `json:"server_verify,omitempty"`
	SkipSelfIssuedCa *bool                   `json:"skip_self_issued_ca,omitempty"`
}

// SslOptionsAcmeScheduler defines model for SslOptions.AcmeScheduler.
type SslOptionsAcmeScheduler string

// SslOptionsModeAsync defines model for SslOptions.ModeAsync.
type SslOptionsModeAsync string

// SslOptionsServerVerify defines model for SslOptions.ServerVerify.
type SslOptionsServerVerify string

// StatsAuth defines model for stats_auth.
type StatsAuth struct {
	Passwd string `json:"passwd"`
	User   string `json:"user"`
}

// StatsHttpRequest defines model for stats_http_request.
type StatsHttpRequest struct {
	Cond     *string              `json:"cond,omitempty"`
	CondTest *string              `json:"cond_test,omitempty"`
	Realm    *string              `json:"realm,omitempty"`
	Type     StatsHttpRequestType `json:"type"`
}

// StatsHttpRequestType defines model for StatsHttpRequest.Type.
type StatsHttpRequestType string

// StatsOptions defines model for stats_options.
type StatsOptions struct {
	StatsAdmin         *bool                       `json:"stats_admin,omitempty"`
	StatsAdminCond     *StatsOptionsStatsAdminCond `json:"stats_admin_cond,omitempty"`
	StatsAdminCondTest *string                     `json:"stats_admin_cond_test,omitempty"`
	StatsAuths         *[]StatsAuth                `json:"stats_auths,omitempty"`
	StatsEnable        *bool                       `json:"stats_enable,omitempty"`
	StatsHideVersion   *bool                       `json:"stats_hide_version,omitempty"`
	StatsHttpRequests  *[]StatsHttpRequest         `json:"stats_http_requests,omitempty"`
	StatsMaxconn       *int                        `json:"stats_maxconn,omitempty"`
	StatsRealm         *bool                       `json:"stats_realm,omitempty"`
	StatsRealmRealm    *string                     `json:"stats_realm_realm"`
	StatsRefreshDelay  *int                        `json:"stats_refresh_delay"`
	StatsShowDesc      *string                     `json:"stats_show_desc"`
	StatsShowLegends   *bool                       `json:"stats_show_legends,omitempty"`
	StatsShowModules   *bool                       `json:"stats_show_modules,omitempty"`
	StatsShowNodeName  *string                     `json:"stats_show_node_name"`
	StatsUriPrefix     *string                     `json:"stats_uri_prefix,omitempty"`
}

// StatsOptionsStatsAdminCond defines model for StatsOptions.StatsAdminCond.
type StatsOptionsStatsAdminCond string

// StickRule Define a pattern used to create an entry in a stickiness table or matching condition or associate a user to a server.
type StickRule struct {
	Cond     *StickRuleCond                     `json:"cond,omitempty"`
	CondTest *string                            `json:"cond_test,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Pattern  string                             `json:"pattern"`
	Table    *string                            `json:"table,omitempty"`
	Type     StickRuleType                      `json:"type"`
}

// StickRuleCond defines model for StickRule.Cond.
type StickRuleCond string

// StickRuleType defines model for StickRule.Type.
type StickRuleType string

// StickRules HAProxy backend stick rules array (corresponds to stick store-request, stick match, stick on, stick store-response)
type StickRules = []StickRule

// StickTable Stick Table Information
type StickTable struct {
	Fields *[]struct {
		Field  *StickTableFieldsField `json:"field,omitempty"`
		Idx    *int                   `json:"idx,omitempty"`
		Period *int                   `json:"period,omitempty"`
		Type   *StickTableFieldsType  `json:"type,omitempty"`
	} `json:"fields,omitempty"`
	Name *string         `json:"name,omitempty"`
	Size *int            `json:"size"`
	Type *StickTableType `json:"type,omitempty"`
	Used *int            `json:"used"`
}

// StickTableFieldsField defines model for StickTable.Fields.Field.
type StickTableFieldsField string

// StickTableFieldsType defines model for StickTable.Fields.Type.
type StickTableFieldsType string

// StickTableType defines model for StickTable.Type.
type StickTableType string

// StickTableEntries Entries of one runtime stick table
type StickTableEntries = []StickTableEntry

// StickTableEntry One entry in stick table
type StickTableEntry struct {
	BytesInCnt   *int `json:"bytes_in_cnt"`
	BytesInRate  *int `json:"bytes_in_rate"`
	BytesOutCnt  *int `json:"bytes_out_cnt"`
	BytesOutRate *int `json:"bytes_out_rate"`
	ConnCnt      *int `json:"conn_cnt"`
	ConnCur      *int `json:"conn_cur"`
	ConnRate     *int `json:"conn_rate"`
	Exp          *int `json:"exp"`
	GlitchCnt    *int `json:"glitch_cnt"`
	GlitchRate   *int `json:"glitch_rate"`
	Gpc          *struct {
		Idx   *int `json:"idx,omitempty"`
		Value *int `json:"value"`
	} `json:"gpc,omitempty"`
	Gpc0     *int `json:"gpc0"`
	Gpc0Rate *int `json:"gpc0_rate"`
	Gpc1     *int `json:"gpc1"`
	Gpc1Rate *int `json:"gpc1_rate"`
	GpcRate  *struct {
		Idx   *int `json:"idx,omitempty"`
		Value *int `json:"value"`
	} `json:"gpc_rate,omitempty"`
	Gpt *struct {
		Idx   *int `json:"idx,omitempty"`
		Value *int `json:"value"`
	} `json:"gpt,omitempty"`
	Gpt0         *int    `json:"gpt0"`
	HttpErrCnt   *int    `json:"http_err_cnt"`
	HttpErrRate  *int    `json:"http_err_rate"`
	HttpFailCnt  *int    `json:"http_fail_cnt"`
	HttpFailRate *int    `json:"http_fail_rate"`
	HttpReqCnt   *int    `json:"http_req_cnt"`
	HttpReqRate  *int    `json:"http_req_rate"`
	Id           *string `json:"id,omitempty"`
	Key          *string `json:"key,omitempty"`
	ServerId     *int    `json:"server_id"`
	SessCnt      *int    `json:"sess_cnt"`
	SessRate     *int    `json:"sess_rate"`
	Use          *bool   `json:"use,omitempty"`
}

// StickTables Array of runtime stick tables
type StickTables = []StickTable

// Table defines model for table.
type Table struct {
	Expire   *string                            `json:"expire"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     *string                            `json:"name,omitempty"`
	NoPurge  *bool                              `json:"no_purge,omitempty"`
	RecvOnly *bool                              `json:"recv_only,omitempty"`
	Size     *string                            `json:"size,omitempty"`
	Store    *string                            `json:"store,omitempty"`
	Type     *TableType                         `json:"type,omitempty"`
	TypeLen  *int                               `json:"type_len"`
	WriteTo  *string                            `json:"write_to"`
}

// TableType defines model for Table.Type.
type TableType string

// Tables HAProxy table array
type Tables = []Table

// TcpCheck defines model for tcp_check.
type TcpCheck struct {
	Action          TcpCheckAction                     `json:"action"`
	Addr            *string                            `json:"addr,omitempty"`
	Alpn            *string                            `json:"alpn,omitempty"`
	CheckComment    *string                            `json:"check_comment,omitempty"`
	Data            *string                            `json:"data,omitempty"`
	Default         *bool                              `json:"default,omitempty"`
	ErrorStatus     *TcpCheckErrorStatus               `json:"error_status,omitempty"`
	ExclamationMark *bool                              `json:"exclamation_mark,omitempty"`
	Fmt             *string                            `json:"fmt,omitempty"`
	HexFmt          *string                            `json:"hex_fmt,omitempty"`
	HexString       *string                            `json:"hex_string,omitempty"`
	Linger          *bool                              `json:"linger,omitempty"`
	Match           *TcpCheckMatch                     `json:"match,omitempty"`
	Metadata        *map[string]map[string]interface{} `json:"metadata,omitempty"`
	MinRecv         *int                               `json:"min_recv,omitempty"`
	OkStatus        *TcpCheckOkStatus                  `json:"ok_status,omitempty"`
	OnError         *string                            `json:"on_error,omitempty"`
	OnSuccess       *string                            `json:"on_success,omitempty"`
	Pattern         *string                            `json:"pattern,omitempty"`
	Port            *int                               `json:"port"`
	PortString      *string                            `json:"port_string,omitempty"`
	Proto           *string                            `json:"proto,omitempty"`
	SendProxy       *bool                              `json:"send_proxy,omitempty"`
	Sni             *string                            `json:"sni,omitempty"`
	Ssl             *bool                              `json:"ssl,omitempty"`
	StatusCode      *string                            `json:"status-code,omitempty"`
	ToutStatus      *TcpCheckToutStatus                `json:"tout_status,omitempty"`
	VarExpr         *string                            `json:"var_expr,omitempty"`
	VarFmt          *string                            `json:"var_fmt,omitempty"`
	VarName         *string                            `json:"var_name,omitempty"`
	VarScope        *string                            `json:"var_scope,omitempty"`
	ViaSocks4       *bool                              `json:"via_socks4,omitempty"`
}

// TcpCheckAction defines model for TcpCheck.Action.
type TcpCheckAction string

// TcpCheckErrorStatus defines model for TcpCheck.ErrorStatus.
type TcpCheckErrorStatus string

// TcpCheckMatch defines model for TcpCheck.Match.
type TcpCheckMatch string

// TcpCheckOkStatus defines model for TcpCheck.OkStatus.
type TcpCheckOkStatus string

// TcpCheckToutStatus defines model for TcpCheck.ToutStatus.
type TcpCheckToutStatus string

// TcpChecks defines model for tcp_checks.
type TcpChecks = []TcpCheck

// TcpRequestRule HAProxy TCP Request Rule configuration (corresponds to tcp-request)
type TcpRequestRule struct {
	Action               *TcpRequestRuleAction              `json:"action,omitempty"`
	BandwidthLimitLimit  *string                            `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                            `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                            `json:"bandwidth_limit_period,omitempty"`
	CaptureLen           *int                               `json:"capture_len,omitempty"`
	CaptureSample        *string                            `json:"capture_sample,omitempty"`
	Cond                 *TcpRequestRuleCond                `json:"cond,omitempty"`
	CondTest             *string                            `json:"cond_test,omitempty"`
	Expr                 *string                            `json:"expr,omitempty"`
	GptValue             *string                            `json:"gpt_value,omitempty"`
	LogLevel             *TcpRequestRuleLogLevel            `json:"log_level,omitempty"`
	LuaAction            *string                            `json:"lua_action,omitempty"`
	LuaParams            *string                            `json:"lua_params,omitempty"`
	MarkValue            *string                            `json:"mark_value,omitempty"`
	Metadata             *map[string]map[string]interface{} `json:"metadata,omitempty"`
	NiceValue            *int                               `json:"nice_value,omitempty"`
	ResolveProtocol      *TcpRequestRuleResolveProtocol     `json:"resolve_protocol,omitempty"`
	ResolveResolvers     *string                            `json:"resolve_resolvers,omitempty"`
	ResolveVar           *string                            `json:"resolve_var,omitempty"`
	RstTtl               *int                               `json:"rst_ttl,omitempty"`
	ScIdx                *string                            `json:"sc_idx,omitempty"`
	ScIncId              *string                            `json:"sc_inc_id,omitempty"`
	ScInt                *int                               `json:"sc_int"`
	ServerName           *string                            `json:"server_name,omitempty"`
	ServiceName          *string                            `json:"service_name,omitempty"`
	SpoeEngineName       *string                            `json:"spoe_engine_name,omitempty"`
	SpoeGroupName        *string                            `json:"spoe_group_name,omitempty"`
	SwitchModeProto      *string                            `json:"switch_mode_proto,omitempty"`
	Timeout              *int                               `json:"timeout"`
	TosValue             *string                            `json:"tos_value,omitempty"`
	TrackKey             *string                            `json:"track_key,omitempty"`
	TrackStickCounter    *int                               `json:"track_stick_counter"`
	TrackTable           *string                            `json:"track_table,omitempty"`
	Type                 TcpRequestRuleType                 `json:"type"`
	VarFormat            *string                            `json:"var_format,omitempty"`
	VarName              *string                            `json:"var_name,omitempty"`
	VarScope             *string                            `json:"var_scope,omitempty"`
}

// TcpRequestRuleAction defines model for TcpRequestRule.Action.
type TcpRequestRuleAction string

// TcpRequestRuleCond defines model for TcpRequestRule.Cond.
type TcpRequestRuleCond string

// TcpRequestRuleLogLevel defines model for TcpRequestRule.LogLevel.
type TcpRequestRuleLogLevel string

// TcpRequestRuleResolveProtocol defines model for TcpRequestRule.ResolveProtocol.
type TcpRequestRuleResolveProtocol string

// TcpRequestRuleType defines model for TcpRequestRule.Type.
type TcpRequestRuleType string

// TcpRequestRules HAProxy TCP request rules array (corresponds to tcp-request directive)
type TcpRequestRules = []TcpRequestRule

// TcpResponseRule HAProxy TCP Response Rule configuration (corresponds to tcp-response)
type TcpResponseRule struct {
	Action               *TcpResponseRuleAction             `json:"action,omitempty"`
	BandwidthLimitLimit  *string                            `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                            `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                            `json:"bandwidth_limit_period,omitempty"`
	Cond                 *TcpResponseRuleCond               `json:"cond,omitempty"`
	CondTest             *string                            `json:"cond_test,omitempty"`
	Expr                 *string                            `json:"expr,omitempty"`
	LogLevel             *TcpResponseRuleLogLevel           `json:"log_level,omitempty"`
	LuaAction            *string                            `json:"lua_action,omitempty"`
	LuaParams            *string                            `json:"lua_params,omitempty"`
	MarkValue            *string                            `json:"mark_value,omitempty"`
	Metadata             *map[string]map[string]interface{} `json:"metadata,omitempty"`
	NiceValue            *int                               `json:"nice_value,omitempty"`
	RstTtl               *int                               `json:"rst_ttl,omitempty"`
	ScExpr               *string                            `json:"sc_expr,omitempty"`
	ScId                 *int                               `json:"sc_id,omitempty"`
	ScIdx                *int                               `json:"sc_idx,omitempty"`
	ScInt                *int                               `json:"sc_int"`
	SpoeEngine           *string                            `json:"spoe_engine,omitempty"`
	SpoeGroup            *string                            `json:"spoe_group,omitempty"`
	Timeout              *int                               `json:"timeout"`
	TosValue             *string                            `json:"tos_value,omitempty"`
	Type                 TcpResponseRuleType                `json:"type"`
	VarFormat            *string                            `json:"var_format,omitempty"`
	VarName              *string                            `json:"var_name,omitempty"`
	VarScope             *string                            `json:"var_scope,omitempty"`
}

// TcpResponseRuleAction defines model for TcpResponseRule.Action.
type TcpResponseRuleAction string

// TcpResponseRuleCond defines model for TcpResponseRule.Cond.
type TcpResponseRuleCond string

// TcpResponseRuleLogLevel defines model for TcpResponseRule.LogLevel.
type TcpResponseRuleLogLevel string

// TcpResponseRuleType defines model for TcpResponseRule.Type.
type TcpResponseRuleType string

// TcpResponseRules HAProxy TCP response rules array (corresponds to tcp-response directive)
type TcpResponseRules = []TcpResponseRule

// TraceEntries list of entries in a traces section
type TraceEntries = []TraceEntry

// TraceEntry Configure a trace event
type TraceEntry struct {
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`

	// Trace Trace parameters
	Trace string `json:"trace"`
}

// Traces Trace events configuration
type Traces struct {
	// Entries list of entries in a traces section
	Entries  *TraceEntries                      `json:"entries,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
}

// Transaction HAProxy configuration transaction
type Transaction struct {
	UnderscoreVersion *int               `json:"_version,omitempty"`
	Id                *string            `json:"id,omitempty"`
	Status            *TransactionStatus `json:"status,omitempty"`
}

// TransactionStatus defines model for Transaction.Status.
type TransactionStatus string

// Transactions Configuration transactions array
type Transactions = []Transaction

// TuneBufferOptions defines model for tune_buffer_options.
type TuneBufferOptions struct {
	BuffersLimit   *int `json:"buffers_limit"`
	BuffersReserve *int `json:"buffers_reserve,omitempty"`
	Bufsize        *int `json:"bufsize,omitempty"`
	BufsizeSmall   *int `json:"bufsize_small"`
	Pipesize       *int `json:"pipesize,omitempty"`
	RcvbufBackend  *int `json:"rcvbuf_backend"`
	RcvbufClient   *int `json:"rcvbuf_client"`
	RcvbufFrontend *int `json:"rcvbuf_frontend"`
	RcvbufServer   *int `json:"rcvbuf_server"`
	RecvEnough     *int `json:"recv_enough,omitempty"`
	SndbufBackend  *int `json:"sndbuf_backend"`
	SndbufClient   *int `json:"sndbuf_client"`
	SndbufFrontend *int `json:"sndbuf_frontend"`
	SndbufServer   *int `json:"sndbuf_server"`
}

// TuneLuaOptions defines model for tune_lua_options.
type TuneLuaOptions struct {
	BoolSampleConversion *TuneLuaOptionsBoolSampleConversion `json:"bool_sample_conversion,omitempty"`
	BurstTimeout         *int                                `json:"burst_timeout"`
	ForcedYield          *int                                `json:"forced_yield,omitempty"`
	LogLoggers           *TuneLuaOptionsLogLoggers           `json:"log_loggers,omitempty"`
	LogStderr            *TuneLuaOptionsLogStderr            `json:"log_stderr,omitempty"`
	Maxmem               *int                                `json:"maxmem"`
	ServiceTimeout       *int                                `json:"service_timeout"`
	SessionTimeout       *int                                `json:"session_timeout"`
	TaskTimeout          *int                                `json:"task_timeout"`
}

// TuneLuaOptionsBoolSampleConversion defines model for TuneLuaOptions.BoolSampleConversion.
type TuneLuaOptionsBoolSampleConversion string

// TuneLuaOptionsLogLoggers defines model for TuneLuaOptions.LogLoggers.
type TuneLuaOptionsLogLoggers string

// TuneLuaOptionsLogStderr defines model for TuneLuaOptions.LogStderr.
type TuneLuaOptionsLogStderr string

// TuneOptions defines model for tune_options.
type TuneOptions struct {
	AppletZeroCopyForwarding   *TuneOptionsAppletZeroCopyForwarding   `json:"applet_zero_copy_forwarding,omitempty"`
	CompMaxlevel               *int                                   `json:"comp_maxlevel,omitempty"`
	DisableFastForward         *bool                                  `json:"disable_fast_forward,omitempty"`
	DisableZeroCopyForwarding  *bool                                  `json:"disable_zero_copy_forwarding,omitempty"`
	EpollMaskEvents            *[]TuneOptionsEpollMaskEvents          `json:"epoll_mask_events,omitempty"`
	EventsMaxEventsAtOnce      *int                                   `json:"events_max_events_at_once,omitempty"`
	FailAlloc                  *bool                                  `json:"fail_alloc,omitempty"`
	FdEdgeTriggered            *TuneOptionsFdEdgeTriggered            `json:"fd_edge_triggered,omitempty"`
	GlitchesKillCpuUsage       *int                                   `json:"glitches_kill_cpu_usage"`
	H1ZeroCopyFwdRecv          *TuneOptionsH1ZeroCopyFwdRecv          `json:"h1_zero_copy_fwd_recv,omitempty"`
	H1ZeroCopyFwdSend          *TuneOptionsH1ZeroCopyFwdSend          `json:"h1_zero_copy_fwd_send,omitempty"`
	H2BeGlitchesThreshold      *int                                   `json:"h2_be_glitches_threshold"`
	H2BeInitialWindowSize      *int                                   `json:"h2_be_initial_window_size,omitempty"`
	H2BeMaxConcurrentStreams   *int                                   `json:"h2_be_max_concurrent_streams,omitempty"`
	H2BeRxbuf                  *int                                   `json:"h2_be_rxbuf"`
	H2FeGlitchesThreshold      *int                                   `json:"h2_fe_glitches_threshold"`
	H2FeInitialWindowSize      *int                                   `json:"h2_fe_initial_window_size,omitempty"`
	H2FeMaxConcurrentStreams   *int                                   `json:"h2_fe_max_concurrent_streams,omitempty"`
	H2FeMaxTotalStreams        *int                                   `json:"h2_fe_max_total_streams"`
	H2FeRxbuf                  *int                                   `json:"h2_fe_rxbuf"`
	H2HeaderTableSize          *int                                   `json:"h2_header_table_size,omitempty"`
	H2InitialWindowSize        *int                                   `json:"h2_initial_window_size"`
	H2MaxConcurrentStreams     *int                                   `json:"h2_max_concurrent_streams,omitempty"`
	H2MaxFrameSize             *int                                   `json:"h2_max_frame_size,omitempty"`
	H2ZeroCopyFwdSend          *TuneOptionsH2ZeroCopyFwdSend          `json:"h2_zero_copy_fwd_send,omitempty"`
	HttpCookielen              *int                                   `json:"http_cookielen,omitempty"`
	HttpLogurilen              *int                                   `json:"http_logurilen,omitempty"`
	HttpMaxhdr                 *int                                   `json:"http_maxhdr,omitempty"`
	IdlePoolShared             *TuneOptionsIdlePoolShared             `json:"idle_pool_shared,omitempty"`
	Idletimer                  *int                                   `json:"idletimer"`
	ListenerDefaultShards      *TuneOptionsListenerDefaultShards      `json:"listener_default_shards,omitempty"`
	ListenerMultiQueue         *TuneOptionsListenerMultiQueue         `json:"listener_multi_queue,omitempty"`
	MaxChecksPerThread         *int                                   `json:"max_checks_per_thread"`
	MaxRulesAtOnce             *int                                   `json:"max_rules_at_once"`
	Maxaccept                  *int                                   `json:"maxaccept,omitempty"`
	Maxpollevents              *int                                   `json:"maxpollevents,omitempty"`
	Maxrewrite                 *int                                   `json:"maxrewrite,omitempty"`
	MemoryHotSize              *int                                   `json:"memory_hot_size"`
	NotsentLowatClient         *int                                   `json:"notsent_lowat_client"`
	NotsentLowatServer         *int                                   `json:"notsent_lowat_server"`
	PatternCacheSize           *int                                   `json:"pattern_cache_size"`
	PeersMaxUpdatesAtOnce      *int                                   `json:"peers_max_updates_at_once,omitempty"`
	PoolHighFdRatio            *int                                   `json:"pool_high_fd_ratio,omitempty"`
	PoolLowFdRatio             *int                                   `json:"pool_low_fd_ratio,omitempty"`
	PtZeroCopyForwarding       *TuneOptionsPtZeroCopyForwarding       `json:"pt_zero_copy_forwarding,omitempty"`
	ReniceRuntime              *int                                   `json:"renice_runtime"`
	ReniceStartup              *int                                   `json:"renice_startup"`
	RingQueues                 *int                                   `json:"ring_queues"`
	RunqueueDepth              *int                                   `json:"runqueue_depth,omitempty"`
	SchedLowLatency            *TuneOptionsSchedLowLatency            `json:"sched_low_latency,omitempty"`
	StickCounters              *int                                   `json:"stick_counters"`
	TakeoverOtherTgConnections *TuneOptionsTakeoverOtherTgConnections `json:"takeover_other_tg_connections,omitempty"`
}

// TuneOptionsAppletZeroCopyForwarding defines model for TuneOptions.AppletZeroCopyForwarding.
type TuneOptionsAppletZeroCopyForwarding string

// TuneOptionsEpollMaskEvents defines model for TuneOptions.EpollMaskEvents.
type TuneOptionsEpollMaskEvents string

// TuneOptionsFdEdgeTriggered defines model for TuneOptions.FdEdgeTriggered.
type TuneOptionsFdEdgeTriggered string

// TuneOptionsH1ZeroCopyFwdRecv defines model for TuneOptions.H1ZeroCopyFwdRecv.
type TuneOptionsH1ZeroCopyFwdRecv string

// TuneOptionsH1ZeroCopyFwdSend defines model for TuneOptions.H1ZeroCopyFwdSend.
type TuneOptionsH1ZeroCopyFwdSend string

// TuneOptionsH2ZeroCopyFwdSend defines model for TuneOptions.H2ZeroCopyFwdSend.
type TuneOptionsH2ZeroCopyFwdSend string

// TuneOptionsIdlePoolShared defines model for TuneOptions.IdlePoolShared.
type TuneOptionsIdlePoolShared string

// TuneOptionsListenerDefaultShards defines model for TuneOptions.ListenerDefaultShards.
type TuneOptionsListenerDefaultShards string

// TuneOptionsListenerMultiQueue defines model for TuneOptions.ListenerMultiQueue.
type TuneOptionsListenerMultiQueue string

// TuneOptionsPtZeroCopyForwarding defines model for TuneOptions.PtZeroCopyForwarding.
type TuneOptionsPtZeroCopyForwarding string

// TuneOptionsSchedLowLatency defines model for TuneOptions.SchedLowLatency.
type TuneOptionsSchedLowLatency string

// TuneOptionsTakeoverOtherTgConnections defines model for TuneOptions.TakeoverOtherTgConnections.
type TuneOptionsTakeoverOtherTgConnections string

// TuneQuicOptions defines model for tune_quic_options.
type TuneQuicOptions struct {
	FrontendConnTxBuffersLimit *int                            `json:"frontend_conn_tx_buffers_limit"`
	FrontendMaxIdleTimeout     *int                            `json:"frontend_max_idle_timeout"`
	FrontendMaxStreamsBidi     *int                            `json:"frontend_max_streams_bidi"`
	FrontendMaxTxMemory        *int                            `json:"frontend_max_tx_memory"`
	MaxFrameLoss               *int                            `json:"max_frame_loss"`
	ReorderRatio               *int                            `json:"reorder_ratio"`
	RetryThreshold             *int                            `json:"retry_threshold"`
	SocketOwner                *TuneQuicOptionsSocketOwner     `json:"socket_owner,omitempty"`
	ZeroCopyFwdSend            *TuneQuicOptionsZeroCopyFwdSend `json:"zero_copy_fwd_send,omitempty"`
}

// TuneQuicOptionsSocketOwner defines model for TuneQuicOptions.SocketOwner.
type TuneQuicOptionsSocketOwner string

// TuneQuicOptionsZeroCopyFwdSend defines model for TuneQuicOptions.ZeroCopyFwdSend.
type TuneQuicOptionsZeroCopyFwdSend string

// TuneSslOptions defines model for tune_ssl_options.
type TuneSslOptions struct {
	Cachesize          *int                  `json:"cachesize"`
	CaptureBufferSize  *int                  `json:"capture_buffer_size"`
	CtxCacheSize       *int                  `json:"ctx_cache_size,omitempty"`
	DefaultDhParam     *int                  `json:"default_dh_param,omitempty"`
	ForcePrivateCache  *bool                 `json:"force_private_cache,omitempty"`
	Keylog             *TuneSslOptionsKeylog `json:"keylog,omitempty"`
	Lifetime           *int                  `json:"lifetime"`
	Maxrecord          *int                  `json:"maxrecord"`
	OcspUpdateMaxDelay *int                  `json:"ocsp_update_max_delay"`
	OcspUpdateMinDelay *int                  `json:"ocsp_update_min_delay"`
}

// TuneSslOptionsKeylog defines model for TuneSslOptions.Keylog.
type TuneSslOptionsKeylog string

// TuneVarsOptions defines model for tune_vars_options.
type TuneVarsOptions struct {
	GlobalMaxSize *int `json:"global_max_size"`
	ProcMaxSize   *int `json:"proc_max_size"`
	ReqresMaxSize *int `json:"reqres_max_size"`
	SessMaxSize   *int `json:"sess_max_size"`
	TxnMaxSize    *int `json:"txn_max_size"`
}

// TuneZlibOptions defines model for tune_zlib_options.
type TuneZlibOptions struct {
	Memlevel   *int `json:"memlevel,omitempty"`
	Windowsize *int `json:"windowsize,omitempty"`
}

// User HAProxy userlist user
type User struct {
	Groups         *string                            `json:"groups,omitempty"`
	Metadata       *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Password       string                             `json:"password"`
	SecurePassword bool                               `json:"secure_password"`
	Username       string                             `json:"username"`
}

// Userlist defines model for userlist.
type Userlist struct {
	Groups   *map[string]Group                  `json:"groups,omitempty"`
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`
	Users    *map[string]User                   `json:"users,omitempty"`
}

// UserlistBase HAProxy configuration of access control
type UserlistBase struct {
	Metadata *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Name     string                             `json:"name"`
}

// Userlists HAProxy userlists array
type Userlists = []Userlist

// Users HAProxy userlist users array
type Users = []User

// WurflOptions defines model for wurfl_options.
type WurflOptions struct {
	CacheSize                *int    `json:"cache_size,omitempty"`
	DataFile                 *string `json:"data_file,omitempty"`
	InformationList          *string `json:"information_list,omitempty"`
	InformationListSeparator *string `json:"information_list_separator,omitempty"`
	PatchFile                *string `json:"patch_file,omitempty"`
}

// ForceReload defines model for force_reload.
type ForceReload = bool

// FullSection defines model for full_section.
type FullSection = bool

// ParentName defines model for parent_name.
type ParentName = string

// SkipReload defines model for skip_reload.
type SkipReload = bool

// TransactionId defines model for transaction_id.
type TransactionId = string

// Version defines model for version.
type Version = int

// AlreadyExists API Error
type AlreadyExists = Error

// BadRequest API Error
type BadRequest = Error

// DefaultError API Error
type DefaultError = Error

// NotAcceptable API Error
type NotAcceptable = Error

// NotFound API Error
type NotFound = Error

// DeleteClusterParams defines parameters for DeleteCluster.
type DeleteClusterParams struct {
	// Configuration In case of moving to single mode do we keep or clean configuration
	Configuration *DeleteClusterParamsConfiguration `form:"configuration,omitempty" json:"configuration,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteClusterParamsConfiguration defines parameters for DeleteCluster.
type DeleteClusterParamsConfiguration string

// PostClusterParams defines parameters for PostCluster.
type PostClusterParams struct {
	// Configuration In case of moving to single mode do we keep or clean configuration
	Configuration *PostClusterParamsConfiguration `form:"configuration,omitempty" json:"configuration,omitempty"`

	// AdvertisedAddress Force the advertised address when joining a cluster
	AdvertisedAddress *string `form:"advertised_address,omitempty" json:"advertised_address,omitempty"`

	// AdvertisedPort Force the advertised port when joining a cluster
	AdvertisedPort *int `form:"advertised_port,omitempty" json:"advertised_port,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// PostClusterParamsConfiguration defines parameters for PostCluster.
type PostClusterParamsConfiguration string

// EditClusterParams defines parameters for EditCluster.
type EditClusterParams struct {
	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAcmeProvidersParams defines parameters for GetAcmeProviders.
type GetAcmeProvidersParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAcmeProviderParams defines parameters for CreateAcmeProvider.
type CreateAcmeProviderParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAcmeProviderParams defines parameters for DeleteAcmeProvider.
type DeleteAcmeProviderParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAcmeProviderParams defines parameters for GetAcmeProvider.
type GetAcmeProviderParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// EditAcmeProviderParams defines parameters for EditAcmeProvider.
type EditAcmeProviderParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendsParams defines parameters for GetBackends.
type GetBackendsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateBackendParams defines parameters for CreateBackend.
type CreateBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteBackendParams defines parameters for DeleteBackend.
type DeleteBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendParams defines parameters for GetBackend.
type GetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceBackendParams defines parameters for ReplaceBackend.
type ReplaceBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclBackendParams defines parameters for GetAllAclBackend.
type GetAllAclBackendParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclBackendParams defines parameters for ReplaceAllAclBackend.
type ReplaceAllAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclBackendParams defines parameters for DeleteAclBackend.
type DeleteAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclBackendParams defines parameters for GetAclBackend.
type GetAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclBackendParams defines parameters for CreateAclBackend.
type CreateAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclBackendParams defines parameters for ReplaceAclBackend.
type ReplaceAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllFilterBackendParams defines parameters for GetAllFilterBackend.
type GetAllFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllFilterBackendParams defines parameters for ReplaceAllFilterBackend.
type ReplaceAllFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteFilterBackendParams defines parameters for DeleteFilterBackend.
type DeleteFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFilterBackendParams defines parameters for GetFilterBackend.
type GetFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateFilterBackendParams defines parameters for CreateFilterBackend.
type CreateFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceFilterBackendParams defines parameters for ReplaceFilterBackend.
type ReplaceFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPAfterResponseRuleBackendParams defines parameters for GetAllHTTPAfterResponseRuleBackend.
type GetAllHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPAfterResponseRuleBackendParams defines parameters for ReplaceAllHTTPAfterResponseRuleBackend.
type ReplaceAllHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPAfterResponseRuleBackendParams defines parameters for DeleteHTTPAfterResponseRuleBackend.
type DeleteHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPAfterResponseRuleBackendParams defines parameters for GetHTTPAfterResponseRuleBackend.
type GetHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPAfterResponseRuleBackendParams defines parameters for CreateHTTPAfterResponseRuleBackend.
type CreateHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPAfterResponseRuleBackendParams defines parameters for ReplaceHTTPAfterResponseRuleBackend.
type ReplaceHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPCheckBackendParams defines parameters for GetAllHTTPCheckBackend.
type GetAllHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPCheckBackendParams defines parameters for ReplaceAllHTTPCheckBackend.
type ReplaceAllHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPCheckBackendParams defines parameters for DeleteHTTPCheckBackend.
type DeleteHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPCheckBackendParams defines parameters for GetHTTPCheckBackend.
type GetHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPCheckBackendParams defines parameters for CreateHTTPCheckBackend.
type CreateHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPCheckBackendParams defines parameters for ReplaceHTTPCheckBackend.
type ReplaceHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPErrorRuleBackendParams defines parameters for GetAllHTTPErrorRuleBackend.
type GetAllHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPErrorRuleBackendParams defines parameters for ReplaceAllHTTPErrorRuleBackend.
type ReplaceAllHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorRuleBackendParams defines parameters for DeleteHTTPErrorRuleBackend.
type DeleteHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorRuleBackendParams defines parameters for GetHTTPErrorRuleBackend.
type GetHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorRuleBackendParams defines parameters for CreateHTTPErrorRuleBackend.
type CreateHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPErrorRuleBackendParams defines parameters for ReplaceHTTPErrorRuleBackend.
type ReplaceHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPRequestRuleBackendParams defines parameters for GetAllHTTPRequestRuleBackend.
type GetAllHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPRequestRuleBackendParams defines parameters for ReplaceAllHTTPRequestRuleBackend.
type ReplaceAllHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPRequestRuleBackendParams defines parameters for DeleteHTTPRequestRuleBackend.
type DeleteHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPRequestRuleBackendParams defines parameters for GetHTTPRequestRuleBackend.
type GetHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPRequestRuleBackendParams defines parameters for CreateHTTPRequestRuleBackend.
type CreateHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPRequestRuleBackendParams defines parameters for ReplaceHTTPRequestRuleBackend.
type ReplaceHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPResponseRuleBackendParams defines parameters for GetAllHTTPResponseRuleBackend.
type GetAllHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPResponseRuleBackendParams defines parameters for ReplaceAllHTTPResponseRuleBackend.
type ReplaceAllHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPResponseRuleBackendParams defines parameters for DeleteHTTPResponseRuleBackend.
type DeleteHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPResponseRuleBackendParams defines parameters for GetHTTPResponseRuleBackend.
type GetHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPResponseRuleBackendParams defines parameters for CreateHTTPResponseRuleBackend.
type CreateHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPResponseRuleBackendParams defines parameters for ReplaceHTTPResponseRuleBackend.
type ReplaceHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetBackendParams defines parameters for GetAllLogTargetBackend.
type GetAllLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetBackendParams defines parameters for ReplaceAllLogTargetBackend.
type ReplaceAllLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetBackendParams defines parameters for DeleteLogTargetBackend.
type DeleteLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetBackendParams defines parameters for GetLogTargetBackend.
type GetLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetBackendParams defines parameters for CreateLogTargetBackend.
type CreateLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetBackendParams defines parameters for ReplaceLogTargetBackend.
type ReplaceLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerSwitchingRulesParams defines parameters for GetServerSwitchingRules.
type GetServerSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerSwitchingRulesParams defines parameters for ReplaceServerSwitchingRules.
type ReplaceServerSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerSwitchingRuleParams defines parameters for DeleteServerSwitchingRule.
type DeleteServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerSwitchingRuleParams defines parameters for GetServerSwitchingRule.
type GetServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerSwitchingRuleParams defines parameters for CreateServerSwitchingRule.
type CreateServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceServerSwitchingRuleParams defines parameters for ReplaceServerSwitchingRule.
type ReplaceServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerTemplatesParams defines parameters for GetServerTemplates.
type GetServerTemplatesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerTemplateParams defines parameters for CreateServerTemplate.
type CreateServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerTemplateParams defines parameters for DeleteServerTemplate.
type DeleteServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerTemplateParams defines parameters for GetServerTemplate.
type GetServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerTemplateParams defines parameters for ReplaceServerTemplate.
type ReplaceServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllServerBackendParams defines parameters for GetAllServerBackend.
type GetAllServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerBackendParams defines parameters for CreateServerBackend.
type CreateServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerBackendParams defines parameters for DeleteServerBackend.
type DeleteServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerBackendParams defines parameters for GetServerBackend.
type GetServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerBackendParams defines parameters for ReplaceServerBackend.
type ReplaceServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetStickRulesParams defines parameters for GetStickRules.
type GetStickRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceStickRulesParams defines parameters for ReplaceStickRules.
type ReplaceStickRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteStickRuleParams defines parameters for DeleteStickRule.
type DeleteStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetStickRuleParams defines parameters for GetStickRule.
type GetStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateStickRuleParams defines parameters for CreateStickRule.
type CreateStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceStickRuleParams defines parameters for ReplaceStickRule.
type ReplaceStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPCheckBackendParams defines parameters for GetAllTCPCheckBackend.
type GetAllTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPCheckBackendParams defines parameters for ReplaceAllTCPCheckBackend.
type ReplaceAllTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPCheckBackendParams defines parameters for DeleteTCPCheckBackend.
type DeleteTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPCheckBackendParams defines parameters for GetTCPCheckBackend.
type GetTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPCheckBackendParams defines parameters for CreateTCPCheckBackend.
type CreateTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPCheckBackendParams defines parameters for ReplaceTCPCheckBackend.
type ReplaceTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPRequestRuleBackendParams defines parameters for GetAllTCPRequestRuleBackend.
type GetAllTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPRequestRuleBackendParams defines parameters for ReplaceAllTCPRequestRuleBackend.
type ReplaceAllTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPRequestRuleBackendParams defines parameters for DeleteTCPRequestRuleBackend.
type DeleteTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPRequestRuleBackendParams defines parameters for GetTCPRequestRuleBackend.
type GetTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPRequestRuleBackendParams defines parameters for CreateTCPRequestRuleBackend.
type CreateTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPRequestRuleBackendParams defines parameters for ReplaceTCPRequestRuleBackend.
type ReplaceTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPResponseRuleBackendParams defines parameters for GetAllTCPResponseRuleBackend.
type GetAllTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPResponseRuleBackendParams defines parameters for ReplaceAllTCPResponseRuleBackend.
type ReplaceAllTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPResponseRuleBackendParams defines parameters for DeleteTCPResponseRuleBackend.
type DeleteTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPResponseRuleBackendParams defines parameters for GetTCPResponseRuleBackend.
type GetTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPResponseRuleBackendParams defines parameters for CreateTCPResponseRuleBackend.
type CreateTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPResponseRuleBackendParams defines parameters for ReplaceTCPResponseRuleBackend.
type ReplaceTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCachesParams defines parameters for GetCaches.
type GetCachesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateCacheParams defines parameters for CreateCache.
type CreateCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteCacheParams defines parameters for DeleteCache.
type DeleteCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCacheParams defines parameters for GetCache.
type GetCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceCacheParams defines parameters for ReplaceCache.
type ReplaceCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtLoadsParams defines parameters for GetCrtLoads.
type GetCrtLoadsParams struct {
	// CrtStore Parent crt_store name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateCrtLoadParams defines parameters for CreateCrtLoad.
type CreateCrtLoadParams struct {
	// CrtStore Parent crt_store section name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteCrtLoadParams defines parameters for DeleteCrtLoad.
type DeleteCrtLoadParams struct {
	// CrtStore Parent crt_store section name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtLoadParams defines parameters for GetCrtLoad.
type GetCrtLoadParams struct {
	// CrtStore Parent crt_store name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceCrtLoadParams defines parameters for ReplaceCrtLoad.
type ReplaceCrtLoadParams struct {
	// CrtStore Parent crt_store section name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtStoresParams defines parameters for GetCrtStores.
type GetCrtStoresParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateCrtStoreParams defines parameters for CreateCrtStore.
type CreateCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteCrtStoreParams defines parameters for DeleteCrtStore.
type DeleteCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtStoreParams defines parameters for GetCrtStore.
type GetCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// EditCrtStoreParams defines parameters for EditCrtStore.
type EditCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDefaultsSectionsParams defines parameters for GetDefaultsSections.
type GetDefaultsSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// AddDefaultsSectionParams defines parameters for AddDefaultsSection.
type AddDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateDefaultsSectionParams defines parameters for CreateDefaultsSection.
type CreateDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteDefaultsSectionParams defines parameters for DeleteDefaultsSection.
type DeleteDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetDefaultsSectionParams defines parameters for GetDefaultsSection.
type GetDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceDefaultsSectionParams defines parameters for ReplaceDefaultsSection.
type ReplaceDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclDefaultsParams defines parameters for GetAllAclDefaults.
type GetAllAclDefaultsParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclDefaultsParams defines parameters for ReplaceAllAclDefaults.
type ReplaceAllAclDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclDefaultsParams defines parameters for DeleteAclDefaults.
type DeleteAclDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclDefaultsParams defines parameters for GetAclDefaults.
type GetAclDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclDefaultsParams defines parameters for CreateAclDefaults.
type CreateAclDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclDefaultsParams defines parameters for ReplaceAclDefaults.
type ReplaceAclDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPAfterResponseRuleDefaultsParams defines parameters for GetAllHTTPAfterResponseRuleDefaults.
type GetAllHTTPAfterResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPAfterResponseRuleDefaultsParams defines parameters for ReplaceAllHTTPAfterResponseRuleDefaults.
type ReplaceAllHTTPAfterResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPAfterResponseRuleDefaultsParams defines parameters for DeleteHTTPAfterResponseRuleDefaults.
type DeleteHTTPAfterResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPAfterResponseRuleDefaultsParams defines parameters for GetHTTPAfterResponseRuleDefaults.
type GetHTTPAfterResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPAfterResponseRuleDefaultsParams defines parameters for CreateHTTPAfterResponseRuleDefaults.
type CreateHTTPAfterResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPAfterResponseRuleDefaultsParams defines parameters for ReplaceHTTPAfterResponseRuleDefaults.
type ReplaceHTTPAfterResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPCheckDefaultsParams defines parameters for GetAllHTTPCheckDefaults.
type GetAllHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPCheckDefaultsParams defines parameters for ReplaceAllHTTPCheckDefaults.
type ReplaceAllHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPCheckDefaultsParams defines parameters for DeleteHTTPCheckDefaults.
type DeleteHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPCheckDefaultsParams defines parameters for GetHTTPCheckDefaults.
type GetHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPCheckDefaultsParams defines parameters for CreateHTTPCheckDefaults.
type CreateHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPCheckDefaultsParams defines parameters for ReplaceHTTPCheckDefaults.
type ReplaceHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPErrorRuleDefaultsParams defines parameters for GetAllHTTPErrorRuleDefaults.
type GetAllHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPErrorRuleDefaultsParams defines parameters for ReplaceAllHTTPErrorRuleDefaults.
type ReplaceAllHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorRuleDefaultsParams defines parameters for DeleteHTTPErrorRuleDefaults.
type DeleteHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorRuleDefaultsParams defines parameters for GetHTTPErrorRuleDefaults.
type GetHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorRuleDefaultsParams defines parameters for CreateHTTPErrorRuleDefaults.
type CreateHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPErrorRuleDefaultsParams defines parameters for ReplaceHTTPErrorRuleDefaults.
type ReplaceHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPRequestRuleDefaultsParams defines parameters for GetAllHTTPRequestRuleDefaults.
type GetAllHTTPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPRequestRuleDefaultsParams defines parameters for ReplaceAllHTTPRequestRuleDefaults.
type ReplaceAllHTTPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPRequestRuleDefaultsParams defines parameters for DeleteHTTPRequestRuleDefaults.
type DeleteHTTPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPRequestRuleDefaultsParams defines parameters for GetHTTPRequestRuleDefaults.
type GetHTTPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPRequestRuleDefaultsParams defines parameters for CreateHTTPRequestRuleDefaults.
type CreateHTTPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPRequestRuleDefaultsParams defines parameters for ReplaceHTTPRequestRuleDefaults.
type ReplaceHTTPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPResponseRuleDefaultsParams defines parameters for GetAllHTTPResponseRuleDefaults.
type GetAllHTTPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPResponseRuleDefaultsParams defines parameters for ReplaceAllHTTPResponseRuleDefaults.
type ReplaceAllHTTPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPResponseRuleDefaultsParams defines parameters for DeleteHTTPResponseRuleDefaults.
type DeleteHTTPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPResponseRuleDefaultsParams defines parameters for GetHTTPResponseRuleDefaults.
type GetHTTPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPResponseRuleDefaultsParams defines parameters for CreateHTTPResponseRuleDefaults.
type CreateHTTPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPResponseRuleDefaultsParams defines parameters for ReplaceHTTPResponseRuleDefaults.
type ReplaceHTTPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetDefaultsParams defines parameters for GetAllLogTargetDefaults.
type GetAllLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetDefaultsParams defines parameters for ReplaceAllLogTargetDefaults.
type ReplaceAllLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetDefaultsParams defines parameters for DeleteLogTargetDefaults.
type DeleteLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetDefaultsParams defines parameters for GetLogTargetDefaults.
type GetLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetDefaultsParams defines parameters for CreateLogTargetDefaults.
type CreateLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetDefaultsParams defines parameters for ReplaceLogTargetDefaults.
type ReplaceLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllQUICInitialRuleDefaultsParams defines parameters for GetAllQUICInitialRuleDefaults.
type GetAllQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllQUICInitialRuleDefaultsParams defines parameters for ReplaceAllQUICInitialRuleDefaults.
type ReplaceAllQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteQUICInitialRuleDefaultsParams defines parameters for DeleteQUICInitialRuleDefaults.
type DeleteQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetQUICInitialRuleDefaultsParams defines parameters for GetQUICInitialRuleDefaults.
type GetQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateQUICInitialRuleDefaultsParams defines parameters for CreateQUICInitialRuleDefaults.
type CreateQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceQUICInitialRuleDefaultsParams defines parameters for ReplaceQUICInitialRuleDefaults.
type ReplaceQUICInitialRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPCheckDefaultsParams defines parameters for GetAllTCPCheckDefaults.
type GetAllTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPCheckDefaultsParams defines parameters for ReplaceAllTCPCheckDefaults.
type ReplaceAllTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPCheckDefaultsParams defines parameters for DeleteTCPCheckDefaults.
type DeleteTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPCheckDefaultsParams defines parameters for GetTCPCheckDefaults.
type GetTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPCheckDefaultsParams defines parameters for CreateTCPCheckDefaults.
type CreateTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPCheckDefaultsParams defines parameters for ReplaceTCPCheckDefaults.
type ReplaceTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPRequestRuleDefaultsParams defines parameters for GetAllTCPRequestRuleDefaults.
type GetAllTCPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPRequestRuleDefaultsParams defines parameters for ReplaceAllTCPRequestRuleDefaults.
type ReplaceAllTCPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPRequestRuleDefaultsParams defines parameters for DeleteTCPRequestRuleDefaults.
type DeleteTCPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPRequestRuleDefaultsParams defines parameters for GetTCPRequestRuleDefaults.
type GetTCPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPRequestRuleDefaultsParams defines parameters for CreateTCPRequestRuleDefaults.
type CreateTCPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPRequestRuleDefaultsParams defines parameters for ReplaceTCPRequestRuleDefaults.
type ReplaceTCPRequestRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPResponseRuleDefaultsParams defines parameters for GetAllTCPResponseRuleDefaults.
type GetAllTCPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPResponseRuleDefaultsParams defines parameters for ReplaceAllTCPResponseRuleDefaults.
type ReplaceAllTCPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPResponseRuleDefaultsParams defines parameters for DeleteTCPResponseRuleDefaults.
type DeleteTCPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPResponseRuleDefaultsParams defines parameters for GetTCPResponseRuleDefaults.
type GetTCPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPResponseRuleDefaultsParams defines parameters for CreateTCPResponseRuleDefaults.
type CreateTCPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPResponseRuleDefaultsParams defines parameters for ReplaceTCPResponseRuleDefaults.
type ReplaceTCPResponseRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFCGIAppsParams defines parameters for GetFCGIApps.
type GetFCGIAppsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateFCGIAppParams defines parameters for CreateFCGIApp.
type CreateFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteFCGIAppParams defines parameters for DeleteFCGIApp.
type DeleteFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFCGIAppParams defines parameters for GetFCGIApp.
type GetFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceFCGIAppParams defines parameters for ReplaceFCGIApp.
type ReplaceFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclFCGIAppParams defines parameters for GetAllAclFCGIApp.
type GetAllAclFCGIAppParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclFCGIAppParams defines parameters for ReplaceAllAclFCGIApp.
type ReplaceAllAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclFCGIAppParams defines parameters for DeleteAclFCGIApp.
type DeleteAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclFCGIAppParams defines parameters for GetAclFCGIApp.
type GetAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclFCGIAppParams defines parameters for CreateAclFCGIApp.
type CreateAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclFCGIAppParams defines parameters for ReplaceAclFCGIApp.
type ReplaceAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFrontendsParams defines parameters for GetFrontends.
type GetFrontendsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateFrontendParams defines parameters for CreateFrontend.
type CreateFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteFrontendParams defines parameters for DeleteFrontend.
type DeleteFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFrontendParams defines parameters for GetFrontend.
type GetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceFrontendParams defines parameters for ReplaceFrontend.
type ReplaceFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclFrontendParams defines parameters for GetAllAclFrontend.
type GetAllAclFrontendParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclFrontendParams defines parameters for ReplaceAllAclFrontend.
type ReplaceAllAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclFrontendParams defines parameters for DeleteAclFrontend.
type DeleteAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclFrontendParams defines parameters for GetAclFrontend.
type GetAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclFrontendParams defines parameters for CreateAclFrontend.
type CreateAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclFrontendParams defines parameters for ReplaceAclFrontend.
type ReplaceAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendSwitchingRulesParams defines parameters for GetBackendSwitchingRules.
type GetBackendSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBackendSwitchingRulesParams defines parameters for ReplaceBackendSwitchingRules.
type ReplaceBackendSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBackendSwitchingRuleParams defines parameters for DeleteBackendSwitchingRule.
type DeleteBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendSwitchingRuleParams defines parameters for GetBackendSwitchingRule.
type GetBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBackendSwitchingRuleParams defines parameters for CreateBackendSwitchingRule.
type CreateBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceBackendSwitchingRuleParams defines parameters for ReplaceBackendSwitchingRule.
type ReplaceBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllBindFrontendParams defines parameters for GetAllBindFrontend.
type GetAllBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBindFrontendParams defines parameters for CreateBindFrontend.
type CreateBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBindFrontendParams defines parameters for DeleteBindFrontend.
type DeleteBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBindFrontendParams defines parameters for GetBindFrontend.
type GetBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBindFrontendParams defines parameters for ReplaceBindFrontend.
type ReplaceBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDeclareCapturesParams defines parameters for GetDeclareCaptures.
type GetDeclareCapturesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceDeclareCapturesParams defines parameters for ReplaceDeclareCaptures.
type ReplaceDeclareCapturesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteDeclareCaptureParams defines parameters for DeleteDeclareCapture.
type DeleteDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDeclareCaptureParams defines parameters for GetDeclareCapture.
type GetDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateDeclareCaptureParams defines parameters for CreateDeclareCapture.
type CreateDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceDeclareCaptureParams defines parameters for ReplaceDeclareCapture.
type ReplaceDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllFilterFrontendParams defines parameters for GetAllFilterFrontend.
type GetAllFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllFilterFrontendParams defines parameters for ReplaceAllFilterFrontend.
type ReplaceAllFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteFilterFrontendParams defines parameters for DeleteFilterFrontend.
type DeleteFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFilterFrontendParams defines parameters for GetFilterFrontend.
type GetFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateFilterFrontendParams defines parameters for CreateFilterFrontend.
type CreateFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceFilterFrontendParams defines parameters for ReplaceFilterFrontend.
type ReplaceFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPAfterResponseRuleFrontendParams defines parameters for GetAllHTTPAfterResponseRuleFrontend.
type GetAllHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPAfterResponseRuleFrontendParams defines parameters for ReplaceAllHTTPAfterResponseRuleFrontend.
type ReplaceAllHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPAfterResponseRuleFrontendParams defines parameters for DeleteHTTPAfterResponseRuleFrontend.
type DeleteHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPAfterResponseRuleFrontendParams defines parameters for GetHTTPAfterResponseRuleFrontend.
type GetHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPAfterResponseRuleFrontendParams defines parameters for CreateHTTPAfterResponseRuleFrontend.
type CreateHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPAfterResponseRuleFrontendParams defines parameters for ReplaceHTTPAfterResponseRuleFrontend.
type ReplaceHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPErrorRuleFrontendParams defines parameters for GetAllHTTPErrorRuleFrontend.
type GetAllHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPErrorRuleFrontendParams defines parameters for ReplaceAllHTTPErrorRuleFrontend.
type ReplaceAllHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorRuleFrontendParams defines parameters for DeleteHTTPErrorRuleFrontend.
type DeleteHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorRuleFrontendParams defines parameters for GetHTTPErrorRuleFrontend.
type GetHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorRuleFrontendParams defines parameters for CreateHTTPErrorRuleFrontend.
type CreateHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPErrorRuleFrontendParams defines parameters for ReplaceHTTPErrorRuleFrontend.
type ReplaceHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPRequestRuleFrontendParams defines parameters for GetAllHTTPRequestRuleFrontend.
type GetAllHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPRequestRuleFrontendParams defines parameters for ReplaceAllHTTPRequestRuleFrontend.
type ReplaceAllHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPRequestRuleFrontendParams defines parameters for DeleteHTTPRequestRuleFrontend.
type DeleteHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPRequestRuleFrontendParams defines parameters for GetHTTPRequestRuleFrontend.
type GetHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPRequestRuleFrontendParams defines parameters for CreateHTTPRequestRuleFrontend.
type CreateHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPRequestRuleFrontendParams defines parameters for ReplaceHTTPRequestRuleFrontend.
type ReplaceHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPResponseRuleFrontendParams defines parameters for GetAllHTTPResponseRuleFrontend.
type GetAllHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPResponseRuleFrontendParams defines parameters for ReplaceAllHTTPResponseRuleFrontend.
type ReplaceAllHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPResponseRuleFrontendParams defines parameters for DeleteHTTPResponseRuleFrontend.
type DeleteHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPResponseRuleFrontendParams defines parameters for GetHTTPResponseRuleFrontend.
type GetHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPResponseRuleFrontendParams defines parameters for CreateHTTPResponseRuleFrontend.
type CreateHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPResponseRuleFrontendParams defines parameters for ReplaceHTTPResponseRuleFrontend.
type ReplaceHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetFrontendParams defines parameters for GetAllLogTargetFrontend.
type GetAllLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetFrontendParams defines parameters for ReplaceAllLogTargetFrontend.
type ReplaceAllLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetFrontendParams defines parameters for DeleteLogTargetFrontend.
type DeleteLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetFrontendParams defines parameters for GetLogTargetFrontend.
type GetLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetFrontendParams defines parameters for CreateLogTargetFrontend.
type CreateLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetFrontendParams defines parameters for ReplaceLogTargetFrontend.
type ReplaceLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllQUICInitialRuleFrontendParams defines parameters for GetAllQUICInitialRuleFrontend.
type GetAllQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllQUICInitialRuleFrontendParams defines parameters for ReplaceAllQUICInitialRuleFrontend.
type ReplaceAllQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteQUICInitialRuleFrontendParams defines parameters for DeleteQUICInitialRuleFrontend.
type DeleteQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetQUICInitialRuleFrontendParams defines parameters for GetQUICInitialRuleFrontend.
type GetQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateQUICInitialRuleFrontendParams defines parameters for CreateQUICInitialRuleFrontend.
type CreateQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceQUICInitialRuleFrontendParams defines parameters for ReplaceQUICInitialRuleFrontend.
type ReplaceQUICInitialRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllSSLFrontUsesParams defines parameters for GetAllSSLFrontUses.
type GetAllSSLFrontUsesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSSLFrontUseParams defines parameters for CreateSSLFrontUse.
type CreateSSLFrontUseParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteSSLFrontUseParams defines parameters for DeleteSSLFrontUse.
type DeleteSSLFrontUseParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetSSLFrontUseParams defines parameters for GetSSLFrontUse.
type GetSSLFrontUseParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSSLFrontUseParams defines parameters for ReplaceSSLFrontUse.
type ReplaceSSLFrontUseParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPRequestRuleFrontendParams defines parameters for GetAllTCPRequestRuleFrontend.
type GetAllTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPRequestRuleFrontendParams defines parameters for ReplaceAllTCPRequestRuleFrontend.
type ReplaceAllTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPRequestRuleFrontendParams defines parameters for DeleteTCPRequestRuleFrontend.
type DeleteTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPRequestRuleFrontendParams defines parameters for GetTCPRequestRuleFrontend.
type GetTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPRequestRuleFrontendParams defines parameters for CreateTCPRequestRuleFrontend.
type CreateTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPRequestRuleFrontendParams defines parameters for ReplaceTCPRequestRuleFrontend.
type ReplaceTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetGlobalParams defines parameters for GetGlobal.
type GetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceGlobalParams defines parameters for ReplaceGlobal.
type ReplaceGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllLogTargetGlobalParams defines parameters for GetAllLogTargetGlobal.
type GetAllLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetGlobalParams defines parameters for ReplaceAllLogTargetGlobal.
type ReplaceAllLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetGlobalParams defines parameters for DeleteLogTargetGlobal.
type DeleteLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetGlobalParams defines parameters for GetLogTargetGlobal.
type GetLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetGlobalParams defines parameters for CreateLogTargetGlobal.
type CreateLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetGlobalParams defines parameters for ReplaceLogTargetGlobal.
type ReplaceLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateGroupParams defines parameters for CreateGroup.
type CreateGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteGroupParams defines parameters for DeleteGroup.
type DeleteGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetGroupParams defines parameters for GetGroup.
type GetGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceGroupParams defines parameters for ReplaceGroup.
type ReplaceGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorsSectionsParams defines parameters for GetHTTPErrorsSections.
type GetHTTPErrorsSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorsSectionParams defines parameters for CreateHTTPErrorsSection.
type CreateHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorsSectionParams defines parameters for DeleteHTTPErrorsSection.
type DeleteHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorsSectionParams defines parameters for GetHTTPErrorsSection.
type GetHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceHTTPErrorsSectionParams defines parameters for ReplaceHTTPErrorsSection.
type ReplaceHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogForwardsParams defines parameters for GetLogForwards.
type GetLogForwardsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateLogForwardParams defines parameters for CreateLogForward.
type CreateLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteLogForwardParams defines parameters for DeleteLogForward.
type DeleteLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogForwardParams defines parameters for GetLogForward.
type GetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceLogForwardParams defines parameters for ReplaceLogForward.
type ReplaceLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllBindLogForwardParams defines parameters for GetAllBindLogForward.
type GetAllBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBindLogForwardParams defines parameters for CreateBindLogForward.
type CreateBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBindLogForwardParams defines parameters for DeleteBindLogForward.
type DeleteBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBindLogForwardParams defines parameters for GetBindLogForward.
type GetBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBindLogForwardParams defines parameters for ReplaceBindLogForward.
type ReplaceBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDgramBindsParams defines parameters for GetDgramBinds.
type GetDgramBindsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateDgramBindParams defines parameters for CreateDgramBind.
type CreateDgramBindParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteDgramBindParams defines parameters for DeleteDgramBind.
type DeleteDgramBindParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDgramBindParams defines parameters for GetDgramBind.
type GetDgramBindParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceDgramBindParams defines parameters for ReplaceDgramBind.
type ReplaceDgramBindParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetLogForwardParams defines parameters for GetAllLogTargetLogForward.
type GetAllLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetLogForwardParams defines parameters for ReplaceAllLogTargetLogForward.
type ReplaceAllLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetLogForwardParams defines parameters for DeleteLogTargetLogForward.
type DeleteLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetLogForwardParams defines parameters for GetLogTargetLogForward.
type GetLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetLogForwardParams defines parameters for CreateLogTargetLogForward.
type CreateLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetLogForwardParams defines parameters for ReplaceLogTargetLogForward.
type ReplaceLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogProfilesParams defines parameters for GetLogProfiles.
type GetLogProfilesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogProfileParams defines parameters for CreateLogProfile.
type CreateLogProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogProfileParams defines parameters for DeleteLogProfile.
type DeleteLogProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogProfileParams defines parameters for GetLogProfile.
type GetLogProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// EditLogProfileParams defines parameters for EditLogProfile.
type EditLogProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailerEntriesParams defines parameters for GetMailerEntries.
type GetMailerEntriesParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateMailerEntryParams defines parameters for CreateMailerEntry.
type CreateMailerEntryParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteMailerEntryParams defines parameters for DeleteMailerEntry.
type DeleteMailerEntryParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailerEntryParams defines parameters for GetMailerEntry.
type GetMailerEntryParams struct {
	// MailersSection Parent mailers name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceMailerEntryParams defines parameters for ReplaceMailerEntry.
type ReplaceMailerEntryParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailersSectionsParams defines parameters for GetMailersSections.
type GetMailersSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateMailersSectionParams defines parameters for CreateMailersSection.
type CreateMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteMailersSectionParams defines parameters for DeleteMailersSection.
type DeleteMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailersSectionParams defines parameters for GetMailersSection.
type GetMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// EditMailersSectionParams defines parameters for EditMailersSection.
type EditMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetNameserversParams defines parameters for GetNameservers.
type GetNameserversParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateNameserverParams defines parameters for CreateNameserver.
type CreateNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteNameserverParams defines parameters for DeleteNameserver.
type DeleteNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetNameserverParams defines parameters for GetNameserver.
type GetNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceNameserverParams defines parameters for ReplaceNameserver.
type ReplaceNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerEntriesParams defines parameters for GetPeerEntries.
type GetPeerEntriesParams struct {
	// PeerSection Parent peer section name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreatePeerEntryParams defines parameters for CreatePeerEntry.
type CreatePeerEntryParams struct {
	// PeerSection Parent peer section name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeletePeerEntryParams defines parameters for DeletePeerEntry.
type DeletePeerEntryParams struct {
	// PeerSection Parent peers name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerEntryParams defines parameters for GetPeerEntry.
type GetPeerEntryParams struct {
	// PeerSection Parent peers name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplacePeerEntryParams defines parameters for ReplacePeerEntry.
type ReplacePeerEntryParams struct {
	// PeerSection Parent peers name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerSectionsParams defines parameters for GetPeerSections.
type GetPeerSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreatePeerParams defines parameters for CreatePeer.
type CreatePeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeletePeerParams defines parameters for DeletePeer.
type DeletePeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerSectionParams defines parameters for GetPeerSection.
type GetPeerSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllBindPeerParams defines parameters for GetAllBindPeer.
type GetAllBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBindPeerParams defines parameters for CreateBindPeer.
type CreateBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBindPeerParams defines parameters for DeleteBindPeer.
type DeleteBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBindPeerParams defines parameters for GetBindPeer.
type GetBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBindPeerParams defines parameters for ReplaceBindPeer.
type ReplaceBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetPeerParams defines parameters for GetAllLogTargetPeer.
type GetAllLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetPeerParams defines parameters for ReplaceAllLogTargetPeer.
type ReplaceAllLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetPeerParams defines parameters for DeleteLogTargetPeer.
type DeleteLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetPeerParams defines parameters for GetLogTargetPeer.
type GetLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetPeerParams defines parameters for CreateLogTargetPeer.
type CreateLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetPeerParams defines parameters for ReplaceLogTargetPeer.
type ReplaceLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllServerPeerParams defines parameters for GetAllServerPeer.
type GetAllServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerPeerParams defines parameters for CreateServerPeer.
type CreateServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerPeerParams defines parameters for DeleteServerPeer.
type DeleteServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerPeerParams defines parameters for GetServerPeer.
type GetServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerPeerParams defines parameters for ReplaceServerPeer.
type ReplaceServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTablesParams defines parameters for GetTables.
type GetTablesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTableParams defines parameters for CreateTable.
type CreateTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTableParams defines parameters for DeleteTable.
type DeleteTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTableParams defines parameters for GetTable.
type GetTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceTableParams defines parameters for ReplaceTable.
type ReplaceTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetProgramsParams defines parameters for GetPrograms.
type GetProgramsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateProgramParams defines parameters for CreateProgram.
type CreateProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteProgramParams defines parameters for DeleteProgram.
type DeleteProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetProgramParams defines parameters for GetProgram.
type GetProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceProgramParams defines parameters for ReplaceProgram.
type ReplaceProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHAProxyConfigurationParams defines parameters for GetHAProxyConfiguration.
type GetHAProxyConfigurationParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// PostHAProxyConfigurationTextBody defines parameters for PostHAProxyConfiguration.
type PostHAProxyConfigurationTextBody = string

// PostHAProxyConfigurationParams defines parameters for PostHAProxyConfiguration.
type PostHAProxyConfigurationParams struct {
	// SkipVersion If set, no version check will be done and the pushed config will be enforced
	SkipVersion *bool `form:"skip_version,omitempty" json:"skip_version,omitempty"`

	// SkipReload If set, no reload will be initiated and runtime actions from X-Runtime-Actions will be applied
	SkipReload *bool `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// OnlyValidate If set, only validates configuration, without applying it
	OnlyValidate *bool `form:"only_validate,omitempty" json:"only_validate,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// XRuntimeActions List of Runtime API commands with parameters separated by ';'
	XRuntimeActions *string `json:"X-Runtime-Actions,omitempty"`
}

// GetResolversParams defines parameters for GetResolvers.
type GetResolversParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateResolverParams defines parameters for CreateResolver.
type CreateResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteResolverParams defines parameters for DeleteResolver.
type DeleteResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetResolverParams defines parameters for GetResolver.
type GetResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceResolverParams defines parameters for ReplaceResolver.
type ReplaceResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetRingsParams defines parameters for GetRings.
type GetRingsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateRingParams defines parameters for CreateRing.
type CreateRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteRingParams defines parameters for DeleteRing.
type DeleteRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetRingParams defines parameters for GetRing.
type GetRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceRingParams defines parameters for ReplaceRing.
type ReplaceRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllServerRingParams defines parameters for GetAllServerRing.
type GetAllServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerRingParams defines parameters for CreateServerRing.
type CreateServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerRingParams defines parameters for DeleteServerRing.
type DeleteServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerRingParams defines parameters for GetServerRing.
type GetServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerRingParams defines parameters for ReplaceServerRing.
type ReplaceServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTracesParams defines parameters for DeleteTraces.
type DeleteTracesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTracesParams defines parameters for GetTraces.
type GetTracesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateTracesParams defines parameters for CreateTraces.
type CreateTracesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTracesParams defines parameters for ReplaceTraces.
type ReplaceTracesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteTraceEntryParams defines parameters for DeleteTraceEntry.
type DeleteTraceEntryParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateTraceEntryParams defines parameters for CreateTraceEntry.
type CreateTraceEntryParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUserlistsParams defines parameters for GetUserlists.
type GetUserlistsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateUserlistParams defines parameters for CreateUserlist.
type CreateUserlistParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteUserlistParams defines parameters for DeleteUserlist.
type DeleteUserlistParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUserlistParams defines parameters for GetUserlist.
type GetUserlistParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceUserParams defines parameters for ReplaceUser.
type ReplaceUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetConfigurationVersionParams defines parameters for GetConfigurationVersion.
type GetConfigurationVersionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// RenewAcmeCertificateParams defines parameters for RenewAcmeCertificate.
type RenewAcmeCertificateParams struct {
	// Certificate Certificate file name
	Certificate string `form:"certificate" json:"certificate"`
}

// GetAllRuntimeMapFilesParams defines parameters for GetAllRuntimeMapFiles.
type GetAllRuntimeMapFilesParams struct {
	// IncludeUnmanaged If true, also show unmanaged map files loaded in haproxy
	IncludeUnmanaged *bool `form:"include_unmanaged,omitempty" json:"include_unmanaged,omitempty"`
}

// ClearRuntimeMapParams defines parameters for ClearRuntimeMap.
type ClearRuntimeMapParams struct {
	// ForceDelete If true, deletes file from disk
	ForceDelete *bool `form:"forceDelete,omitempty" json:"forceDelete,omitempty"`

	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// AddPayloadRuntimeMapParams defines parameters for AddPayloadRuntimeMap.
type AddPayloadRuntimeMapParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// AddMapEntryParams defines parameters for AddMapEntry.
type AddMapEntryParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// DeleteRuntimeMapEntryParams defines parameters for DeleteRuntimeMapEntry.
type DeleteRuntimeMapEntryParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// ReplaceRuntimeMapEntryJSONBody defines parameters for ReplaceRuntimeMapEntry.
type ReplaceRuntimeMapEntryJSONBody struct {
	// Value Map value
	Value string `json:"value"`
}

// ReplaceRuntimeMapEntryParams defines parameters for ReplaceRuntimeMapEntry.
type ReplaceRuntimeMapEntryParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// CreateCaFileMultipartBody defines parameters for CreateCaFile.
type CreateCaFileMultipartBody struct {
	// FileUpload CA certificate file
	FileUpload openapi_types.File `json:"file_upload"`
}

// SetCaFileMultipartBody defines parameters for SetCaFile.
type SetCaFileMultipartBody struct {
	FileUpload openapi_types.File `json:"file_upload"`
}

// AddCaEntryMultipartBody defines parameters for AddCaEntry.
type AddCaEntryMultipartBody struct {
	// FileUpload Payload of the cert entry
	FileUpload openapi_types.File `json:"file_upload"`
}

// CreateCertMultipartBody defines parameters for CreateCert.
type CreateCertMultipartBody struct {
	// FileUpload Certificate file
	FileUpload openapi_types.File `json:"file_upload"`
}

// ReplaceCertMultipartBody defines parameters for ReplaceCert.
type ReplaceCertMultipartBody struct {
	FileUpload openapi_types.File `json:"file_upload"`
}

// CreateCrlMultipartBody defines parameters for CreateCrl.
type CreateCrlMultipartBody struct {
	// FileUpload CRL file
	FileUpload openapi_types.File `json:"file_upload"`
}

// GetCrlParams defines parameters for GetCrl.
type GetCrlParams struct {
	// Index Entry index to return. Starts at 1. If not provided, all entries are returned.
	Index *int `form:"index,omitempty" json:"index,omitempty"`
}

// ReplaceCrlMultipartBody defines parameters for ReplaceCrl.
type ReplaceCrlMultipartBody struct {
	// FileUpload CRL file contents
	FileUpload openapi_types.File `json:"file_upload"`
}

// DeleteCrtListEntryParams defines parameters for DeleteCrtListEntry.
type DeleteCrtListEntryParams struct {
	// Name SSL crt list name
	Name string `form:"name" json:"name"`

	// CertFile SSL cert entry name
	CertFile string `form:"cert_file" json:"cert_file"`

	// LineNumber The line number where the entry is located, in case several entries share the same certificate.
	LineNumber *int `form:"line_number,omitempty" json:"line_number,omitempty"`
}

// GetAllCrtListEntriesParams defines parameters for GetAllCrtListEntries.
type GetAllCrtListEntriesParams struct {
	// Name SSL crt-list filename
	Name string `form:"name" json:"name"`
}

// AddCrtListEntryParams defines parameters for AddCrtListEntry.
type AddCrtListEntryParams struct {
	// Name SSL crt-list filename
	Name string `form:"name" json:"name"`
}

// GetStickTableEntriesParams defines parameters for GetStickTableEntries.
type GetStickTableEntriesParams struct {
	// Filter A list of filters in format data.<type> <operator> <value> separated by comma
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Key Key which we want the entries for
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Count Max number of entries to be returned for pagination
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Offset Offset which indicates how many items we skip in pagination
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// SetStickTableEntriesJSONBody defines parameters for SetStickTableEntries.
type SetStickTableEntriesJSONBody struct {
	// DataType One entry in stick table
	DataType StickTableEntry `json:"data_type"`
	Key      string          `json:"key"`
}

// GetSitesParams defines parameters for GetSites.
type GetSitesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSiteParams defines parameters for CreateSite.
type CreateSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteSiteParams defines parameters for DeleteSite.
type DeleteSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetSiteParams defines parameters for GetSite.
type GetSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSiteParams defines parameters for ReplaceSite.
type ReplaceSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateSpoeMultipartBody defines parameters for CreateSpoe.
type CreateSpoeMultipartBody struct {
	// FileUpload The spoe file to upload
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// GetAllSpoeScopeParams defines parameters for GetAllSpoeScope.
type GetAllSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeScopeParams defines parameters for CreateSpoeScope.
type CreateSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeScopeParams defines parameters for DeleteSpoeScope.
type DeleteSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeScopeParams defines parameters for GetSpoeScope.
type GetSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// GetAllSpoeAgentParams defines parameters for GetAllSpoeAgent.
type GetAllSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeAgentParams defines parameters for CreateSpoeAgent.
type CreateSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeAgentParams defines parameters for DeleteSpoeAgent.
type DeleteSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeAgentParams defines parameters for GetSpoeAgent.
type GetSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSpoeAgentParams defines parameters for ReplaceSpoeAgent.
type ReplaceSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAllSpoeGroupParams defines parameters for GetAllSpoeGroup.
type GetAllSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeGroupParams defines parameters for CreateSpoeGroup.
type CreateSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeGroupParams defines parameters for DeleteSpoeGroup.
type DeleteSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeGroupParams defines parameters for GetSpoeGroup.
type GetSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSpoeGroupParams defines parameters for ReplaceSpoeGroup.
type ReplaceSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAllSpoeMessageParams defines parameters for GetAllSpoeMessage.
type GetAllSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeMessageParams defines parameters for CreateSpoeMessage.
type CreateSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeMessageParams defines parameters for DeleteSpoeMessage.
type DeleteSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeMessageParams defines parameters for GetSpoeMessage.
type GetSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSpoeMessageParams defines parameters for ReplaceSpoeMessage.
type ReplaceSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAllSpoeTransactionParams defines parameters for GetAllSpoeTransaction.
type GetAllSpoeTransactionParams struct {
	// Status Filter by transaction status
	Status *GetAllSpoeTransactionParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetAllSpoeTransactionParamsStatus defines parameters for GetAllSpoeTransaction.
type GetAllSpoeTransactionParamsStatus string

// StartSpoeTransactionParams defines parameters for StartSpoeTransaction.
type StartSpoeTransactionParams struct {
	// Version Configuration version on which to work on
	Version int `form:"version" json:"version"`
}

// CommitSpoeTransactionParams defines parameters for CommitSpoeTransaction.
type CommitSpoeTransactionParams struct {
	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetSpoeConfigurationVersionParams defines parameters for GetSpoeConfigurationVersion.
type GetSpoeConfigurationVersionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// GetStatsParams defines parameters for GetStats.
type GetStatsParams struct {
	// Type Object type to get stats for (one of frontend, backend, server)
	Type *GetStatsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Name Object name to get stats for
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Parent Object parent name to get stats for, in case the object is a server
	Parent *string `form:"parent,omitempty" json:"parent,omitempty"`
}

// GetStatsParamsType defines parameters for GetStats.
type GetStatsParamsType string

// CreateStorageGeneralFileMultipartBody defines parameters for CreateStorageGeneralFile.
type CreateStorageGeneralFileMultipartBody struct {
	// FileUpload General use file content
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceStorageGeneralFileMultipartBody defines parameters for ReplaceStorageGeneralFile.
type ReplaceStorageGeneralFileMultipartBody struct {
	// FileUpload General use file content
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceStorageGeneralFileParams defines parameters for ReplaceStorageGeneralFile.
type ReplaceStorageGeneralFileParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateStorageMapFileMultipartBody defines parameters for CreateStorageMapFile.
type CreateStorageMapFileMultipartBody struct {
	// FileUpload The map file contents
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceStorageMapFileTextBody defines parameters for ReplaceStorageMapFile.
type ReplaceStorageMapFileTextBody = string

// ReplaceStorageMapFileParams defines parameters for ReplaceStorageMapFile.
type ReplaceStorageMapFileParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateStorageSSLCertificateMultipartBody defines parameters for CreateStorageSSLCertificate.
type CreateStorageSSLCertificateMultipartBody struct {
	// FileUpload The SSL certificate to upload
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// CreateStorageSSLCertificateParams defines parameters for CreateStorageSSLCertificate.
type CreateStorageSSLCertificateParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteStorageSSLCertificateParams defines parameters for DeleteStorageSSLCertificate.
type DeleteStorageSSLCertificateParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceStorageSSLCertificateTextBody defines parameters for ReplaceStorageSSLCertificate.
type ReplaceStorageSSLCertificateTextBody = string

// ReplaceStorageSSLCertificateParams defines parameters for ReplaceStorageSSLCertificate.
type ReplaceStorageSSLCertificateParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateStorageSSLCrtListFileMultipartBody defines parameters for CreateStorageSSLCrtListFile.
type CreateStorageSSLCrtListFileMultipartBody struct {
	// FileUpload The certificate list to upload
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// CreateStorageSSLCrtListFileParams defines parameters for CreateStorageSSLCrtListFile.
type CreateStorageSSLCrtListFileParams struct {
	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteStorageSSLCrtListFileParams defines parameters for DeleteStorageSSLCrtListFile.
type DeleteStorageSSLCrtListFileParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceStorageSSLCrtListFileTextBody defines parameters for ReplaceStorageSSLCrtListFile.
type ReplaceStorageSSLCrtListFileTextBody = string

// ReplaceStorageSSLCrtListFileParams defines parameters for ReplaceStorageSSLCrtListFile.
type ReplaceStorageSSLCrtListFileParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteStorageSSLCrtListEntryParams defines parameters for DeleteStorageSSLCrtListEntry.
type DeleteStorageSSLCrtListEntryParams struct {
	// Certificate SSL certificate filename
	Certificate string `form:"certificate" json:"certificate"`

	// LineNumber The line number in the crt-list
	LineNumber int `form:"line_number" json:"line_number"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateStorageSSLCrtListEntryParams defines parameters for CreateStorageSSLCrtListEntry.
type CreateStorageSSLCrtListEntryParams struct {
	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTransactionsParams defines parameters for GetTransactions.
type GetTransactionsParams struct {
	// Status Filter by transaction status
	Status *GetTransactionsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetTransactionsParamsStatus defines parameters for GetTransactions.
type GetTransactionsParamsStatus string

// StartTransactionParams defines parameters for StartTransaction.
type StartTransactionParams struct {
	// Version Configuration version on which to work on
	Version int `form:"version" json:"version"`
}

// CommitTransactionParams defines parameters for CommitTransaction.
type CommitTransactionParams struct {
	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// PostClusterJSONRequestBody defines body for PostCluster for application/json ContentType.
type PostClusterJSONRequestBody = ClusterSettings

// EditClusterJSONRequestBody defines body for EditCluster for application/json ContentType.
type EditClusterJSONRequestBody = ClusterSettings

// CreateAWSRegionJSONRequestBody defines body for CreateAWSRegion for application/json ContentType.
type CreateAWSRegionJSONRequestBody = AwsRegion

// ReplaceAWSRegionJSONRequestBody defines body for ReplaceAWSRegion for application/json ContentType.
type ReplaceAWSRegionJSONRequestBody = AwsRegion

// CreateConsulJSONRequestBody defines body for CreateConsul for application/json ContentType.
type CreateConsulJSONRequestBody = Consul

// ReplaceConsulJSONRequestBody defines body for ReplaceConsul for application/json ContentType.
type ReplaceConsulJSONRequestBody = Consul

// CreateAcmeProviderJSONRequestBody defines body for CreateAcmeProvider for application/json ContentType.
type CreateAcmeProviderJSONRequestBody = AcmeProvider

// EditAcmeProviderJSONRequestBody defines body for EditAcmeProvider for application/json ContentType.
type EditAcmeProviderJSONRequestBody = AcmeProvider

// CreateBackendJSONRequestBody defines body for CreateBackend for application/json ContentType.
type CreateBackendJSONRequestBody = Backend

// ReplaceBackendJSONRequestBody defines body for ReplaceBackend for application/json ContentType.
type ReplaceBackendJSONRequestBody = Backend

// ReplaceAllAclBackendJSONRequestBody defines body for ReplaceAllAclBackend for application/json ContentType.
type ReplaceAllAclBackendJSONRequestBody = Acls

// CreateAclBackendJSONRequestBody defines body for CreateAclBackend for application/json ContentType.
type CreateAclBackendJSONRequestBody = Acl

// ReplaceAclBackendJSONRequestBody defines body for ReplaceAclBackend for application/json ContentType.
type ReplaceAclBackendJSONRequestBody = Acl

// ReplaceAllFilterBackendJSONRequestBody defines body for ReplaceAllFilterBackend for application/json ContentType.
type ReplaceAllFilterBackendJSONRequestBody = Filters

// CreateFilterBackendJSONRequestBody defines body for CreateFilterBackend for application/json ContentType.
type CreateFilterBackendJSONRequestBody = Filter

// ReplaceFilterBackendJSONRequestBody defines body for ReplaceFilterBackend for application/json ContentType.
type ReplaceFilterBackendJSONRequestBody = Filter

// ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody defines body for ReplaceAllHTTPAfterResponseRuleBackend for application/json ContentType.
type ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody = HttpAfterResponseRules

// CreateHTTPAfterResponseRuleBackendJSONRequestBody defines body for CreateHTTPAfterResponseRuleBackend for application/json ContentType.
type CreateHTTPAfterResponseRuleBackendJSONRequestBody = HttpAfterResponseRule

// ReplaceHTTPAfterResponseRuleBackendJSONRequestBody defines body for ReplaceHTTPAfterResponseRuleBackend for application/json ContentType.
type ReplaceHTTPAfterResponseRuleBackendJSONRequestBody = HttpAfterResponseRule

// ReplaceAllHTTPCheckBackendJSONRequestBody defines body for ReplaceAllHTTPCheckBackend for application/json ContentType.
type ReplaceAllHTTPCheckBackendJSONRequestBody = HttpChecks

// CreateHTTPCheckBackendJSONRequestBody defines body for CreateHTTPCheckBackend for application/json ContentType.
type CreateHTTPCheckBackendJSONRequestBody = HttpCheck

// ReplaceHTTPCheckBackendJSONRequestBody defines body for ReplaceHTTPCheckBackend for application/json ContentType.
type ReplaceHTTPCheckBackendJSONRequestBody = HttpCheck

// ReplaceAllHTTPErrorRuleBackendJSONRequestBody defines body for ReplaceAllHTTPErrorRuleBackend for application/json ContentType.
type ReplaceAllHTTPErrorRuleBackendJSONRequestBody = HttpErrorRules

// CreateHTTPErrorRuleBackendJSONRequestBody defines body for CreateHTTPErrorRuleBackend for application/json ContentType.
type CreateHTTPErrorRuleBackendJSONRequestBody = HttpErrorRule

// ReplaceHTTPErrorRuleBackendJSONRequestBody defines body for ReplaceHTTPErrorRuleBackend for application/json ContentType.
type ReplaceHTTPErrorRuleBackendJSONRequestBody = HttpErrorRule

// ReplaceAllHTTPRequestRuleBackendJSONRequestBody defines body for ReplaceAllHTTPRequestRuleBackend for application/json ContentType.
type ReplaceAllHTTPRequestRuleBackendJSONRequestBody = HttpRequestRules

// CreateHTTPRequestRuleBackendJSONRequestBody defines body for CreateHTTPRequestRuleBackend for application/json ContentType.
type CreateHTTPRequestRuleBackendJSONRequestBody = HttpRequestRule

// ReplaceHTTPRequestRuleBackendJSONRequestBody defines body for ReplaceHTTPRequestRuleBackend for application/json ContentType.
type ReplaceHTTPRequestRuleBackendJSONRequestBody = HttpRequestRule

// ReplaceAllHTTPResponseRuleBackendJSONRequestBody defines body for ReplaceAllHTTPResponseRuleBackend for application/json ContentType.
type ReplaceAllHTTPResponseRuleBackendJSONRequestBody = HttpResponseRules

// CreateHTTPResponseRuleBackendJSONRequestBody defines body for CreateHTTPResponseRuleBackend for application/json ContentType.
type CreateHTTPResponseRuleBackendJSONRequestBody = HttpResponseRule

// ReplaceHTTPResponseRuleBackendJSONRequestBody defines body for ReplaceHTTPResponseRuleBackend for application/json ContentType.
type ReplaceHTTPResponseRuleBackendJSONRequestBody = HttpResponseRule

// ReplaceAllLogTargetBackendJSONRequestBody defines body for ReplaceAllLogTargetBackend for application/json ContentType.
type ReplaceAllLogTargetBackendJSONRequestBody = LogTargets

// CreateLogTargetBackendJSONRequestBody defines body for CreateLogTargetBackend for application/json ContentType.
type CreateLogTargetBackendJSONRequestBody = LogTarget

// ReplaceLogTargetBackendJSONRequestBody defines body for ReplaceLogTargetBackend for application/json ContentType.
type ReplaceLogTargetBackendJSONRequestBody = LogTarget

// ReplaceServerSwitchingRulesJSONRequestBody defines body for ReplaceServerSwitchingRules for application/json ContentType.
type ReplaceServerSwitchingRulesJSONRequestBody = ServerSwitchingRules

// CreateServerSwitchingRuleJSONRequestBody defines body for CreateServerSwitchingRule for application/json ContentType.
type CreateServerSwitchingRuleJSONRequestBody = ServerSwitchingRule

// ReplaceServerSwitchingRuleJSONRequestBody defines body for ReplaceServerSwitchingRule for application/json ContentType.
type ReplaceServerSwitchingRuleJSONRequestBody = ServerSwitchingRule

// CreateServerTemplateJSONRequestBody defines body for CreateServerTemplate for application/json ContentType.
type CreateServerTemplateJSONRequestBody = ServerTemplate

// ReplaceServerTemplateJSONRequestBody defines body for ReplaceServerTemplate for application/json ContentType.
type ReplaceServerTemplateJSONRequestBody = ServerTemplate

// CreateServerBackendJSONRequestBody defines body for CreateServerBackend for application/json ContentType.
type CreateServerBackendJSONRequestBody = Server

// ReplaceServerBackendJSONRequestBody defines body for ReplaceServerBackend for application/json ContentType.
type ReplaceServerBackendJSONRequestBody = Server

// ReplaceStickRulesJSONRequestBody defines body for ReplaceStickRules for application/json ContentType.
type ReplaceStickRulesJSONRequestBody = StickRules

// CreateStickRuleJSONRequestBody defines body for CreateStickRule for application/json ContentType.
type CreateStickRuleJSONRequestBody = StickRule

// ReplaceStickRuleJSONRequestBody defines body for ReplaceStickRule for application/json ContentType.
type ReplaceStickRuleJSONRequestBody = StickRule

// ReplaceAllTCPCheckBackendJSONRequestBody defines body for ReplaceAllTCPCheckBackend for application/json ContentType.
type ReplaceAllTCPCheckBackendJSONRequestBody = TcpChecks

// CreateTCPCheckBackendJSONRequestBody defines body for CreateTCPCheckBackend for application/json ContentType.
type CreateTCPCheckBackendJSONRequestBody = TcpCheck

// ReplaceTCPCheckBackendJSONRequestBody defines body for ReplaceTCPCheckBackend for application/json ContentType.
type ReplaceTCPCheckBackendJSONRequestBody = TcpCheck

// ReplaceAllTCPRequestRuleBackendJSONRequestBody defines body for ReplaceAllTCPRequestRuleBackend for application/json ContentType.
type ReplaceAllTCPRequestRuleBackendJSONRequestBody = TcpRequestRules

// CreateTCPRequestRuleBackendJSONRequestBody defines body for CreateTCPRequestRuleBackend for application/json ContentType.
type CreateTCPRequestRuleBackendJSONRequestBody = TcpRequestRule

// ReplaceTCPRequestRuleBackendJSONRequestBody defines body for ReplaceTCPRequestRuleBackend for application/json ContentType.
type ReplaceTCPRequestRuleBackendJSONRequestBody = TcpRequestRule

// ReplaceAllTCPResponseRuleBackendJSONRequestBody defines body for ReplaceAllTCPResponseRuleBackend for application/json ContentType.
type ReplaceAllTCPResponseRuleBackendJSONRequestBody = TcpResponseRules

// CreateTCPResponseRuleBackendJSONRequestBody defines body for CreateTCPResponseRuleBackend for application/json ContentType.
type CreateTCPResponseRuleBackendJSONRequestBody = TcpResponseRule

// ReplaceTCPResponseRuleBackendJSONRequestBody defines body for ReplaceTCPResponseRuleBackend for application/json ContentType.
type ReplaceTCPResponseRuleBackendJSONRequestBody = TcpResponseRule

// CreateCacheJSONRequestBody defines body for CreateCache for application/json ContentType.
type CreateCacheJSONRequestBody = Cache

// ReplaceCacheJSONRequestBody defines body for ReplaceCache for application/json ContentType.
type ReplaceCacheJSONRequestBody = Cache

// CreateCrtLoadJSONRequestBody defines body for CreateCrtLoad for application/json ContentType.
type CreateCrtLoadJSONRequestBody = CrtLoad

// ReplaceCrtLoadJSONRequestBody defines body for ReplaceCrtLoad for application/json ContentType.
type ReplaceCrtLoadJSONRequestBody = CrtLoad

// CreateCrtStoreJSONRequestBody defines body for CreateCrtStore for application/json ContentType.
type CreateCrtStoreJSONRequestBody = CrtStore

// EditCrtStoreJSONRequestBody defines body for EditCrtStore for application/json ContentType.
type EditCrtStoreJSONRequestBody = CrtStore

// AddDefaultsSectionJSONRequestBody defines body for AddDefaultsSection for application/json ContentType.
type AddDefaultsSectionJSONRequestBody = Defaults

// CreateDefaultsSectionJSONRequestBody defines body for CreateDefaultsSection for application/json ContentType.
type CreateDefaultsSectionJSONRequestBody = Defaults

// ReplaceDefaultsSectionJSONRequestBody defines body for ReplaceDefaultsSection for application/json ContentType.
type ReplaceDefaultsSectionJSONRequestBody = Defaults

// ReplaceAllAclDefaultsJSONRequestBody defines body for ReplaceAllAclDefaults for application/json ContentType.
type ReplaceAllAclDefaultsJSONRequestBody = Acls

// CreateAclDefaultsJSONRequestBody defines body for CreateAclDefaults for application/json ContentType.
type CreateAclDefaultsJSONRequestBody = Acl

// ReplaceAclDefaultsJSONRequestBody defines body for ReplaceAclDefaults for application/json ContentType.
type ReplaceAclDefaultsJSONRequestBody = Acl

// ReplaceAllHTTPAfterResponseRuleDefaultsJSONRequestBody defines body for ReplaceAllHTTPAfterResponseRuleDefaults for application/json ContentType.
type ReplaceAllHTTPAfterResponseRuleDefaultsJSONRequestBody = HttpAfterResponseRules

// CreateHTTPAfterResponseRuleDefaultsJSONRequestBody defines body for CreateHTTPAfterResponseRuleDefaults for application/json ContentType.
type CreateHTTPAfterResponseRuleDefaultsJSONRequestBody = HttpAfterResponseRule

// ReplaceHTTPAfterResponseRuleDefaultsJSONRequestBody defines body for ReplaceHTTPAfterResponseRuleDefaults for application/json ContentType.
type ReplaceHTTPAfterResponseRuleDefaultsJSONRequestBody = HttpAfterResponseRule

// ReplaceAllHTTPCheckDefaultsJSONRequestBody defines body for ReplaceAllHTTPCheckDefaults for application/json ContentType.
type ReplaceAllHTTPCheckDefaultsJSONRequestBody = HttpChecks

// CreateHTTPCheckDefaultsJSONRequestBody defines body for CreateHTTPCheckDefaults for application/json ContentType.
type CreateHTTPCheckDefaultsJSONRequestBody = HttpCheck

// ReplaceHTTPCheckDefaultsJSONRequestBody defines body for ReplaceHTTPCheckDefaults for application/json ContentType.
type ReplaceHTTPCheckDefaultsJSONRequestBody = HttpCheck

// ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody defines body for ReplaceAllHTTPErrorRuleDefaults for application/json ContentType.
type ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody = HttpErrorRules

// CreateHTTPErrorRuleDefaultsJSONRequestBody defines body for CreateHTTPErrorRuleDefaults for application/json ContentType.
type CreateHTTPErrorRuleDefaultsJSONRequestBody = HttpErrorRule

// ReplaceHTTPErrorRuleDefaultsJSONRequestBody defines body for ReplaceHTTPErrorRuleDefaults for application/json ContentType.
type ReplaceHTTPErrorRuleDefaultsJSONRequestBody = HttpErrorRule

// ReplaceAllHTTPRequestRuleDefaultsJSONRequestBody defines body for ReplaceAllHTTPRequestRuleDefaults for application/json ContentType.
type ReplaceAllHTTPRequestRuleDefaultsJSONRequestBody = HttpRequestRules

// CreateHTTPRequestRuleDefaultsJSONRequestBody defines body for CreateHTTPRequestRuleDefaults for application/json ContentType.
type CreateHTTPRequestRuleDefaultsJSONRequestBody = HttpRequestRule

// ReplaceHTTPRequestRuleDefaultsJSONRequestBody defines body for ReplaceHTTPRequestRuleDefaults for application/json ContentType.
type ReplaceHTTPRequestRuleDefaultsJSONRequestBody = HttpRequestRule

// ReplaceAllHTTPResponseRuleDefaultsJSONRequestBody defines body for ReplaceAllHTTPResponseRuleDefaults for application/json ContentType.
type ReplaceAllHTTPResponseRuleDefaultsJSONRequestBody = HttpResponseRules

// CreateHTTPResponseRuleDefaultsJSONRequestBody defines body for CreateHTTPResponseRuleDefaults for application/json ContentType.
type CreateHTTPResponseRuleDefaultsJSONRequestBody = HttpResponseRule

// ReplaceHTTPResponseRuleDefaultsJSONRequestBody defines body for ReplaceHTTPResponseRuleDefaults for application/json ContentType.
type ReplaceHTTPResponseRuleDefaultsJSONRequestBody = HttpResponseRule

// ReplaceAllLogTargetDefaultsJSONRequestBody defines body for ReplaceAllLogTargetDefaults for application/json ContentType.
type ReplaceAllLogTargetDefaultsJSONRequestBody = LogTargets

// CreateLogTargetDefaultsJSONRequestBody defines body for CreateLogTargetDefaults for application/json ContentType.
type CreateLogTargetDefaultsJSONRequestBody = LogTarget

// ReplaceLogTargetDefaultsJSONRequestBody defines body for ReplaceLogTargetDefaults for application/json ContentType.
type ReplaceLogTargetDefaultsJSONRequestBody = LogTarget

// ReplaceAllQUICInitialRuleDefaultsJSONRequestBody defines body for ReplaceAllQUICInitialRuleDefaults for application/json ContentType.
type ReplaceAllQUICInitialRuleDefaultsJSONRequestBody = QUICInitialRules

// CreateQUICInitialRuleDefaultsJSONRequestBody defines body for CreateQUICInitialRuleDefaults for application/json ContentType.
type CreateQUICInitialRuleDefaultsJSONRequestBody = QUICInitialRule

// ReplaceQUICInitialRuleDefaultsJSONRequestBody defines body for ReplaceQUICInitialRuleDefaults for application/json ContentType.
type ReplaceQUICInitialRuleDefaultsJSONRequestBody = QUICInitialRule

// ReplaceAllTCPCheckDefaultsJSONRequestBody defines body for ReplaceAllTCPCheckDefaults for application/json ContentType.
type ReplaceAllTCPCheckDefaultsJSONRequestBody = TcpChecks

// CreateTCPCheckDefaultsJSONRequestBody defines body for CreateTCPCheckDefaults for application/json ContentType.
type CreateTCPCheckDefaultsJSONRequestBody = TcpCheck

// ReplaceTCPCheckDefaultsJSONRequestBody defines body for ReplaceTCPCheckDefaults for application/json ContentType.
type ReplaceTCPCheckDefaultsJSONRequestBody = TcpCheck

// ReplaceAllTCPRequestRuleDefaultsJSONRequestBody defines body for ReplaceAllTCPRequestRuleDefaults for application/json ContentType.
type ReplaceAllTCPRequestRuleDefaultsJSONRequestBody = TcpRequestRules

// CreateTCPRequestRuleDefaultsJSONRequestBody defines body for CreateTCPRequestRuleDefaults for application/json ContentType.
type CreateTCPRequestRuleDefaultsJSONRequestBody = TcpRequestRule

// ReplaceTCPRequestRuleDefaultsJSONRequestBody defines body for ReplaceTCPRequestRuleDefaults for application/json ContentType.
type ReplaceTCPRequestRuleDefaultsJSONRequestBody = TcpRequestRule

// ReplaceAllTCPResponseRuleDefaultsJSONRequestBody defines body for ReplaceAllTCPResponseRuleDefaults for application/json ContentType.
type ReplaceAllTCPResponseRuleDefaultsJSONRequestBody = TcpResponseRules

// CreateTCPResponseRuleDefaultsJSONRequestBody defines body for CreateTCPResponseRuleDefaults for application/json ContentType.
type CreateTCPResponseRuleDefaultsJSONRequestBody = TcpResponseRule

// ReplaceTCPResponseRuleDefaultsJSONRequestBody defines body for ReplaceTCPResponseRuleDefaults for application/json ContentType.
type ReplaceTCPResponseRuleDefaultsJSONRequestBody = TcpResponseRule

// CreateFCGIAppJSONRequestBody defines body for CreateFCGIApp for application/json ContentType.
type CreateFCGIAppJSONRequestBody = FCGIApp

// ReplaceFCGIAppJSONRequestBody defines body for ReplaceFCGIApp for application/json ContentType.
type ReplaceFCGIAppJSONRequestBody = FCGIApp

// ReplaceAllAclFCGIAppJSONRequestBody defines body for ReplaceAllAclFCGIApp for application/json ContentType.
type ReplaceAllAclFCGIAppJSONRequestBody = Acls

// CreateAclFCGIAppJSONRequestBody defines body for CreateAclFCGIApp for application/json ContentType.
type CreateAclFCGIAppJSONRequestBody = Acl

// ReplaceAclFCGIAppJSONRequestBody defines body for ReplaceAclFCGIApp for application/json ContentType.
type ReplaceAclFCGIAppJSONRequestBody = Acl

// CreateFrontendJSONRequestBody defines body for CreateFrontend for application/json ContentType.
type CreateFrontendJSONRequestBody = Frontend

// ReplaceFrontendJSONRequestBody defines body for ReplaceFrontend for application/json ContentType.
type ReplaceFrontendJSONRequestBody = Frontend

// ReplaceAllAclFrontendJSONRequestBody defines body for ReplaceAllAclFrontend for application/json ContentType.
type ReplaceAllAclFrontendJSONRequestBody = Acls

// CreateAclFrontendJSONRequestBody defines body for CreateAclFrontend for application/json ContentType.
type CreateAclFrontendJSONRequestBody = Acl

// ReplaceAclFrontendJSONRequestBody defines body for ReplaceAclFrontend for application/json ContentType.
type ReplaceAclFrontendJSONRequestBody = Acl

// ReplaceBackendSwitchingRulesJSONRequestBody defines body for ReplaceBackendSwitchingRules for application/json ContentType.
type ReplaceBackendSwitchingRulesJSONRequestBody = BackendSwitchingRules

// CreateBackendSwitchingRuleJSONRequestBody defines body for CreateBackendSwitchingRule for application/json ContentType.
type CreateBackendSwitchingRuleJSONRequestBody = BackendSwitchingRule

// ReplaceBackendSwitchingRuleJSONRequestBody defines body for ReplaceBackendSwitchingRule for application/json ContentType.
type ReplaceBackendSwitchingRuleJSONRequestBody = BackendSwitchingRule

// CreateBindFrontendJSONRequestBody defines body for CreateBindFrontend for application/json ContentType.
type CreateBindFrontendJSONRequestBody = Bind

// ReplaceBindFrontendJSONRequestBody defines body for ReplaceBindFrontend for application/json ContentType.
type ReplaceBindFrontendJSONRequestBody = Bind

// ReplaceDeclareCapturesJSONRequestBody defines body for ReplaceDeclareCaptures for application/json ContentType.
type ReplaceDeclareCapturesJSONRequestBody = Captures

// CreateDeclareCaptureJSONRequestBody defines body for CreateDeclareCapture for application/json ContentType.
type CreateDeclareCaptureJSONRequestBody = Capture

// ReplaceDeclareCaptureJSONRequestBody defines body for ReplaceDeclareCapture for application/json ContentType.
type ReplaceDeclareCaptureJSONRequestBody = Capture

// ReplaceAllFilterFrontendJSONRequestBody defines body for ReplaceAllFilterFrontend for application/json ContentType.
type ReplaceAllFilterFrontendJSONRequestBody = Filters

// CreateFilterFrontendJSONRequestBody defines body for CreateFilterFrontend for application/json ContentType.
type CreateFilterFrontendJSONRequestBody = Filter

// ReplaceFilterFrontendJSONRequestBody defines body for ReplaceFilterFrontend for application/json ContentType.
type ReplaceFilterFrontendJSONRequestBody = Filter

// ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPAfterResponseRuleFrontend for application/json ContentType.
type ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody = HttpAfterResponseRules

// CreateHTTPAfterResponseRuleFrontendJSONRequestBody defines body for CreateHTTPAfterResponseRuleFrontend for application/json ContentType.
type CreateHTTPAfterResponseRuleFrontendJSONRequestBody = HttpAfterResponseRule

// ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody defines body for ReplaceHTTPAfterResponseRuleFrontend for application/json ContentType.
type ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody = HttpAfterResponseRule

// ReplaceAllHTTPErrorRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPErrorRuleFrontend for application/json ContentType.
type ReplaceAllHTTPErrorRuleFrontendJSONRequestBody = HttpErrorRules

// CreateHTTPErrorRuleFrontendJSONRequestBody defines body for CreateHTTPErrorRuleFrontend for application/json ContentType.
type CreateHTTPErrorRuleFrontendJSONRequestBody = HttpErrorRule

// ReplaceHTTPErrorRuleFrontendJSONRequestBody defines body for ReplaceHTTPErrorRuleFrontend for application/json ContentType.
type ReplaceHTTPErrorRuleFrontendJSONRequestBody = HttpErrorRule

// ReplaceAllHTTPRequestRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPRequestRuleFrontend for application/json ContentType.
type ReplaceAllHTTPRequestRuleFrontendJSONRequestBody = HttpRequestRules

// CreateHTTPRequestRuleFrontendJSONRequestBody defines body for CreateHTTPRequestRuleFrontend for application/json ContentType.
type CreateHTTPRequestRuleFrontendJSONRequestBody = HttpRequestRule

// ReplaceHTTPRequestRuleFrontendJSONRequestBody defines body for ReplaceHTTPRequestRuleFrontend for application/json ContentType.
type ReplaceHTTPRequestRuleFrontendJSONRequestBody = HttpRequestRule

// ReplaceAllHTTPResponseRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPResponseRuleFrontend for application/json ContentType.
type ReplaceAllHTTPResponseRuleFrontendJSONRequestBody = HttpResponseRules

// CreateHTTPResponseRuleFrontendJSONRequestBody defines body for CreateHTTPResponseRuleFrontend for application/json ContentType.
type CreateHTTPResponseRuleFrontendJSONRequestBody = HttpResponseRule

// ReplaceHTTPResponseRuleFrontendJSONRequestBody defines body for ReplaceHTTPResponseRuleFrontend for application/json ContentType.
type ReplaceHTTPResponseRuleFrontendJSONRequestBody = HttpResponseRule

// ReplaceAllLogTargetFrontendJSONRequestBody defines body for ReplaceAllLogTargetFrontend for application/json ContentType.
type ReplaceAllLogTargetFrontendJSONRequestBody = LogTargets

// CreateLogTargetFrontendJSONRequestBody defines body for CreateLogTargetFrontend for application/json ContentType.
type CreateLogTargetFrontendJSONRequestBody = LogTarget

// ReplaceLogTargetFrontendJSONRequestBody defines body for ReplaceLogTargetFrontend for application/json ContentType.
type ReplaceLogTargetFrontendJSONRequestBody = LogTarget

// ReplaceAllQUICInitialRuleFrontendJSONRequestBody defines body for ReplaceAllQUICInitialRuleFrontend for application/json ContentType.
type ReplaceAllQUICInitialRuleFrontendJSONRequestBody = QUICInitialRules

// CreateQUICInitialRuleFrontendJSONRequestBody defines body for CreateQUICInitialRuleFrontend for application/json ContentType.
type CreateQUICInitialRuleFrontendJSONRequestBody = QUICInitialRule

// ReplaceQUICInitialRuleFrontendJSONRequestBody defines body for ReplaceQUICInitialRuleFrontend for application/json ContentType.
type ReplaceQUICInitialRuleFrontendJSONRequestBody = QUICInitialRule

// CreateSSLFrontUseJSONRequestBody defines body for CreateSSLFrontUse for application/json ContentType.
type CreateSSLFrontUseJSONRequestBody = SSLFrontUse

// ReplaceSSLFrontUseJSONRequestBody defines body for ReplaceSSLFrontUse for application/json ContentType.
type ReplaceSSLFrontUseJSONRequestBody = SSLFrontUse

// ReplaceAllTCPRequestRuleFrontendJSONRequestBody defines body for ReplaceAllTCPRequestRuleFrontend for application/json ContentType.
type ReplaceAllTCPRequestRuleFrontendJSONRequestBody = TcpRequestRules

// CreateTCPRequestRuleFrontendJSONRequestBody defines body for CreateTCPRequestRuleFrontend for application/json ContentType.
type CreateTCPRequestRuleFrontendJSONRequestBody = TcpRequestRule

// ReplaceTCPRequestRuleFrontendJSONRequestBody defines body for ReplaceTCPRequestRuleFrontend for application/json ContentType.
type ReplaceTCPRequestRuleFrontendJSONRequestBody = TcpRequestRule

// ReplaceGlobalJSONRequestBody defines body for ReplaceGlobal for application/json ContentType.
type ReplaceGlobalJSONRequestBody = Global

// ReplaceAllLogTargetGlobalJSONRequestBody defines body for ReplaceAllLogTargetGlobal for application/json ContentType.
type ReplaceAllLogTargetGlobalJSONRequestBody = LogTargets

// CreateLogTargetGlobalJSONRequestBody defines body for CreateLogTargetGlobal for application/json ContentType.
type CreateLogTargetGlobalJSONRequestBody = LogTarget

// ReplaceLogTargetGlobalJSONRequestBody defines body for ReplaceLogTargetGlobal for application/json ContentType.
type ReplaceLogTargetGlobalJSONRequestBody = LogTarget

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody = Group

// ReplaceGroupJSONRequestBody defines body for ReplaceGroup for application/json ContentType.
type ReplaceGroupJSONRequestBody = Group

// CreateHTTPErrorsSectionJSONRequestBody defines body for CreateHTTPErrorsSection for application/json ContentType.
type CreateHTTPErrorsSectionJSONRequestBody = HttpErrorsSection

// ReplaceHTTPErrorsSectionJSONRequestBody defines body for ReplaceHTTPErrorsSection for application/json ContentType.
type ReplaceHTTPErrorsSectionJSONRequestBody = HttpErrorsSection

// CreateLogForwardJSONRequestBody defines body for CreateLogForward for application/json ContentType.
type CreateLogForwardJSONRequestBody = LogForward

// ReplaceLogForwardJSONRequestBody defines body for ReplaceLogForward for application/json ContentType.
type ReplaceLogForwardJSONRequestBody = LogForward

// CreateBindLogForwardJSONRequestBody defines body for CreateBindLogForward for application/json ContentType.
type CreateBindLogForwardJSONRequestBody = Bind

// ReplaceBindLogForwardJSONRequestBody defines body for ReplaceBindLogForward for application/json ContentType.
type ReplaceBindLogForwardJSONRequestBody = Bind

// CreateDgramBindJSONRequestBody defines body for CreateDgramBind for application/json ContentType.
type CreateDgramBindJSONRequestBody = DgramBind

// ReplaceDgramBindJSONRequestBody defines body for ReplaceDgramBind for application/json ContentType.
type ReplaceDgramBindJSONRequestBody = DgramBind

// ReplaceAllLogTargetLogForwardJSONRequestBody defines body for ReplaceAllLogTargetLogForward for application/json ContentType.
type ReplaceAllLogTargetLogForwardJSONRequestBody = LogTargets

// CreateLogTargetLogForwardJSONRequestBody defines body for CreateLogTargetLogForward for application/json ContentType.
type CreateLogTargetLogForwardJSONRequestBody = LogTarget

// ReplaceLogTargetLogForwardJSONRequestBody defines body for ReplaceLogTargetLogForward for application/json ContentType.
type ReplaceLogTargetLogForwardJSONRequestBody = LogTarget

// CreateLogProfileJSONRequestBody defines body for CreateLogProfile for application/json ContentType.
type CreateLogProfileJSONRequestBody = LogProfile

// EditLogProfileJSONRequestBody defines body for EditLogProfile for application/json ContentType.
type EditLogProfileJSONRequestBody = LogProfile

// CreateMailerEntryJSONRequestBody defines body for CreateMailerEntry for application/json ContentType.
type CreateMailerEntryJSONRequestBody = MailerEntry

// ReplaceMailerEntryJSONRequestBody defines body for ReplaceMailerEntry for application/json ContentType.
type ReplaceMailerEntryJSONRequestBody = MailerEntry

// CreateMailersSectionJSONRequestBody defines body for CreateMailersSection for application/json ContentType.
type CreateMailersSectionJSONRequestBody = MailersSection

// EditMailersSectionJSONRequestBody defines body for EditMailersSection for application/json ContentType.
type EditMailersSectionJSONRequestBody = MailersSection

// CreateNameserverJSONRequestBody defines body for CreateNameserver for application/json ContentType.
type CreateNameserverJSONRequestBody = Nameserver

// ReplaceNameserverJSONRequestBody defines body for ReplaceNameserver for application/json ContentType.
type ReplaceNameserverJSONRequestBody = Nameserver

// CreatePeerEntryJSONRequestBody defines body for CreatePeerEntry for application/json ContentType.
type CreatePeerEntryJSONRequestBody = PeerEntry

// ReplacePeerEntryJSONRequestBody defines body for ReplacePeerEntry for application/json ContentType.
type ReplacePeerEntryJSONRequestBody = PeerEntry

// CreatePeerJSONRequestBody defines body for CreatePeer for application/json ContentType.
type CreatePeerJSONRequestBody = PeerSection

// CreateBindPeerJSONRequestBody defines body for CreateBindPeer for application/json ContentType.
type CreateBindPeerJSONRequestBody = Bind

// ReplaceBindPeerJSONRequestBody defines body for ReplaceBindPeer for application/json ContentType.
type ReplaceBindPeerJSONRequestBody = Bind

// ReplaceAllLogTargetPeerJSONRequestBody defines body for ReplaceAllLogTargetPeer for application/json ContentType.
type ReplaceAllLogTargetPeerJSONRequestBody = LogTargets

// CreateLogTargetPeerJSONRequestBody defines body for CreateLogTargetPeer for application/json ContentType.
type CreateLogTargetPeerJSONRequestBody = LogTarget

// ReplaceLogTargetPeerJSONRequestBody defines body for ReplaceLogTargetPeer for application/json ContentType.
type ReplaceLogTargetPeerJSONRequestBody = LogTarget

// CreateServerPeerJSONRequestBody defines body for CreateServerPeer for application/json ContentType.
type CreateServerPeerJSONRequestBody = Server

// ReplaceServerPeerJSONRequestBody defines body for ReplaceServerPeer for application/json ContentType.
type ReplaceServerPeerJSONRequestBody = Server

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = Table

// ReplaceTableJSONRequestBody defines body for ReplaceTable for application/json ContentType.
type ReplaceTableJSONRequestBody = Table

// CreateProgramJSONRequestBody defines body for CreateProgram for application/json ContentType.
type CreateProgramJSONRequestBody = Program

// ReplaceProgramJSONRequestBody defines body for ReplaceProgram for application/json ContentType.
type ReplaceProgramJSONRequestBody = Program

// PostHAProxyConfigurationTextRequestBody defines body for PostHAProxyConfiguration for text/plain ContentType.
type PostHAProxyConfigurationTextRequestBody = PostHAProxyConfigurationTextBody

// CreateResolverJSONRequestBody defines body for CreateResolver for application/json ContentType.
type CreateResolverJSONRequestBody = Resolver

// ReplaceResolverJSONRequestBody defines body for ReplaceResolver for application/json ContentType.
type ReplaceResolverJSONRequestBody = Resolver

// CreateRingJSONRequestBody defines body for CreateRing for application/json ContentType.
type CreateRingJSONRequestBody = Ring

// ReplaceRingJSONRequestBody defines body for ReplaceRing for application/json ContentType.
type ReplaceRingJSONRequestBody = Ring

// CreateServerRingJSONRequestBody defines body for CreateServerRing for application/json ContentType.
type CreateServerRingJSONRequestBody = Server

// ReplaceServerRingJSONRequestBody defines body for ReplaceServerRing for application/json ContentType.
type ReplaceServerRingJSONRequestBody = Server

// CreateTracesJSONRequestBody defines body for CreateTraces for application/json ContentType.
type CreateTracesJSONRequestBody = Traces

// ReplaceTracesJSONRequestBody defines body for ReplaceTraces for application/json ContentType.
type ReplaceTracesJSONRequestBody = Traces

// DeleteTraceEntryJSONRequestBody defines body for DeleteTraceEntry for application/json ContentType.
type DeleteTraceEntryJSONRequestBody = TraceEntry

// CreateTraceEntryJSONRequestBody defines body for CreateTraceEntry for application/json ContentType.
type CreateTraceEntryJSONRequestBody = TraceEntry

// CreateUserlistJSONRequestBody defines body for CreateUserlist for application/json ContentType.
type CreateUserlistJSONRequestBody = Userlist

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = User

// ReplaceUserJSONRequestBody defines body for ReplaceUser for application/json ContentType.
type ReplaceUserJSONRequestBody = User

// PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody defines body for PostServicesHaproxyRuntimeAclsParentNameEntries for application/json ContentType.
type PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody = AclFileEntry

// AddPayloadRuntimeACLJSONRequestBody defines body for AddPayloadRuntimeACL for application/json ContentType.
type AddPayloadRuntimeACLJSONRequestBody = AclFilesEntries

// AddRuntimeServerJSONRequestBody defines body for AddRuntimeServer for application/json ContentType.
type AddRuntimeServerJSONRequestBody = RuntimeAddServer

// ReplaceRuntimeServerJSONRequestBody defines body for ReplaceRuntimeServer for application/json ContentType.
type ReplaceRuntimeServerJSONRequestBody = RuntimeServer

// AddPayloadRuntimeMapJSONRequestBody defines body for AddPayloadRuntimeMap for application/json ContentType.
type AddPayloadRuntimeMapJSONRequestBody = MapEntries

// AddMapEntryJSONRequestBody defines body for AddMapEntry for application/json ContentType.
type AddMapEntryJSONRequestBody = MapEntry

// ReplaceRuntimeMapEntryJSONRequestBody defines body for ReplaceRuntimeMapEntry for application/json ContentType.
type ReplaceRuntimeMapEntryJSONRequestBody ReplaceRuntimeMapEntryJSONBody

// CreateCaFileMultipartRequestBody defines body for CreateCaFile for multipart/form-data ContentType.
type CreateCaFileMultipartRequestBody CreateCaFileMultipartBody

// SetCaFileMultipartRequestBody defines body for SetCaFile for multipart/form-data ContentType.
type SetCaFileMultipartRequestBody SetCaFileMultipartBody

// AddCaEntryMultipartRequestBody defines body for AddCaEntry for multipart/form-data ContentType.
type AddCaEntryMultipartRequestBody AddCaEntryMultipartBody

// CreateCertMultipartRequestBody defines body for CreateCert for multipart/form-data ContentType.
type CreateCertMultipartRequestBody CreateCertMultipartBody

// ReplaceCertMultipartRequestBody defines body for ReplaceCert for multipart/form-data ContentType.
type ReplaceCertMultipartRequestBody ReplaceCertMultipartBody

// CreateCrlMultipartRequestBody defines body for CreateCrl for multipart/form-data ContentType.
type CreateCrlMultipartRequestBody CreateCrlMultipartBody

// ReplaceCrlMultipartRequestBody defines body for ReplaceCrl for multipart/form-data ContentType.
type ReplaceCrlMultipartRequestBody ReplaceCrlMultipartBody

// AddCrtListEntryJSONRequestBody defines body for AddCrtListEntry for application/json ContentType.
type AddCrtListEntryJSONRequestBody = SslCrtListEntry

// SetStickTableEntriesJSONRequestBody defines body for SetStickTableEntries for application/json ContentType.
type SetStickTableEntriesJSONRequestBody SetStickTableEntriesJSONBody

// CreateSiteJSONRequestBody defines body for CreateSite for application/json ContentType.
type CreateSiteJSONRequestBody = Site

// ReplaceSiteJSONRequestBody defines body for ReplaceSite for application/json ContentType.
type ReplaceSiteJSONRequestBody = Site

// CreateSpoeMultipartRequestBody defines body for CreateSpoe for multipart/form-data ContentType.
type CreateSpoeMultipartRequestBody CreateSpoeMultipartBody

// CreateSpoeScopeJSONRequestBody defines body for CreateSpoeScope for application/json ContentType.
type CreateSpoeScopeJSONRequestBody = SpoeScope

// CreateSpoeAgentJSONRequestBody defines body for CreateSpoeAgent for application/json ContentType.
type CreateSpoeAgentJSONRequestBody = SpoeAgent

// ReplaceSpoeAgentJSONRequestBody defines body for ReplaceSpoeAgent for application/json ContentType.
type ReplaceSpoeAgentJSONRequestBody = SpoeAgent

// CreateSpoeGroupJSONRequestBody defines body for CreateSpoeGroup for application/json ContentType.
type CreateSpoeGroupJSONRequestBody = SpoeGroup

// ReplaceSpoeGroupJSONRequestBody defines body for ReplaceSpoeGroup for application/json ContentType.
type ReplaceSpoeGroupJSONRequestBody = SpoeGroup

// CreateSpoeMessageJSONRequestBody defines body for CreateSpoeMessage for application/json ContentType.
type CreateSpoeMessageJSONRequestBody = SpoeMessage

// ReplaceSpoeMessageJSONRequestBody defines body for ReplaceSpoeMessage for application/json ContentType.
type ReplaceSpoeMessageJSONRequestBody = SpoeMessage

// CreateStorageGeneralFileMultipartRequestBody defines body for CreateStorageGeneralFile for multipart/form-data ContentType.
type CreateStorageGeneralFileMultipartRequestBody CreateStorageGeneralFileMultipartBody

// ReplaceStorageGeneralFileMultipartRequestBody defines body for ReplaceStorageGeneralFile for multipart/form-data ContentType.
type ReplaceStorageGeneralFileMultipartRequestBody ReplaceStorageGeneralFileMultipartBody

// CreateStorageMapFileMultipartRequestBody defines body for CreateStorageMapFile for multipart/form-data ContentType.
type CreateStorageMapFileMultipartRequestBody CreateStorageMapFileMultipartBody

// ReplaceStorageMapFileTextRequestBody defines body for ReplaceStorageMapFile for text/plain ContentType.
type ReplaceStorageMapFileTextRequestBody = ReplaceStorageMapFileTextBody

// CreateStorageSSLCertificateMultipartRequestBody defines body for CreateStorageSSLCertificate for multipart/form-data ContentType.
type CreateStorageSSLCertificateMultipartRequestBody CreateStorageSSLCertificateMultipartBody

// ReplaceStorageSSLCertificateTextRequestBody defines body for ReplaceStorageSSLCertificate for text/plain ContentType.
type ReplaceStorageSSLCertificateTextRequestBody = ReplaceStorageSSLCertificateTextBody

// CreateStorageSSLCrtListFileMultipartRequestBody defines body for CreateStorageSSLCrtListFile for multipart/form-data ContentType.
type CreateStorageSSLCrtListFileMultipartRequestBody CreateStorageSSLCrtListFileMultipartBody

// ReplaceStorageSSLCrtListFileTextRequestBody defines body for ReplaceStorageSSLCrtListFile for text/plain ContentType.
type ReplaceStorageSSLCrtListFileTextRequestBody = ReplaceStorageSSLCrtListFileTextBody

// CreateStorageSSLCrtListEntryJSONRequestBody defines body for CreateStorageSSLCrtListEntry for application/json ContentType.
type CreateStorageSSLCrtListEntryJSONRequestBody = SslCrtListEntry

// Getter for additional properties for Error. Returns the specified
// element and whether it was found
func (a Error) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Error
func (a *Error) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Error to handle AdditionalProperties
func (a *Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &a.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
		delete(object, "code")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Error to handle AdditionalProperties
func (a Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["code"], err = json.Marshal(a.Code)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'code': %w", err)
	}

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAPIEndpoints request
	GetAPIEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClusterWithBody request with any body
	PostClusterWithBody(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCluster(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditClusterWithBody request with any body
	EditClusterWithBody(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCluster(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitiateCertificateRefresh request
	InitiateCertificateRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfo request
	GetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAWSRegions request
	GetAWSRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAWSRegionWithBody request with any body
	CreateAWSRegionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAWSRegion(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAWSRegion request
	DeleteAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAWSRegion request
	GetAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAWSRegionWithBody request with any body
	ReplaceAWSRegionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAWSRegion(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsuls request
	GetConsuls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConsulWithBody request with any body
	CreateConsulWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConsul(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConsul request
	DeleteConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsul request
	GetConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceConsulWithBody request with any body
	ReplaceConsulWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceConsul(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesEndpoints request
	GetServicesEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHaproxyEndpoints request
	GetHaproxyEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationEndpoints request
	GetConfigurationEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAcmeProviders request
	GetAcmeProviders(ctx context.Context, params *GetAcmeProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAcmeProviderWithBody request with any body
	CreateAcmeProviderWithBody(ctx context.Context, params *CreateAcmeProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAcmeProvider(ctx context.Context, params *CreateAcmeProviderParams, body CreateAcmeProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAcmeProvider request
	DeleteAcmeProvider(ctx context.Context, name string, params *DeleteAcmeProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAcmeProvider request
	GetAcmeProvider(ctx context.Context, name string, params *GetAcmeProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditAcmeProviderWithBody request with any body
	EditAcmeProviderWithBody(ctx context.Context, name string, params *EditAcmeProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditAcmeProvider(ctx context.Context, name string, params *EditAcmeProviderParams, body EditAcmeProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackends request
	GetBackends(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackendWithBody request with any body
	CreateBackendWithBody(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackend(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackend request
	DeleteBackend(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackend request
	GetBackend(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBackendWithBody request with any body
	ReplaceBackendWithBody(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBackend(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclBackend request
	GetAllAclBackend(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclBackendWithBody request with any body
	ReplaceAllAclBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclBackend(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclBackend request
	DeleteAclBackend(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclBackend request
	GetAclBackend(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclBackendWithBody request with any body
	CreateAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclBackend(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclBackendWithBody request with any body
	ReplaceAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllFilterBackend request
	GetAllFilterBackend(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllFilterBackendWithBody request with any body
	ReplaceAllFilterBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllFilterBackend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilterBackend request
	DeleteFilterBackend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterBackend request
	GetFilterBackend(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFilterBackendWithBody request with any body
	CreateFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFilterBackend(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFilterBackendWithBody request with any body
	ReplaceFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFilterBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPAfterResponseRuleBackend request
	GetAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPAfterResponseRuleBackendWithBody request with any body
	ReplaceAllHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPAfterResponseRuleBackend request
	DeleteHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPAfterResponseRuleBackend request
	GetHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPAfterResponseRuleBackendWithBody request with any body
	CreateHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPAfterResponseRuleBackendWithBody request with any body
	ReplaceHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPCheckBackend request
	GetAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPCheckBackendWithBody request with any body
	ReplaceAllHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPCheckBackend request
	DeleteHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPCheckBackend request
	GetHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPCheckBackendWithBody request with any body
	CreateHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPCheckBackendWithBody request with any body
	ReplaceHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPErrorRuleBackend request
	GetAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPErrorRuleBackendWithBody request with any body
	ReplaceAllHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorRuleBackend request
	DeleteHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorRuleBackend request
	GetHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorRuleBackendWithBody request with any body
	CreateHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorRuleBackendWithBody request with any body
	ReplaceHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPRequestRuleBackend request
	GetAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPRequestRuleBackendWithBody request with any body
	ReplaceAllHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPRequestRuleBackend request
	DeleteHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPRequestRuleBackend request
	GetHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPRequestRuleBackendWithBody request with any body
	CreateHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPRequestRuleBackendWithBody request with any body
	ReplaceHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPResponseRuleBackend request
	GetAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPResponseRuleBackendWithBody request with any body
	ReplaceAllHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPResponseRuleBackend request
	DeleteHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPResponseRuleBackend request
	GetHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPResponseRuleBackendWithBody request with any body
	CreateHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPResponseRuleBackendWithBody request with any body
	ReplaceHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetBackend request
	GetAllLogTargetBackend(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetBackendWithBody request with any body
	ReplaceAllLogTargetBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetBackend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetBackend request
	DeleteLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetBackend request
	GetLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetBackendWithBody request with any body
	CreateLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetBackendWithBody request with any body
	ReplaceLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerSwitchingRules request
	GetServerSwitchingRules(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerSwitchingRulesWithBody request with any body
	ReplaceServerSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerSwitchingRule request
	DeleteServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerSwitchingRule request
	GetServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerSwitchingRuleWithBody request with any body
	CreateServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerSwitchingRuleWithBody request with any body
	ReplaceServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerTemplates request
	GetServerTemplates(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerTemplateWithBody request with any body
	CreateServerTemplateWithBody(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerTemplate(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerTemplate request
	DeleteServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerTemplate request
	GetServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerTemplateWithBody request with any body
	ReplaceServerTemplateWithBody(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerBackend request
	GetAllServerBackend(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerBackendWithBody request with any body
	CreateServerBackendWithBody(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerBackend(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerBackend request
	DeleteServerBackend(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerBackend request
	GetServerBackend(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerBackendWithBody request with any body
	ReplaceServerBackendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerBackend(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickRules request
	GetStickRules(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStickRulesWithBody request with any body
	ReplaceStickRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStickRules(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStickRule request
	DeleteStickRule(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickRule request
	GetStickRule(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStickRuleWithBody request with any body
	CreateStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStickRule(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStickRuleWithBody request with any body
	ReplaceStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStickRule(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPCheckBackend request
	GetAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPCheckBackendWithBody request with any body
	ReplaceAllTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPCheckBackend request
	DeleteTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPCheckBackend request
	GetTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPCheckBackendWithBody request with any body
	CreateTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPCheckBackendWithBody request with any body
	ReplaceTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPRequestRuleBackend request
	GetAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPRequestRuleBackendWithBody request with any body
	ReplaceAllTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPRequestRuleBackend request
	DeleteTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPRequestRuleBackend request
	GetTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPRequestRuleBackendWithBody request with any body
	CreateTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPRequestRuleBackendWithBody request with any body
	ReplaceTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPResponseRuleBackend request
	GetAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPResponseRuleBackendWithBody request with any body
	ReplaceAllTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPResponseRuleBackend request
	DeleteTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPResponseRuleBackend request
	GetTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPResponseRuleBackendWithBody request with any body
	CreateTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPResponseRuleBackendWithBody request with any body
	ReplaceTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaches request
	GetCaches(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCacheWithBody request with any body
	CreateCacheWithBody(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCache(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCache request
	DeleteCache(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCache request
	GetCache(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceCacheWithBody request with any body
	ReplaceCacheWithBody(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceCache(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtLoads request
	GetCrtLoads(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCrtLoadWithBody request with any body
	CreateCrtLoadWithBody(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCrtLoad(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCrtLoad request
	DeleteCrtLoad(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtLoad request
	GetCrtLoad(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceCrtLoadWithBody request with any body
	ReplaceCrtLoadWithBody(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceCrtLoad(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtStores request
	GetCrtStores(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCrtStoreWithBody request with any body
	CreateCrtStoreWithBody(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCrtStore(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCrtStore request
	DeleteCrtStore(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtStore request
	GetCrtStore(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCrtStoreWithBody request with any body
	EditCrtStoreWithBody(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCrtStore(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultsSections request
	GetDefaultsSections(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddDefaultsSectionWithBody request with any body
	AddDefaultsSectionWithBody(ctx context.Context, params *AddDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddDefaultsSection(ctx context.Context, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDefaultsSectionWithBody request with any body
	CreateDefaultsSectionWithBody(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDefaultsSection(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDefaultsSection request
	DeleteDefaultsSection(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultsSection request
	GetDefaultsSection(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDefaultsSectionWithBody request with any body
	ReplaceDefaultsSectionWithBody(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDefaultsSection(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclDefaults request
	GetAllAclDefaults(ctx context.Context, parentName ParentName, params *GetAllAclDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclDefaultsWithBody request with any body
	ReplaceAllAclDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllAclDefaultsParams, body ReplaceAllAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclDefaults request
	DeleteAclDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteAclDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclDefaults request
	GetAclDefaults(ctx context.Context, parentName ParentName, index int, params *GetAclDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclDefaultsWithBody request with any body
	CreateAclDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclDefaults(ctx context.Context, parentName ParentName, index int, params *CreateAclDefaultsParams, body CreateAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclDefaultsWithBody request with any body
	ReplaceAclDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceAclDefaultsParams, body ReplaceAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPAfterResponseRuleDefaults request
	GetAllHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPAfterResponseRuleDefaultsWithBody request with any body
	ReplaceAllHTTPAfterResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, body ReplaceAllHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPAfterResponseRuleDefaults request
	DeleteHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPAfterResponseRuleDefaults request
	GetHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPAfterResponseRuleDefaultsWithBody request with any body
	CreateHTTPAfterResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, body CreateHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPAfterResponseRuleDefaultsWithBody request with any body
	ReplaceHTTPAfterResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, body ReplaceHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPCheckDefaults request
	GetAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPCheckDefaultsWithBody request with any body
	ReplaceAllHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPCheckDefaults request
	DeleteHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPCheckDefaults request
	GetHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPCheckDefaultsWithBody request with any body
	CreateHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPCheckDefaultsWithBody request with any body
	ReplaceHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPErrorRuleDefaults request
	GetAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPErrorRuleDefaultsWithBody request with any body
	ReplaceAllHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorRuleDefaults request
	DeleteHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorRuleDefaults request
	GetHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorRuleDefaultsWithBody request with any body
	CreateHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorRuleDefaultsWithBody request with any body
	ReplaceHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPRequestRuleDefaults request
	GetAllHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPRequestRuleDefaultsWithBody request with any body
	ReplaceAllHTTPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, body ReplaceAllHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPRequestRuleDefaults request
	DeleteHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPRequestRuleDefaults request
	GetHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPRequestRuleDefaultsWithBody request with any body
	CreateHTTPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, body CreateHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPRequestRuleDefaultsWithBody request with any body
	ReplaceHTTPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, body ReplaceHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPResponseRuleDefaults request
	GetAllHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPResponseRuleDefaultsWithBody request with any body
	ReplaceAllHTTPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, body ReplaceAllHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPResponseRuleDefaults request
	DeleteHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPResponseRuleDefaults request
	GetHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPResponseRuleDefaultsWithBody request with any body
	CreateHTTPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, body CreateHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPResponseRuleDefaultsWithBody request with any body
	ReplaceHTTPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, body ReplaceHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetDefaults request
	GetAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetDefaultsWithBody request with any body
	ReplaceAllLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetDefaults request
	DeleteLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetDefaults request
	GetLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetDefaultsWithBody request with any body
	CreateLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetDefaultsWithBody request with any body
	ReplaceLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllQUICInitialRuleDefaults request
	GetAllQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllQUICInitialRuleDefaultsWithBody request with any body
	ReplaceAllQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteQUICInitialRuleDefaults request
	DeleteQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQUICInitialRuleDefaults request
	GetQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateQUICInitialRuleDefaultsWithBody request with any body
	CreateQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceQUICInitialRuleDefaultsWithBody request with any body
	ReplaceQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPCheckDefaults request
	GetAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPCheckDefaultsWithBody request with any body
	ReplaceAllTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPCheckDefaults request
	DeleteTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPCheckDefaults request
	GetTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPCheckDefaultsWithBody request with any body
	CreateTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPCheckDefaultsWithBody request with any body
	ReplaceTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPRequestRuleDefaults request
	GetAllTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPRequestRuleDefaultsWithBody request with any body
	ReplaceAllTCPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, body ReplaceAllTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPRequestRuleDefaults request
	DeleteTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPRequestRuleDefaults request
	GetTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPRequestRuleDefaultsWithBody request with any body
	CreateTCPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, body CreateTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPRequestRuleDefaultsWithBody request with any body
	ReplaceTCPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, body ReplaceTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPResponseRuleDefaults request
	GetAllTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPResponseRuleDefaultsWithBody request with any body
	ReplaceAllTCPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, body ReplaceAllTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPResponseRuleDefaults request
	DeleteTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPResponseRuleDefaults request
	GetTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPResponseRuleDefaultsWithBody request with any body
	CreateTCPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, body CreateTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPResponseRuleDefaultsWithBody request with any body
	ReplaceTCPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, body ReplaceTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFCGIApps request
	GetFCGIApps(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFCGIAppWithBody request with any body
	CreateFCGIAppWithBody(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFCGIApp(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFCGIApp request
	DeleteFCGIApp(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFCGIApp request
	GetFCGIApp(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFCGIAppWithBody request with any body
	ReplaceFCGIAppWithBody(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFCGIApp(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclFCGIApp request
	GetAllAclFCGIApp(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclFCGIAppWithBody request with any body
	ReplaceAllAclFCGIAppWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclFCGIApp(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclFCGIApp request
	DeleteAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclFCGIApp request
	GetAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclFCGIAppWithBody request with any body
	CreateAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclFCGIAppWithBody request with any body
	ReplaceAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFrontends request
	GetFrontends(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFrontendWithBody request with any body
	CreateFrontendWithBody(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFrontend(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFrontend request
	DeleteFrontend(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFrontend request
	GetFrontend(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFrontendWithBody request with any body
	ReplaceFrontendWithBody(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFrontend(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclFrontend request
	GetAllAclFrontend(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclFrontendWithBody request with any body
	ReplaceAllAclFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclFrontend request
	DeleteAclFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclFrontend request
	GetAclFrontend(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclFrontendWithBody request with any body
	CreateAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclFrontend(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclFrontendWithBody request with any body
	ReplaceAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackendSwitchingRules request
	GetBackendSwitchingRules(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBackendSwitchingRulesWithBody request with any body
	ReplaceBackendSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBackendSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackendSwitchingRule request
	DeleteBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackendSwitchingRule request
	GetBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackendSwitchingRuleWithBody request with any body
	CreateBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBackendSwitchingRuleWithBody request with any body
	ReplaceBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBindFrontend request
	GetAllBindFrontend(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBindFrontendWithBody request with any body
	CreateBindFrontendWithBody(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBindFrontend(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBindFrontend request
	DeleteBindFrontend(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindFrontend request
	GetBindFrontend(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBindFrontendWithBody request with any body
	ReplaceBindFrontendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBindFrontend(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeclareCaptures request
	GetDeclareCaptures(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDeclareCapturesWithBody request with any body
	ReplaceDeclareCapturesWithBody(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDeclareCaptures(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDeclareCapture request
	DeleteDeclareCapture(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeclareCapture request
	GetDeclareCapture(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeclareCaptureWithBody request with any body
	CreateDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDeclareCapture(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDeclareCaptureWithBody request with any body
	ReplaceDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDeclareCapture(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllFilterFrontend request
	GetAllFilterFrontend(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllFilterFrontendWithBody request with any body
	ReplaceAllFilterFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllFilterFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilterFrontend request
	DeleteFilterFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterFrontend request
	GetFilterFrontend(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFilterFrontendWithBody request with any body
	CreateFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFilterFrontend(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFilterFrontendWithBody request with any body
	ReplaceFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFilterFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPAfterResponseRuleFrontend request
	GetAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPAfterResponseRuleFrontendWithBody request with any body
	ReplaceAllHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPAfterResponseRuleFrontend request
	DeleteHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPAfterResponseRuleFrontend request
	GetHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPAfterResponseRuleFrontendWithBody request with any body
	CreateHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPAfterResponseRuleFrontendWithBody request with any body
	ReplaceHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPErrorRuleFrontend request
	GetAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPErrorRuleFrontendWithBody request with any body
	ReplaceAllHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorRuleFrontend request
	DeleteHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorRuleFrontend request
	GetHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorRuleFrontendWithBody request with any body
	CreateHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorRuleFrontendWithBody request with any body
	ReplaceHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPRequestRuleFrontend request
	GetAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPRequestRuleFrontendWithBody request with any body
	ReplaceAllHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPRequestRuleFrontend request
	DeleteHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPRequestRuleFrontend request
	GetHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPRequestRuleFrontendWithBody request with any body
	CreateHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPRequestRuleFrontendWithBody request with any body
	ReplaceHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPResponseRuleFrontend request
	GetAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPResponseRuleFrontendWithBody request with any body
	ReplaceAllHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPResponseRuleFrontend request
	DeleteHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPResponseRuleFrontend request
	GetHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPResponseRuleFrontendWithBody request with any body
	CreateHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPResponseRuleFrontendWithBody request with any body
	ReplaceHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetFrontend request
	GetAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetFrontendWithBody request with any body
	ReplaceAllLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetFrontend request
	DeleteLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetFrontend request
	GetLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetFrontendWithBody request with any body
	CreateLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetFrontendWithBody request with any body
	ReplaceLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllQUICInitialRuleFrontend request
	GetAllQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllQUICInitialRuleFrontendWithBody request with any body
	ReplaceAllQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteQUICInitialRuleFrontend request
	DeleteQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetQUICInitialRuleFrontend request
	GetQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateQUICInitialRuleFrontendWithBody request with any body
	CreateQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceQUICInitialRuleFrontendWithBody request with any body
	ReplaceQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSSLFrontUses request
	GetAllSSLFrontUses(ctx context.Context, parentName ParentName, params *GetAllSSLFrontUsesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSSLFrontUseWithBody request with any body
	CreateSSLFrontUseWithBody(ctx context.Context, parentName ParentName, params *CreateSSLFrontUseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSSLFrontUse(ctx context.Context, parentName ParentName, params *CreateSSLFrontUseParams, body CreateSSLFrontUseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSSLFrontUse request
	DeleteSSLFrontUse(ctx context.Context, parentName ParentName, index int, params *DeleteSSLFrontUseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSSLFrontUse request
	GetSSLFrontUse(ctx context.Context, parentName ParentName, index int, params *GetSSLFrontUseParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSSLFrontUseWithBody request with any body
	ReplaceSSLFrontUseWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSSLFrontUse(ctx context.Context, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, body ReplaceSSLFrontUseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPRequestRuleFrontend request
	GetAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPRequestRuleFrontendWithBody request with any body
	ReplaceAllTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPRequestRuleFrontend request
	DeleteTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPRequestRuleFrontend request
	GetTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPRequestRuleFrontendWithBody request with any body
	CreateTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPRequestRuleFrontendWithBody request with any body
	ReplaceTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobal request
	GetGlobal(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceGlobalWithBody request with any body
	ReplaceGlobalWithBody(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceGlobal(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetGlobal request
	GetAllLogTargetGlobal(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetGlobalWithBody request with any body
	ReplaceAllLogTargetGlobalWithBody(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetGlobal(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetGlobal request
	DeleteLogTargetGlobal(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetGlobal request
	GetLogTargetGlobal(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetGlobalWithBody request with any body
	CreateLogTargetGlobalWithBody(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetGlobal(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetGlobalWithBody request with any body
	ReplaceLogTargetGlobalWithBody(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetGlobal(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceGroupWithBody request with any body
	ReplaceGroupWithBody(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceGroup(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorsSections request
	GetHTTPErrorsSections(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorsSectionWithBody request with any body
	CreateHTTPErrorsSectionWithBody(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorsSection(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorsSection request
	DeleteHTTPErrorsSection(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorsSection request
	GetHTTPErrorsSection(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorsSectionWithBody request with any body
	ReplaceHTTPErrorsSectionWithBody(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorsSection(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogForwards request
	GetLogForwards(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogForwardWithBody request with any body
	CreateLogForwardWithBody(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogForward(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogForward request
	DeleteLogForward(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogForward request
	GetLogForward(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogForwardWithBody request with any body
	ReplaceLogForwardWithBody(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogForward(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBindLogForward request
	GetAllBindLogForward(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBindLogForwardWithBody request with any body
	CreateBindLogForwardWithBody(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBindLogForward(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBindLogForward request
	DeleteBindLogForward(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindLogForward request
	GetBindLogForward(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBindLogForwardWithBody request with any body
	ReplaceBindLogForwardWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBindLogForward(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDgramBinds request
	GetDgramBinds(ctx context.Context, parentName ParentName, params *GetDgramBindsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDgramBindWithBody request with any body
	CreateDgramBindWithBody(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDgramBind(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDgramBind request
	DeleteDgramBind(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDgramBind request
	GetDgramBind(ctx context.Context, parentName ParentName, name string, params *GetDgramBindParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDgramBindWithBody request with any body
	ReplaceDgramBindWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDgramBind(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetLogForward request
	GetAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetLogForwardWithBody request with any body
	ReplaceAllLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetLogForward request
	DeleteLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetLogForward request
	GetLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetLogForwardWithBody request with any body
	CreateLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetLogForwardWithBody request with any body
	ReplaceLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogProfiles request
	GetLogProfiles(ctx context.Context, params *GetLogProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogProfileWithBody request with any body
	CreateLogProfileWithBody(ctx context.Context, params *CreateLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogProfile(ctx context.Context, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogProfile request
	DeleteLogProfile(ctx context.Context, name string, params *DeleteLogProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogProfile request
	GetLogProfile(ctx context.Context, name string, params *GetLogProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditLogProfileWithBody request with any body
	EditLogProfileWithBody(ctx context.Context, name string, params *EditLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditLogProfile(ctx context.Context, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailerEntries request
	GetMailerEntries(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMailerEntryWithBody request with any body
	CreateMailerEntryWithBody(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMailerEntry(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMailerEntry request
	DeleteMailerEntry(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailerEntry request
	GetMailerEntry(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceMailerEntryWithBody request with any body
	ReplaceMailerEntryWithBody(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceMailerEntry(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailersSections request
	GetMailersSections(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMailersSectionWithBody request with any body
	CreateMailersSectionWithBody(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMailersSection(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMailersSection request
	DeleteMailersSection(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailersSection request
	GetMailersSection(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditMailersSectionWithBody request with any body
	EditMailersSectionWithBody(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditMailersSection(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNameservers request
	GetNameservers(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNameserverWithBody request with any body
	CreateNameserverWithBody(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNameserver(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNameserver request
	DeleteNameserver(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNameserver request
	GetNameserver(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceNameserverWithBody request with any body
	ReplaceNameserverWithBody(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceNameserver(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerEntries request
	GetPeerEntries(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePeerEntryWithBody request with any body
	CreatePeerEntryWithBody(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePeerEntry(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePeerEntry request
	DeletePeerEntry(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerEntry request
	GetPeerEntry(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplacePeerEntryWithBody request with any body
	ReplacePeerEntryWithBody(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplacePeerEntry(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerSections request
	GetPeerSections(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePeerWithBody request with any body
	CreatePeerWithBody(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePeer(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePeer request
	DeletePeer(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerSection request
	GetPeerSection(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBindPeer request
	GetAllBindPeer(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBindPeerWithBody request with any body
	CreateBindPeerWithBody(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBindPeer(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBindPeer request
	DeleteBindPeer(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindPeer request
	GetBindPeer(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBindPeerWithBody request with any body
	ReplaceBindPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBindPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetPeer request
	GetAllLogTargetPeer(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetPeerWithBody request with any body
	ReplaceAllLogTargetPeerWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetPeer(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetPeer request
	DeleteLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetPeer request
	GetLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetPeerWithBody request with any body
	CreateLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetPeerWithBody request with any body
	ReplaceLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerPeer request
	GetAllServerPeer(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerPeerWithBody request with any body
	CreateServerPeerWithBody(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerPeer(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerPeer request
	DeleteServerPeer(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerPeer request
	GetServerPeer(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerPeerWithBody request with any body
	ReplaceServerPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTables request
	GetTables(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTable request
	DeleteTable(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTableWithBody request with any body
	ReplaceTableWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTable(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrograms request
	GetPrograms(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProgramWithBody request with any body
	CreateProgramWithBody(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProgram(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgram request
	DeleteProgram(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgram request
	GetProgram(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceProgramWithBody request with any body
	ReplaceProgramWithBody(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceProgram(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHAProxyConfiguration request
	GetHAProxyConfiguration(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostHAProxyConfigurationWithBody request with any body
	PostHAProxyConfigurationWithBody(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostHAProxyConfigurationWithTextBody(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResolvers request
	GetResolvers(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResolverWithBody request with any body
	CreateResolverWithBody(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResolver(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResolver request
	DeleteResolver(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResolver request
	GetResolver(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceResolverWithBody request with any body
	ReplaceResolverWithBody(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceResolver(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRings request
	GetRings(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRingWithBody request with any body
	CreateRingWithBody(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRing(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRing request
	DeleteRing(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRing request
	GetRing(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRingWithBody request with any body
	ReplaceRingWithBody(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRing(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerRing request
	GetAllServerRing(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerRingWithBody request with any body
	CreateServerRingWithBody(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerRing(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerRing request
	DeleteServerRing(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerRing request
	GetServerRing(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerRingWithBody request with any body
	ReplaceServerRingWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerRing(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTraces request
	DeleteTraces(ctx context.Context, params *DeleteTracesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTraces request
	GetTraces(ctx context.Context, params *GetTracesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTracesWithBody request with any body
	CreateTracesWithBody(ctx context.Context, params *CreateTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTraces(ctx context.Context, params *CreateTracesParams, body CreateTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTracesWithBody request with any body
	ReplaceTracesWithBody(ctx context.Context, params *ReplaceTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTraces(ctx context.Context, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTraceEntryWithBody request with any body
	DeleteTraceEntryWithBody(ctx context.Context, params *DeleteTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTraceEntry(ctx context.Context, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTraceEntryWithBody request with any body
	CreateTraceEntryWithBody(ctx context.Context, params *CreateTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTraceEntry(ctx context.Context, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserlists request
	GetUserlists(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserlistWithBody request with any body
	CreateUserlistWithBody(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserlist(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserlist request
	DeleteUserlist(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserlist request
	GetUserlist(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceUserWithBody request with any body
	ReplaceUserWithBody(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceUser(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationVersion request
	GetConfigurationVersion(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReloads request
	GetReloads(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReload request
	GetReload(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeEndpoints request
	GetRuntimeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAcls request
	GetServicesHaproxyRuntimeAcls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAclsId request
	GetServicesHaproxyRuntimeAclsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntries request
	GetServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody request with any body
	PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPayloadRuntimeACLWithBody request with any body
	AddPayloadRuntimeACLWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPayloadRuntimeACL(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServicesHaproxyRuntimeAclsParentNameEntriesId request
	DeleteServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntriesId request
	GetServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAcmeStatus request
	GetAcmeStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RenewAcmeCertificate request
	RenewAcmeCertificate(ctx context.Context, params *RenewAcmeCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRuntimeServer request
	GetAllRuntimeServer(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRuntimeServerWithBody request with any body
	AddRuntimeServerWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRuntimeServer(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuntimeServer request
	DeleteRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeServer request
	GetRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRuntimeServerWithBody request with any body
	ReplaceRuntimeServerWithBody(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRuntimeServer(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHaproxyProcessInfo request
	GetHaproxyProcessInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRuntimeMapFiles request
	GetAllRuntimeMapFiles(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearRuntimeMap request
	ClearRuntimeMap(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneRuntimeMap request
	GetOneRuntimeMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPayloadRuntimeMapWithBody request with any body
	AddPayloadRuntimeMapWithBody(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPayloadRuntimeMap(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowRuntimeMap request
	ShowRuntimeMap(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMapEntryWithBody request with any body
	AddMapEntryWithBody(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMapEntry(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuntimeMapEntry request
	DeleteRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeMapEntry request
	GetRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRuntimeMapEntryWithBody request with any body
	ReplaceRuntimeMapEntryWithBody(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCaFiles request
	GetAllCaFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCaFileWithBody request with any body
	CreateCaFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCaFile request
	DeleteCaFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaFile request
	GetCaFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCaFileWithBody request with any body
	SetCaFileWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCaEntryWithBody request with any body
	AddCaEntryWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaEntry request
	GetCaEntry(ctx context.Context, name string, index int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCerts request
	GetAllCerts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCertWithBody request with any body
	CreateCertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCert request
	DeleteCert(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCert request
	GetCert(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceCertWithBody request with any body
	ReplaceCertWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCrl request
	GetAllCrl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCrlWithBody request with any body
	CreateCrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCrl request
	DeleteCrl(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrl request
	GetCrl(ctx context.Context, name string, params *GetCrlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceCrlWithBody request with any body
	ReplaceCrlWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCrtLists request
	GetAllCrtLists(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCrtListEntry request
	DeleteCrtListEntry(ctx context.Context, params *DeleteCrtListEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllCrtListEntries request
	GetAllCrtListEntries(ctx context.Context, params *GetAllCrtListEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCrtListEntryWithBody request with any body
	AddCrtListEntryWithBody(ctx context.Context, params *AddCrtListEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCrtListEntry(ctx context.Context, params *AddCrtListEntryParams, body AddCrtListEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickTables request
	GetStickTables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickTable request
	GetStickTable(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickTableEntries request
	GetStickTableEntries(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetStickTableEntriesWithBody request with any body
	SetStickTableEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetStickTableEntries(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSites request
	GetSites(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSiteWithBody request with any body
	CreateSiteWithBody(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSite(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSite request
	DeleteSite(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSite request
	GetSite(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSiteWithBody request with any body
	ReplaceSiteWithBody(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSite(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeEndpoints request
	GetSpoeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeFiles request
	GetAllSpoeFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeWithBody request with any body
	CreateSpoeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeFile request
	DeleteSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneSpoeFile request
	GetOneSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeScope request
	GetAllSpoeScope(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeScopeWithBody request with any body
	CreateSpoeScopeWithBody(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeScope(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeScope request
	DeleteSpoeScope(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeScope request
	GetSpoeScope(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeAgent request
	GetAllSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeAgentWithBody request with any body
	CreateSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeAgent request
	DeleteSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeAgent request
	GetSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSpoeAgentWithBody request with any body
	ReplaceSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeGroup request
	GetAllSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeGroupWithBody request with any body
	CreateSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeGroup request
	DeleteSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeGroup request
	GetSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSpoeGroupWithBody request with any body
	ReplaceSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeMessage request
	GetAllSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeMessageWithBody request with any body
	CreateSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeMessage request
	DeleteSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeMessage request
	GetSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSpoeMessageWithBody request with any body
	ReplaceSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeTransaction request
	GetAllSpoeTransaction(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartSpoeTransaction request
	StartSpoeTransaction(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeTransaction request
	DeleteSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeTransaction request
	GetSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitSpoeTransaction request
	CommitSpoeTransaction(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeConfigurationVersion request
	GetSpoeConfigurationVersion(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatsEndpoints request
	GetStatsEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageEndpoints request
	GetStorageEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageGeneralFiles request
	GetAllStorageGeneralFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageGeneralFileWithBody request with any body
	CreateStorageGeneralFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageGeneralFile request
	DeleteStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageGeneralFile request
	GetOneStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageGeneralFileWithBody request with any body
	ReplaceStorageGeneralFileWithBody(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageMapFiles request
	GetAllStorageMapFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageMapFileWithBody request with any body
	CreateStorageMapFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageMap request
	DeleteStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageMap request
	GetOneStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageMapFileWithBody request with any body
	ReplaceStorageMapFileWithBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStorageMapFileWithTextBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageSSLCertificates request
	GetAllStorageSSLCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageSSLCertificateWithBody request with any body
	CreateStorageSSLCertificateWithBody(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageSSLCertificate request
	DeleteStorageSSLCertificate(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageSSLCertificate request
	GetOneStorageSSLCertificate(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageSSLCertificateWithBody request with any body
	ReplaceStorageSSLCertificateWithBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStorageSSLCertificateWithTextBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageSSLCrtListFiles request
	GetAllStorageSSLCrtListFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageSSLCrtListFileWithBody request with any body
	CreateStorageSSLCrtListFileWithBody(ctx context.Context, params *CreateStorageSSLCrtListFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageSSLCrtListFile request
	DeleteStorageSSLCrtListFile(ctx context.Context, name string, params *DeleteStorageSSLCrtListFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageSSLCrtListFile request
	GetOneStorageSSLCrtListFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageSSLCrtListFileWithBody request with any body
	ReplaceStorageSSLCrtListFileWithBody(ctx context.Context, name string, params *ReplaceStorageSSLCrtListFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStorageSSLCrtListFileWithTextBody(ctx context.Context, name string, params *ReplaceStorageSSLCrtListFileParams, body ReplaceStorageSSLCrtListFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageSSLCrtListEntry request
	DeleteStorageSSLCrtListEntry(ctx context.Context, name string, params *DeleteStorageSSLCrtListEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageSSLCrtListEntries request
	GetStorageSSLCrtListEntries(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageSSLCrtListEntryWithBody request with any body
	CreateStorageSSLCrtListEntryWithBody(ctx context.Context, name string, params *CreateStorageSSLCrtListEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStorageSSLCrtListEntry(ctx context.Context, name string, params *CreateStorageSSLCrtListEntryParams, body CreateStorageSSLCrtListEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactions request
	GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartTransaction request
	StartTransaction(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransaction request
	DeleteTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransaction request
	GetTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitTransaction request
	CommitTransaction(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpecification request
	GetSpecification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiv3Specification request
	GetOpenapiv3Specification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAPIEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClusterWithBody(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCluster(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditClusterWithBody(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditClusterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCluster(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditClusterRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateCertificateRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateCertificateRefreshRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAWSRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAWSRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAWSRegionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAWSRegionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAWSRegion(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAWSRegionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAWSRegionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAWSRegionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAWSRegionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAWSRegionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAWSRegion(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAWSRegionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsuls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsulsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsulWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsulRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsul(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsulRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConsulRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsulRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceConsulWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceConsulRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceConsul(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceConsulRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHaproxyEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHaproxyEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAcmeProviders(ctx context.Context, params *GetAcmeProvidersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAcmeProvidersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAcmeProviderWithBody(ctx context.Context, params *CreateAcmeProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAcmeProviderRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAcmeProvider(ctx context.Context, params *CreateAcmeProviderParams, body CreateAcmeProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAcmeProviderRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAcmeProvider(ctx context.Context, name string, params *DeleteAcmeProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAcmeProviderRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAcmeProvider(ctx context.Context, name string, params *GetAcmeProviderParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAcmeProviderRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAcmeProviderWithBody(ctx context.Context, name string, params *EditAcmeProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAcmeProviderRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditAcmeProvider(ctx context.Context, name string, params *EditAcmeProviderParams, body EditAcmeProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditAcmeProviderRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackends(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackendWithBody(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackend(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackend(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackend(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendWithBody(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackend(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclBackend(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclBackend(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclBackend(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclBackend(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclBackend(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllFilterBackend(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllFilterBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterBackend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilterBackend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFilterBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterBackend(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterBackend(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPAfterResponseRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPCheckBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPErrorRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPRequestRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPResponseRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetBackend(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetBackend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerSwitchingRules(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerSwitchingRulesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRulesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRulesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerTemplates(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerTemplatesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerTemplateWithBody(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerTemplateRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerTemplate(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerTemplateRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerTemplateRequest(c.Server, parentName, prefix, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerTemplateRequest(c.Server, parentName, prefix, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerTemplateWithBody(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerTemplateRequestWithBody(c.Server, parentName, prefix, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerTemplateRequest(c.Server, parentName, prefix, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerBackend(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerBackendWithBody(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerBackend(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerBackend(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerBackendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerBackend(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerBackendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerBackendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerBackendRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerBackend(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerBackendRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickRules(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickRulesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRulesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRules(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRulesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStickRule(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStickRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickRule(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStickRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStickRule(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStickRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRule(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPCheckBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPRequestRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPResponseRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPResponseRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPResponseRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaches(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCachesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCacheWithBody(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCacheRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCache(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCacheRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCache(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCacheRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCache(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCacheRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCacheWithBody(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCacheRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCache(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCacheRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtLoads(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtLoadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtLoadWithBody(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtLoadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtLoad(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtLoadRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCrtLoad(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCrtLoadRequest(c.Server, certificate, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtLoad(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtLoadRequest(c.Server, certificate, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCrtLoadWithBody(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCrtLoadRequestWithBody(c.Server, certificate, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCrtLoad(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCrtLoadRequest(c.Server, certificate, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtStores(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtStoresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtStoreWithBody(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtStoreRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtStore(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtStoreRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCrtStore(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCrtStoreRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtStore(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtStoreRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCrtStoreWithBody(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCrtStoreRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCrtStore(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCrtStoreRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultsSections(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultsSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDefaultsSectionWithBody(ctx context.Context, params *AddDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDefaultsSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddDefaultsSection(ctx context.Context, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddDefaultsSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDefaultsSectionWithBody(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDefaultsSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDefaultsSection(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDefaultsSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDefaultsSection(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDefaultsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultsSection(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDefaultsSectionWithBody(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDefaultsSectionRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDefaultsSection(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDefaultsSectionRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclDefaults(ctx context.Context, parentName ParentName, params *GetAllAclDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllAclDefaultsParams, body ReplaceAllAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteAclDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclDefaults(ctx context.Context, parentName ParentName, index int, params *GetAclDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclDefaults(ctx context.Context, parentName ParentName, index int, params *CreateAclDefaultsParams, body CreateAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceAclDefaultsParams, body ReplaceAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPAfterResponseRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, body ReplaceAllHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPAfterResponseRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPAfterResponseRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, body CreateHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, body ReplaceHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPCheckDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPErrorRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPRequestRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, body ReplaceAllHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPRequestRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPRequestRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, body CreateHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, body ReplaceHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPResponseRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, body ReplaceAllHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPResponseRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPResponseRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, body CreateHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, body ReplaceHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllQUICInitialRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllQUICInitialRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllQUICInitialRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQUICInitialRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQUICInitialRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQUICInitialRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQUICInitialRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceQUICInitialRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceQUICInitialRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceQUICInitialRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceQUICInitialRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPCheckDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPRequestRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, body ReplaceAllTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPRequestRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPRequestRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, body CreateTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, body ReplaceTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPResponseRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPResponseRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, body ReplaceAllTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPResponseRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPResponseRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPResponseRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPResponseRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, body CreateTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPResponseRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPResponseRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPResponseRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPResponseRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, body ReplaceTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPResponseRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFCGIApps(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFCGIAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFCGIAppWithBody(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFCGIAppRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFCGIApp(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFCGIAppRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFCGIApp(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFCGIAppRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFCGIApp(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFCGIAppRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFCGIAppWithBody(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFCGIAppRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFCGIApp(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFCGIAppRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclFCGIApp(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclFCGIAppRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFCGIAppWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFCGIAppRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFCGIApp(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFCGIAppRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclFCGIAppRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclFCGIAppRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFCGIAppRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFCGIAppRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFCGIAppRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFCGIAppRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFrontends(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFrontendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFrontendWithBody(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFrontendRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFrontend(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFrontendRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFrontend(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFrontendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFrontend(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFrontendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFrontendWithBody(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFrontendRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFrontend(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFrontendRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclFrontend(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclFrontend(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFrontend(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackendSwitchingRules(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendSwitchingRulesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRulesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRulesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackendSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBindFrontend(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBindFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindFrontendWithBody(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindFrontend(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBindFrontend(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBindFrontendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindFrontend(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindFrontendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindFrontendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindFrontendRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindFrontend(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindFrontendRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeclareCaptures(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeclareCapturesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCapturesWithBody(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCapturesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCaptures(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCapturesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDeclareCapture(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeclareCaptureRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeclareCapture(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeclareCaptureRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeclareCaptureRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeclareCapture(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeclareCaptureRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCaptureRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCapture(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCaptureRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllFilterFrontend(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllFilterFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilterFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFilterFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterFrontend(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterFrontend(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPErrorRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPRequestRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPResponseRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllQUICInitialRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllQUICInitialRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllQUICInitialRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteQUICInitialRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetQUICInitialRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQUICInitialRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateQUICInitialRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceQUICInitialRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceQUICInitialRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceQUICInitialRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceQUICInitialRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSSLFrontUses(ctx context.Context, parentName ParentName, params *GetAllSSLFrontUsesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSSLFrontUsesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSSLFrontUseWithBody(ctx context.Context, parentName ParentName, params *CreateSSLFrontUseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSSLFrontUseRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSSLFrontUse(ctx context.Context, parentName ParentName, params *CreateSSLFrontUseParams, body CreateSSLFrontUseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSSLFrontUseRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSSLFrontUse(ctx context.Context, parentName ParentName, index int, params *DeleteSSLFrontUseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSSLFrontUseRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSSLFrontUse(ctx context.Context, parentName ParentName, index int, params *GetSSLFrontUseParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSSLFrontUseRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSSLFrontUseWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSSLFrontUseRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSSLFrontUse(ctx context.Context, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, body ReplaceSSLFrontUseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSSLFrontUseRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPRequestRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobal(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGlobalWithBody(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGlobalRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGlobal(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGlobalRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetGlobal(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetGlobalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetGlobalWithBody(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetGlobalRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetGlobal(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetGlobalRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetGlobal(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetGlobalRequest(c.Server, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetGlobal(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetGlobalRequest(c.Server, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetGlobalWithBody(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetGlobalRequestWithBody(c.Server, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetGlobal(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetGlobalRequest(c.Server, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetGlobalWithBody(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetGlobalRequestWithBody(c.Server, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetGlobal(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetGlobalRequest(c.Server, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGroupWithBody(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGroupRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGroup(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGroupRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorsSections(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorsSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorsSectionWithBody(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorsSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorsSection(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorsSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorsSection(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorsSection(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorsSectionWithBody(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorsSectionRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorsSection(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorsSectionRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogForwards(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogForwardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogForwardWithBody(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogForwardRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogForward(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogForwardRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogForward(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogForwardRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogForward(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogForwardRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogForwardWithBody(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogForwardRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogForward(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogForwardRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBindLogForward(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBindLogForwardRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindLogForwardWithBody(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindLogForwardRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindLogForward(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindLogForwardRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBindLogForward(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBindLogForwardRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindLogForward(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindLogForwardRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindLogForwardWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindLogForwardRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindLogForward(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindLogForwardRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDgramBinds(ctx context.Context, parentName ParentName, params *GetDgramBindsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDgramBindsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDgramBindWithBody(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDgramBindRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDgramBind(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDgramBindRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDgramBind(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDgramBindRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDgramBind(ctx context.Context, parentName ParentName, name string, params *GetDgramBindParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDgramBindRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDgramBindWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDgramBindRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDgramBind(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDgramBindRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetLogForwardRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetLogForwardRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetLogForwardRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetLogForwardRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetLogForwardRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetLogForwardRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetLogForwardRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetLogForwardRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetLogForwardRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogProfiles(ctx context.Context, params *GetLogProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogProfilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogProfileWithBody(ctx context.Context, params *CreateLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogProfileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogProfile(ctx context.Context, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogProfileRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogProfile(ctx context.Context, name string, params *DeleteLogProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogProfileRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogProfile(ctx context.Context, name string, params *GetLogProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogProfileRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLogProfileWithBody(ctx context.Context, name string, params *EditLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLogProfileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditLogProfile(ctx context.Context, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditLogProfileRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailerEntries(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailerEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailerEntryWithBody(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailerEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailerEntry(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailerEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMailerEntry(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMailerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailerEntry(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceMailerEntryWithBody(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceMailerEntryRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceMailerEntry(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceMailerEntryRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailersSections(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailersSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailersSectionWithBody(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailersSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailersSection(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailersSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMailersSection(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMailersSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailersSection(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailersSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMailersSectionWithBody(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMailersSectionRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMailersSection(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMailersSectionRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNameservers(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNameserversRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNameserverWithBody(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNameserverRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNameserver(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNameserverRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNameserver(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNameserverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNameserver(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNameserverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceNameserverWithBody(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceNameserverRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceNameserver(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceNameserverRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerEntries(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeerEntryWithBody(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeerEntry(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePeerEntry(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePeerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerEntry(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplacePeerEntryWithBody(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplacePeerEntryRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplacePeerEntry(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplacePeerEntryRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerSections(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeerWithBody(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeer(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePeer(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePeerRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerSection(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBindPeer(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBindPeerRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindPeerWithBody(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindPeerRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindPeer(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindPeerRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBindPeer(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBindPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindPeer(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindPeerRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindPeerRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetPeer(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetPeerRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetPeerWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetPeerRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetPeer(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetPeerRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetPeerRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetPeerRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetPeerRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetPeerRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetPeerRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetPeerRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerPeer(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerPeerRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerPeerWithBody(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerPeerRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerPeer(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerPeerRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerPeer(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerPeer(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerPeerRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerPeerRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTables(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTablesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTable(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTableRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTableWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTableRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTable(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTableRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrograms(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramWithBody(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgram(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgram(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgram(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceProgramWithBody(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceProgramRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceProgram(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceProgramRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHAProxyConfiguration(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHAProxyConfigurationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHAProxyConfigurationWithBody(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHAProxyConfigurationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHAProxyConfigurationWithTextBody(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHAProxyConfigurationRequestWithTextBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResolvers(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResolversRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResolverWithBody(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResolverRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResolver(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResolverRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResolver(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResolverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResolver(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResolverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResolverWithBody(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResolverRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResolver(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResolverRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRings(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRingWithBody(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRingRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRing(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRingRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRing(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRingRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRing(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRingRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRingWithBody(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRingRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRing(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRingRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerRing(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerRingRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerRingWithBody(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRingRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerRing(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRingRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerRing(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerRingRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerRing(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerRingRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerRingWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerRingRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerRing(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerRingRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTraces(ctx context.Context, params *DeleteTracesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTracesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTraces(ctx context.Context, params *GetTracesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTracesWithBody(ctx context.Context, params *CreateTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTracesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTraces(ctx context.Context, params *CreateTracesParams, body CreateTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTracesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTracesWithBody(ctx context.Context, params *ReplaceTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTracesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTraces(ctx context.Context, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTracesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTraceEntryWithBody(ctx context.Context, params *DeleteTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTraceEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTraceEntry(ctx context.Context, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTraceEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTraceEntryWithBody(ctx context.Context, params *CreateTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTraceEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTraceEntry(ctx context.Context, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTraceEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserlists(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserlistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserlistWithBody(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserlistRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserlist(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserlistRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserlist(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserlistRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserlist(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserlistRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceUserWithBody(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceUserRequestWithBody(c.Server, username, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceUser(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceUserRequest(c.Server, username, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationVersion(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationVersionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReloads(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReloadsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReload(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReloadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAcls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAclsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsParentNameEntriesRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeACLWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeACLRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeACL(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeACLRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAcmeStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAcmeStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RenewAcmeCertificate(ctx context.Context, params *RenewAcmeCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenewAcmeCertificateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRuntimeServer(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRuntimeServerRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRuntimeServerWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuntimeServerRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRuntimeServer(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuntimeServerRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuntimeServerRequest(c.Server, parentName, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeServerRequest(c.Server, parentName, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeServerWithBody(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeServerRequestWithBody(c.Server, parentName, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeServer(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeServerRequest(c.Server, parentName, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHaproxyProcessInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHaproxyProcessInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRuntimeMapFiles(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRuntimeMapFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearRuntimeMap(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearRuntimeMapRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneRuntimeMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneRuntimeMapRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeMapWithBody(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeMapRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeMap(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeMapRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowRuntimeMap(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowRuntimeMapRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMapEntryWithBody(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMapEntryRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMapEntry(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMapEntryRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuntimeMapEntryRequest(c.Server, parentName, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeMapEntryRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeMapEntryWithBody(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeMapEntryRequestWithBody(c.Server, parentName, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeMapEntryRequest(c.Server, parentName, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCaFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCaFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCaFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCaFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCaFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCaFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCaFileWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCaFileRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCaEntryWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCaEntryRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaEntry(ctx context.Context, name string, index int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaEntryRequest(c.Server, name, index)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCerts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCertsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCert(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCertRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCert(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCertWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCertRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCrl(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCrlRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrlWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrlRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCrl(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCrlRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrl(ctx context.Context, name string, params *GetCrlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrlRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCrlWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCrlRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCrtLists(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCrtListsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCrtListEntry(ctx context.Context, params *DeleteCrtListEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCrtListEntryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllCrtListEntries(ctx context.Context, params *GetAllCrtListEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllCrtListEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCrtListEntryWithBody(ctx context.Context, params *AddCrtListEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCrtListEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCrtListEntry(ctx context.Context, params *AddCrtListEntryParams, body AddCrtListEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCrtListEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickTables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickTablesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickTable(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickTableRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickTableEntries(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickTableEntriesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetStickTableEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetStickTableEntriesRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetStickTableEntries(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetStickTableEntriesRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSites(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSiteWithBody(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSite(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSite(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSiteRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSite(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSiteRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSiteWithBody(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSiteRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSite(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSiteRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneSpoeFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeScope(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeScopeRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeScopeWithBody(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeScopeRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeScope(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeScopeRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeScope(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeScopeRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeScope(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeScopeRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeAgentRequest(c.Server, parentName, scopeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeAgentRequestWithBody(c.Server, parentName, scopeName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeAgentRequest(c.Server, parentName, scopeName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeAgentRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeAgentRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeAgentRequestWithBody(c.Server, parentName, scopeName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeAgentRequest(c.Server, parentName, scopeName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeGroupRequest(c.Server, parentName, scopeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeGroupRequestWithBody(c.Server, parentName, scopeName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeGroupRequest(c.Server, parentName, scopeName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeGroupRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeGroupRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeGroupRequestWithBody(c.Server, parentName, scopeName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeGroupRequest(c.Server, parentName, scopeName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeMessageRequest(c.Server, parentName, scopeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeMessageRequestWithBody(c.Server, parentName, scopeName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeMessageRequest(c.Server, parentName, scopeName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeMessageRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeMessageRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeMessageRequestWithBody(c.Server, parentName, scopeName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeMessageRequest(c.Server, parentName, scopeName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeTransaction(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeTransactionRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartSpoeTransaction(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartSpoeTransactionRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeTransactionRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeTransactionRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitSpoeTransaction(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitSpoeTransactionRequest(c.Server, parentName, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeConfigurationVersion(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeConfigurationVersionRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatsEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageGeneralFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageGeneralFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageGeneralFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageGeneralFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageGeneralFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageGeneralFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageGeneralFileWithBody(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageGeneralFileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageMapFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageMapFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageMapFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageMapFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageMapRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageMapRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageMapFileWithBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageMapFileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageMapFileWithTextBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageMapFileRequestWithTextBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageSSLCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageSSLCertificatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageSSLCertificateWithBody(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageSSLCertificateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageSSLCertificate(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageSSLCertificateRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageSSLCertificate(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageSSLCertificateRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageSSLCertificateWithBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageSSLCertificateRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageSSLCertificateWithTextBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageSSLCertificateRequestWithTextBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageSSLCrtListFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageSSLCrtListFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageSSLCrtListFileWithBody(ctx context.Context, params *CreateStorageSSLCrtListFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageSSLCrtListFileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageSSLCrtListFile(ctx context.Context, name string, params *DeleteStorageSSLCrtListFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageSSLCrtListFileRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageSSLCrtListFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageSSLCrtListFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageSSLCrtListFileWithBody(ctx context.Context, name string, params *ReplaceStorageSSLCrtListFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageSSLCrtListFileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageSSLCrtListFileWithTextBody(ctx context.Context, name string, params *ReplaceStorageSSLCrtListFileParams, body ReplaceStorageSSLCrtListFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageSSLCrtListFileRequestWithTextBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageSSLCrtListEntry(ctx context.Context, name string, params *DeleteStorageSSLCrtListEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageSSLCrtListEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageSSLCrtListEntries(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageSSLCrtListEntriesRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageSSLCrtListEntryWithBody(ctx context.Context, name string, params *CreateStorageSSLCrtListEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageSSLCrtListEntryRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageSSLCrtListEntry(ctx context.Context, name string, params *CreateStorageSSLCrtListEntryParams, body CreateStorageSSLCrtListEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageSSLCrtListEntryRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartTransaction(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartTransactionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitTransaction(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitTransactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpecification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpecificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiv3Specification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiv3SpecificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAPIEndpointsRequest generates requests for GetAPIEndpoints
func NewGetAPIEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, params *DeleteClusterParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Configuration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configuration", runtime.ParamLocationQuery, *params.Configuration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClusterRequest calls the generic PostCluster builder with application/json body
func NewPostClusterRequest(server string, params *PostClusterParams, body PostClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClusterRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostClusterRequestWithBody generates requests for PostCluster with any type of body
func NewPostClusterRequestWithBody(server string, params *PostClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Configuration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configuration", runtime.ParamLocationQuery, *params.Configuration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdvertisedAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "advertised_address", runtime.ParamLocationQuery, *params.AdvertisedAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdvertisedPort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "advertised_port", runtime.ParamLocationQuery, *params.AdvertisedPort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditClusterRequest calls the generic EditCluster builder with application/json body
func NewEditClusterRequest(server string, params *EditClusterParams, body EditClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditClusterRequestWithBody(server, params, "application/json", bodyReader)
}

// NewEditClusterRequestWithBody generates requests for EditCluster with any type of body
func NewEditClusterRequestWithBody(server string, params *EditClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInitiateCertificateRefreshRequest generates requests for InitiateCertificateRefresh
func NewInitiateCertificateRefreshRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/certificate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfoRequest generates requests for GetInfo
func NewGetInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAWSRegionsRequest generates requests for GetAWSRegions
func NewGetAWSRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAWSRegionRequest calls the generic CreateAWSRegion builder with application/json body
func NewCreateAWSRegionRequest(server string, body CreateAWSRegionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAWSRegionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAWSRegionRequestWithBody generates requests for CreateAWSRegion with any type of body
func NewCreateAWSRegionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAWSRegionRequest generates requests for DeleteAWSRegion
func NewDeleteAWSRegionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAWSRegionRequest generates requests for GetAWSRegion
func NewGetAWSRegionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAWSRegionRequest calls the generic ReplaceAWSRegion builder with application/json body
func NewReplaceAWSRegionRequest(server string, id string, body ReplaceAWSRegionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAWSRegionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceAWSRegionRequestWithBody generates requests for ReplaceAWSRegion with any type of body
func NewReplaceAWSRegionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConsulsRequest generates requests for GetConsuls
func NewGetConsulsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateConsulRequest calls the generic CreateConsul builder with application/json body
func NewCreateConsulRequest(server string, body CreateConsulJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConsulRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConsulRequestWithBody generates requests for CreateConsul with any type of body
func NewCreateConsulRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConsulRequest generates requests for DeleteConsul
func NewDeleteConsulRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsulRequest generates requests for GetConsul
func NewGetConsulRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceConsulRequest calls the generic ReplaceConsul builder with application/json body
func NewReplaceConsulRequest(server string, id string, body ReplaceConsulJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceConsulRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceConsulRequestWithBody generates requests for ReplaceConsul with any type of body
func NewReplaceConsulRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicesEndpointsRequest generates requests for GetServicesEndpoints
func NewGetServicesEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHaproxyEndpointsRequest generates requests for GetHaproxyEndpoints
func NewGetHaproxyEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationEndpointsRequest generates requests for GetConfigurationEndpoints
func NewGetConfigurationEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAcmeProvidersRequest generates requests for GetAcmeProviders
func NewGetAcmeProvidersRequest(server string, params *GetAcmeProvidersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/acme")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAcmeProviderRequest calls the generic CreateAcmeProvider builder with application/json body
func NewCreateAcmeProviderRequest(server string, params *CreateAcmeProviderParams, body CreateAcmeProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAcmeProviderRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAcmeProviderRequestWithBody generates requests for CreateAcmeProvider with any type of body
func NewCreateAcmeProviderRequestWithBody(server string, params *CreateAcmeProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/acme")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAcmeProviderRequest generates requests for DeleteAcmeProvider
func NewDeleteAcmeProviderRequest(server string, name string, params *DeleteAcmeProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/acme/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAcmeProviderRequest generates requests for GetAcmeProvider
func NewGetAcmeProviderRequest(server string, name string, params *GetAcmeProviderParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/acme/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditAcmeProviderRequest calls the generic EditAcmeProvider builder with application/json body
func NewEditAcmeProviderRequest(server string, name string, params *EditAcmeProviderParams, body EditAcmeProviderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditAcmeProviderRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditAcmeProviderRequestWithBody generates requests for EditAcmeProvider with any type of body
func NewEditAcmeProviderRequestWithBody(server string, name string, params *EditAcmeProviderParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/acme/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBackendsRequest generates requests for GetBackends
func NewGetBackendsRequest(server string, params *GetBackendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackendRequest calls the generic CreateBackend builder with application/json body
func NewCreateBackendRequest(server string, params *CreateBackendParams, body CreateBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackendRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBackendRequestWithBody generates requests for CreateBackend with any type of body
func NewCreateBackendRequestWithBody(server string, params *CreateBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBackendRequest generates requests for DeleteBackend
func NewDeleteBackendRequest(server string, name string, params *DeleteBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackendRequest generates requests for GetBackend
func NewGetBackendRequest(server string, name string, params *GetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBackendRequest calls the generic ReplaceBackend builder with application/json body
func NewReplaceBackendRequest(server string, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBackendRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceBackendRequestWithBody generates requests for ReplaceBackend with any type of body
func NewReplaceBackendRequestWithBody(server string, name string, params *ReplaceBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclBackendRequest generates requests for GetAllAclBackend
func NewGetAllAclBackendRequest(server string, parentName ParentName, params *GetAllAclBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclBackendRequest calls the generic ReplaceAllAclBackend builder with application/json body
func NewReplaceAllAclBackendRequest(server string, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclBackendRequestWithBody generates requests for ReplaceAllAclBackend with any type of body
func NewReplaceAllAclBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclBackendRequest generates requests for DeleteAclBackend
func NewDeleteAclBackendRequest(server string, parentName ParentName, index int, params *DeleteAclBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclBackendRequest generates requests for GetAclBackend
func NewGetAclBackendRequest(server string, parentName ParentName, index int, params *GetAclBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclBackendRequest calls the generic CreateAclBackend builder with application/json body
func NewCreateAclBackendRequest(server string, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclBackendRequestWithBody generates requests for CreateAclBackend with any type of body
func NewCreateAclBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclBackendRequest calls the generic ReplaceAclBackend builder with application/json body
func NewReplaceAclBackendRequest(server string, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclBackendRequestWithBody generates requests for ReplaceAclBackend with any type of body
func NewReplaceAclBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllFilterBackendRequest generates requests for GetAllFilterBackend
func NewGetAllFilterBackendRequest(server string, parentName ParentName, params *GetAllFilterBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllFilterBackendRequest calls the generic ReplaceAllFilterBackend builder with application/json body
func NewReplaceAllFilterBackendRequest(server string, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllFilterBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllFilterBackendRequestWithBody generates requests for ReplaceAllFilterBackend with any type of body
func NewReplaceAllFilterBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFilterBackendRequest generates requests for DeleteFilterBackend
func NewDeleteFilterBackendRequest(server string, parentName ParentName, index int, params *DeleteFilterBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterBackendRequest generates requests for GetFilterBackend
func NewGetFilterBackendRequest(server string, parentName ParentName, index int, params *GetFilterBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFilterBackendRequest calls the generic CreateFilterBackend builder with application/json body
func NewCreateFilterBackendRequest(server string, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFilterBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateFilterBackendRequestWithBody generates requests for CreateFilterBackend with any type of body
func NewCreateFilterBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceFilterBackendRequest calls the generic ReplaceFilterBackend builder with application/json body
func NewReplaceFilterBackendRequest(server string, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFilterBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceFilterBackendRequestWithBody generates requests for ReplaceFilterBackend with any type of body
func NewReplaceFilterBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPAfterResponseRuleBackendRequest generates requests for GetAllHTTPAfterResponseRuleBackend
func NewGetAllHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPAfterResponseRuleBackendRequest calls the generic ReplaceAllHTTPAfterResponseRuleBackend builder with application/json body
func NewReplaceAllHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody generates requests for ReplaceAllHTTPAfterResponseRuleBackend with any type of body
func NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPAfterResponseRuleBackendRequest generates requests for DeleteHTTPAfterResponseRuleBackend
func NewDeleteHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPAfterResponseRuleBackendRequest generates requests for GetHTTPAfterResponseRuleBackend
func NewGetHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPAfterResponseRuleBackendRequest calls the generic CreateHTTPAfterResponseRuleBackend builder with application/json body
func NewCreateHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPAfterResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPAfterResponseRuleBackendRequestWithBody generates requests for CreateHTTPAfterResponseRuleBackend with any type of body
func NewCreateHTTPAfterResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPAfterResponseRuleBackendRequest calls the generic ReplaceHTTPAfterResponseRuleBackend builder with application/json body
func NewReplaceHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPAfterResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPAfterResponseRuleBackendRequestWithBody generates requests for ReplaceHTTPAfterResponseRuleBackend with any type of body
func NewReplaceHTTPAfterResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPCheckBackendRequest generates requests for GetAllHTTPCheckBackend
func NewGetAllHTTPCheckBackendRequest(server string, parentName ParentName, params *GetAllHTTPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPCheckBackendRequest calls the generic ReplaceAllHTTPCheckBackend builder with application/json body
func NewReplaceAllHTTPCheckBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPCheckBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPCheckBackendRequestWithBody generates requests for ReplaceAllHTTPCheckBackend with any type of body
func NewReplaceAllHTTPCheckBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPCheckBackendRequest generates requests for DeleteHTTPCheckBackend
func NewDeleteHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPCheckBackendRequest generates requests for GetHTTPCheckBackend
func NewGetHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *GetHTTPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPCheckBackendRequest calls the generic CreateHTTPCheckBackend builder with application/json body
func NewCreateHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPCheckBackendRequestWithBody generates requests for CreateHTTPCheckBackend with any type of body
func NewCreateHTTPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPCheckBackendRequest calls the generic ReplaceHTTPCheckBackend builder with application/json body
func NewReplaceHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPCheckBackendRequestWithBody generates requests for ReplaceHTTPCheckBackend with any type of body
func NewReplaceHTTPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPErrorRuleBackendRequest generates requests for GetAllHTTPErrorRuleBackend
func NewGetAllHTTPErrorRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPErrorRuleBackendRequest calls the generic ReplaceAllHTTPErrorRuleBackend builder with application/json body
func NewReplaceAllHTTPErrorRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPErrorRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPErrorRuleBackendRequestWithBody generates requests for ReplaceAllHTTPErrorRuleBackend with any type of body
func NewReplaceAllHTTPErrorRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorRuleBackendRequest generates requests for DeleteHTTPErrorRuleBackend
func NewDeleteHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorRuleBackendRequest generates requests for GetHTTPErrorRuleBackend
func NewGetHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorRuleBackendRequest calls the generic CreateHTTPErrorRuleBackend builder with application/json body
func NewCreateHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorRuleBackendRequestWithBody generates requests for CreateHTTPErrorRuleBackend with any type of body
func NewCreateHTTPErrorRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPErrorRuleBackendRequest calls the generic ReplaceHTTPErrorRuleBackend builder with application/json body
func NewReplaceHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorRuleBackendRequestWithBody generates requests for ReplaceHTTPErrorRuleBackend with any type of body
func NewReplaceHTTPErrorRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPRequestRuleBackendRequest generates requests for GetAllHTTPRequestRuleBackend
func NewGetAllHTTPRequestRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPRequestRuleBackendRequest calls the generic ReplaceAllHTTPRequestRuleBackend builder with application/json body
func NewReplaceAllHTTPRequestRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPRequestRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPRequestRuleBackendRequestWithBody generates requests for ReplaceAllHTTPRequestRuleBackend with any type of body
func NewReplaceAllHTTPRequestRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPRequestRuleBackendRequest generates requests for DeleteHTTPRequestRuleBackend
func NewDeleteHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPRequestRuleBackendRequest generates requests for GetHTTPRequestRuleBackend
func NewGetHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPRequestRuleBackendRequest calls the generic CreateHTTPRequestRuleBackend builder with application/json body
func NewCreateHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPRequestRuleBackendRequestWithBody generates requests for CreateHTTPRequestRuleBackend with any type of body
func NewCreateHTTPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPRequestRuleBackendRequest calls the generic ReplaceHTTPRequestRuleBackend builder with application/json body
func NewReplaceHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPRequestRuleBackendRequestWithBody generates requests for ReplaceHTTPRequestRuleBackend with any type of body
func NewReplaceHTTPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPResponseRuleBackendRequest generates requests for GetAllHTTPResponseRuleBackend
func NewGetAllHTTPResponseRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPResponseRuleBackendRequest calls the generic ReplaceAllHTTPResponseRuleBackend builder with application/json body
func NewReplaceAllHTTPResponseRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPResponseRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPResponseRuleBackendRequestWithBody generates requests for ReplaceAllHTTPResponseRuleBackend with any type of body
func NewReplaceAllHTTPResponseRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPResponseRuleBackendRequest generates requests for DeleteHTTPResponseRuleBackend
func NewDeleteHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPResponseRuleBackendRequest generates requests for GetHTTPResponseRuleBackend
func NewGetHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPResponseRuleBackendRequest calls the generic CreateHTTPResponseRuleBackend builder with application/json body
func NewCreateHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPResponseRuleBackendRequestWithBody generates requests for CreateHTTPResponseRuleBackend with any type of body
func NewCreateHTTPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPResponseRuleBackendRequest calls the generic ReplaceHTTPResponseRuleBackend builder with application/json body
func NewReplaceHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPResponseRuleBackendRequestWithBody generates requests for ReplaceHTTPResponseRuleBackend with any type of body
func NewReplaceHTTPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetBackendRequest generates requests for GetAllLogTargetBackend
func NewGetAllLogTargetBackendRequest(server string, parentName ParentName, params *GetAllLogTargetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetBackendRequest calls the generic ReplaceAllLogTargetBackend builder with application/json body
func NewReplaceAllLogTargetBackendRequest(server string, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetBackendRequestWithBody generates requests for ReplaceAllLogTargetBackend with any type of body
func NewReplaceAllLogTargetBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetBackendRequest generates requests for DeleteLogTargetBackend
func NewDeleteLogTargetBackendRequest(server string, parentName ParentName, index int, params *DeleteLogTargetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetBackendRequest generates requests for GetLogTargetBackend
func NewGetLogTargetBackendRequest(server string, parentName ParentName, index int, params *GetLogTargetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetBackendRequest calls the generic CreateLogTargetBackend builder with application/json body
func NewCreateLogTargetBackendRequest(server string, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetBackendRequestWithBody generates requests for CreateLogTargetBackend with any type of body
func NewCreateLogTargetBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetBackendRequest calls the generic ReplaceLogTargetBackend builder with application/json body
func NewReplaceLogTargetBackendRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetBackendRequestWithBody generates requests for ReplaceLogTargetBackend with any type of body
func NewReplaceLogTargetBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerSwitchingRulesRequest generates requests for GetServerSwitchingRules
func NewGetServerSwitchingRulesRequest(server string, parentName ParentName, params *GetServerSwitchingRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerSwitchingRulesRequest calls the generic ReplaceServerSwitchingRules builder with application/json body
func NewReplaceServerSwitchingRulesRequest(server string, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerSwitchingRulesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceServerSwitchingRulesRequestWithBody generates requests for ReplaceServerSwitchingRules with any type of body
func NewReplaceServerSwitchingRulesRequestWithBody(server string, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerSwitchingRuleRequest generates requests for DeleteServerSwitchingRule
func NewDeleteServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerSwitchingRuleRequest generates requests for GetServerSwitchingRule
func NewGetServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *GetServerSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerSwitchingRuleRequest calls the generic CreateServerSwitchingRule builder with application/json body
func NewCreateServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateServerSwitchingRuleRequestWithBody generates requests for CreateServerSwitchingRule with any type of body
func NewCreateServerSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceServerSwitchingRuleRequest calls the generic ReplaceServerSwitchingRule builder with application/json body
func NewReplaceServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceServerSwitchingRuleRequestWithBody generates requests for ReplaceServerSwitchingRule with any type of body
func NewReplaceServerSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerTemplatesRequest generates requests for GetServerTemplates
func NewGetServerTemplatesRequest(server string, parentName ParentName, params *GetServerTemplatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerTemplateRequest calls the generic CreateServerTemplate builder with application/json body
func NewCreateServerTemplateRequest(server string, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerTemplateRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerTemplateRequestWithBody generates requests for CreateServerTemplate with any type of body
func NewCreateServerTemplateRequestWithBody(server string, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerTemplateRequest generates requests for DeleteServerTemplate
func NewDeleteServerTemplateRequest(server string, parentName ParentName, prefix string, params *DeleteServerTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerTemplateRequest generates requests for GetServerTemplate
func NewGetServerTemplateRequest(server string, parentName ParentName, prefix string, params *GetServerTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerTemplateRequest calls the generic ReplaceServerTemplate builder with application/json body
func NewReplaceServerTemplateRequest(server string, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerTemplateRequestWithBody(server, parentName, prefix, params, "application/json", bodyReader)
}

// NewReplaceServerTemplateRequestWithBody generates requests for ReplaceServerTemplate with any type of body
func NewReplaceServerTemplateRequestWithBody(server string, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerBackendRequest generates requests for GetAllServerBackend
func NewGetAllServerBackendRequest(server string, parentName ParentName, params *GetAllServerBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerBackendRequest calls the generic CreateServerBackend builder with application/json body
func NewCreateServerBackendRequest(server string, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerBackendRequestWithBody generates requests for CreateServerBackend with any type of body
func NewCreateServerBackendRequestWithBody(server string, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerBackendRequest generates requests for DeleteServerBackend
func NewDeleteServerBackendRequest(server string, parentName ParentName, name string, params *DeleteServerBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerBackendRequest generates requests for GetServerBackend
func NewGetServerBackendRequest(server string, parentName ParentName, name string, params *GetServerBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerBackendRequest calls the generic ReplaceServerBackend builder with application/json body
func NewReplaceServerBackendRequest(server string, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerBackendRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceServerBackendRequestWithBody generates requests for ReplaceServerBackend with any type of body
func NewReplaceServerBackendRequestWithBody(server string, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStickRulesRequest generates requests for GetStickRules
func NewGetStickRulesRequest(server string, parentName ParentName, params *GetStickRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStickRulesRequest calls the generic ReplaceStickRules builder with application/json body
func NewReplaceStickRulesRequest(server string, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceStickRulesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceStickRulesRequestWithBody generates requests for ReplaceStickRules with any type of body
func NewReplaceStickRulesRequestWithBody(server string, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStickRuleRequest generates requests for DeleteStickRule
func NewDeleteStickRuleRequest(server string, parentName ParentName, index int, params *DeleteStickRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStickRuleRequest generates requests for GetStickRule
func NewGetStickRuleRequest(server string, parentName ParentName, index int, params *GetStickRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStickRuleRequest calls the generic CreateStickRule builder with application/json body
func NewCreateStickRuleRequest(server string, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStickRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateStickRuleRequestWithBody generates requests for CreateStickRule with any type of body
func NewCreateStickRuleRequestWithBody(server string, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceStickRuleRequest calls the generic ReplaceStickRule builder with application/json body
func NewReplaceStickRuleRequest(server string, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceStickRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceStickRuleRequestWithBody generates requests for ReplaceStickRule with any type of body
func NewReplaceStickRuleRequestWithBody(server string, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPCheckBackendRequest generates requests for GetAllTCPCheckBackend
func NewGetAllTCPCheckBackendRequest(server string, parentName ParentName, params *GetAllTCPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPCheckBackendRequest calls the generic ReplaceAllTCPCheckBackend builder with application/json body
func NewReplaceAllTCPCheckBackendRequest(server string, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPCheckBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPCheckBackendRequestWithBody generates requests for ReplaceAllTCPCheckBackend with any type of body
func NewReplaceAllTCPCheckBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPCheckBackendRequest generates requests for DeleteTCPCheckBackend
func NewDeleteTCPCheckBackendRequest(server string, parentName ParentName, index int, params *DeleteTCPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPCheckBackendRequest generates requests for GetTCPCheckBackend
func NewGetTCPCheckBackendRequest(server string, parentName ParentName, index int, params *GetTCPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPCheckBackendRequest calls the generic CreateTCPCheckBackend builder with application/json body
func NewCreateTCPCheckBackendRequest(server string, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPCheckBackendRequestWithBody generates requests for CreateTCPCheckBackend with any type of body
func NewCreateTCPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPCheckBackendRequest calls the generic ReplaceTCPCheckBackend builder with application/json body
func NewReplaceTCPCheckBackendRequest(server string, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPCheckBackendRequestWithBody generates requests for ReplaceTCPCheckBackend with any type of body
func NewReplaceTCPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPRequestRuleBackendRequest generates requests for GetAllTCPRequestRuleBackend
func NewGetAllTCPRequestRuleBackendRequest(server string, parentName ParentName, params *GetAllTCPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPRequestRuleBackendRequest calls the generic ReplaceAllTCPRequestRuleBackend builder with application/json body
func NewReplaceAllTCPRequestRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPRequestRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPRequestRuleBackendRequestWithBody generates requests for ReplaceAllTCPRequestRuleBackend with any type of body
func NewReplaceAllTCPRequestRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPRequestRuleBackendRequest generates requests for DeleteTCPRequestRuleBackend
func NewDeleteTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPRequestRuleBackendRequest generates requests for GetTCPRequestRuleBackend
func NewGetTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPRequestRuleBackendRequest calls the generic CreateTCPRequestRuleBackend builder with application/json body
func NewCreateTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPRequestRuleBackendRequestWithBody generates requests for CreateTCPRequestRuleBackend with any type of body
func NewCreateTCPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPRequestRuleBackendRequest calls the generic ReplaceTCPRequestRuleBackend builder with application/json body
func NewReplaceTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPRequestRuleBackendRequestWithBody generates requests for ReplaceTCPRequestRuleBackend with any type of body
func NewReplaceTCPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPResponseRuleBackendRequest generates requests for GetAllTCPResponseRuleBackend
func NewGetAllTCPResponseRuleBackendRequest(server string, parentName ParentName, params *GetAllTCPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPResponseRuleBackendRequest calls the generic ReplaceAllTCPResponseRuleBackend builder with application/json body
func NewReplaceAllTCPResponseRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPResponseRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPResponseRuleBackendRequestWithBody generates requests for ReplaceAllTCPResponseRuleBackend with any type of body
func NewReplaceAllTCPResponseRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPResponseRuleBackendRequest generates requests for DeleteTCPResponseRuleBackend
func NewDeleteTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPResponseRuleBackendRequest generates requests for GetTCPResponseRuleBackend
func NewGetTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPResponseRuleBackendRequest calls the generic CreateTCPResponseRuleBackend builder with application/json body
func NewCreateTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPResponseRuleBackendRequestWithBody generates requests for CreateTCPResponseRuleBackend with any type of body
func NewCreateTCPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPResponseRuleBackendRequest calls the generic ReplaceTCPResponseRuleBackend builder with application/json body
func NewReplaceTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPResponseRuleBackendRequestWithBody generates requests for ReplaceTCPResponseRuleBackend with any type of body
func NewReplaceTCPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCachesRequest generates requests for GetCaches
func NewGetCachesRequest(server string, params *GetCachesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCacheRequest calls the generic CreateCache builder with application/json body
func NewCreateCacheRequest(server string, params *CreateCacheParams, body CreateCacheJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCacheRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCacheRequestWithBody generates requests for CreateCache with any type of body
func NewCreateCacheRequestWithBody(server string, params *CreateCacheParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCacheRequest generates requests for DeleteCache
func NewDeleteCacheRequest(server string, name string, params *DeleteCacheParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCacheRequest generates requests for GetCache
func NewGetCacheRequest(server string, name string, params *GetCacheParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceCacheRequest calls the generic ReplaceCache builder with application/json body
func NewReplaceCacheRequest(server string, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceCacheRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceCacheRequestWithBody generates requests for ReplaceCache with any type of body
func NewReplaceCacheRequestWithBody(server string, name string, params *ReplaceCacheParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCrtLoadsRequest generates requests for GetCrtLoads
func NewGetCrtLoadsRequest(server string, params *GetCrtLoadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCrtLoadRequest calls the generic CreateCrtLoad builder with application/json body
func NewCreateCrtLoadRequest(server string, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCrtLoadRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCrtLoadRequestWithBody generates requests for CreateCrtLoad with any type of body
func NewCreateCrtLoadRequestWithBody(server string, params *CreateCrtLoadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCrtLoadRequest generates requests for DeleteCrtLoad
func NewDeleteCrtLoadRequest(server string, certificate string, params *DeleteCrtLoadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate", runtime.ParamLocationPath, certificate)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCrtLoadRequest generates requests for GetCrtLoad
func NewGetCrtLoadRequest(server string, certificate string, params *GetCrtLoadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate", runtime.ParamLocationPath, certificate)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceCrtLoadRequest calls the generic ReplaceCrtLoad builder with application/json body
func NewReplaceCrtLoadRequest(server string, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceCrtLoadRequestWithBody(server, certificate, params, "application/json", bodyReader)
}

// NewReplaceCrtLoadRequestWithBody generates requests for ReplaceCrtLoad with any type of body
func NewReplaceCrtLoadRequestWithBody(server string, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate", runtime.ParamLocationPath, certificate)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCrtStoresRequest generates requests for GetCrtStores
func NewGetCrtStoresRequest(server string, params *GetCrtStoresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCrtStoreRequest calls the generic CreateCrtStore builder with application/json body
func NewCreateCrtStoreRequest(server string, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCrtStoreRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCrtStoreRequestWithBody generates requests for CreateCrtStore with any type of body
func NewCreateCrtStoreRequestWithBody(server string, params *CreateCrtStoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCrtStoreRequest generates requests for DeleteCrtStore
func NewDeleteCrtStoreRequest(server string, name string, params *DeleteCrtStoreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCrtStoreRequest generates requests for GetCrtStore
func NewGetCrtStoreRequest(server string, name string, params *GetCrtStoreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditCrtStoreRequest calls the generic EditCrtStore builder with application/json body
func NewEditCrtStoreRequest(server string, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCrtStoreRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditCrtStoreRequestWithBody generates requests for EditCrtStore with any type of body
func NewEditCrtStoreRequestWithBody(server string, name string, params *EditCrtStoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultsSectionsRequest generates requests for GetDefaultsSections
func NewGetDefaultsSectionsRequest(server string, params *GetDefaultsSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddDefaultsSectionRequest calls the generic AddDefaultsSection builder with application/json body
func NewAddDefaultsSectionRequest(server string, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddDefaultsSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddDefaultsSectionRequestWithBody generates requests for AddDefaultsSection with any type of body
func NewAddDefaultsSectionRequestWithBody(server string, params *AddDefaultsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDefaultsSectionRequest calls the generic CreateDefaultsSection builder with application/json body
func NewCreateDefaultsSectionRequest(server string, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDefaultsSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateDefaultsSectionRequestWithBody generates requests for CreateDefaultsSection with any type of body
func NewCreateDefaultsSectionRequestWithBody(server string, params *CreateDefaultsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDefaultsSectionRequest generates requests for DeleteDefaultsSection
func NewDeleteDefaultsSectionRequest(server string, name string, params *DeleteDefaultsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultsSectionRequest generates requests for GetDefaultsSection
func NewGetDefaultsSectionRequest(server string, name string, params *GetDefaultsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDefaultsSectionRequest calls the generic ReplaceDefaultsSection builder with application/json body
func NewReplaceDefaultsSectionRequest(server string, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDefaultsSectionRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceDefaultsSectionRequestWithBody generates requests for ReplaceDefaultsSection with any type of body
func NewReplaceDefaultsSectionRequestWithBody(server string, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclDefaultsRequest generates requests for GetAllAclDefaults
func NewGetAllAclDefaultsRequest(server string, parentName ParentName, params *GetAllAclDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclDefaultsRequest calls the generic ReplaceAllAclDefaults builder with application/json body
func NewReplaceAllAclDefaultsRequest(server string, parentName ParentName, params *ReplaceAllAclDefaultsParams, body ReplaceAllAclDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclDefaultsRequestWithBody generates requests for ReplaceAllAclDefaults with any type of body
func NewReplaceAllAclDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclDefaultsRequest generates requests for DeleteAclDefaults
func NewDeleteAclDefaultsRequest(server string, parentName ParentName, index int, params *DeleteAclDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclDefaultsRequest generates requests for GetAclDefaults
func NewGetAclDefaultsRequest(server string, parentName ParentName, index int, params *GetAclDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclDefaultsRequest calls the generic CreateAclDefaults builder with application/json body
func NewCreateAclDefaultsRequest(server string, parentName ParentName, index int, params *CreateAclDefaultsParams, body CreateAclDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclDefaultsRequestWithBody generates requests for CreateAclDefaults with any type of body
func NewCreateAclDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateAclDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclDefaultsRequest calls the generic ReplaceAclDefaults builder with application/json body
func NewReplaceAclDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceAclDefaultsParams, body ReplaceAclDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclDefaultsRequestWithBody generates requests for ReplaceAclDefaults with any type of body
func NewReplaceAclDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPAfterResponseRuleDefaultsRequest generates requests for GetAllHTTPAfterResponseRuleDefaults
func NewGetAllHTTPAfterResponseRuleDefaultsRequest(server string, parentName ParentName, params *GetAllHTTPAfterResponseRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPAfterResponseRuleDefaultsRequest calls the generic ReplaceAllHTTPAfterResponseRuleDefaults builder with application/json body
func NewReplaceAllHTTPAfterResponseRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, body ReplaceAllHTTPAfterResponseRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPAfterResponseRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPAfterResponseRuleDefaultsRequestWithBody generates requests for ReplaceAllHTTPAfterResponseRuleDefaults with any type of body
func NewReplaceAllHTTPAfterResponseRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPAfterResponseRuleDefaultsRequest generates requests for DeleteHTTPAfterResponseRuleDefaults
func NewDeleteHTTPAfterResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPAfterResponseRuleDefaultsRequest generates requests for GetHTTPAfterResponseRuleDefaults
func NewGetHTTPAfterResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetHTTPAfterResponseRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPAfterResponseRuleDefaultsRequest calls the generic CreateHTTPAfterResponseRuleDefaults builder with application/json body
func NewCreateHTTPAfterResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, body CreateHTTPAfterResponseRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPAfterResponseRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPAfterResponseRuleDefaultsRequestWithBody generates requests for CreateHTTPAfterResponseRuleDefaults with any type of body
func NewCreateHTTPAfterResponseRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPAfterResponseRuleDefaultsRequest calls the generic ReplaceHTTPAfterResponseRuleDefaults builder with application/json body
func NewReplaceHTTPAfterResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, body ReplaceHTTPAfterResponseRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPAfterResponseRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPAfterResponseRuleDefaultsRequestWithBody generates requests for ReplaceHTTPAfterResponseRuleDefaults with any type of body
func NewReplaceHTTPAfterResponseRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPCheckDefaultsRequest generates requests for GetAllHTTPCheckDefaults
func NewGetAllHTTPCheckDefaultsRequest(server string, parentName ParentName, params *GetAllHTTPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPCheckDefaultsRequest calls the generic ReplaceAllHTTPCheckDefaults builder with application/json body
func NewReplaceAllHTTPCheckDefaultsRequest(server string, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPCheckDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPCheckDefaultsRequestWithBody generates requests for ReplaceAllHTTPCheckDefaults with any type of body
func NewReplaceAllHTTPCheckDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPCheckDefaultsRequest generates requests for DeleteHTTPCheckDefaults
func NewDeleteHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPCheckDefaultsRequest generates requests for GetHTTPCheckDefaults
func NewGetHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPCheckDefaultsRequest calls the generic CreateHTTPCheckDefaults builder with application/json body
func NewCreateHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPCheckDefaultsRequestWithBody generates requests for CreateHTTPCheckDefaults with any type of body
func NewCreateHTTPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPCheckDefaultsRequest calls the generic ReplaceHTTPCheckDefaults builder with application/json body
func NewReplaceHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPCheckDefaultsRequestWithBody generates requests for ReplaceHTTPCheckDefaults with any type of body
func NewReplaceHTTPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPErrorRuleDefaultsRequest generates requests for GetAllHTTPErrorRuleDefaults
func NewGetAllHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPErrorRuleDefaultsRequest calls the generic ReplaceAllHTTPErrorRuleDefaults builder with application/json body
func NewReplaceAllHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody generates requests for ReplaceAllHTTPErrorRuleDefaults with any type of body
func NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorRuleDefaultsRequest generates requests for DeleteHTTPErrorRuleDefaults
func NewDeleteHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorRuleDefaultsRequest generates requests for GetHTTPErrorRuleDefaults
func NewGetHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorRuleDefaultsRequest calls the generic CreateHTTPErrorRuleDefaults builder with application/json body
func NewCreateHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorRuleDefaultsRequestWithBody generates requests for CreateHTTPErrorRuleDefaults with any type of body
func NewCreateHTTPErrorRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPErrorRuleDefaultsRequest calls the generic ReplaceHTTPErrorRuleDefaults builder with application/json body
func NewReplaceHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorRuleDefaultsRequestWithBody generates requests for ReplaceHTTPErrorRuleDefaults with any type of body
func NewReplaceHTTPErrorRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPRequestRuleDefaultsRequest generates requests for GetAllHTTPRequestRuleDefaults
func NewGetAllHTTPRequestRuleDefaultsRequest(server string, parentName ParentName, params *GetAllHTTPRequestRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPRequestRuleDefaultsRequest calls the generic ReplaceAllHTTPRequestRuleDefaults builder with application/json body
func NewReplaceAllHTTPRequestRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, body ReplaceAllHTTPRequestRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPRequestRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPRequestRuleDefaultsRequestWithBody generates requests for ReplaceAllHTTPRequestRuleDefaults with any type of body
func NewReplaceAllHTTPRequestRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPRequestRuleDefaultsRequest generates requests for DeleteHTTPRequestRuleDefaults
func NewDeleteHTTPRequestRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteHTTPRequestRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPRequestRuleDefaultsRequest generates requests for GetHTTPRequestRuleDefaults
func NewGetHTTPRequestRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetHTTPRequestRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPRequestRuleDefaultsRequest calls the generic CreateHTTPRequestRuleDefaults builder with application/json body
func NewCreateHTTPRequestRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, body CreateHTTPRequestRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPRequestRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPRequestRuleDefaultsRequestWithBody generates requests for CreateHTTPRequestRuleDefaults with any type of body
func NewCreateHTTPRequestRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPRequestRuleDefaultsRequest calls the generic ReplaceHTTPRequestRuleDefaults builder with application/json body
func NewReplaceHTTPRequestRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, body ReplaceHTTPRequestRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPRequestRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPRequestRuleDefaultsRequestWithBody generates requests for ReplaceHTTPRequestRuleDefaults with any type of body
func NewReplaceHTTPRequestRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPResponseRuleDefaultsRequest generates requests for GetAllHTTPResponseRuleDefaults
func NewGetAllHTTPResponseRuleDefaultsRequest(server string, parentName ParentName, params *GetAllHTTPResponseRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPResponseRuleDefaultsRequest calls the generic ReplaceAllHTTPResponseRuleDefaults builder with application/json body
func NewReplaceAllHTTPResponseRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, body ReplaceAllHTTPResponseRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPResponseRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPResponseRuleDefaultsRequestWithBody generates requests for ReplaceAllHTTPResponseRuleDefaults with any type of body
func NewReplaceAllHTTPResponseRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPResponseRuleDefaultsRequest generates requests for DeleteHTTPResponseRuleDefaults
func NewDeleteHTTPResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteHTTPResponseRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPResponseRuleDefaultsRequest generates requests for GetHTTPResponseRuleDefaults
func NewGetHTTPResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetHTTPResponseRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPResponseRuleDefaultsRequest calls the generic CreateHTTPResponseRuleDefaults builder with application/json body
func NewCreateHTTPResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, body CreateHTTPResponseRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPResponseRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPResponseRuleDefaultsRequestWithBody generates requests for CreateHTTPResponseRuleDefaults with any type of body
func NewCreateHTTPResponseRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPResponseRuleDefaultsRequest calls the generic ReplaceHTTPResponseRuleDefaults builder with application/json body
func NewReplaceHTTPResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, body ReplaceHTTPResponseRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPResponseRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPResponseRuleDefaultsRequestWithBody generates requests for ReplaceHTTPResponseRuleDefaults with any type of body
func NewReplaceHTTPResponseRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetDefaultsRequest generates requests for GetAllLogTargetDefaults
func NewGetAllLogTargetDefaultsRequest(server string, parentName ParentName, params *GetAllLogTargetDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetDefaultsRequest calls the generic ReplaceAllLogTargetDefaults builder with application/json body
func NewReplaceAllLogTargetDefaultsRequest(server string, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetDefaultsRequestWithBody generates requests for ReplaceAllLogTargetDefaults with any type of body
func NewReplaceAllLogTargetDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetDefaultsRequest generates requests for DeleteLogTargetDefaults
func NewDeleteLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetDefaultsRequest generates requests for GetLogTargetDefaults
func NewGetLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *GetLogTargetDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetDefaultsRequest calls the generic CreateLogTargetDefaults builder with application/json body
func NewCreateLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetDefaultsRequestWithBody generates requests for CreateLogTargetDefaults with any type of body
func NewCreateLogTargetDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetDefaultsRequest calls the generic ReplaceLogTargetDefaults builder with application/json body
func NewReplaceLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetDefaultsRequestWithBody generates requests for ReplaceLogTargetDefaults with any type of body
func NewReplaceLogTargetDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllQUICInitialRuleDefaultsRequest generates requests for GetAllQUICInitialRuleDefaults
func NewGetAllQUICInitialRuleDefaultsRequest(server string, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllQUICInitialRuleDefaultsRequest calls the generic ReplaceAllQUICInitialRuleDefaults builder with application/json body
func NewReplaceAllQUICInitialRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllQUICInitialRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllQUICInitialRuleDefaultsRequestWithBody generates requests for ReplaceAllQUICInitialRuleDefaults with any type of body
func NewReplaceAllQUICInitialRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteQUICInitialRuleDefaultsRequest generates requests for DeleteQUICInitialRuleDefaults
func NewDeleteQUICInitialRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQUICInitialRuleDefaultsRequest generates requests for GetQUICInitialRuleDefaults
func NewGetQUICInitialRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateQUICInitialRuleDefaultsRequest calls the generic CreateQUICInitialRuleDefaults builder with application/json body
func NewCreateQUICInitialRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateQUICInitialRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateQUICInitialRuleDefaultsRequestWithBody generates requests for CreateQUICInitialRuleDefaults with any type of body
func NewCreateQUICInitialRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceQUICInitialRuleDefaultsRequest calls the generic ReplaceQUICInitialRuleDefaults builder with application/json body
func NewReplaceQUICInitialRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceQUICInitialRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceQUICInitialRuleDefaultsRequestWithBody generates requests for ReplaceQUICInitialRuleDefaults with any type of body
func NewReplaceQUICInitialRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPCheckDefaultsRequest generates requests for GetAllTCPCheckDefaults
func NewGetAllTCPCheckDefaultsRequest(server string, parentName ParentName, params *GetAllTCPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPCheckDefaultsRequest calls the generic ReplaceAllTCPCheckDefaults builder with application/json body
func NewReplaceAllTCPCheckDefaultsRequest(server string, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPCheckDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPCheckDefaultsRequestWithBody generates requests for ReplaceAllTCPCheckDefaults with any type of body
func NewReplaceAllTCPCheckDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPCheckDefaultsRequest generates requests for DeleteTCPCheckDefaults
func NewDeleteTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPCheckDefaultsRequest generates requests for GetTCPCheckDefaults
func NewGetTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *GetTCPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPCheckDefaultsRequest calls the generic CreateTCPCheckDefaults builder with application/json body
func NewCreateTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPCheckDefaultsRequestWithBody generates requests for CreateTCPCheckDefaults with any type of body
func NewCreateTCPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPCheckDefaultsRequest calls the generic ReplaceTCPCheckDefaults builder with application/json body
func NewReplaceTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPCheckDefaultsRequestWithBody generates requests for ReplaceTCPCheckDefaults with any type of body
func NewReplaceTCPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPRequestRuleDefaultsRequest generates requests for GetAllTCPRequestRuleDefaults
func NewGetAllTCPRequestRuleDefaultsRequest(server string, parentName ParentName, params *GetAllTCPRequestRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPRequestRuleDefaultsRequest calls the generic ReplaceAllTCPRequestRuleDefaults builder with application/json body
func NewReplaceAllTCPRequestRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, body ReplaceAllTCPRequestRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPRequestRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPRequestRuleDefaultsRequestWithBody generates requests for ReplaceAllTCPRequestRuleDefaults with any type of body
func NewReplaceAllTCPRequestRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPRequestRuleDefaultsRequest generates requests for DeleteTCPRequestRuleDefaults
func NewDeleteTCPRequestRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteTCPRequestRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPRequestRuleDefaultsRequest generates requests for GetTCPRequestRuleDefaults
func NewGetTCPRequestRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetTCPRequestRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPRequestRuleDefaultsRequest calls the generic CreateTCPRequestRuleDefaults builder with application/json body
func NewCreateTCPRequestRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, body CreateTCPRequestRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPRequestRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPRequestRuleDefaultsRequestWithBody generates requests for CreateTCPRequestRuleDefaults with any type of body
func NewCreateTCPRequestRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPRequestRuleDefaultsRequest calls the generic ReplaceTCPRequestRuleDefaults builder with application/json body
func NewReplaceTCPRequestRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, body ReplaceTCPRequestRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPRequestRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPRequestRuleDefaultsRequestWithBody generates requests for ReplaceTCPRequestRuleDefaults with any type of body
func NewReplaceTCPRequestRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPResponseRuleDefaultsRequest generates requests for GetAllTCPResponseRuleDefaults
func NewGetAllTCPResponseRuleDefaultsRequest(server string, parentName ParentName, params *GetAllTCPResponseRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPResponseRuleDefaultsRequest calls the generic ReplaceAllTCPResponseRuleDefaults builder with application/json body
func NewReplaceAllTCPResponseRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, body ReplaceAllTCPResponseRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPResponseRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPResponseRuleDefaultsRequestWithBody generates requests for ReplaceAllTCPResponseRuleDefaults with any type of body
func NewReplaceAllTCPResponseRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPResponseRuleDefaultsRequest generates requests for DeleteTCPResponseRuleDefaults
func NewDeleteTCPResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteTCPResponseRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPResponseRuleDefaultsRequest generates requests for GetTCPResponseRuleDefaults
func NewGetTCPResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetTCPResponseRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPResponseRuleDefaultsRequest calls the generic CreateTCPResponseRuleDefaults builder with application/json body
func NewCreateTCPResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, body CreateTCPResponseRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPResponseRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPResponseRuleDefaultsRequestWithBody generates requests for CreateTCPResponseRuleDefaults with any type of body
func NewCreateTCPResponseRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPResponseRuleDefaultsRequest calls the generic ReplaceTCPResponseRuleDefaults builder with application/json body
func NewReplaceTCPResponseRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, body ReplaceTCPResponseRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPResponseRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPResponseRuleDefaultsRequestWithBody generates requests for ReplaceTCPResponseRuleDefaults with any type of body
func NewReplaceTCPResponseRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFCGIAppsRequest generates requests for GetFCGIApps
func NewGetFCGIAppsRequest(server string, params *GetFCGIAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFCGIAppRequest calls the generic CreateFCGIApp builder with application/json body
func NewCreateFCGIAppRequest(server string, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFCGIAppRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateFCGIAppRequestWithBody generates requests for CreateFCGIApp with any type of body
func NewCreateFCGIAppRequestWithBody(server string, params *CreateFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFCGIAppRequest generates requests for DeleteFCGIApp
func NewDeleteFCGIAppRequest(server string, name string, params *DeleteFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFCGIAppRequest generates requests for GetFCGIApp
func NewGetFCGIAppRequest(server string, name string, params *GetFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceFCGIAppRequest calls the generic ReplaceFCGIApp builder with application/json body
func NewReplaceFCGIAppRequest(server string, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFCGIAppRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceFCGIAppRequestWithBody generates requests for ReplaceFCGIApp with any type of body
func NewReplaceFCGIAppRequestWithBody(server string, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclFCGIAppRequest generates requests for GetAllAclFCGIApp
func NewGetAllAclFCGIAppRequest(server string, parentName ParentName, params *GetAllAclFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclFCGIAppRequest calls the generic ReplaceAllAclFCGIApp builder with application/json body
func NewReplaceAllAclFCGIAppRequest(server string, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclFCGIAppRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclFCGIAppRequestWithBody generates requests for ReplaceAllAclFCGIApp with any type of body
func NewReplaceAllAclFCGIAppRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclFCGIAppRequest generates requests for DeleteAclFCGIApp
func NewDeleteAclFCGIAppRequest(server string, parentName ParentName, index int, params *DeleteAclFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclFCGIAppRequest generates requests for GetAclFCGIApp
func NewGetAclFCGIAppRequest(server string, parentName ParentName, index int, params *GetAclFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclFCGIAppRequest calls the generic CreateAclFCGIApp builder with application/json body
func NewCreateAclFCGIAppRequest(server string, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclFCGIAppRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclFCGIAppRequestWithBody generates requests for CreateAclFCGIApp with any type of body
func NewCreateAclFCGIAppRequestWithBody(server string, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclFCGIAppRequest calls the generic ReplaceAclFCGIApp builder with application/json body
func NewReplaceAclFCGIAppRequest(server string, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclFCGIAppRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclFCGIAppRequestWithBody generates requests for ReplaceAclFCGIApp with any type of body
func NewReplaceAclFCGIAppRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFrontendsRequest generates requests for GetFrontends
func NewGetFrontendsRequest(server string, params *GetFrontendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFrontendRequest calls the generic CreateFrontend builder with application/json body
func NewCreateFrontendRequest(server string, params *CreateFrontendParams, body CreateFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFrontendRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateFrontendRequestWithBody generates requests for CreateFrontend with any type of body
func NewCreateFrontendRequestWithBody(server string, params *CreateFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFrontendRequest generates requests for DeleteFrontend
func NewDeleteFrontendRequest(server string, name string, params *DeleteFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFrontendRequest generates requests for GetFrontend
func NewGetFrontendRequest(server string, name string, params *GetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceFrontendRequest calls the generic ReplaceFrontend builder with application/json body
func NewReplaceFrontendRequest(server string, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFrontendRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceFrontendRequestWithBody generates requests for ReplaceFrontend with any type of body
func NewReplaceFrontendRequestWithBody(server string, name string, params *ReplaceFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclFrontendRequest generates requests for GetAllAclFrontend
func NewGetAllAclFrontendRequest(server string, parentName ParentName, params *GetAllAclFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclFrontendRequest calls the generic ReplaceAllAclFrontend builder with application/json body
func NewReplaceAllAclFrontendRequest(server string, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclFrontendRequestWithBody generates requests for ReplaceAllAclFrontend with any type of body
func NewReplaceAllAclFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclFrontendRequest generates requests for DeleteAclFrontend
func NewDeleteAclFrontendRequest(server string, parentName ParentName, index int, params *DeleteAclFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclFrontendRequest generates requests for GetAclFrontend
func NewGetAclFrontendRequest(server string, parentName ParentName, index int, params *GetAclFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclFrontendRequest calls the generic CreateAclFrontend builder with application/json body
func NewCreateAclFrontendRequest(server string, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclFrontendRequestWithBody generates requests for CreateAclFrontend with any type of body
func NewCreateAclFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclFrontendRequest calls the generic ReplaceAclFrontend builder with application/json body
func NewReplaceAclFrontendRequest(server string, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclFrontendRequestWithBody generates requests for ReplaceAclFrontend with any type of body
func NewReplaceAclFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBackendSwitchingRulesRequest generates requests for GetBackendSwitchingRules
func NewGetBackendSwitchingRulesRequest(server string, parentName ParentName, params *GetBackendSwitchingRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBackendSwitchingRulesRequest calls the generic ReplaceBackendSwitchingRules builder with application/json body
func NewReplaceBackendSwitchingRulesRequest(server string, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBackendSwitchingRulesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceBackendSwitchingRulesRequestWithBody generates requests for ReplaceBackendSwitchingRules with any type of body
func NewReplaceBackendSwitchingRulesRequestWithBody(server string, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBackendSwitchingRuleRequest generates requests for DeleteBackendSwitchingRule
func NewDeleteBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackendSwitchingRuleRequest generates requests for GetBackendSwitchingRule
func NewGetBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *GetBackendSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackendSwitchingRuleRequest calls the generic CreateBackendSwitchingRule builder with application/json body
func NewCreateBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackendSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateBackendSwitchingRuleRequestWithBody generates requests for CreateBackendSwitchingRule with any type of body
func NewCreateBackendSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceBackendSwitchingRuleRequest calls the generic ReplaceBackendSwitchingRule builder with application/json body
func NewReplaceBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBackendSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceBackendSwitchingRuleRequestWithBody generates requests for ReplaceBackendSwitchingRule with any type of body
func NewReplaceBackendSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllBindFrontendRequest generates requests for GetAllBindFrontend
func NewGetAllBindFrontendRequest(server string, parentName ParentName, params *GetAllBindFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBindFrontendRequest calls the generic CreateBindFrontend builder with application/json body
func NewCreateBindFrontendRequest(server string, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBindFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateBindFrontendRequestWithBody generates requests for CreateBindFrontend with any type of body
func NewCreateBindFrontendRequestWithBody(server string, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBindFrontendRequest generates requests for DeleteBindFrontend
func NewDeleteBindFrontendRequest(server string, parentName ParentName, name string, params *DeleteBindFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBindFrontendRequest generates requests for GetBindFrontend
func NewGetBindFrontendRequest(server string, parentName ParentName, name string, params *GetBindFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBindFrontendRequest calls the generic ReplaceBindFrontend builder with application/json body
func NewReplaceBindFrontendRequest(server string, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBindFrontendRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceBindFrontendRequestWithBody generates requests for ReplaceBindFrontend with any type of body
func NewReplaceBindFrontendRequestWithBody(server string, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDeclareCapturesRequest generates requests for GetDeclareCaptures
func NewGetDeclareCapturesRequest(server string, parentName ParentName, params *GetDeclareCapturesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDeclareCapturesRequest calls the generic ReplaceDeclareCaptures builder with application/json body
func NewReplaceDeclareCapturesRequest(server string, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDeclareCapturesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceDeclareCapturesRequestWithBody generates requests for ReplaceDeclareCaptures with any type of body
func NewReplaceDeclareCapturesRequestWithBody(server string, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDeclareCaptureRequest generates requests for DeleteDeclareCapture
func NewDeleteDeclareCaptureRequest(server string, parentName ParentName, index int, params *DeleteDeclareCaptureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeclareCaptureRequest generates requests for GetDeclareCapture
func NewGetDeclareCaptureRequest(server string, parentName ParentName, index int, params *GetDeclareCaptureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeclareCaptureRequest calls the generic CreateDeclareCapture builder with application/json body
func NewCreateDeclareCaptureRequest(server string, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeclareCaptureRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateDeclareCaptureRequestWithBody generates requests for CreateDeclareCapture with any type of body
func NewCreateDeclareCaptureRequestWithBody(server string, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceDeclareCaptureRequest calls the generic ReplaceDeclareCapture builder with application/json body
func NewReplaceDeclareCaptureRequest(server string, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDeclareCaptureRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceDeclareCaptureRequestWithBody generates requests for ReplaceDeclareCapture with any type of body
func NewReplaceDeclareCaptureRequestWithBody(server string, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllFilterFrontendRequest generates requests for GetAllFilterFrontend
func NewGetAllFilterFrontendRequest(server string, parentName ParentName, params *GetAllFilterFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllFilterFrontendRequest calls the generic ReplaceAllFilterFrontend builder with application/json body
func NewReplaceAllFilterFrontendRequest(server string, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllFilterFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllFilterFrontendRequestWithBody generates requests for ReplaceAllFilterFrontend with any type of body
func NewReplaceAllFilterFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFilterFrontendRequest generates requests for DeleteFilterFrontend
func NewDeleteFilterFrontendRequest(server string, parentName ParentName, index int, params *DeleteFilterFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterFrontendRequest generates requests for GetFilterFrontend
func NewGetFilterFrontendRequest(server string, parentName ParentName, index int, params *GetFilterFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFilterFrontendRequest calls the generic CreateFilterFrontend builder with application/json body
func NewCreateFilterFrontendRequest(server string, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFilterFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateFilterFrontendRequestWithBody generates requests for CreateFilterFrontend with any type of body
func NewCreateFilterFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceFilterFrontendRequest calls the generic ReplaceFilterFrontend builder with application/json body
func NewReplaceFilterFrontendRequest(server string, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFilterFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceFilterFrontendRequestWithBody generates requests for ReplaceFilterFrontend with any type of body
func NewReplaceFilterFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPAfterResponseRuleFrontendRequest generates requests for GetAllHTTPAfterResponseRuleFrontend
func NewGetAllHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPAfterResponseRuleFrontendRequest calls the generic ReplaceAllHTTPAfterResponseRuleFrontend builder with application/json body
func NewReplaceAllHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPAfterResponseRuleFrontend with any type of body
func NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPAfterResponseRuleFrontendRequest generates requests for DeleteHTTPAfterResponseRuleFrontend
func NewDeleteHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPAfterResponseRuleFrontendRequest generates requests for GetHTTPAfterResponseRuleFrontend
func NewGetHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPAfterResponseRuleFrontendRequest calls the generic CreateHTTPAfterResponseRuleFrontend builder with application/json body
func NewCreateHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPAfterResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPAfterResponseRuleFrontendRequestWithBody generates requests for CreateHTTPAfterResponseRuleFrontend with any type of body
func NewCreateHTTPAfterResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPAfterResponseRuleFrontendRequest calls the generic ReplaceHTTPAfterResponseRuleFrontend builder with application/json body
func NewReplaceHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody generates requests for ReplaceHTTPAfterResponseRuleFrontend with any type of body
func NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPErrorRuleFrontendRequest generates requests for GetAllHTTPErrorRuleFrontend
func NewGetAllHTTPErrorRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPErrorRuleFrontendRequest calls the generic ReplaceAllHTTPErrorRuleFrontend builder with application/json body
func NewReplaceAllHTTPErrorRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPErrorRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPErrorRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPErrorRuleFrontend with any type of body
func NewReplaceAllHTTPErrorRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorRuleFrontendRequest generates requests for DeleteHTTPErrorRuleFrontend
func NewDeleteHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorRuleFrontendRequest generates requests for GetHTTPErrorRuleFrontend
func NewGetHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorRuleFrontendRequest calls the generic CreateHTTPErrorRuleFrontend builder with application/json body
func NewCreateHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorRuleFrontendRequestWithBody generates requests for CreateHTTPErrorRuleFrontend with any type of body
func NewCreateHTTPErrorRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPErrorRuleFrontendRequest calls the generic ReplaceHTTPErrorRuleFrontend builder with application/json body
func NewReplaceHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorRuleFrontendRequestWithBody generates requests for ReplaceHTTPErrorRuleFrontend with any type of body
func NewReplaceHTTPErrorRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPRequestRuleFrontendRequest generates requests for GetAllHTTPRequestRuleFrontend
func NewGetAllHTTPRequestRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPRequestRuleFrontendRequest calls the generic ReplaceAllHTTPRequestRuleFrontend builder with application/json body
func NewReplaceAllHTTPRequestRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPRequestRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPRequestRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPRequestRuleFrontend with any type of body
func NewReplaceAllHTTPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPRequestRuleFrontendRequest generates requests for DeleteHTTPRequestRuleFrontend
func NewDeleteHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPRequestRuleFrontendRequest generates requests for GetHTTPRequestRuleFrontend
func NewGetHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPRequestRuleFrontendRequest calls the generic CreateHTTPRequestRuleFrontend builder with application/json body
func NewCreateHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPRequestRuleFrontendRequestWithBody generates requests for CreateHTTPRequestRuleFrontend with any type of body
func NewCreateHTTPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPRequestRuleFrontendRequest calls the generic ReplaceHTTPRequestRuleFrontend builder with application/json body
func NewReplaceHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPRequestRuleFrontendRequestWithBody generates requests for ReplaceHTTPRequestRuleFrontend with any type of body
func NewReplaceHTTPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPResponseRuleFrontendRequest generates requests for GetAllHTTPResponseRuleFrontend
func NewGetAllHTTPResponseRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPResponseRuleFrontendRequest calls the generic ReplaceAllHTTPResponseRuleFrontend builder with application/json body
func NewReplaceAllHTTPResponseRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPResponseRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPResponseRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPResponseRuleFrontend with any type of body
func NewReplaceAllHTTPResponseRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPResponseRuleFrontendRequest generates requests for DeleteHTTPResponseRuleFrontend
func NewDeleteHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPResponseRuleFrontendRequest generates requests for GetHTTPResponseRuleFrontend
func NewGetHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPResponseRuleFrontendRequest calls the generic CreateHTTPResponseRuleFrontend builder with application/json body
func NewCreateHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPResponseRuleFrontendRequestWithBody generates requests for CreateHTTPResponseRuleFrontend with any type of body
func NewCreateHTTPResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPResponseRuleFrontendRequest calls the generic ReplaceHTTPResponseRuleFrontend builder with application/json body
func NewReplaceHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPResponseRuleFrontendRequestWithBody generates requests for ReplaceHTTPResponseRuleFrontend with any type of body
func NewReplaceHTTPResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetFrontendRequest generates requests for GetAllLogTargetFrontend
func NewGetAllLogTargetFrontendRequest(server string, parentName ParentName, params *GetAllLogTargetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetFrontendRequest calls the generic ReplaceAllLogTargetFrontend builder with application/json body
func NewReplaceAllLogTargetFrontendRequest(server string, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetFrontendRequestWithBody generates requests for ReplaceAllLogTargetFrontend with any type of body
func NewReplaceAllLogTargetFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetFrontendRequest generates requests for DeleteLogTargetFrontend
func NewDeleteLogTargetFrontendRequest(server string, parentName ParentName, index int, params *DeleteLogTargetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetFrontendRequest generates requests for GetLogTargetFrontend
func NewGetLogTargetFrontendRequest(server string, parentName ParentName, index int, params *GetLogTargetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetFrontendRequest calls the generic CreateLogTargetFrontend builder with application/json body
func NewCreateLogTargetFrontendRequest(server string, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetFrontendRequestWithBody generates requests for CreateLogTargetFrontend with any type of body
func NewCreateLogTargetFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetFrontendRequest calls the generic ReplaceLogTargetFrontend builder with application/json body
func NewReplaceLogTargetFrontendRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetFrontendRequestWithBody generates requests for ReplaceLogTargetFrontend with any type of body
func NewReplaceLogTargetFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllQUICInitialRuleFrontendRequest generates requests for GetAllQUICInitialRuleFrontend
func NewGetAllQUICInitialRuleFrontendRequest(server string, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllQUICInitialRuleFrontendRequest calls the generic ReplaceAllQUICInitialRuleFrontend builder with application/json body
func NewReplaceAllQUICInitialRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllQUICInitialRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllQUICInitialRuleFrontendRequestWithBody generates requests for ReplaceAllQUICInitialRuleFrontend with any type of body
func NewReplaceAllQUICInitialRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteQUICInitialRuleFrontendRequest generates requests for DeleteQUICInitialRuleFrontend
func NewDeleteQUICInitialRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetQUICInitialRuleFrontendRequest generates requests for GetQUICInitialRuleFrontend
func NewGetQUICInitialRuleFrontendRequest(server string, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateQUICInitialRuleFrontendRequest calls the generic CreateQUICInitialRuleFrontend builder with application/json body
func NewCreateQUICInitialRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateQUICInitialRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateQUICInitialRuleFrontendRequestWithBody generates requests for CreateQUICInitialRuleFrontend with any type of body
func NewCreateQUICInitialRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceQUICInitialRuleFrontendRequest calls the generic ReplaceQUICInitialRuleFrontend builder with application/json body
func NewReplaceQUICInitialRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceQUICInitialRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceQUICInitialRuleFrontendRequestWithBody generates requests for ReplaceQUICInitialRuleFrontend with any type of body
func NewReplaceQUICInitialRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/quic_initial_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSSLFrontUsesRequest generates requests for GetAllSSLFrontUses
func NewGetAllSSLFrontUsesRequest(server string, parentName ParentName, params *GetAllSSLFrontUsesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/ssl_front_uses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSSLFrontUseRequest calls the generic CreateSSLFrontUse builder with application/json body
func NewCreateSSLFrontUseRequest(server string, parentName ParentName, params *CreateSSLFrontUseParams, body CreateSSLFrontUseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSSLFrontUseRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateSSLFrontUseRequestWithBody generates requests for CreateSSLFrontUse with any type of body
func NewCreateSSLFrontUseRequestWithBody(server string, parentName ParentName, params *CreateSSLFrontUseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/ssl_front_uses", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSSLFrontUseRequest generates requests for DeleteSSLFrontUse
func NewDeleteSSLFrontUseRequest(server string, parentName ParentName, index int, params *DeleteSSLFrontUseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/ssl_front_uses/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSSLFrontUseRequest generates requests for GetSSLFrontUse
func NewGetSSLFrontUseRequest(server string, parentName ParentName, index int, params *GetSSLFrontUseParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/ssl_front_uses/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSSLFrontUseRequest calls the generic ReplaceSSLFrontUse builder with application/json body
func NewReplaceSSLFrontUseRequest(server string, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, body ReplaceSSLFrontUseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSSLFrontUseRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceSSLFrontUseRequestWithBody generates requests for ReplaceSSLFrontUse with any type of body
func NewReplaceSSLFrontUseRequestWithBody(server string, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/ssl_front_uses/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPRequestRuleFrontendRequest generates requests for GetAllTCPRequestRuleFrontend
func NewGetAllTCPRequestRuleFrontendRequest(server string, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPRequestRuleFrontendRequest calls the generic ReplaceAllTCPRequestRuleFrontend builder with application/json body
func NewReplaceAllTCPRequestRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPRequestRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPRequestRuleFrontendRequestWithBody generates requests for ReplaceAllTCPRequestRuleFrontend with any type of body
func NewReplaceAllTCPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPRequestRuleFrontendRequest generates requests for DeleteTCPRequestRuleFrontend
func NewDeleteTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPRequestRuleFrontendRequest generates requests for GetTCPRequestRuleFrontend
func NewGetTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPRequestRuleFrontendRequest calls the generic CreateTCPRequestRuleFrontend builder with application/json body
func NewCreateTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPRequestRuleFrontendRequestWithBody generates requests for CreateTCPRequestRuleFrontend with any type of body
func NewCreateTCPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPRequestRuleFrontendRequest calls the generic ReplaceTCPRequestRuleFrontend builder with application/json body
func NewReplaceTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPRequestRuleFrontendRequestWithBody generates requests for ReplaceTCPRequestRuleFrontend with any type of body
func NewReplaceTCPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGlobalRequest generates requests for GetGlobal
func NewGetGlobalRequest(server string, params *GetGlobalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceGlobalRequest calls the generic ReplaceGlobal builder with application/json body
func NewReplaceGlobalRequest(server string, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceGlobalRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceGlobalRequestWithBody generates requests for ReplaceGlobal with any type of body
func NewReplaceGlobalRequestWithBody(server string, params *ReplaceGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetGlobalRequest generates requests for GetAllLogTargetGlobal
func NewGetAllLogTargetGlobalRequest(server string, params *GetAllLogTargetGlobalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetGlobalRequest calls the generic ReplaceAllLogTargetGlobal builder with application/json body
func NewReplaceAllLogTargetGlobalRequest(server string, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetGlobalRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetGlobalRequestWithBody generates requests for ReplaceAllLogTargetGlobal with any type of body
func NewReplaceAllLogTargetGlobalRequestWithBody(server string, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetGlobalRequest generates requests for DeleteLogTargetGlobal
func NewDeleteLogTargetGlobalRequest(server string, index int, params *DeleteLogTargetGlobalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetGlobalRequest generates requests for GetLogTargetGlobal
func NewGetLogTargetGlobalRequest(server string, index int, params *GetLogTargetGlobalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetGlobalRequest calls the generic CreateLogTargetGlobal builder with application/json body
func NewCreateLogTargetGlobalRequest(server string, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetGlobalRequestWithBody(server, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetGlobalRequestWithBody generates requests for CreateLogTargetGlobal with any type of body
func NewCreateLogTargetGlobalRequestWithBody(server string, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetGlobalRequest calls the generic ReplaceLogTargetGlobal builder with application/json body
func NewReplaceLogTargetGlobalRequest(server string, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetGlobalRequestWithBody(server, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetGlobalRequestWithBody generates requests for ReplaceLogTargetGlobal with any type of body
func NewReplaceLogTargetGlobalRequestWithBody(server string, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string, params *GetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, params *CreateGroupParams, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, params *CreateGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, name string, params *DeleteGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, name string, params *GetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceGroupRequest calls the generic ReplaceGroup builder with application/json body
func NewReplaceGroupRequest(server string, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceGroupRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceGroupRequestWithBody generates requests for ReplaceGroup with any type of body
func NewReplaceGroupRequestWithBody(server string, name string, params *ReplaceGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHTTPErrorsSectionsRequest generates requests for GetHTTPErrorsSections
func NewGetHTTPErrorsSectionsRequest(server string, params *GetHTTPErrorsSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorsSectionRequest calls the generic CreateHTTPErrorsSection builder with application/json body
func NewCreateHTTPErrorsSectionRequest(server string, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorsSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorsSectionRequestWithBody generates requests for CreateHTTPErrorsSection with any type of body
func NewCreateHTTPErrorsSectionRequestWithBody(server string, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorsSectionRequest generates requests for DeleteHTTPErrorsSection
func NewDeleteHTTPErrorsSectionRequest(server string, name string, params *DeleteHTTPErrorsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorsSectionRequest generates requests for GetHTTPErrorsSection
func NewGetHTTPErrorsSectionRequest(server string, name string, params *GetHTTPErrorsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceHTTPErrorsSectionRequest calls the generic ReplaceHTTPErrorsSection builder with application/json body
func NewReplaceHTTPErrorsSectionRequest(server string, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorsSectionRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorsSectionRequestWithBody generates requests for ReplaceHTTPErrorsSection with any type of body
func NewReplaceHTTPErrorsSectionRequestWithBody(server string, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogForwardsRequest generates requests for GetLogForwards
func NewGetLogForwardsRequest(server string, params *GetLogForwardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogForwardRequest calls the generic CreateLogForward builder with application/json body
func NewCreateLogForwardRequest(server string, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogForwardRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateLogForwardRequestWithBody generates requests for CreateLogForward with any type of body
func NewCreateLogForwardRequestWithBody(server string, params *CreateLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogForwardRequest generates requests for DeleteLogForward
func NewDeleteLogForwardRequest(server string, name string, params *DeleteLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogForwardRequest generates requests for GetLogForward
func NewGetLogForwardRequest(server string, name string, params *GetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceLogForwardRequest calls the generic ReplaceLogForward builder with application/json body
func NewReplaceLogForwardRequest(server string, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogForwardRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceLogForwardRequestWithBody generates requests for ReplaceLogForward with any type of body
func NewReplaceLogForwardRequestWithBody(server string, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllBindLogForwardRequest generates requests for GetAllBindLogForward
func NewGetAllBindLogForwardRequest(server string, parentName ParentName, params *GetAllBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBindLogForwardRequest calls the generic CreateBindLogForward builder with application/json body
func NewCreateBindLogForwardRequest(server string, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBindLogForwardRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateBindLogForwardRequestWithBody generates requests for CreateBindLogForward with any type of body
func NewCreateBindLogForwardRequestWithBody(server string, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBindLogForwardRequest generates requests for DeleteBindLogForward
func NewDeleteBindLogForwardRequest(server string, parentName ParentName, name string, params *DeleteBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBindLogForwardRequest generates requests for GetBindLogForward
func NewGetBindLogForwardRequest(server string, parentName ParentName, name string, params *GetBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBindLogForwardRequest calls the generic ReplaceBindLogForward builder with application/json body
func NewReplaceBindLogForwardRequest(server string, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBindLogForwardRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceBindLogForwardRequestWithBody generates requests for ReplaceBindLogForward with any type of body
func NewReplaceBindLogForwardRequestWithBody(server string, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDgramBindsRequest generates requests for GetDgramBinds
func NewGetDgramBindsRequest(server string, parentName ParentName, params *GetDgramBindsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDgramBindRequest calls the generic CreateDgramBind builder with application/json body
func NewCreateDgramBindRequest(server string, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDgramBindRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateDgramBindRequestWithBody generates requests for CreateDgramBind with any type of body
func NewCreateDgramBindRequestWithBody(server string, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDgramBindRequest generates requests for DeleteDgramBind
func NewDeleteDgramBindRequest(server string, parentName ParentName, name string, params *DeleteDgramBindParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDgramBindRequest generates requests for GetDgramBind
func NewGetDgramBindRequest(server string, parentName ParentName, name string, params *GetDgramBindParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDgramBindRequest calls the generic ReplaceDgramBind builder with application/json body
func NewReplaceDgramBindRequest(server string, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDgramBindRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceDgramBindRequestWithBody generates requests for ReplaceDgramBind with any type of body
func NewReplaceDgramBindRequestWithBody(server string, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetLogForwardRequest generates requests for GetAllLogTargetLogForward
func NewGetAllLogTargetLogForwardRequest(server string, parentName ParentName, params *GetAllLogTargetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetLogForwardRequest calls the generic ReplaceAllLogTargetLogForward builder with application/json body
func NewReplaceAllLogTargetLogForwardRequest(server string, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetLogForwardRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetLogForwardRequestWithBody generates requests for ReplaceAllLogTargetLogForward with any type of body
func NewReplaceAllLogTargetLogForwardRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetLogForwardRequest generates requests for DeleteLogTargetLogForward
func NewDeleteLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetLogForwardRequest generates requests for GetLogTargetLogForward
func NewGetLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *GetLogTargetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetLogForwardRequest calls the generic CreateLogTargetLogForward builder with application/json body
func NewCreateLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetLogForwardRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetLogForwardRequestWithBody generates requests for CreateLogTargetLogForward with any type of body
func NewCreateLogTargetLogForwardRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetLogForwardRequest calls the generic ReplaceLogTargetLogForward builder with application/json body
func NewReplaceLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetLogForwardRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetLogForwardRequestWithBody generates requests for ReplaceLogTargetLogForward with any type of body
func NewReplaceLogTargetLogForwardRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogProfilesRequest generates requests for GetLogProfiles
func NewGetLogProfilesRequest(server string, params *GetLogProfilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogProfileRequest calls the generic CreateLogProfile builder with application/json body
func NewCreateLogProfileRequest(server string, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogProfileRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateLogProfileRequestWithBody generates requests for CreateLogProfile with any type of body
func NewCreateLogProfileRequestWithBody(server string, params *CreateLogProfileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogProfileRequest generates requests for DeleteLogProfile
func NewDeleteLogProfileRequest(server string, name string, params *DeleteLogProfileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogProfileRequest generates requests for GetLogProfile
func NewGetLogProfileRequest(server string, name string, params *GetLogProfileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditLogProfileRequest calls the generic EditLogProfile builder with application/json body
func NewEditLogProfileRequest(server string, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditLogProfileRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditLogProfileRequestWithBody generates requests for EditLogProfile with any type of body
func NewEditLogProfileRequestWithBody(server string, name string, params *EditLogProfileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMailerEntriesRequest generates requests for GetMailerEntries
func NewGetMailerEntriesRequest(server string, params *GetMailerEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMailerEntryRequest calls the generic CreateMailerEntry builder with application/json body
func NewCreateMailerEntryRequest(server string, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMailerEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateMailerEntryRequestWithBody generates requests for CreateMailerEntry with any type of body
func NewCreateMailerEntryRequestWithBody(server string, params *CreateMailerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMailerEntryRequest generates requests for DeleteMailerEntry
func NewDeleteMailerEntryRequest(server string, name string, params *DeleteMailerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMailerEntryRequest generates requests for GetMailerEntry
func NewGetMailerEntryRequest(server string, name string, params *GetMailerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceMailerEntryRequest calls the generic ReplaceMailerEntry builder with application/json body
func NewReplaceMailerEntryRequest(server string, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceMailerEntryRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceMailerEntryRequestWithBody generates requests for ReplaceMailerEntry with any type of body
func NewReplaceMailerEntryRequestWithBody(server string, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMailersSectionsRequest generates requests for GetMailersSections
func NewGetMailersSectionsRequest(server string, params *GetMailersSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMailersSectionRequest calls the generic CreateMailersSection builder with application/json body
func NewCreateMailersSectionRequest(server string, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMailersSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateMailersSectionRequestWithBody generates requests for CreateMailersSection with any type of body
func NewCreateMailersSectionRequestWithBody(server string, params *CreateMailersSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMailersSectionRequest generates requests for DeleteMailersSection
func NewDeleteMailersSectionRequest(server string, name string, params *DeleteMailersSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMailersSectionRequest generates requests for GetMailersSection
func NewGetMailersSectionRequest(server string, name string, params *GetMailersSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditMailersSectionRequest calls the generic EditMailersSection builder with application/json body
func NewEditMailersSectionRequest(server string, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditMailersSectionRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditMailersSectionRequestWithBody generates requests for EditMailersSection with any type of body
func NewEditMailersSectionRequestWithBody(server string, name string, params *EditMailersSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNameserversRequest generates requests for GetNameservers
func NewGetNameserversRequest(server string, params *GetNameserversParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNameserverRequest calls the generic CreateNameserver builder with application/json body
func NewCreateNameserverRequest(server string, params *CreateNameserverParams, body CreateNameserverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNameserverRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateNameserverRequestWithBody generates requests for CreateNameserver with any type of body
func NewCreateNameserverRequestWithBody(server string, params *CreateNameserverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNameserverRequest generates requests for DeleteNameserver
func NewDeleteNameserverRequest(server string, name string, params *DeleteNameserverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNameserverRequest generates requests for GetNameserver
func NewGetNameserverRequest(server string, name string, params *GetNameserverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceNameserverRequest calls the generic ReplaceNameserver builder with application/json body
func NewReplaceNameserverRequest(server string, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceNameserverRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceNameserverRequestWithBody generates requests for ReplaceNameserver with any type of body
func NewReplaceNameserverRequestWithBody(server string, name string, params *ReplaceNameserverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPeerEntriesRequest generates requests for GetPeerEntries
func NewGetPeerEntriesRequest(server string, params *GetPeerEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePeerEntryRequest calls the generic CreatePeerEntry builder with application/json body
func NewCreatePeerEntryRequest(server string, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePeerEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePeerEntryRequestWithBody generates requests for CreatePeerEntry with any type of body
func NewCreatePeerEntryRequestWithBody(server string, params *CreatePeerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePeerEntryRequest generates requests for DeletePeerEntry
func NewDeletePeerEntryRequest(server string, name string, params *DeletePeerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeerEntryRequest generates requests for GetPeerEntry
func NewGetPeerEntryRequest(server string, name string, params *GetPeerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplacePeerEntryRequest calls the generic ReplacePeerEntry builder with application/json body
func NewReplacePeerEntryRequest(server string, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplacePeerEntryRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplacePeerEntryRequestWithBody generates requests for ReplacePeerEntry with any type of body
func NewReplacePeerEntryRequestWithBody(server string, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPeerSectionsRequest generates requests for GetPeerSections
func NewGetPeerSectionsRequest(server string, params *GetPeerSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePeerRequest calls the generic CreatePeer builder with application/json body
func NewCreatePeerRequest(server string, params *CreatePeerParams, body CreatePeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePeerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePeerRequestWithBody generates requests for CreatePeer with any type of body
func NewCreatePeerRequestWithBody(server string, params *CreatePeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePeerRequest generates requests for DeletePeer
func NewDeletePeerRequest(server string, name string, params *DeletePeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeerSectionRequest generates requests for GetPeerSection
func NewGetPeerSectionRequest(server string, name string, params *GetPeerSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllBindPeerRequest generates requests for GetAllBindPeer
func NewGetAllBindPeerRequest(server string, parentName ParentName, params *GetAllBindPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBindPeerRequest calls the generic CreateBindPeer builder with application/json body
func NewCreateBindPeerRequest(server string, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBindPeerRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateBindPeerRequestWithBody generates requests for CreateBindPeer with any type of body
func NewCreateBindPeerRequestWithBody(server string, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBindPeerRequest generates requests for DeleteBindPeer
func NewDeleteBindPeerRequest(server string, parentName ParentName, name string, params *DeleteBindPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBindPeerRequest generates requests for GetBindPeer
func NewGetBindPeerRequest(server string, parentName ParentName, name string, params *GetBindPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBindPeerRequest calls the generic ReplaceBindPeer builder with application/json body
func NewReplaceBindPeerRequest(server string, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBindPeerRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceBindPeerRequestWithBody generates requests for ReplaceBindPeer with any type of body
func NewReplaceBindPeerRequestWithBody(server string, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetPeerRequest generates requests for GetAllLogTargetPeer
func NewGetAllLogTargetPeerRequest(server string, parentName ParentName, params *GetAllLogTargetPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetPeerRequest calls the generic ReplaceAllLogTargetPeer builder with application/json body
func NewReplaceAllLogTargetPeerRequest(server string, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetPeerRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetPeerRequestWithBody generates requests for ReplaceAllLogTargetPeer with any type of body
func NewReplaceAllLogTargetPeerRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetPeerRequest generates requests for DeleteLogTargetPeer
func NewDeleteLogTargetPeerRequest(server string, parentName ParentName, index int, params *DeleteLogTargetPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetPeerRequest generates requests for GetLogTargetPeer
func NewGetLogTargetPeerRequest(server string, parentName ParentName, index int, params *GetLogTargetPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetPeerRequest calls the generic CreateLogTargetPeer builder with application/json body
func NewCreateLogTargetPeerRequest(server string, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetPeerRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetPeerRequestWithBody generates requests for CreateLogTargetPeer with any type of body
func NewCreateLogTargetPeerRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetPeerRequest calls the generic ReplaceLogTargetPeer builder with application/json body
func NewReplaceLogTargetPeerRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetPeerRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetPeerRequestWithBody generates requests for ReplaceLogTargetPeer with any type of body
func NewReplaceLogTargetPeerRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerPeerRequest generates requests for GetAllServerPeer
func NewGetAllServerPeerRequest(server string, parentName ParentName, params *GetAllServerPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerPeerRequest calls the generic CreateServerPeer builder with application/json body
func NewCreateServerPeerRequest(server string, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerPeerRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerPeerRequestWithBody generates requests for CreateServerPeer with any type of body
func NewCreateServerPeerRequestWithBody(server string, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerPeerRequest generates requests for DeleteServerPeer
func NewDeleteServerPeerRequest(server string, parentName ParentName, name string, params *DeleteServerPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerPeerRequest generates requests for GetServerPeer
func NewGetServerPeerRequest(server string, parentName ParentName, name string, params *GetServerPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerPeerRequest calls the generic ReplaceServerPeer builder with application/json body
func NewReplaceServerPeerRequest(server string, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerPeerRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceServerPeerRequestWithBody generates requests for ReplaceServerPeer with any type of body
func NewReplaceServerPeerRequestWithBody(server string, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTablesRequest generates requests for GetTables
func NewGetTablesRequest(server string, parentName ParentName, params *GetTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTableRequest generates requests for DeleteTable
func NewDeleteTableRequest(server string, parentName ParentName, name string, params *DeleteTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, parentName ParentName, name string, params *GetTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceTableRequest calls the generic ReplaceTable builder with application/json body
func NewReplaceTableRequest(server string, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTableRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceTableRequestWithBody generates requests for ReplaceTable with any type of body
func NewReplaceTableRequestWithBody(server string, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProgramsRequest generates requests for GetPrograms
func NewGetProgramsRequest(server string, params *GetProgramsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProgramRequest calls the generic CreateProgram builder with application/json body
func NewCreateProgramRequest(server string, params *CreateProgramParams, body CreateProgramJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProgramRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateProgramRequestWithBody generates requests for CreateProgram with any type of body
func NewCreateProgramRequestWithBody(server string, params *CreateProgramParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProgramRequest generates requests for DeleteProgram
func NewDeleteProgramRequest(server string, name string, params *DeleteProgramParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramRequest generates requests for GetProgram
func NewGetProgramRequest(server string, name string, params *GetProgramParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceProgramRequest calls the generic ReplaceProgram builder with application/json body
func NewReplaceProgramRequest(server string, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceProgramRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceProgramRequestWithBody generates requests for ReplaceProgram with any type of body
func NewReplaceProgramRequestWithBody(server string, name string, params *ReplaceProgramParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHAProxyConfigurationRequest generates requests for GetHAProxyConfiguration
func NewGetHAProxyConfigurationRequest(server string, params *GetHAProxyConfigurationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostHAProxyConfigurationRequestWithTextBody calls the generic PostHAProxyConfiguration builder with text/plain body
func NewPostHAProxyConfigurationRequestWithTextBody(server string, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewPostHAProxyConfigurationRequestWithBody(server, params, "text/plain", bodyReader)
}

// NewPostHAProxyConfigurationRequestWithBody generates requests for PostHAProxyConfiguration with any type of body
func NewPostHAProxyConfigurationRequestWithBody(server string, params *PostHAProxyConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_version", runtime.ParamLocationQuery, *params.SkipVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyValidate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_validate", runtime.ParamLocationQuery, *params.OnlyValidate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRuntimeActions != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Runtime-Actions", runtime.ParamLocationHeader, *params.XRuntimeActions)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Runtime-Actions", headerParam0)
		}

	}

	return req, nil
}

// NewGetResolversRequest generates requests for GetResolvers
func NewGetResolversRequest(server string, params *GetResolversParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateResolverRequest calls the generic CreateResolver builder with application/json body
func NewCreateResolverRequest(server string, params *CreateResolverParams, body CreateResolverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResolverRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateResolverRequestWithBody generates requests for CreateResolver with any type of body
func NewCreateResolverRequestWithBody(server string, params *CreateResolverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResolverRequest generates requests for DeleteResolver
func NewDeleteResolverRequest(server string, name string, params *DeleteResolverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResolverRequest generates requests for GetResolver
func NewGetResolverRequest(server string, name string, params *GetResolverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceResolverRequest calls the generic ReplaceResolver builder with application/json body
func NewReplaceResolverRequest(server string, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceResolverRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceResolverRequestWithBody generates requests for ReplaceResolver with any type of body
func NewReplaceResolverRequestWithBody(server string, name string, params *ReplaceResolverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRingsRequest generates requests for GetRings
func NewGetRingsRequest(server string, params *GetRingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRingRequest calls the generic CreateRing builder with application/json body
func NewCreateRingRequest(server string, params *CreateRingParams, body CreateRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRingRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRingRequestWithBody generates requests for CreateRing with any type of body
func NewCreateRingRequestWithBody(server string, params *CreateRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRingRequest generates requests for DeleteRing
func NewDeleteRingRequest(server string, name string, params *DeleteRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRingRequest generates requests for GetRing
func NewGetRingRequest(server string, name string, params *GetRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceRingRequest calls the generic ReplaceRing builder with application/json body
func NewReplaceRingRequest(server string, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRingRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceRingRequestWithBody generates requests for ReplaceRing with any type of body
func NewReplaceRingRequestWithBody(server string, name string, params *ReplaceRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerRingRequest generates requests for GetAllServerRing
func NewGetAllServerRingRequest(server string, parentName ParentName, params *GetAllServerRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerRingRequest calls the generic CreateServerRing builder with application/json body
func NewCreateServerRingRequest(server string, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerRingRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerRingRequestWithBody generates requests for CreateServerRing with any type of body
func NewCreateServerRingRequestWithBody(server string, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerRingRequest generates requests for DeleteServerRing
func NewDeleteServerRingRequest(server string, parentName ParentName, name string, params *DeleteServerRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerRingRequest generates requests for GetServerRing
func NewGetServerRingRequest(server string, parentName ParentName, name string, params *GetServerRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerRingRequest calls the generic ReplaceServerRing builder with application/json body
func NewReplaceServerRingRequest(server string, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerRingRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceServerRingRequestWithBody generates requests for ReplaceServerRing with any type of body
func NewReplaceServerRingRequestWithBody(server string, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTracesRequest generates requests for DeleteTraces
func NewDeleteTracesRequest(server string, params *DeleteTracesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTracesRequest generates requests for GetTraces
func NewGetTracesRequest(server string, params *GetTracesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTracesRequest calls the generic CreateTraces builder with application/json body
func NewCreateTracesRequest(server string, params *CreateTracesParams, body CreateTracesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTracesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTracesRequestWithBody generates requests for CreateTraces with any type of body
func NewCreateTracesRequestWithBody(server string, params *CreateTracesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTracesRequest calls the generic ReplaceTraces builder with application/json body
func NewReplaceTracesRequest(server string, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTracesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceTracesRequestWithBody generates requests for ReplaceTraces with any type of body
func NewReplaceTracesRequestWithBody(server string, params *ReplaceTracesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTraceEntryRequest calls the generic DeleteTraceEntry builder with application/json body
func NewDeleteTraceEntryRequest(server string, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTraceEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeleteTraceEntryRequestWithBody generates requests for DeleteTraceEntry with any type of body
func NewDeleteTraceEntryRequestWithBody(server string, params *DeleteTraceEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTraceEntryRequest calls the generic CreateTraceEntry builder with application/json body
func NewCreateTraceEntryRequest(server string, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTraceEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTraceEntryRequestWithBody generates requests for CreateTraceEntry with any type of body
func NewCreateTraceEntryRequestWithBody(server string, params *CreateTraceEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/traces/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserlistsRequest generates requests for GetUserlists
func NewGetUserlistsRequest(server string, params *GetUserlistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserlistRequest calls the generic CreateUserlist builder with application/json body
func NewCreateUserlistRequest(server string, params *CreateUserlistParams, body CreateUserlistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserlistRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserlistRequestWithBody generates requests for CreateUserlist with any type of body
func NewCreateUserlistRequestWithBody(server string, params *CreateUserlistParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserlistRequest generates requests for DeleteUserlist
func NewDeleteUserlistRequest(server string, name string, params *DeleteUserlistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserlistRequest generates requests for GetUserlist
func NewGetUserlistRequest(server string, name string, params *GetUserlistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, params *CreateUserParams, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, username string, params *DeleteUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, username string, params *GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceUserRequest calls the generic ReplaceUser builder with application/json body
func NewReplaceUserRequest(server string, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceUserRequestWithBody(server, username, params, "application/json", bodyReader)
}

// NewReplaceUserRequestWithBody generates requests for ReplaceUser with any type of body
func NewReplaceUserRequestWithBody(server string, username string, params *ReplaceUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConfigurationVersionRequest generates requests for GetConfigurationVersion
func NewGetConfigurationVersionRequest(server string, params *GetConfigurationVersionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReloadsRequest generates requests for GetReloads
func NewGetReloadsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/reloads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReloadRequest generates requests for GetReload
func NewGetReloadRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/reloads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeEndpointsRequest generates requests for GetRuntimeEndpoints
func NewGetRuntimeEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsRequest generates requests for GetServicesHaproxyRuntimeAcls
func NewGetServicesHaproxyRuntimeAclsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsIdRequest generates requests for GetServicesHaproxyRuntimeAclsId
func NewGetServicesHaproxyRuntimeAclsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsParentNameEntriesRequest generates requests for GetServicesHaproxyRuntimeAclsParentNameEntries
func NewGetServicesHaproxyRuntimeAclsParentNameEntriesRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequest calls the generic PostServicesHaproxyRuntimeAclsParentNameEntries builder with application/json body
func NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequest(server string, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody generates requests for PostServicesHaproxyRuntimeAclsParentNameEntries with any type of body
func NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddPayloadRuntimeACLRequest calls the generic AddPayloadRuntimeACL builder with application/json body
func NewAddPayloadRuntimeACLRequest(server string, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPayloadRuntimeACLRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewAddPayloadRuntimeACLRequestWithBody generates requests for AddPayloadRuntimeACL with any type of body
func NewAddPayloadRuntimeACLRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdRequest generates requests for DeleteServicesHaproxyRuntimeAclsParentNameEntriesId
func NewDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsParentNameEntriesIdRequest generates requests for GetServicesHaproxyRuntimeAclsParentNameEntriesId
func NewGetServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAcmeStatusRequest generates requests for GetAcmeStatus
func NewGetAcmeStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acme")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRenewAcmeCertificateRequest generates requests for RenewAcmeCertificate
func NewRenewAcmeCertificateRequest(server string, params *RenewAcmeCertificateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acme")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "certificate", runtime.ParamLocationQuery, params.Certificate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllRuntimeServerRequest generates requests for GetAllRuntimeServer
func NewGetAllRuntimeServerRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRuntimeServerRequest calls the generic AddRuntimeServer builder with application/json body
func NewAddRuntimeServerRequest(server string, parentName ParentName, body AddRuntimeServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRuntimeServerRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewAddRuntimeServerRequestWithBody generates requests for AddRuntimeServer with any type of body
func NewAddRuntimeServerRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuntimeServerRequest generates requests for DeleteRuntimeServer
func NewDeleteRuntimeServerRequest(server string, parentName ParentName, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeServerRequest generates requests for GetRuntimeServer
func NewGetRuntimeServerRequest(server string, parentName ParentName, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceRuntimeServerRequest calls the generic ReplaceRuntimeServer builder with application/json body
func NewReplaceRuntimeServerRequest(server string, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRuntimeServerRequestWithBody(server, parentName, name, "application/json", bodyReader)
}

// NewReplaceRuntimeServerRequestWithBody generates requests for ReplaceRuntimeServer with any type of body
func NewReplaceRuntimeServerRequestWithBody(server string, parentName ParentName, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHaproxyProcessInfoRequest generates requests for GetHaproxyProcessInfo
func NewGetHaproxyProcessInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllRuntimeMapFilesRequest generates requests for GetAllRuntimeMapFiles
func NewGetAllRuntimeMapFilesRequest(server string, params *GetAllRuntimeMapFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeUnmanaged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_unmanaged", runtime.ParamLocationQuery, *params.IncludeUnmanaged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearRuntimeMapRequest generates requests for ClearRuntimeMap
func NewClearRuntimeMapRequest(server string, name string, params *ClearRuntimeMapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "forceDelete", runtime.ParamLocationQuery, *params.ForceDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneRuntimeMapRequest generates requests for GetOneRuntimeMap
func NewGetOneRuntimeMapRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPayloadRuntimeMapRequest calls the generic AddPayloadRuntimeMap builder with application/json body
func NewAddPayloadRuntimeMapRequest(server string, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPayloadRuntimeMapRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewAddPayloadRuntimeMapRequestWithBody generates requests for AddPayloadRuntimeMap with any type of body
func NewAddPayloadRuntimeMapRequestWithBody(server string, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShowRuntimeMapRequest generates requests for ShowRuntimeMap
func NewShowRuntimeMapRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMapEntryRequest calls the generic AddMapEntry builder with application/json body
func NewAddMapEntryRequest(server string, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMapEntryRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewAddMapEntryRequestWithBody generates requests for AddMapEntry with any type of body
func NewAddMapEntryRequestWithBody(server string, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuntimeMapEntryRequest generates requests for DeleteRuntimeMapEntry
func NewDeleteRuntimeMapEntryRequest(server string, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeMapEntryRequest generates requests for GetRuntimeMapEntry
func NewGetRuntimeMapEntryRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceRuntimeMapEntryRequest calls the generic ReplaceRuntimeMapEntry builder with application/json body
func NewReplaceRuntimeMapEntryRequest(server string, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRuntimeMapEntryRequestWithBody(server, parentName, id, params, "application/json", bodyReader)
}

// NewReplaceRuntimeMapEntryRequestWithBody generates requests for ReplaceRuntimeMapEntry with any type of body
func NewReplaceRuntimeMapEntryRequestWithBody(server string, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllCaFilesRequest generates requests for GetAllCaFiles
func NewGetAllCaFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_ca_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCaFileRequestWithBody generates requests for CreateCaFile with any type of body
func NewCreateCaFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_ca_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCaFileRequest generates requests for DeleteCaFile
func NewDeleteCaFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_ca_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCaFileRequest generates requests for GetCaFile
func NewGetCaFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_ca_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetCaFileRequestWithBody generates requests for SetCaFile with any type of body
func NewSetCaFileRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_ca_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddCaEntryRequestWithBody generates requests for AddCaEntry with any type of body
func NewAddCaEntryRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_ca_files/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCaEntryRequest generates requests for GetCaEntry
func NewGetCaEntryRequest(server string, name string, index int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_ca_files/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllCertsRequest generates requests for GetAllCerts
func NewGetAllCertsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_certs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCertRequestWithBody generates requests for CreateCert with any type of body
func NewCreateCertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_certs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCertRequest generates requests for DeleteCert
func NewDeleteCertRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_certs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCertRequest generates requests for GetCert
func NewGetCertRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_certs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceCertRequestWithBody generates requests for ReplaceCert with any type of body
func NewReplaceCertRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_certs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllCrlRequest generates requests for GetAllCrl
func NewGetAllCrlRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_crl_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCrlRequestWithBody generates requests for CreateCrl with any type of body
func NewCreateCrlRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_crl_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCrlRequest generates requests for DeleteCrl
func NewDeleteCrlRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_crl_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCrlRequest generates requests for GetCrl
func NewGetCrlRequest(server string, name string, params *GetCrlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_crl_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Index != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "index", runtime.ParamLocationQuery, *params.Index); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceCrlRequestWithBody generates requests for ReplaceCrl with any type of body
func NewReplaceCrlRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_crl_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllCrtListsRequest generates requests for GetAllCrtLists
func NewGetAllCrtListsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_crt_lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCrtListEntryRequest generates requests for DeleteCrtListEntry
func NewDeleteCrtListEntryRequest(server string, params *DeleteCrtListEntryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_crt_lists/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cert_file", runtime.ParamLocationQuery, params.CertFile); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LineNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "line_number", runtime.ParamLocationQuery, *params.LineNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllCrtListEntriesRequest generates requests for GetAllCrtListEntries
func NewGetAllCrtListEntriesRequest(server string, params *GetAllCrtListEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_crt_lists/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddCrtListEntryRequest calls the generic AddCrtListEntry builder with application/json body
func NewAddCrtListEntryRequest(server string, params *AddCrtListEntryParams, body AddCrtListEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCrtListEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddCrtListEntryRequestWithBody generates requests for AddCrtListEntry with any type of body
func NewAddCrtListEntryRequestWithBody(server string, params *AddCrtListEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/ssl_crt_lists/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, params.Name); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStickTablesRequest generates requests for GetStickTables
func NewGetStickTablesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStickTableRequest generates requests for GetStickTable
func NewGetStickTableRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStickTableEntriesRequest generates requests for GetStickTableEntries
func NewGetStickTableEntriesRequest(server string, parentName ParentName, params *GetStickTableEntriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetStickTableEntriesRequest calls the generic SetStickTableEntries builder with application/json body
func NewSetStickTableEntriesRequest(server string, parentName ParentName, body SetStickTableEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetStickTableEntriesRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewSetStickTableEntriesRequestWithBody generates requests for SetStickTableEntries with any type of body
func NewSetStickTableEntriesRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSitesRequest generates requests for GetSites
func NewGetSitesRequest(server string, params *GetSitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSiteRequest calls the generic CreateSite builder with application/json body
func NewCreateSiteRequest(server string, params *CreateSiteParams, body CreateSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSiteRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSiteRequestWithBody generates requests for CreateSite with any type of body
func NewCreateSiteRequestWithBody(server string, params *CreateSiteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSiteRequest generates requests for DeleteSite
func NewDeleteSiteRequest(server string, name string, params *DeleteSiteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSiteRequest generates requests for GetSite
func NewGetSiteRequest(server string, name string, params *GetSiteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSiteRequest calls the generic ReplaceSite builder with application/json body
func NewReplaceSiteRequest(server string, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSiteRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceSiteRequestWithBody generates requests for ReplaceSite with any type of body
func NewReplaceSiteRequestWithBody(server string, name string, params *ReplaceSiteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSpoeEndpointsRequest generates requests for GetSpoeEndpoints
func NewGetSpoeEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSpoeFilesRequest generates requests for GetAllSpoeFiles
func NewGetAllSpoeFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeRequestWithBody generates requests for CreateSpoe with any type of body
func NewCreateSpoeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeFileRequest generates requests for DeleteSpoeFile
func NewDeleteSpoeFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneSpoeFileRequest generates requests for GetOneSpoeFile
func NewGetOneSpoeFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSpoeScopeRequest generates requests for GetAllSpoeScope
func NewGetAllSpoeScopeRequest(server string, parentName ParentName, params *GetAllSpoeScopeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeScopeRequest calls the generic CreateSpoeScope builder with application/json body
func NewCreateSpoeScopeRequest(server string, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeScopeRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateSpoeScopeRequestWithBody generates requests for CreateSpoeScope with any type of body
func NewCreateSpoeScopeRequestWithBody(server string, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeScopeRequest generates requests for DeleteSpoeScope
func NewDeleteSpoeScopeRequest(server string, parentName ParentName, name string, params *DeleteSpoeScopeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeScopeRequest generates requests for GetSpoeScope
func NewGetSpoeScopeRequest(server string, parentName ParentName, name string, params *GetSpoeScopeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSpoeAgentRequest generates requests for GetAllSpoeAgent
func NewGetAllSpoeAgentRequest(server string, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeAgentRequest calls the generic CreateSpoeAgent builder with application/json body
func NewCreateSpoeAgentRequest(server string, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeAgentRequestWithBody(server, parentName, scopeName, params, "application/json", bodyReader)
}

// NewCreateSpoeAgentRequestWithBody generates requests for CreateSpoeAgent with any type of body
func NewCreateSpoeAgentRequestWithBody(server string, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeAgentRequest generates requests for DeleteSpoeAgent
func NewDeleteSpoeAgentRequest(server string, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeAgentRequest generates requests for GetSpoeAgent
func NewGetSpoeAgentRequest(server string, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSpoeAgentRequest calls the generic ReplaceSpoeAgent builder with application/json body
func NewReplaceSpoeAgentRequest(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSpoeAgentRequestWithBody(server, parentName, scopeName, name, params, "application/json", bodyReader)
}

// NewReplaceSpoeAgentRequestWithBody generates requests for ReplaceSpoeAgent with any type of body
func NewReplaceSpoeAgentRequestWithBody(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSpoeGroupRequest generates requests for GetAllSpoeGroup
func NewGetAllSpoeGroupRequest(server string, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeGroupRequest calls the generic CreateSpoeGroup builder with application/json body
func NewCreateSpoeGroupRequest(server string, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeGroupRequestWithBody(server, parentName, scopeName, params, "application/json", bodyReader)
}

// NewCreateSpoeGroupRequestWithBody generates requests for CreateSpoeGroup with any type of body
func NewCreateSpoeGroupRequestWithBody(server string, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeGroupRequest generates requests for DeleteSpoeGroup
func NewDeleteSpoeGroupRequest(server string, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeGroupRequest generates requests for GetSpoeGroup
func NewGetSpoeGroupRequest(server string, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSpoeGroupRequest calls the generic ReplaceSpoeGroup builder with application/json body
func NewReplaceSpoeGroupRequest(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSpoeGroupRequestWithBody(server, parentName, scopeName, name, params, "application/json", bodyReader)
}

// NewReplaceSpoeGroupRequestWithBody generates requests for ReplaceSpoeGroup with any type of body
func NewReplaceSpoeGroupRequestWithBody(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSpoeMessageRequest generates requests for GetAllSpoeMessage
func NewGetAllSpoeMessageRequest(server string, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeMessageRequest calls the generic CreateSpoeMessage builder with application/json body
func NewCreateSpoeMessageRequest(server string, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeMessageRequestWithBody(server, parentName, scopeName, params, "application/json", bodyReader)
}

// NewCreateSpoeMessageRequestWithBody generates requests for CreateSpoeMessage with any type of body
func NewCreateSpoeMessageRequestWithBody(server string, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeMessageRequest generates requests for DeleteSpoeMessage
func NewDeleteSpoeMessageRequest(server string, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeMessageRequest generates requests for GetSpoeMessage
func NewGetSpoeMessageRequest(server string, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSpoeMessageRequest calls the generic ReplaceSpoeMessage builder with application/json body
func NewReplaceSpoeMessageRequest(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSpoeMessageRequestWithBody(server, parentName, scopeName, name, params, "application/json", bodyReader)
}

// NewReplaceSpoeMessageRequestWithBody generates requests for ReplaceSpoeMessage with any type of body
func NewReplaceSpoeMessageRequestWithBody(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSpoeTransactionRequest generates requests for GetAllSpoeTransaction
func NewGetAllSpoeTransactionRequest(server string, parentName ParentName, params *GetAllSpoeTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartSpoeTransactionRequest generates requests for StartSpoeTransaction
func NewStartSpoeTransactionRequest(server string, parentName ParentName, params *StartSpoeTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSpoeTransactionRequest generates requests for DeleteSpoeTransaction
func NewDeleteSpoeTransactionRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeTransactionRequest generates requests for GetSpoeTransaction
func NewGetSpoeTransactionRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitSpoeTransactionRequest generates requests for CommitSpoeTransaction
func NewCommitSpoeTransactionRequest(server string, parentName ParentName, id string, params *CommitSpoeTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeConfigurationVersionRequest generates requests for GetSpoeConfigurationVersion
func NewGetSpoeConfigurationVersionRequest(server string, parentName ParentName, params *GetSpoeConfigurationVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/%s/version", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsEndpointsRequest generates requests for GetStatsEndpoints
func NewGetStatsEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, params *GetStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/stats/native")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageEndpointsRequest generates requests for GetStorageEndpoints
func NewGetStorageEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllStorageGeneralFilesRequest generates requests for GetAllStorageGeneralFiles
func NewGetAllStorageGeneralFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageGeneralFileRequestWithBody generates requests for CreateStorageGeneralFile with any type of body
func NewCreateStorageGeneralFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageGeneralFileRequest generates requests for DeleteStorageGeneralFile
func NewDeleteStorageGeneralFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageGeneralFileRequest generates requests for GetOneStorageGeneralFile
func NewGetOneStorageGeneralFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageGeneralFileRequestWithBody generates requests for ReplaceStorageGeneralFile with any type of body
func NewReplaceStorageGeneralFileRequestWithBody(server string, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllStorageMapFilesRequest generates requests for GetAllStorageMapFiles
func NewGetAllStorageMapFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageMapFileRequestWithBody generates requests for CreateStorageMapFile with any type of body
func NewCreateStorageMapFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageMapRequest generates requests for DeleteStorageMap
func NewDeleteStorageMapRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageMapRequest generates requests for GetOneStorageMap
func NewGetOneStorageMapRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageMapFileRequestWithTextBody calls the generic ReplaceStorageMapFile builder with text/plain body
func NewReplaceStorageMapFileRequestWithTextBody(server string, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewReplaceStorageMapFileRequestWithBody(server, name, params, "text/plain", bodyReader)
}

// NewReplaceStorageMapFileRequestWithBody generates requests for ReplaceStorageMapFile with any type of body
func NewReplaceStorageMapFileRequestWithBody(server string, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllStorageSSLCertificatesRequest generates requests for GetAllStorageSSLCertificates
func NewGetAllStorageSSLCertificatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageSSLCertificateRequestWithBody generates requests for CreateStorageSSLCertificate with any type of body
func NewCreateStorageSSLCertificateRequestWithBody(server string, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageSSLCertificateRequest generates requests for DeleteStorageSSLCertificate
func NewDeleteStorageSSLCertificateRequest(server string, name string, params *DeleteStorageSSLCertificateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageSSLCertificateRequest generates requests for GetOneStorageSSLCertificate
func NewGetOneStorageSSLCertificateRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageSSLCertificateRequestWithTextBody calls the generic ReplaceStorageSSLCertificate builder with text/plain body
func NewReplaceStorageSSLCertificateRequestWithTextBody(server string, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewReplaceStorageSSLCertificateRequestWithBody(server, name, params, "text/plain", bodyReader)
}

// NewReplaceStorageSSLCertificateRequestWithBody generates requests for ReplaceStorageSSLCertificate with any type of body
func NewReplaceStorageSSLCertificateRequestWithBody(server string, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllStorageSSLCrtListFilesRequest generates requests for GetAllStorageSSLCrtListFiles
func NewGetAllStorageSSLCrtListFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_crt_lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageSSLCrtListFileRequestWithBody generates requests for CreateStorageSSLCrtListFile with any type of body
func NewCreateStorageSSLCrtListFileRequestWithBody(server string, params *CreateStorageSSLCrtListFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_crt_lists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageSSLCrtListFileRequest generates requests for DeleteStorageSSLCrtListFile
func NewDeleteStorageSSLCrtListFileRequest(server string, name string, params *DeleteStorageSSLCrtListFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_crt_lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageSSLCrtListFileRequest generates requests for GetOneStorageSSLCrtListFile
func NewGetOneStorageSSLCrtListFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_crt_lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageSSLCrtListFileRequestWithTextBody calls the generic ReplaceStorageSSLCrtListFile builder with text/plain body
func NewReplaceStorageSSLCrtListFileRequestWithTextBody(server string, name string, params *ReplaceStorageSSLCrtListFileParams, body ReplaceStorageSSLCrtListFileTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewReplaceStorageSSLCrtListFileRequestWithBody(server, name, params, "text/plain", bodyReader)
}

// NewReplaceStorageSSLCrtListFileRequestWithBody generates requests for ReplaceStorageSSLCrtListFile with any type of body
func NewReplaceStorageSSLCrtListFileRequestWithBody(server string, name string, params *ReplaceStorageSSLCrtListFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_crt_lists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageSSLCrtListEntryRequest generates requests for DeleteStorageSSLCrtListEntry
func NewDeleteStorageSSLCrtListEntryRequest(server string, name string, params *DeleteStorageSSLCrtListEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_crt_lists/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "certificate", runtime.ParamLocationQuery, params.Certificate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "line_number", runtime.ParamLocationQuery, params.LineNumber); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageSSLCrtListEntriesRequest generates requests for GetStorageSSLCrtListEntries
func NewGetStorageSSLCrtListEntriesRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_crt_lists/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageSSLCrtListEntryRequest calls the generic CreateStorageSSLCrtListEntry builder with application/json body
func NewCreateStorageSSLCrtListEntryRequest(server string, name string, params *CreateStorageSSLCrtListEntryParams, body CreateStorageSSLCrtListEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStorageSSLCrtListEntryRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewCreateStorageSSLCrtListEntryRequestWithBody generates requests for CreateStorageSSLCrtListEntry with any type of body
func NewCreateStorageSSLCrtListEntryRequestWithBody(server string, name string, params *CreateStorageSSLCrtListEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_crt_lists/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTransactionsRequest generates requests for GetTransactions
func NewGetTransactionsRequest(server string, params *GetTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartTransactionRequest generates requests for StartTransaction
func NewStartTransactionRequest(server string, params *StartTransactionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTransactionRequest generates requests for DeleteTransaction
func NewDeleteTransactionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionRequest generates requests for GetTransaction
func NewGetTransactionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitTransactionRequest generates requests for CommitTransaction
func NewCommitTransactionRequest(server string, id string, params *CommitTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpecificationRequest generates requests for GetSpecification
func NewGetSpecificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/specification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiv3SpecificationRequest generates requests for GetOpenapiv3Specification
func NewGetOpenapiv3SpecificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/specification_openapiv3")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAPIEndpointsWithResponse request
	GetAPIEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAPIEndpointsResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// PostClusterWithBodyWithResponse request with any body
	PostClusterWithBodyWithResponse(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterResponse, error)

	PostClusterWithResponse(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterResponse, error)

	// EditClusterWithBodyWithResponse request with any body
	EditClusterWithBodyWithResponse(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditClusterResponse, error)

	EditClusterWithResponse(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*EditClusterResponse, error)

	// InitiateCertificateRefreshWithResponse request
	InitiateCertificateRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitiateCertificateRefreshResponse, error)

	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// GetInfoWithResponse request
	GetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfoResponse, error)

	// GetAWSRegionsWithResponse request
	GetAWSRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAWSRegionsResponse, error)

	// CreateAWSRegionWithBodyWithResponse request with any body
	CreateAWSRegionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error)

	CreateAWSRegionWithResponse(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error)

	// DeleteAWSRegionWithResponse request
	DeleteAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAWSRegionResponse, error)

	// GetAWSRegionWithResponse request
	GetAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAWSRegionResponse, error)

	// ReplaceAWSRegionWithBodyWithResponse request with any body
	ReplaceAWSRegionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error)

	ReplaceAWSRegionWithResponse(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error)

	// GetConsulsWithResponse request
	GetConsulsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConsulsResponse, error)

	// CreateConsulWithBodyWithResponse request with any body
	CreateConsulWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error)

	CreateConsulWithResponse(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error)

	// DeleteConsulWithResponse request
	DeleteConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteConsulResponse, error)

	// GetConsulWithResponse request
	GetConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConsulResponse, error)

	// ReplaceConsulWithBodyWithResponse request with any body
	ReplaceConsulWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error)

	ReplaceConsulWithResponse(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error)

	// GetServicesEndpointsWithResponse request
	GetServicesEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesEndpointsResponse, error)

	// GetHaproxyEndpointsWithResponse request
	GetHaproxyEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyEndpointsResponse, error)

	// GetConfigurationEndpointsWithResponse request
	GetConfigurationEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationEndpointsResponse, error)

	// GetAcmeProvidersWithResponse request
	GetAcmeProvidersWithResponse(ctx context.Context, params *GetAcmeProvidersParams, reqEditors ...RequestEditorFn) (*GetAcmeProvidersResponse, error)

	// CreateAcmeProviderWithBodyWithResponse request with any body
	CreateAcmeProviderWithBodyWithResponse(ctx context.Context, params *CreateAcmeProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAcmeProviderResponse, error)

	CreateAcmeProviderWithResponse(ctx context.Context, params *CreateAcmeProviderParams, body CreateAcmeProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAcmeProviderResponse, error)

	// DeleteAcmeProviderWithResponse request
	DeleteAcmeProviderWithResponse(ctx context.Context, name string, params *DeleteAcmeProviderParams, reqEditors ...RequestEditorFn) (*DeleteAcmeProviderResponse, error)

	// GetAcmeProviderWithResponse request
	GetAcmeProviderWithResponse(ctx context.Context, name string, params *GetAcmeProviderParams, reqEditors ...RequestEditorFn) (*GetAcmeProviderResponse, error)

	// EditAcmeProviderWithBodyWithResponse request with any body
	EditAcmeProviderWithBodyWithResponse(ctx context.Context, name string, params *EditAcmeProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAcmeProviderResponse, error)

	EditAcmeProviderWithResponse(ctx context.Context, name string, params *EditAcmeProviderParams, body EditAcmeProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*EditAcmeProviderResponse, error)

	// GetBackendsWithResponse request
	GetBackendsWithResponse(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*GetBackendsResponse, error)

	// CreateBackendWithBodyWithResponse request with any body
	CreateBackendWithBodyWithResponse(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error)

	CreateBackendWithResponse(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error)

	// DeleteBackendWithResponse request
	DeleteBackendWithResponse(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*DeleteBackendResponse, error)

	// GetBackendWithResponse request
	GetBackendWithResponse(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*GetBackendResponse, error)

	// ReplaceBackendWithBodyWithResponse request with any body
	ReplaceBackendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error)

	ReplaceBackendWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error)

	// GetAllAclBackendWithResponse request
	GetAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*GetAllAclBackendResponse, error)

	// ReplaceAllAclBackendWithBodyWithResponse request with any body
	ReplaceAllAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error)

	ReplaceAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error)

	// DeleteAclBackendWithResponse request
	DeleteAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*DeleteAclBackendResponse, error)

	// GetAclBackendWithResponse request
	GetAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*GetAclBackendResponse, error)

	// CreateAclBackendWithBodyWithResponse request with any body
	CreateAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error)

	CreateAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error)

	// ReplaceAclBackendWithBodyWithResponse request with any body
	ReplaceAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error)

	ReplaceAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error)

	// GetAllFilterBackendWithResponse request
	GetAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*GetAllFilterBackendResponse, error)

	// ReplaceAllFilterBackendWithBodyWithResponse request with any body
	ReplaceAllFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error)

	ReplaceAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error)

	// DeleteFilterBackendWithResponse request
	DeleteFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*DeleteFilterBackendResponse, error)

	// GetFilterBackendWithResponse request
	GetFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*GetFilterBackendResponse, error)

	// CreateFilterBackendWithBodyWithResponse request with any body
	CreateFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error)

	CreateFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error)

	// ReplaceFilterBackendWithBodyWithResponse request with any body
	ReplaceFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error)

	ReplaceFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error)

	// GetAllHTTPAfterResponseRuleBackendWithResponse request
	GetAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleBackendResponse, error)

	// ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error)

	ReplaceAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error)

	// DeleteHTTPAfterResponseRuleBackendWithResponse request
	DeleteHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleBackendResponse, error)

	// GetHTTPAfterResponseRuleBackendWithResponse request
	GetHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleBackendResponse, error)

	// CreateHTTPAfterResponseRuleBackendWithBodyWithResponse request with any body
	CreateHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error)

	CreateHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error)

	// ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error)

	ReplaceHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error)

	// GetAllHTTPCheckBackendWithResponse request
	GetAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckBackendResponse, error)

	// ReplaceAllHTTPCheckBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error)

	ReplaceAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error)

	// DeleteHTTPCheckBackendWithResponse request
	DeleteHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckBackendResponse, error)

	// GetHTTPCheckBackendWithResponse request
	GetHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckBackendResponse, error)

	// CreateHTTPCheckBackendWithBodyWithResponse request with any body
	CreateHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error)

	CreateHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error)

	// ReplaceHTTPCheckBackendWithBodyWithResponse request with any body
	ReplaceHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error)

	ReplaceHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error)

	// GetAllHTTPErrorRuleBackendWithResponse request
	GetAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleBackendResponse, error)

	// ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error)

	ReplaceAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error)

	// DeleteHTTPErrorRuleBackendWithResponse request
	DeleteHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleBackendResponse, error)

	// GetHTTPErrorRuleBackendWithResponse request
	GetHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleBackendResponse, error)

	// CreateHTTPErrorRuleBackendWithBodyWithResponse request with any body
	CreateHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error)

	CreateHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error)

	// ReplaceHTTPErrorRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error)

	ReplaceHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error)

	// GetAllHTTPRequestRuleBackendWithResponse request
	GetAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleBackendResponse, error)

	// ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error)

	ReplaceAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error)

	// DeleteHTTPRequestRuleBackendWithResponse request
	DeleteHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleBackendResponse, error)

	// GetHTTPRequestRuleBackendWithResponse request
	GetHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleBackendResponse, error)

	// CreateHTTPRequestRuleBackendWithBodyWithResponse request with any body
	CreateHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error)

	CreateHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error)

	// ReplaceHTTPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error)

	ReplaceHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error)

	// GetAllHTTPResponseRuleBackendWithResponse request
	GetAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleBackendResponse, error)

	// ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error)

	ReplaceAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error)

	// DeleteHTTPResponseRuleBackendWithResponse request
	DeleteHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleBackendResponse, error)

	// GetHTTPResponseRuleBackendWithResponse request
	GetHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleBackendResponse, error)

	// CreateHTTPResponseRuleBackendWithBodyWithResponse request with any body
	CreateHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error)

	CreateHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error)

	// ReplaceHTTPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error)

	ReplaceHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error)

	// GetAllLogTargetBackendWithResponse request
	GetAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetBackendResponse, error)

	// ReplaceAllLogTargetBackendWithBodyWithResponse request with any body
	ReplaceAllLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error)

	ReplaceAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error)

	// DeleteLogTargetBackendWithResponse request
	DeleteLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetBackendResponse, error)

	// GetLogTargetBackendWithResponse request
	GetLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetLogTargetBackendResponse, error)

	// CreateLogTargetBackendWithBodyWithResponse request with any body
	CreateLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error)

	CreateLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error)

	// ReplaceLogTargetBackendWithBodyWithResponse request with any body
	ReplaceLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error)

	ReplaceLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error)

	// GetServerSwitchingRulesWithResponse request
	GetServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRulesResponse, error)

	// ReplaceServerSwitchingRulesWithBodyWithResponse request with any body
	ReplaceServerSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error)

	ReplaceServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error)

	// DeleteServerSwitchingRuleWithResponse request
	DeleteServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteServerSwitchingRuleResponse, error)

	// GetServerSwitchingRuleWithResponse request
	GetServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRuleResponse, error)

	// CreateServerSwitchingRuleWithBodyWithResponse request with any body
	CreateServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error)

	CreateServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error)

	// ReplaceServerSwitchingRuleWithBodyWithResponse request with any body
	ReplaceServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error)

	ReplaceServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error)

	// GetServerTemplatesWithResponse request
	GetServerTemplatesWithResponse(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*GetServerTemplatesResponse, error)

	// CreateServerTemplateWithBodyWithResponse request with any body
	CreateServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error)

	CreateServerTemplateWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error)

	// DeleteServerTemplateWithResponse request
	DeleteServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*DeleteServerTemplateResponse, error)

	// GetServerTemplateWithResponse request
	GetServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*GetServerTemplateResponse, error)

	// ReplaceServerTemplateWithBodyWithResponse request with any body
	ReplaceServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error)

	ReplaceServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error)

	// GetAllServerBackendWithResponse request
	GetAllServerBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*GetAllServerBackendResponse, error)

	// CreateServerBackendWithBodyWithResponse request with any body
	CreateServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error)

	CreateServerBackendWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error)

	// DeleteServerBackendWithResponse request
	DeleteServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*DeleteServerBackendResponse, error)

	// GetServerBackendWithResponse request
	GetServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*GetServerBackendResponse, error)

	// ReplaceServerBackendWithBodyWithResponse request with any body
	ReplaceServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error)

	ReplaceServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error)

	// GetStickRulesWithResponse request
	GetStickRulesWithResponse(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*GetStickRulesResponse, error)

	// ReplaceStickRulesWithBodyWithResponse request with any body
	ReplaceStickRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error)

	ReplaceStickRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error)

	// DeleteStickRuleWithResponse request
	DeleteStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*DeleteStickRuleResponse, error)

	// GetStickRuleWithResponse request
	GetStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*GetStickRuleResponse, error)

	// CreateStickRuleWithBodyWithResponse request with any body
	CreateStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error)

	CreateStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error)

	// ReplaceStickRuleWithBodyWithResponse request with any body
	ReplaceStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error)

	ReplaceStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error)

	// GetAllTCPCheckBackendWithResponse request
	GetAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckBackendResponse, error)

	// ReplaceAllTCPCheckBackendWithBodyWithResponse request with any body
	ReplaceAllTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error)

	ReplaceAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error)

	// DeleteTCPCheckBackendWithResponse request
	DeleteTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckBackendResponse, error)

	// GetTCPCheckBackendWithResponse request
	GetTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetTCPCheckBackendResponse, error)

	// CreateTCPCheckBackendWithBodyWithResponse request with any body
	CreateTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error)

	CreateTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error)

	// ReplaceTCPCheckBackendWithBodyWithResponse request with any body
	ReplaceTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error)

	ReplaceTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error)

	// GetAllTCPRequestRuleBackendWithResponse request
	GetAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleBackendResponse, error)

	// ReplaceAllTCPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceAllTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error)

	ReplaceAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error)

	// DeleteTCPRequestRuleBackendWithResponse request
	DeleteTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleBackendResponse, error)

	// GetTCPRequestRuleBackendWithResponse request
	GetTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleBackendResponse, error)

	// CreateTCPRequestRuleBackendWithBodyWithResponse request with any body
	CreateTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error)

	CreateTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error)

	// ReplaceTCPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error)

	ReplaceTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error)

	// GetAllTCPResponseRuleBackendWithResponse request
	GetAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPResponseRuleBackendResponse, error)

	// ReplaceAllTCPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceAllTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error)

	ReplaceAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error)

	// DeleteTCPResponseRuleBackendWithResponse request
	DeleteTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPResponseRuleBackendResponse, error)

	// GetTCPResponseRuleBackendWithResponse request
	GetTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPResponseRuleBackendResponse, error)

	// CreateTCPResponseRuleBackendWithBodyWithResponse request with any body
	CreateTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error)

	CreateTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error)

	// ReplaceTCPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error)

	ReplaceTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error)

	// GetCachesWithResponse request
	GetCachesWithResponse(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*GetCachesResponse, error)

	// CreateCacheWithBodyWithResponse request with any body
	CreateCacheWithBodyWithResponse(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error)

	CreateCacheWithResponse(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error)

	// DeleteCacheWithResponse request
	DeleteCacheWithResponse(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*DeleteCacheResponse, error)

	// GetCacheWithResponse request
	GetCacheWithResponse(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*GetCacheResponse, error)

	// ReplaceCacheWithBodyWithResponse request with any body
	ReplaceCacheWithBodyWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error)

	ReplaceCacheWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error)

	// GetCrtLoadsWithResponse request
	GetCrtLoadsWithResponse(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*GetCrtLoadsResponse, error)

	// CreateCrtLoadWithBodyWithResponse request with any body
	CreateCrtLoadWithBodyWithResponse(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error)

	CreateCrtLoadWithResponse(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error)

	// DeleteCrtLoadWithResponse request
	DeleteCrtLoadWithResponse(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*DeleteCrtLoadResponse, error)

	// GetCrtLoadWithResponse request
	GetCrtLoadWithResponse(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*GetCrtLoadResponse, error)

	// ReplaceCrtLoadWithBodyWithResponse request with any body
	ReplaceCrtLoadWithBodyWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error)

	ReplaceCrtLoadWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error)

	// GetCrtStoresWithResponse request
	GetCrtStoresWithResponse(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*GetCrtStoresResponse, error)

	// CreateCrtStoreWithBodyWithResponse request with any body
	CreateCrtStoreWithBodyWithResponse(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error)

	CreateCrtStoreWithResponse(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error)

	// DeleteCrtStoreWithResponse request
	DeleteCrtStoreWithResponse(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*DeleteCrtStoreResponse, error)

	// GetCrtStoreWithResponse request
	GetCrtStoreWithResponse(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*GetCrtStoreResponse, error)

	// EditCrtStoreWithBodyWithResponse request with any body
	EditCrtStoreWithBodyWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error)

	EditCrtStoreWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error)

	// GetDefaultsSectionsWithResponse request
	GetDefaultsSectionsWithResponse(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionsResponse, error)

	// AddDefaultsSectionWithBodyWithResponse request with any body
	AddDefaultsSectionWithBodyWithResponse(ctx context.Context, params *AddDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDefaultsSectionResponse, error)

	AddDefaultsSectionWithResponse(ctx context.Context, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDefaultsSectionResponse, error)

	// CreateDefaultsSectionWithBodyWithResponse request with any body
	CreateDefaultsSectionWithBodyWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error)

	CreateDefaultsSectionWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error)

	// DeleteDefaultsSectionWithResponse request
	DeleteDefaultsSectionWithResponse(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*DeleteDefaultsSectionResponse, error)

	// GetDefaultsSectionWithResponse request
	GetDefaultsSectionWithResponse(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionResponse, error)

	// ReplaceDefaultsSectionWithBodyWithResponse request with any body
	ReplaceDefaultsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error)

	ReplaceDefaultsSectionWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error)

	// GetAllAclDefaultsWithResponse request
	GetAllAclDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllAclDefaultsResponse, error)

	// ReplaceAllAclDefaultsWithBodyWithResponse request with any body
	ReplaceAllAclDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclDefaultsResponse, error)

	ReplaceAllAclDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclDefaultsParams, body ReplaceAllAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclDefaultsResponse, error)

	// DeleteAclDefaultsWithResponse request
	DeleteAclDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteAclDefaultsResponse, error)

	// GetAclDefaultsWithResponse request
	GetAclDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclDefaultsParams, reqEditors ...RequestEditorFn) (*GetAclDefaultsResponse, error)

	// CreateAclDefaultsWithBodyWithResponse request with any body
	CreateAclDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclDefaultsResponse, error)

	CreateAclDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclDefaultsParams, body CreateAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclDefaultsResponse, error)

	// ReplaceAclDefaultsWithBodyWithResponse request with any body
	ReplaceAclDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclDefaultsResponse, error)

	ReplaceAclDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclDefaultsParams, body ReplaceAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclDefaultsResponse, error)

	// GetAllHTTPAfterResponseRuleDefaultsWithResponse request
	GetAllHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleDefaultsResponse, error)

	// ReplaceAllHTTPAfterResponseRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllHTTPAfterResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleDefaultsResponse, error)

	ReplaceAllHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, body ReplaceAllHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleDefaultsResponse, error)

	// DeleteHTTPAfterResponseRuleDefaultsWithResponse request
	DeleteHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleDefaultsResponse, error)

	// GetHTTPAfterResponseRuleDefaultsWithResponse request
	GetHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleDefaultsResponse, error)

	// CreateHTTPAfterResponseRuleDefaultsWithBodyWithResponse request with any body
	CreateHTTPAfterResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleDefaultsResponse, error)

	CreateHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, body CreateHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleDefaultsResponse, error)

	// ReplaceHTTPAfterResponseRuleDefaultsWithBodyWithResponse request with any body
	ReplaceHTTPAfterResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleDefaultsResponse, error)

	ReplaceHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, body ReplaceHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleDefaultsResponse, error)

	// GetAllHTTPCheckDefaultsWithResponse request
	GetAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckDefaultsResponse, error)

	// ReplaceAllHTTPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceAllHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error)

	ReplaceAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error)

	// DeleteHTTPCheckDefaultsWithResponse request
	DeleteHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckDefaultsResponse, error)

	// GetHTTPCheckDefaultsWithResponse request
	GetHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckDefaultsResponse, error)

	// CreateHTTPCheckDefaultsWithBodyWithResponse request with any body
	CreateHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error)

	CreateHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error)

	// ReplaceHTTPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error)

	ReplaceHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error)

	// GetAllHTTPErrorRuleDefaultsWithResponse request
	GetAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleDefaultsResponse, error)

	// ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error)

	ReplaceAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error)

	// DeleteHTTPErrorRuleDefaultsWithResponse request
	DeleteHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleDefaultsResponse, error)

	// GetHTTPErrorRuleDefaultsWithResponse request
	GetHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleDefaultsResponse, error)

	// CreateHTTPErrorRuleDefaultsWithBodyWithResponse request with any body
	CreateHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error)

	CreateHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error)

	// ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse request with any body
	ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error)

	ReplaceHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error)

	// GetAllHTTPRequestRuleDefaultsWithResponse request
	GetAllHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleDefaultsResponse, error)

	// ReplaceAllHTTPRequestRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllHTTPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleDefaultsResponse, error)

	ReplaceAllHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, body ReplaceAllHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleDefaultsResponse, error)

	// DeleteHTTPRequestRuleDefaultsWithResponse request
	DeleteHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleDefaultsResponse, error)

	// GetHTTPRequestRuleDefaultsWithResponse request
	GetHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleDefaultsResponse, error)

	// CreateHTTPRequestRuleDefaultsWithBodyWithResponse request with any body
	CreateHTTPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleDefaultsResponse, error)

	CreateHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, body CreateHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleDefaultsResponse, error)

	// ReplaceHTTPRequestRuleDefaultsWithBodyWithResponse request with any body
	ReplaceHTTPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleDefaultsResponse, error)

	ReplaceHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, body ReplaceHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleDefaultsResponse, error)

	// GetAllHTTPResponseRuleDefaultsWithResponse request
	GetAllHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleDefaultsResponse, error)

	// ReplaceAllHTTPResponseRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllHTTPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleDefaultsResponse, error)

	ReplaceAllHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, body ReplaceAllHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleDefaultsResponse, error)

	// DeleteHTTPResponseRuleDefaultsWithResponse request
	DeleteHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleDefaultsResponse, error)

	// GetHTTPResponseRuleDefaultsWithResponse request
	GetHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleDefaultsResponse, error)

	// CreateHTTPResponseRuleDefaultsWithBodyWithResponse request with any body
	CreateHTTPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleDefaultsResponse, error)

	CreateHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, body CreateHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleDefaultsResponse, error)

	// ReplaceHTTPResponseRuleDefaultsWithBodyWithResponse request with any body
	ReplaceHTTPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleDefaultsResponse, error)

	ReplaceHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, body ReplaceHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleDefaultsResponse, error)

	// GetAllLogTargetDefaultsWithResponse request
	GetAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetDefaultsResponse, error)

	// ReplaceAllLogTargetDefaultsWithBodyWithResponse request with any body
	ReplaceAllLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error)

	ReplaceAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error)

	// DeleteLogTargetDefaultsWithResponse request
	DeleteLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetDefaultsResponse, error)

	// GetLogTargetDefaultsWithResponse request
	GetLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetLogTargetDefaultsResponse, error)

	// CreateLogTargetDefaultsWithBodyWithResponse request with any body
	CreateLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error)

	CreateLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error)

	// ReplaceLogTargetDefaultsWithBodyWithResponse request with any body
	ReplaceLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error)

	ReplaceLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error)

	// GetAllQUICInitialRuleDefaultsWithResponse request
	GetAllQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllQUICInitialRuleDefaultsResponse, error)

	// ReplaceAllQUICInitialRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleDefaultsResponse, error)

	ReplaceAllQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleDefaultsResponse, error)

	// DeleteQUICInitialRuleDefaultsWithResponse request
	DeleteQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteQUICInitialRuleDefaultsResponse, error)

	// GetQUICInitialRuleDefaultsWithResponse request
	GetQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetQUICInitialRuleDefaultsResponse, error)

	// CreateQUICInitialRuleDefaultsWithBodyWithResponse request with any body
	CreateQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleDefaultsResponse, error)

	CreateQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleDefaultsResponse, error)

	// ReplaceQUICInitialRuleDefaultsWithBodyWithResponse request with any body
	ReplaceQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleDefaultsResponse, error)

	ReplaceQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleDefaultsResponse, error)

	// GetAllTCPCheckDefaultsWithResponse request
	GetAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckDefaultsResponse, error)

	// ReplaceAllTCPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceAllTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error)

	ReplaceAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error)

	// DeleteTCPCheckDefaultsWithResponse request
	DeleteTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckDefaultsResponse, error)

	// GetTCPCheckDefaultsWithResponse request
	GetTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPCheckDefaultsResponse, error)

	// CreateTCPCheckDefaultsWithBodyWithResponse request with any body
	CreateTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error)

	CreateTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error)

	// ReplaceTCPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error)

	ReplaceTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error)

	// GetAllTCPRequestRuleDefaultsWithResponse request
	GetAllTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleDefaultsResponse, error)

	// ReplaceAllTCPRequestRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllTCPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleDefaultsResponse, error)

	ReplaceAllTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, body ReplaceAllTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleDefaultsResponse, error)

	// DeleteTCPRequestRuleDefaultsWithResponse request
	DeleteTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleDefaultsResponse, error)

	// GetTCPRequestRuleDefaultsWithResponse request
	GetTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleDefaultsResponse, error)

	// CreateTCPRequestRuleDefaultsWithBodyWithResponse request with any body
	CreateTCPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleDefaultsResponse, error)

	CreateTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, body CreateTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleDefaultsResponse, error)

	// ReplaceTCPRequestRuleDefaultsWithBodyWithResponse request with any body
	ReplaceTCPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleDefaultsResponse, error)

	ReplaceTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, body ReplaceTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleDefaultsResponse, error)

	// GetAllTCPResponseRuleDefaultsWithResponse request
	GetAllTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPResponseRuleDefaultsResponse, error)

	// ReplaceAllTCPResponseRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllTCPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleDefaultsResponse, error)

	ReplaceAllTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, body ReplaceAllTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleDefaultsResponse, error)

	// DeleteTCPResponseRuleDefaultsWithResponse request
	DeleteTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPResponseRuleDefaultsResponse, error)

	// GetTCPResponseRuleDefaultsWithResponse request
	GetTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPResponseRuleDefaultsResponse, error)

	// CreateTCPResponseRuleDefaultsWithBodyWithResponse request with any body
	CreateTCPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleDefaultsResponse, error)

	CreateTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, body CreateTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleDefaultsResponse, error)

	// ReplaceTCPResponseRuleDefaultsWithBodyWithResponse request with any body
	ReplaceTCPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleDefaultsResponse, error)

	ReplaceTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, body ReplaceTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleDefaultsResponse, error)

	// GetFCGIAppsWithResponse request
	GetFCGIAppsWithResponse(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*GetFCGIAppsResponse, error)

	// CreateFCGIAppWithBodyWithResponse request with any body
	CreateFCGIAppWithBodyWithResponse(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error)

	CreateFCGIAppWithResponse(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error)

	// DeleteFCGIAppWithResponse request
	DeleteFCGIAppWithResponse(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteFCGIAppResponse, error)

	// GetFCGIAppWithResponse request
	GetFCGIAppWithResponse(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*GetFCGIAppResponse, error)

	// ReplaceFCGIAppWithBodyWithResponse request with any body
	ReplaceFCGIAppWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error)

	ReplaceFCGIAppWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error)

	// GetAllAclFCGIAppWithResponse request
	GetAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAllAclFCGIAppResponse, error)

	// ReplaceAllAclFCGIAppWithBodyWithResponse request with any body
	ReplaceAllAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error)

	ReplaceAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error)

	// DeleteAclFCGIAppWithResponse request
	DeleteAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteAclFCGIAppResponse, error)

	// GetAclFCGIAppWithResponse request
	GetAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAclFCGIAppResponse, error)

	// CreateAclFCGIAppWithBodyWithResponse request with any body
	CreateAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error)

	CreateAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error)

	// ReplaceAclFCGIAppWithBodyWithResponse request with any body
	ReplaceAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error)

	ReplaceAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error)

	// GetFrontendsWithResponse request
	GetFrontendsWithResponse(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*GetFrontendsResponse, error)

	// CreateFrontendWithBodyWithResponse request with any body
	CreateFrontendWithBodyWithResponse(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error)

	CreateFrontendWithResponse(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error)

	// DeleteFrontendWithResponse request
	DeleteFrontendWithResponse(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFrontendResponse, error)

	// GetFrontendWithResponse request
	GetFrontendWithResponse(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*GetFrontendResponse, error)

	// ReplaceFrontendWithBodyWithResponse request with any body
	ReplaceFrontendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error)

	ReplaceFrontendWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error)

	// GetAllAclFrontendWithResponse request
	GetAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAllAclFrontendResponse, error)

	// ReplaceAllAclFrontendWithBodyWithResponse request with any body
	ReplaceAllAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error)

	ReplaceAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error)

	// DeleteAclFrontendWithResponse request
	DeleteAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*DeleteAclFrontendResponse, error)

	// GetAclFrontendWithResponse request
	GetAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAclFrontendResponse, error)

	// CreateAclFrontendWithBodyWithResponse request with any body
	CreateAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error)

	CreateAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error)

	// ReplaceAclFrontendWithBodyWithResponse request with any body
	ReplaceAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error)

	ReplaceAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error)

	// GetBackendSwitchingRulesWithResponse request
	GetBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRulesResponse, error)

	// ReplaceBackendSwitchingRulesWithBodyWithResponse request with any body
	ReplaceBackendSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error)

	ReplaceBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error)

	// DeleteBackendSwitchingRuleWithResponse request
	DeleteBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteBackendSwitchingRuleResponse, error)

	// GetBackendSwitchingRuleWithResponse request
	GetBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRuleResponse, error)

	// CreateBackendSwitchingRuleWithBodyWithResponse request with any body
	CreateBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error)

	CreateBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error)

	// ReplaceBackendSwitchingRuleWithBodyWithResponse request with any body
	ReplaceBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error)

	ReplaceBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error)

	// GetAllBindFrontendWithResponse request
	GetAllBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*GetAllBindFrontendResponse, error)

	// CreateBindFrontendWithBodyWithResponse request with any body
	CreateBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error)

	CreateBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error)

	// DeleteBindFrontendWithResponse request
	DeleteBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*DeleteBindFrontendResponse, error)

	// GetBindFrontendWithResponse request
	GetBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*GetBindFrontendResponse, error)

	// ReplaceBindFrontendWithBodyWithResponse request with any body
	ReplaceBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error)

	ReplaceBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error)

	// GetDeclareCapturesWithResponse request
	GetDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*GetDeclareCapturesResponse, error)

	// ReplaceDeclareCapturesWithBodyWithResponse request with any body
	ReplaceDeclareCapturesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error)

	ReplaceDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error)

	// DeleteDeclareCaptureWithResponse request
	DeleteDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*DeleteDeclareCaptureResponse, error)

	// GetDeclareCaptureWithResponse request
	GetDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*GetDeclareCaptureResponse, error)

	// CreateDeclareCaptureWithBodyWithResponse request with any body
	CreateDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error)

	CreateDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error)

	// ReplaceDeclareCaptureWithBodyWithResponse request with any body
	ReplaceDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error)

	ReplaceDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error)

	// GetAllFilterFrontendWithResponse request
	GetAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetAllFilterFrontendResponse, error)

	// ReplaceAllFilterFrontendWithBodyWithResponse request with any body
	ReplaceAllFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error)

	ReplaceAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error)

	// DeleteFilterFrontendWithResponse request
	DeleteFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFilterFrontendResponse, error)

	// GetFilterFrontendWithResponse request
	GetFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetFilterFrontendResponse, error)

	// CreateFilterFrontendWithBodyWithResponse request with any body
	CreateFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error)

	CreateFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error)

	// ReplaceFilterFrontendWithBodyWithResponse request with any body
	ReplaceFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error)

	ReplaceFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error)

	// GetAllHTTPAfterResponseRuleFrontendWithResponse request
	GetAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleFrontendResponse, error)

	// ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error)

	ReplaceAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error)

	// DeleteHTTPAfterResponseRuleFrontendWithResponse request
	DeleteHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleFrontendResponse, error)

	// GetHTTPAfterResponseRuleFrontendWithResponse request
	GetHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleFrontendResponse, error)

	// CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error)

	CreateHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error)

	// ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error)

	ReplaceHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error)

	// GetAllHTTPErrorRuleFrontendWithResponse request
	GetAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleFrontendResponse, error)

	// ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error)

	ReplaceAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error)

	// DeleteHTTPErrorRuleFrontendWithResponse request
	DeleteHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleFrontendResponse, error)

	// GetHTTPErrorRuleFrontendWithResponse request
	GetHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleFrontendResponse, error)

	// CreateHTTPErrorRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error)

	CreateHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error)

	// ReplaceHTTPErrorRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error)

	ReplaceHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error)

	// GetAllHTTPRequestRuleFrontendWithResponse request
	GetAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleFrontendResponse, error)

	// ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error)

	ReplaceAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error)

	// DeleteHTTPRequestRuleFrontendWithResponse request
	DeleteHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleFrontendResponse, error)

	// GetHTTPRequestRuleFrontendWithResponse request
	GetHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleFrontendResponse, error)

	// CreateHTTPRequestRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error)

	CreateHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error)

	// ReplaceHTTPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error)

	ReplaceHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error)

	// GetAllHTTPResponseRuleFrontendWithResponse request
	GetAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleFrontendResponse, error)

	// ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error)

	ReplaceAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error)

	// DeleteHTTPResponseRuleFrontendWithResponse request
	DeleteHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleFrontendResponse, error)

	// GetHTTPResponseRuleFrontendWithResponse request
	GetHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleFrontendResponse, error)

	// CreateHTTPResponseRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error)

	CreateHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error)

	// ReplaceHTTPResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error)

	ReplaceHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error)

	// GetAllLogTargetFrontendWithResponse request
	GetAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetFrontendResponse, error)

	// ReplaceAllLogTargetFrontendWithBodyWithResponse request with any body
	ReplaceAllLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error)

	ReplaceAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error)

	// DeleteLogTargetFrontendWithResponse request
	DeleteLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetFrontendResponse, error)

	// GetLogTargetFrontendWithResponse request
	GetLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetLogTargetFrontendResponse, error)

	// CreateLogTargetFrontendWithBodyWithResponse request with any body
	CreateLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error)

	CreateLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error)

	// ReplaceLogTargetFrontendWithBodyWithResponse request with any body
	ReplaceLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error)

	ReplaceLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error)

	// GetAllQUICInitialRuleFrontendWithResponse request
	GetAllQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllQUICInitialRuleFrontendResponse, error)

	// ReplaceAllQUICInitialRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleFrontendResponse, error)

	ReplaceAllQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleFrontendResponse, error)

	// DeleteQUICInitialRuleFrontendWithResponse request
	DeleteQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteQUICInitialRuleFrontendResponse, error)

	// GetQUICInitialRuleFrontendWithResponse request
	GetQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetQUICInitialRuleFrontendResponse, error)

	// CreateQUICInitialRuleFrontendWithBodyWithResponse request with any body
	CreateQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleFrontendResponse, error)

	CreateQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleFrontendResponse, error)

	// ReplaceQUICInitialRuleFrontendWithBodyWithResponse request with any body
	ReplaceQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleFrontendResponse, error)

	ReplaceQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleFrontendResponse, error)

	// GetAllSSLFrontUsesWithResponse request
	GetAllSSLFrontUsesWithResponse(ctx context.Context, parentName ParentName, params *GetAllSSLFrontUsesParams, reqEditors ...RequestEditorFn) (*GetAllSSLFrontUsesResponse, error)

	// CreateSSLFrontUseWithBodyWithResponse request with any body
	CreateSSLFrontUseWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateSSLFrontUseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSSLFrontUseResponse, error)

	CreateSSLFrontUseWithResponse(ctx context.Context, parentName ParentName, params *CreateSSLFrontUseParams, body CreateSSLFrontUseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSSLFrontUseResponse, error)

	// DeleteSSLFrontUseWithResponse request
	DeleteSSLFrontUseWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteSSLFrontUseParams, reqEditors ...RequestEditorFn) (*DeleteSSLFrontUseResponse, error)

	// GetSSLFrontUseWithResponse request
	GetSSLFrontUseWithResponse(ctx context.Context, parentName ParentName, index int, params *GetSSLFrontUseParams, reqEditors ...RequestEditorFn) (*GetSSLFrontUseResponse, error)

	// ReplaceSSLFrontUseWithBodyWithResponse request with any body
	ReplaceSSLFrontUseWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSSLFrontUseResponse, error)

	ReplaceSSLFrontUseWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, body ReplaceSSLFrontUseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSSLFrontUseResponse, error)

	// GetAllTCPRequestRuleFrontendWithResponse request
	GetAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleFrontendResponse, error)

	// ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error)

	ReplaceAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error)

	// DeleteTCPRequestRuleFrontendWithResponse request
	DeleteTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleFrontendResponse, error)

	// GetTCPRequestRuleFrontendWithResponse request
	GetTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleFrontendResponse, error)

	// CreateTCPRequestRuleFrontendWithBodyWithResponse request with any body
	CreateTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error)

	CreateTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error)

	// ReplaceTCPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error)

	ReplaceTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error)

	// GetGlobalWithResponse request
	GetGlobalWithResponse(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error)

	// ReplaceGlobalWithBodyWithResponse request with any body
	ReplaceGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error)

	ReplaceGlobalWithResponse(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error)

	// GetAllLogTargetGlobalWithResponse request
	GetAllLogTargetGlobalWithResponse(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetGlobalResponse, error)

	// ReplaceAllLogTargetGlobalWithBodyWithResponse request with any body
	ReplaceAllLogTargetGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error)

	ReplaceAllLogTargetGlobalWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error)

	// DeleteLogTargetGlobalWithResponse request
	DeleteLogTargetGlobalWithResponse(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetGlobalResponse, error)

	// GetLogTargetGlobalWithResponse request
	GetLogTargetGlobalWithResponse(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetLogTargetGlobalResponse, error)

	// CreateLogTargetGlobalWithBodyWithResponse request with any body
	CreateLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error)

	CreateLogTargetGlobalWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error)

	// ReplaceLogTargetGlobalWithBodyWithResponse request with any body
	ReplaceLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error)

	ReplaceLogTargetGlobalWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error)

	// GetGroupsWithResponse request
	GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// ReplaceGroupWithBodyWithResponse request with any body
	ReplaceGroupWithBodyWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error)

	ReplaceGroupWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error)

	// GetHTTPErrorsSectionsWithResponse request
	GetHTTPErrorsSectionsWithResponse(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionsResponse, error)

	// CreateHTTPErrorsSectionWithBodyWithResponse request with any body
	CreateHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error)

	CreateHTTPErrorsSectionWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error)

	// DeleteHTTPErrorsSectionWithResponse request
	DeleteHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorsSectionResponse, error)

	// GetHTTPErrorsSectionWithResponse request
	GetHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionResponse, error)

	// ReplaceHTTPErrorsSectionWithBodyWithResponse request with any body
	ReplaceHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error)

	ReplaceHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error)

	// GetLogForwardsWithResponse request
	GetLogForwardsWithResponse(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*GetLogForwardsResponse, error)

	// CreateLogForwardWithBodyWithResponse request with any body
	CreateLogForwardWithBodyWithResponse(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error)

	CreateLogForwardWithResponse(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error)

	// DeleteLogForwardWithResponse request
	DeleteLogForwardWithResponse(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogForwardResponse, error)

	// GetLogForwardWithResponse request
	GetLogForwardWithResponse(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogForwardResponse, error)

	// ReplaceLogForwardWithBodyWithResponse request with any body
	ReplaceLogForwardWithBodyWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error)

	ReplaceLogForwardWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error)

	// GetAllBindLogForwardWithResponse request
	GetAllBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllBindLogForwardResponse, error)

	// CreateBindLogForwardWithBodyWithResponse request with any body
	CreateBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error)

	CreateBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error)

	// DeleteBindLogForwardWithResponse request
	DeleteBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteBindLogForwardResponse, error)

	// GetBindLogForwardWithResponse request
	GetBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetBindLogForwardResponse, error)

	// ReplaceBindLogForwardWithBodyWithResponse request with any body
	ReplaceBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error)

	ReplaceBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error)

	// GetDgramBindsWithResponse request
	GetDgramBindsWithResponse(ctx context.Context, parentName ParentName, params *GetDgramBindsParams, reqEditors ...RequestEditorFn) (*GetDgramBindsResponse, error)

	// CreateDgramBindWithBodyWithResponse request with any body
	CreateDgramBindWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDgramBindResponse, error)

	CreateDgramBindWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDgramBindResponse, error)

	// DeleteDgramBindWithResponse request
	DeleteDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindParams, reqEditors ...RequestEditorFn) (*DeleteDgramBindResponse, error)

	// GetDgramBindWithResponse request
	GetDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *GetDgramBindParams, reqEditors ...RequestEditorFn) (*GetDgramBindResponse, error)

	// ReplaceDgramBindWithBodyWithResponse request with any body
	ReplaceDgramBindWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDgramBindResponse, error)

	ReplaceDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDgramBindResponse, error)

	// GetAllLogTargetLogForwardWithResponse request
	GetAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetLogForwardResponse, error)

	// ReplaceAllLogTargetLogForwardWithBodyWithResponse request with any body
	ReplaceAllLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error)

	ReplaceAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error)

	// DeleteLogTargetLogForwardWithResponse request
	DeleteLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetLogForwardResponse, error)

	// GetLogTargetLogForwardWithResponse request
	GetLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogTargetLogForwardResponse, error)

	// CreateLogTargetLogForwardWithBodyWithResponse request with any body
	CreateLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error)

	CreateLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error)

	// ReplaceLogTargetLogForwardWithBodyWithResponse request with any body
	ReplaceLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error)

	ReplaceLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error)

	// GetLogProfilesWithResponse request
	GetLogProfilesWithResponse(ctx context.Context, params *GetLogProfilesParams, reqEditors ...RequestEditorFn) (*GetLogProfilesResponse, error)

	// CreateLogProfileWithBodyWithResponse request with any body
	CreateLogProfileWithBodyWithResponse(ctx context.Context, params *CreateLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogProfileResponse, error)

	CreateLogProfileWithResponse(ctx context.Context, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogProfileResponse, error)

	// DeleteLogProfileWithResponse request
	DeleteLogProfileWithResponse(ctx context.Context, name string, params *DeleteLogProfileParams, reqEditors ...RequestEditorFn) (*DeleteLogProfileResponse, error)

	// GetLogProfileWithResponse request
	GetLogProfileWithResponse(ctx context.Context, name string, params *GetLogProfileParams, reqEditors ...RequestEditorFn) (*GetLogProfileResponse, error)

	// EditLogProfileWithBodyWithResponse request with any body
	EditLogProfileWithBodyWithResponse(ctx context.Context, name string, params *EditLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLogProfileResponse, error)

	EditLogProfileWithResponse(ctx context.Context, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLogProfileResponse, error)

	// GetMailerEntriesWithResponse request
	GetMailerEntriesWithResponse(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*GetMailerEntriesResponse, error)

	// CreateMailerEntryWithBodyWithResponse request with any body
	CreateMailerEntryWithBodyWithResponse(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error)

	CreateMailerEntryWithResponse(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error)

	// DeleteMailerEntryWithResponse request
	DeleteMailerEntryWithResponse(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*DeleteMailerEntryResponse, error)

	// GetMailerEntryWithResponse request
	GetMailerEntryWithResponse(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*GetMailerEntryResponse, error)

	// ReplaceMailerEntryWithBodyWithResponse request with any body
	ReplaceMailerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error)

	ReplaceMailerEntryWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error)

	// GetMailersSectionsWithResponse request
	GetMailersSectionsWithResponse(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*GetMailersSectionsResponse, error)

	// CreateMailersSectionWithBodyWithResponse request with any body
	CreateMailersSectionWithBodyWithResponse(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error)

	CreateMailersSectionWithResponse(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error)

	// DeleteMailersSectionWithResponse request
	DeleteMailersSectionWithResponse(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*DeleteMailersSectionResponse, error)

	// GetMailersSectionWithResponse request
	GetMailersSectionWithResponse(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*GetMailersSectionResponse, error)

	// EditMailersSectionWithBodyWithResponse request with any body
	EditMailersSectionWithBodyWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error)

	EditMailersSectionWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error)

	// GetNameserversWithResponse request
	GetNameserversWithResponse(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*GetNameserversResponse, error)

	// CreateNameserverWithBodyWithResponse request with any body
	CreateNameserverWithBodyWithResponse(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error)

	CreateNameserverWithResponse(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error)

	// DeleteNameserverWithResponse request
	DeleteNameserverWithResponse(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*DeleteNameserverResponse, error)

	// GetNameserverWithResponse request
	GetNameserverWithResponse(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*GetNameserverResponse, error)

	// ReplaceNameserverWithBodyWithResponse request with any body
	ReplaceNameserverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error)

	ReplaceNameserverWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error)

	// GetPeerEntriesWithResponse request
	GetPeerEntriesWithResponse(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*GetPeerEntriesResponse, error)

	// CreatePeerEntryWithBodyWithResponse request with any body
	CreatePeerEntryWithBodyWithResponse(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error)

	CreatePeerEntryWithResponse(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error)

	// DeletePeerEntryWithResponse request
	DeletePeerEntryWithResponse(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*DeletePeerEntryResponse, error)

	// GetPeerEntryWithResponse request
	GetPeerEntryWithResponse(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*GetPeerEntryResponse, error)

	// ReplacePeerEntryWithBodyWithResponse request with any body
	ReplacePeerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error)

	ReplacePeerEntryWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error)

	// GetPeerSectionsWithResponse request
	GetPeerSectionsWithResponse(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*GetPeerSectionsResponse, error)

	// CreatePeerWithBodyWithResponse request with any body
	CreatePeerWithBodyWithResponse(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error)

	CreatePeerWithResponse(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error)

	// DeletePeerWithResponse request
	DeletePeerWithResponse(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*DeletePeerResponse, error)

	// GetPeerSectionWithResponse request
	GetPeerSectionWithResponse(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*GetPeerSectionResponse, error)

	// GetAllBindPeerWithResponse request
	GetAllBindPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*GetAllBindPeerResponse, error)

	// CreateBindPeerWithBodyWithResponse request with any body
	CreateBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error)

	CreateBindPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error)

	// DeleteBindPeerWithResponse request
	DeleteBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*DeleteBindPeerResponse, error)

	// GetBindPeerWithResponse request
	GetBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*GetBindPeerResponse, error)

	// ReplaceBindPeerWithBodyWithResponse request with any body
	ReplaceBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error)

	ReplaceBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error)

	// GetAllLogTargetPeerWithResponse request
	GetAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetPeerResponse, error)

	// ReplaceAllLogTargetPeerWithBodyWithResponse request with any body
	ReplaceAllLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error)

	ReplaceAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error)

	// DeleteLogTargetPeerWithResponse request
	DeleteLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetPeerResponse, error)

	// GetLogTargetPeerWithResponse request
	GetLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetLogTargetPeerResponse, error)

	// CreateLogTargetPeerWithBodyWithResponse request with any body
	CreateLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error)

	CreateLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error)

	// ReplaceLogTargetPeerWithBodyWithResponse request with any body
	ReplaceLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error)

	ReplaceLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error)

	// GetAllServerPeerWithResponse request
	GetAllServerPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*GetAllServerPeerResponse, error)

	// CreateServerPeerWithBodyWithResponse request with any body
	CreateServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error)

	CreateServerPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error)

	// DeleteServerPeerWithResponse request
	DeleteServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*DeleteServerPeerResponse, error)

	// GetServerPeerWithResponse request
	GetServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*GetServerPeerResponse, error)

	// ReplaceServerPeerWithBodyWithResponse request with any body
	ReplaceServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error)

	ReplaceServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error)

	// GetTablesWithResponse request
	GetTablesWithResponse(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	CreateTableWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	// DeleteTableWithResponse request
	DeleteTableWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error)

	// GetTableWithResponse request
	GetTableWithResponse(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error)

	// ReplaceTableWithBodyWithResponse request with any body
	ReplaceTableWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error)

	ReplaceTableWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error)

	// GetProgramsWithResponse request
	GetProgramsWithResponse(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error)

	// CreateProgramWithBodyWithResponse request with any body
	CreateProgramWithBodyWithResponse(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error)

	CreateProgramWithResponse(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error)

	// DeleteProgramWithResponse request
	DeleteProgramWithResponse(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*DeleteProgramResponse, error)

	// GetProgramWithResponse request
	GetProgramWithResponse(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error)

	// ReplaceProgramWithBodyWithResponse request with any body
	ReplaceProgramWithBodyWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error)

	ReplaceProgramWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error)

	// GetHAProxyConfigurationWithResponse request
	GetHAProxyConfigurationWithResponse(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*GetHAProxyConfigurationResponse, error)

	// PostHAProxyConfigurationWithBodyWithResponse request with any body
	PostHAProxyConfigurationWithBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error)

	PostHAProxyConfigurationWithTextBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error)

	// GetResolversWithResponse request
	GetResolversWithResponse(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*GetResolversResponse, error)

	// CreateResolverWithBodyWithResponse request with any body
	CreateResolverWithBodyWithResponse(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error)

	CreateResolverWithResponse(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error)

	// DeleteResolverWithResponse request
	DeleteResolverWithResponse(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*DeleteResolverResponse, error)

	// GetResolverWithResponse request
	GetResolverWithResponse(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*GetResolverResponse, error)

	// ReplaceResolverWithBodyWithResponse request with any body
	ReplaceResolverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error)

	ReplaceResolverWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error)

	// GetRingsWithResponse request
	GetRingsWithResponse(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*GetRingsResponse, error)

	// CreateRingWithBodyWithResponse request with any body
	CreateRingWithBodyWithResponse(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRingResponse, error)

	CreateRingWithResponse(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRingResponse, error)

	// DeleteRingWithResponse request
	DeleteRingWithResponse(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*DeleteRingResponse, error)

	// GetRingWithResponse request
	GetRingWithResponse(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*GetRingResponse, error)

	// ReplaceRingWithBodyWithResponse request with any body
	ReplaceRingWithBodyWithResponse(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error)

	ReplaceRingWithResponse(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error)

	// GetAllServerRingWithResponse request
	GetAllServerRingWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*GetAllServerRingResponse, error)

	// CreateServerRingWithBodyWithResponse request with any body
	CreateServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error)

	CreateServerRingWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error)

	// DeleteServerRingWithResponse request
	DeleteServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*DeleteServerRingResponse, error)

	// GetServerRingWithResponse request
	GetServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*GetServerRingResponse, error)

	// ReplaceServerRingWithBodyWithResponse request with any body
	ReplaceServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error)

	ReplaceServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error)

	// DeleteTracesWithResponse request
	DeleteTracesWithResponse(ctx context.Context, params *DeleteTracesParams, reqEditors ...RequestEditorFn) (*DeleteTracesResponse, error)

	// GetTracesWithResponse request
	GetTracesWithResponse(ctx context.Context, params *GetTracesParams, reqEditors ...RequestEditorFn) (*GetTracesResponse, error)

	// CreateTracesWithBodyWithResponse request with any body
	CreateTracesWithBodyWithResponse(ctx context.Context, params *CreateTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTracesResponse, error)

	CreateTracesWithResponse(ctx context.Context, params *CreateTracesParams, body CreateTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTracesResponse, error)

	// ReplaceTracesWithBodyWithResponse request with any body
	ReplaceTracesWithBodyWithResponse(ctx context.Context, params *ReplaceTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTracesResponse, error)

	ReplaceTracesWithResponse(ctx context.Context, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTracesResponse, error)

	// DeleteTraceEntryWithBodyWithResponse request with any body
	DeleteTraceEntryWithBodyWithResponse(ctx context.Context, params *DeleteTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTraceEntryResponse, error)

	DeleteTraceEntryWithResponse(ctx context.Context, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTraceEntryResponse, error)

	// CreateTraceEntryWithBodyWithResponse request with any body
	CreateTraceEntryWithBodyWithResponse(ctx context.Context, params *CreateTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTraceEntryResponse, error)

	CreateTraceEntryWithResponse(ctx context.Context, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTraceEntryResponse, error)

	// GetUserlistsWithResponse request
	GetUserlistsWithResponse(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*GetUserlistsResponse, error)

	// CreateUserlistWithBodyWithResponse request with any body
	CreateUserlistWithBodyWithResponse(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error)

	CreateUserlistWithResponse(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error)

	// DeleteUserlistWithResponse request
	DeleteUserlistWithResponse(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*DeleteUserlistResponse, error)

	// GetUserlistWithResponse request
	GetUserlistWithResponse(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*GetUserlistResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ReplaceUserWithBodyWithResponse request with any body
	ReplaceUserWithBodyWithResponse(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error)

	ReplaceUserWithResponse(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error)

	// GetConfigurationVersionWithResponse request
	GetConfigurationVersionWithResponse(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetConfigurationVersionResponse, error)

	// GetReloadsWithResponse request
	GetReloadsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReloadsResponse, error)

	// GetReloadWithResponse request
	GetReloadWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReloadResponse, error)

	// GetRuntimeEndpointsWithResponse request
	GetRuntimeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeEndpointsResponse, error)

	// GetServicesHaproxyRuntimeAclsWithResponse request
	GetServicesHaproxyRuntimeAclsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsResponse, error)

	// GetServicesHaproxyRuntimeAclsIdWithResponse request
	GetServicesHaproxyRuntimeAclsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsIdResponse, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse request
	GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesResponse, error)

	// PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse request with any body
	PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error)

	PostServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error)

	// AddPayloadRuntimeACLWithBodyWithResponse request with any body
	AddPayloadRuntimeACLWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error)

	AddPayloadRuntimeACLWithResponse(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error)

	// DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request
	DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request
	GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error)

	// GetAcmeStatusWithResponse request
	GetAcmeStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAcmeStatusResponse, error)

	// RenewAcmeCertificateWithResponse request
	RenewAcmeCertificateWithResponse(ctx context.Context, params *RenewAcmeCertificateParams, reqEditors ...RequestEditorFn) (*RenewAcmeCertificateResponse, error)

	// GetAllRuntimeServerWithResponse request
	GetAllRuntimeServerWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetAllRuntimeServerResponse, error)

	// AddRuntimeServerWithBodyWithResponse request with any body
	AddRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error)

	AddRuntimeServerWithResponse(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error)

	// DeleteRuntimeServerWithResponse request
	DeleteRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*DeleteRuntimeServerResponse, error)

	// GetRuntimeServerWithResponse request
	GetRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*GetRuntimeServerResponse, error)

	// ReplaceRuntimeServerWithBodyWithResponse request with any body
	ReplaceRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error)

	ReplaceRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error)

	// GetHaproxyProcessInfoWithResponse request
	GetHaproxyProcessInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyProcessInfoResponse, error)

	// GetAllRuntimeMapFilesWithResponse request
	GetAllRuntimeMapFilesWithResponse(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*GetAllRuntimeMapFilesResponse, error)

	// ClearRuntimeMapWithResponse request
	ClearRuntimeMapWithResponse(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*ClearRuntimeMapResponse, error)

	// GetOneRuntimeMapWithResponse request
	GetOneRuntimeMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneRuntimeMapResponse, error)

	// AddPayloadRuntimeMapWithBodyWithResponse request with any body
	AddPayloadRuntimeMapWithBodyWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error)

	AddPayloadRuntimeMapWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error)

	// ShowRuntimeMapWithResponse request
	ShowRuntimeMapWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*ShowRuntimeMapResponse, error)

	// AddMapEntryWithBodyWithResponse request with any body
	AddMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error)

	AddMapEntryWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error)

	// DeleteRuntimeMapEntryWithResponse request
	DeleteRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*DeleteRuntimeMapEntryResponse, error)

	// GetRuntimeMapEntryWithResponse request
	GetRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetRuntimeMapEntryResponse, error)

	// ReplaceRuntimeMapEntryWithBodyWithResponse request with any body
	ReplaceRuntimeMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error)

	ReplaceRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error)

	// GetAllCaFilesWithResponse request
	GetAllCaFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCaFilesResponse, error)

	// CreateCaFileWithBodyWithResponse request with any body
	CreateCaFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCaFileResponse, error)

	// DeleteCaFileWithResponse request
	DeleteCaFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteCaFileResponse, error)

	// GetCaFileWithResponse request
	GetCaFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetCaFileResponse, error)

	// SetCaFileWithBodyWithResponse request with any body
	SetCaFileWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCaFileResponse, error)

	// AddCaEntryWithBodyWithResponse request with any body
	AddCaEntryWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCaEntryResponse, error)

	// GetCaEntryWithResponse request
	GetCaEntryWithResponse(ctx context.Context, name string, index int, reqEditors ...RequestEditorFn) (*GetCaEntryResponse, error)

	// GetAllCertsWithResponse request
	GetAllCertsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCertsResponse, error)

	// CreateCertWithBodyWithResponse request with any body
	CreateCertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCertResponse, error)

	// DeleteCertWithResponse request
	DeleteCertWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteCertResponse, error)

	// GetCertWithResponse request
	GetCertWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetCertResponse, error)

	// ReplaceCertWithBodyWithResponse request with any body
	ReplaceCertWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCertResponse, error)

	// GetAllCrlWithResponse request
	GetAllCrlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCrlResponse, error)

	// CreateCrlWithBodyWithResponse request with any body
	CreateCrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrlResponse, error)

	// DeleteCrlWithResponse request
	DeleteCrlWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteCrlResponse, error)

	// GetCrlWithResponse request
	GetCrlWithResponse(ctx context.Context, name string, params *GetCrlParams, reqEditors ...RequestEditorFn) (*GetCrlResponse, error)

	// ReplaceCrlWithBodyWithResponse request with any body
	ReplaceCrlWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCrlResponse, error)

	// GetAllCrtListsWithResponse request
	GetAllCrtListsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCrtListsResponse, error)

	// DeleteCrtListEntryWithResponse request
	DeleteCrtListEntryWithResponse(ctx context.Context, params *DeleteCrtListEntryParams, reqEditors ...RequestEditorFn) (*DeleteCrtListEntryResponse, error)

	// GetAllCrtListEntriesWithResponse request
	GetAllCrtListEntriesWithResponse(ctx context.Context, params *GetAllCrtListEntriesParams, reqEditors ...RequestEditorFn) (*GetAllCrtListEntriesResponse, error)

	// AddCrtListEntryWithBodyWithResponse request with any body
	AddCrtListEntryWithBodyWithResponse(ctx context.Context, params *AddCrtListEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCrtListEntryResponse, error)

	AddCrtListEntryWithResponse(ctx context.Context, params *AddCrtListEntryParams, body AddCrtListEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCrtListEntryResponse, error)

	// GetStickTablesWithResponse request
	GetStickTablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStickTablesResponse, error)

	// GetStickTableWithResponse request
	GetStickTableWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetStickTableResponse, error)

	// GetStickTableEntriesWithResponse request
	GetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*GetStickTableEntriesResponse, error)

	// SetStickTableEntriesWithBodyWithResponse request with any body
	SetStickTableEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error)

	SetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error)

	// GetSitesWithResponse request
	GetSitesWithResponse(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*GetSitesResponse, error)

	// CreateSiteWithBodyWithResponse request with any body
	CreateSiteWithBodyWithResponse(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	CreateSiteWithResponse(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	// DeleteSiteWithResponse request
	DeleteSiteWithResponse(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error)

	// GetSiteWithResponse request
	GetSiteWithResponse(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*GetSiteResponse, error)

	// ReplaceSiteWithBodyWithResponse request with any body
	ReplaceSiteWithBodyWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error)

	ReplaceSiteWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error)

	// GetSpoeEndpointsWithResponse request
	GetSpoeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpoeEndpointsResponse, error)

	// GetAllSpoeFilesWithResponse request
	GetAllSpoeFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSpoeFilesResponse, error)

	// CreateSpoeWithBodyWithResponse request with any body
	CreateSpoeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeResponse, error)

	// DeleteSpoeFileWithResponse request
	DeleteSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteSpoeFileResponse, error)

	// GetOneSpoeFileWithResponse request
	GetOneSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneSpoeFileResponse, error)

	// GetAllSpoeScopeWithResponse request
	GetAllSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetAllSpoeScopeResponse, error)

	// CreateSpoeScopeWithBodyWithResponse request with any body
	CreateSpoeScopeWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error)

	CreateSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error)

	// DeleteSpoeScopeWithResponse request
	DeleteSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*DeleteSpoeScopeResponse, error)

	// GetSpoeScopeWithResponse request
	GetSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetSpoeScopeResponse, error)

	// GetAllSpoeAgentWithResponse request
	GetAllSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetAllSpoeAgentResponse, error)

	// CreateSpoeAgentWithBodyWithResponse request with any body
	CreateSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error)

	CreateSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error)

	// DeleteSpoeAgentWithResponse request
	DeleteSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*DeleteSpoeAgentResponse, error)

	// GetSpoeAgentWithResponse request
	GetSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetSpoeAgentResponse, error)

	// ReplaceSpoeAgentWithBodyWithResponse request with any body
	ReplaceSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error)

	ReplaceSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error)

	// GetAllSpoeGroupWithResponse request
	GetAllSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetAllSpoeGroupResponse, error)

	// CreateSpoeGroupWithBodyWithResponse request with any body
	CreateSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error)

	CreateSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error)

	// DeleteSpoeGroupWithResponse request
	DeleteSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*DeleteSpoeGroupResponse, error)

	// GetSpoeGroupWithResponse request
	GetSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetSpoeGroupResponse, error)

	// ReplaceSpoeGroupWithBodyWithResponse request with any body
	ReplaceSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error)

	ReplaceSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error)

	// GetAllSpoeMessageWithResponse request
	GetAllSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetAllSpoeMessageResponse, error)

	// CreateSpoeMessageWithBodyWithResponse request with any body
	CreateSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error)

	CreateSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error)

	// DeleteSpoeMessageWithResponse request
	DeleteSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*DeleteSpoeMessageResponse, error)

	// GetSpoeMessageWithResponse request
	GetSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetSpoeMessageResponse, error)

	// ReplaceSpoeMessageWithBodyWithResponse request with any body
	ReplaceSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error)

	ReplaceSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error)

	// GetAllSpoeTransactionWithResponse request
	GetAllSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*GetAllSpoeTransactionResponse, error)

	// StartSpoeTransactionWithResponse request
	StartSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*StartSpoeTransactionResponse, error)

	// DeleteSpoeTransactionWithResponse request
	DeleteSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteSpoeTransactionResponse, error)

	// GetSpoeTransactionWithResponse request
	GetSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetSpoeTransactionResponse, error)

	// CommitSpoeTransactionWithResponse request
	CommitSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*CommitSpoeTransactionResponse, error)

	// GetSpoeConfigurationVersionWithResponse request
	GetSpoeConfigurationVersionWithResponse(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetSpoeConfigurationVersionResponse, error)

	// GetStatsEndpointsWithResponse request
	GetStatsEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsEndpointsResponse, error)

	// GetStatsWithResponse request
	GetStatsWithResponse(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// GetStorageEndpointsWithResponse request
	GetStorageEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageEndpointsResponse, error)

	// GetAllStorageGeneralFilesWithResponse request
	GetAllStorageGeneralFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageGeneralFilesResponse, error)

	// CreateStorageGeneralFileWithBodyWithResponse request with any body
	CreateStorageGeneralFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageGeneralFileResponse, error)

	// DeleteStorageGeneralFileWithResponse request
	DeleteStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageGeneralFileResponse, error)

	// GetOneStorageGeneralFileWithResponse request
	GetOneStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageGeneralFileResponse, error)

	// ReplaceStorageGeneralFileWithBodyWithResponse request with any body
	ReplaceStorageGeneralFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageGeneralFileResponse, error)

	// GetAllStorageMapFilesWithResponse request
	GetAllStorageMapFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageMapFilesResponse, error)

	// CreateStorageMapFileWithBodyWithResponse request with any body
	CreateStorageMapFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageMapFileResponse, error)

	// DeleteStorageMapWithResponse request
	DeleteStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageMapResponse, error)

	// GetOneStorageMapWithResponse request
	GetOneStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageMapResponse, error)

	// ReplaceStorageMapFileWithBodyWithResponse request with any body
	ReplaceStorageMapFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error)

	ReplaceStorageMapFileWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error)

	// GetAllStorageSSLCertificatesWithResponse request
	GetAllStorageSSLCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageSSLCertificatesResponse, error)

	// CreateStorageSSLCertificateWithBodyWithResponse request with any body
	CreateStorageSSLCertificateWithBodyWithResponse(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCertificateResponse, error)

	// DeleteStorageSSLCertificateWithResponse request
	DeleteStorageSSLCertificateWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCertificateResponse, error)

	// GetOneStorageSSLCertificateWithResponse request
	GetOneStorageSSLCertificateWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageSSLCertificateResponse, error)

	// ReplaceStorageSSLCertificateWithBodyWithResponse request with any body
	ReplaceStorageSSLCertificateWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error)

	ReplaceStorageSSLCertificateWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error)

	// GetAllStorageSSLCrtListFilesWithResponse request
	GetAllStorageSSLCrtListFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageSSLCrtListFilesResponse, error)

	// CreateStorageSSLCrtListFileWithBodyWithResponse request with any body
	CreateStorageSSLCrtListFileWithBodyWithResponse(ctx context.Context, params *CreateStorageSSLCrtListFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCrtListFileResponse, error)

	// DeleteStorageSSLCrtListFileWithResponse request
	DeleteStorageSSLCrtListFileWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCrtListFileParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCrtListFileResponse, error)

	// GetOneStorageSSLCrtListFileWithResponse request
	GetOneStorageSSLCrtListFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageSSLCrtListFileResponse, error)

	// ReplaceStorageSSLCrtListFileWithBodyWithResponse request with any body
	ReplaceStorageSSLCrtListFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCrtListFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCrtListFileResponse, error)

	ReplaceStorageSSLCrtListFileWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCrtListFileParams, body ReplaceStorageSSLCrtListFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCrtListFileResponse, error)

	// DeleteStorageSSLCrtListEntryWithResponse request
	DeleteStorageSSLCrtListEntryWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCrtListEntryParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCrtListEntryResponse, error)

	// GetStorageSSLCrtListEntriesWithResponse request
	GetStorageSSLCrtListEntriesWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetStorageSSLCrtListEntriesResponse, error)

	// CreateStorageSSLCrtListEntryWithBodyWithResponse request with any body
	CreateStorageSSLCrtListEntryWithBodyWithResponse(ctx context.Context, name string, params *CreateStorageSSLCrtListEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCrtListEntryResponse, error)

	CreateStorageSSLCrtListEntryWithResponse(ctx context.Context, name string, params *CreateStorageSSLCrtListEntryParams, body CreateStorageSSLCrtListEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStorageSSLCrtListEntryResponse, error)

	// GetTransactionsWithResponse request
	GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error)

	// StartTransactionWithResponse request
	StartTransactionWithResponse(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*StartTransactionResponse, error)

	// DeleteTransactionWithResponse request
	DeleteTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error)

	// GetTransactionWithResponse request
	GetTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error)

	// CommitTransactionWithResponse request
	CommitTransactionWithResponse(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error)

	// GetSpecificationWithResponse request
	GetSpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpecificationResponse, error)

	// GetOpenapiv3SpecificationWithResponse request
	GetOpenapiv3SpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiv3SpecificationResponse, error)
}

type GetAPIEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAPIEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r PostClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitiateCertificateRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r InitiateCertificateRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitiateCertificateRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Health
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Info
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAWSRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AwsRegions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAWSRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAWSRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AwsRegion
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AwsRegion
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AwsRegion
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsulsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consuls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConsulsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsulsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Consul
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consul
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consul
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHaproxyEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHaproxyEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHaproxyEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConfigurationEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAcmeProvidersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AcmeProviders
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAcmeProvidersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAcmeProvidersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAcmeProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AcmeProvider
	JSON202      *AcmeProvider
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAcmeProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAcmeProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAcmeProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAcmeProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAcmeProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAcmeProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AcmeProvider
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAcmeProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAcmeProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditAcmeProviderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AcmeProvider
	JSON202      *AcmeProvider
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditAcmeProviderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditAcmeProviderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backends
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Backend
	JSON202      *Backend
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backend
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backend
	JSON202      *Backend
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSON202      *Filters
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSON202      *HttpAfterResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSON202      *HttpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSON202      *HttpErrorRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSON202      *HttpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSON202      *HttpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRules
	JSON202      *ServerSwitchingRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServerSwitchingRule
	JSON202      *ServerSwitchingRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRule
	JSON202      *ServerSwitchingRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTemplates
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServerTemplate
	JSON202      *ServerTemplate
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTemplate
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTemplate
	JSON202      *ServerTemplate
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Servers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStickRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRules
	JSON202      *StickRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStickRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStickRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StickRule
	JSON202      *StickRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRule
	JSON202      *StickRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSON202      *TcpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSON202      *TcpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRules
	JSON202      *TcpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpResponseRule
	JSON202      *TcpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRule
	JSON202      *TcpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCachesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Caches
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCachesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCachesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Cache
	JSON202      *Cache
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cache
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cache
	JSON202      *Cache
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtLoadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtLoads
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtLoadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtLoadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CrtLoad
	JSON202      *CrtLoad
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtLoad
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtLoad
	JSON202      *CrtLoad
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtStoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtStores
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtStoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtStoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CrtStore
	JSON202      *CrtStore
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtStore
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtStore
	JSON202      *CrtStore
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultsSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DefaultsSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDefaultsSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultsSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Defaults
	JSON202      *Defaults
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Defaults
	JSON202      *Defaults
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Defaults
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Defaults
	JSON202      *Defaults
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPAfterResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPAfterResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPAfterResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPAfterResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSON202      *HttpAfterResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPAfterResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPAfterResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPAfterResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPAfterResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPAfterResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPAfterResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPAfterResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPAfterResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPAfterResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPAfterResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPAfterResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPAfterResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPAfterResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPAfterResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSON202      *HttpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSON202      *HttpErrorRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSON202      *HttpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSON202      *HttpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRules
	JSON202      *QUICInitialRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *QUICInitialRule
	JSON202      *QUICInitialRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceQUICInitialRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRule
	JSON202      *QUICInitialRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceQUICInitialRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceQUICInitialRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSON202      *TcpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSON202      *TcpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPRequestRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPRequestRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPRequestRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRules
	JSON202      *TcpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpResponseRule
	JSON202      *TcpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPResponseRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRule
	JSON202      *TcpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPResponseRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPResponseRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFCGIAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FcgiApps
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFCGIAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFCGIAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FCGIApp
	JSON202      *FCGIApp
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FCGIApp
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FCGIApp
	JSON202      *FCGIApp
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFrontendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Frontends
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFrontendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFrontendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Frontend
	JSON202      *Frontend
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Frontend
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Frontend
	JSON202      *Frontend
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBackendSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRules
	JSON202      *BackendSwitchingRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBackendSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBackendSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BackendSwitchingRule
	JSON202      *BackendSwitchingRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRule
	JSON202      *BackendSwitchingRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeclareCapturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Captures
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDeclareCapturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeclareCapturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDeclareCapturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Captures
	JSON202      *Captures
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDeclareCapturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDeclareCapturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Capture
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Capture
	JSON202      *Capture
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Capture
	JSON202      *Capture
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSON202      *Filters
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSON202      *HttpAfterResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSON202      *HttpErrorRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSON202      *HttpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSON202      *HttpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRules
	JSON202      *QUICInitialRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *QUICInitialRule
	JSON202      *QUICInitialRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceQUICInitialRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QUICInitialRule
	JSON202      *QUICInitialRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceQUICInitialRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceQUICInitialRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSSLFrontUsesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SSLFrontUses
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSSLFrontUsesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSSLFrontUsesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSSLFrontUseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SSLFrontUse
	JSON202      *SSLFrontUse
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSSLFrontUseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSSLFrontUseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSSLFrontUseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSSLFrontUseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSSLFrontUseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSSLFrontUseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SSLFrontUse
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSSLFrontUseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSSLFrontUseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSSLFrontUseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SSLFrontUse
	JSON202      *SSLFrontUse
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSSLFrontUseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSSLFrontUseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSON202      *TcpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Global
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Global
	JSON202      *Global
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Groups
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Group
	JSON202      *Group
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON202      *Group
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorsSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorsSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorsSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorsSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorsSection
	JSON202      *HttpErrorsSection
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorsSection
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorsSection
	JSON202      *HttpErrorsSection
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogForwardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogForwards
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogForwardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogForwardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogForward
	JSON202      *LogForward
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogForward
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogForward
	JSON202      *LogForward
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDgramBindsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBinds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDgramBindsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDgramBindsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDgramBindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DgramBind
	JSON202      *DgramBind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDgramBindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDgramBindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDgramBindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDgramBindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDgramBindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDgramBindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDgramBindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDgramBindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDgramBindResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBind
	JSON202      *DgramBind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDgramBindResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDgramBindResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogProfiles
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogProfile
	JSON202      *LogProfile
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogProfile
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditLogProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogProfile
	JSON202      *LogProfile
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditLogProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditLogProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailerEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailerEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailerEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailerEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MailerEntry
	JSON202      *MailerEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailerEntry
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailerEntry
	JSON202      *MailerEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailersSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailersSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailersSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailersSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MailersSection
	JSON202      *MailersSection
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailersSection
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailersSection
	JSON202      *MailersSection
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNameserversResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nameservers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetNameserversResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNameserversResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Nameserver
	JSON202      *Nameserver
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nameserver
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nameserver
	JSON202      *Nameserver
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PeerEntry
	JSON202      *PeerEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreatePeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeletePeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerEntry
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplacePeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerEntry
	JSON202      *PeerEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplacePeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplacePeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PeerSection
	JSON202      *PeerSection
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreatePeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeletePeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerSection
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Servers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tables
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Table
	JSON202      *Table
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON202      *Table
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Programs
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetProgramsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Program
	JSON202      *Program
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Program
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Program
	JSON202      *Program
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHAProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHAProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHAProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostHAProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostHAProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostHAProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResolversResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resolvers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetResolversResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResolversResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Resolver
	JSON202      *Resolver
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resolver
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resolver
	JSON202      *Resolver
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rings
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ring
	JSON202      *Ring
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ring
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ring
	JSON202      *Ring
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Servers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTracesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTracesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTracesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Traces
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTracesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTracesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Traces
	JSON202      *Traces
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTracesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTracesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTracesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Traces
	JSON202      *Traces
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTracesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTracesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTraceEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTraceEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTraceEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTraceEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TraceEntry
	JSON202      *TraceEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTraceEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTraceEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserlistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Userlists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserlistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserlistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Userlist
	JSON202      *Userlist
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateUserlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteUserlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Userlist
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Users
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON202      *User
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON202      *User
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConfigurationVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReloadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reloads
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetReloadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReloadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reload
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetReloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRuntimeEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFiles
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFile
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsParentNameEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFilesEntries
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostServicesHaproxyRuntimeAclsParentNameEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AclFileEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r PostServicesHaproxyRuntimeAclsParentNameEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostServicesHaproxyRuntimeAclsParentNameEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPayloadRuntimeACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AclFilesEntries
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddPayloadRuntimeACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPayloadRuntimeACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFileEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAcmeStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AcmeStatus
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAcmeStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAcmeStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenewAcmeCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r RenewAcmeCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenewAcmeCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeServers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RuntimeAddServer
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeServer
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeServer
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHaproxyProcessInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessInfo
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHaproxyProcessInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHaproxyProcessInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRuntimeMapFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Maps
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllRuntimeMapFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRuntimeMapFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ClearRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Map
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPayloadRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MapEntries
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddPayloadRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPayloadRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MapEntries
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ShowRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MapEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuntimeMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRuntimeMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuntimeMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MapEntry
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRuntimeMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRuntimeMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MapEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceRuntimeMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRuntimeMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCaFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCaFiles
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllCaFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCaFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCaFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCaFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCaFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCaFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCaFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCaFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCaFile
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCaFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCaFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r SetCaFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCaFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCaEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SslCertificate
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddCaEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCaEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificate
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCaEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificates
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllCertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificate
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceCertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceCertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceCertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCrls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllCrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCrlEntries
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceCrlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceCrlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceCrlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCrtListsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCrtLists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllCrtListsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCrtListsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCrtListEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCrtListEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCrtListEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllCrtListEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCrtListEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllCrtListEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllCrtListEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCrtListEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddCrtListEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCrtListEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickTables
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickTable
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickTableEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickTableEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickTableEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickTableEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetStickTableEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r SetStickTableEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetStickTableEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sites
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Site
	JSON202      *Site
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Site
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Site
	JSON202      *Site
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeFiles
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *string
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneSpoeFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *string `json:"data,omitempty"`
	}
	JSON404     *NotFound
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneSpoeFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneSpoeFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeScopes
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeScope
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeScope
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeAgents
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeAgent
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeAgent
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeAgent
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeGroups
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeGroup
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeGroup
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeGroup
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeMessages
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeMessage
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeMessage
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeMessage
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeTransactions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeTransaction
	JSON429      *struct {
		Code    *int    `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r StartSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeTransaction
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeTransaction
	JSON202      *SpoeTransaction
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CommitSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeConfigurationVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeConfigurationVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeConfigurationVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStatsEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NativeStats
	JSON500      *NativeStats
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStorageEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageGeneralFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GeneralFiles
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageGeneralFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageGeneralFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GeneralFile
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageMapFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Maps
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageMapFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageMapFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageMapFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Map
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageMapFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageMapFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageMapFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageMapFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageMapFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageSSLCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificates
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageSSLCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageSSLCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SslCertificate
	JSON202      *SslCertificate
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificate
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificate
	JSON202      *SslCertificate
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageSSLCrtListFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCrtListFiles
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageSSLCrtListFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageSSLCrtListFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageSSLCrtListFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SslCrtListFile
	JSON202      *SslCrtListFile
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageSSLCrtListFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageSSLCrtListFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageSSLCrtListFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageSSLCrtListFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageSSLCrtListFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageSSLCrtListFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageSSLCrtListFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageSSLCrtListFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageSSLCrtListFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCrtListFile
	JSON202      *SslCrtListFile
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageSSLCrtListFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageSSLCrtListFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageSSLCrtListEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageSSLCrtListEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageSSLCrtListEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageSSLCrtListEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCrtListEntries
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStorageSSLCrtListEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageSSLCrtListEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageSSLCrtListEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SslCrtListEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageSSLCrtListEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageSSLCrtListEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transactions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Transaction
	JSON429      *struct {
		Code    *int    `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r StartTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON202      *Transaction
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON406      *NotAcceptable
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CommitTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpecificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpecificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpecificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiv3SpecificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOpenapiv3SpecificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiv3SpecificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAPIEndpointsWithResponse request returning *GetAPIEndpointsResponse
func (c *ClientWithResponses) GetAPIEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAPIEndpointsResponse, error) {
	rsp, err := c.GetAPIEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIEndpointsResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// PostClusterWithBodyWithResponse request with arbitrary body returning *PostClusterResponse
func (c *ClientWithResponses) PostClusterWithBodyWithResponse(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterResponse, error) {
	rsp, err := c.PostClusterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterResponse(rsp)
}

func (c *ClientWithResponses) PostClusterWithResponse(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterResponse, error) {
	rsp, err := c.PostCluster(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterResponse(rsp)
}

// EditClusterWithBodyWithResponse request with arbitrary body returning *EditClusterResponse
func (c *ClientWithResponses) EditClusterWithBodyWithResponse(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditClusterResponse, error) {
	rsp, err := c.EditClusterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditClusterResponse(rsp)
}

func (c *ClientWithResponses) EditClusterWithResponse(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*EditClusterResponse, error) {
	rsp, err := c.EditCluster(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditClusterResponse(rsp)
}

// InitiateCertificateRefreshWithResponse request returning *InitiateCertificateRefreshResponse
func (c *ClientWithResponses) InitiateCertificateRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitiateCertificateRefreshResponse, error) {
	rsp, err := c.InitiateCertificateRefresh(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateCertificateRefreshResponse(rsp)
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// GetInfoWithResponse request returning *GetInfoResponse
func (c *ClientWithResponses) GetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfoResponse, error) {
	rsp, err := c.GetInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfoResponse(rsp)
}

// GetAWSRegionsWithResponse request returning *GetAWSRegionsResponse
func (c *ClientWithResponses) GetAWSRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAWSRegionsResponse, error) {
	rsp, err := c.GetAWSRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAWSRegionsResponse(rsp)
}

// CreateAWSRegionWithBodyWithResponse request with arbitrary body returning *CreateAWSRegionResponse
func (c *ClientWithResponses) CreateAWSRegionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error) {
	rsp, err := c.CreateAWSRegionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAWSRegionResponse(rsp)
}

func (c *ClientWithResponses) CreateAWSRegionWithResponse(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error) {
	rsp, err := c.CreateAWSRegion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAWSRegionResponse(rsp)
}

// DeleteAWSRegionWithResponse request returning *DeleteAWSRegionResponse
func (c *ClientWithResponses) DeleteAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAWSRegionResponse, error) {
	rsp, err := c.DeleteAWSRegion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAWSRegionResponse(rsp)
}

// GetAWSRegionWithResponse request returning *GetAWSRegionResponse
func (c *ClientWithResponses) GetAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAWSRegionResponse, error) {
	rsp, err := c.GetAWSRegion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAWSRegionResponse(rsp)
}

// ReplaceAWSRegionWithBodyWithResponse request with arbitrary body returning *ReplaceAWSRegionResponse
func (c *ClientWithResponses) ReplaceAWSRegionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error) {
	rsp, err := c.ReplaceAWSRegionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAWSRegionResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAWSRegionWithResponse(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error) {
	rsp, err := c.ReplaceAWSRegion(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAWSRegionResponse(rsp)
}

// GetConsulsWithResponse request returning *GetConsulsResponse
func (c *ClientWithResponses) GetConsulsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConsulsResponse, error) {
	rsp, err := c.GetConsuls(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsulsResponse(rsp)
}

// CreateConsulWithBodyWithResponse request with arbitrary body returning *CreateConsulResponse
func (c *ClientWithResponses) CreateConsulWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error) {
	rsp, err := c.CreateConsulWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsulResponse(rsp)
}

func (c *ClientWithResponses) CreateConsulWithResponse(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error) {
	rsp, err := c.CreateConsul(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsulResponse(rsp)
}

// DeleteConsulWithResponse request returning *DeleteConsulResponse
func (c *ClientWithResponses) DeleteConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteConsulResponse, error) {
	rsp, err := c.DeleteConsul(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConsulResponse(rsp)
}

// GetConsulWithResponse request returning *GetConsulResponse
func (c *ClientWithResponses) GetConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConsulResponse, error) {
	rsp, err := c.GetConsul(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsulResponse(rsp)
}

// ReplaceConsulWithBodyWithResponse request with arbitrary body returning *ReplaceConsulResponse
func (c *ClientWithResponses) ReplaceConsulWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error) {
	rsp, err := c.ReplaceConsulWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceConsulResponse(rsp)
}

func (c *ClientWithResponses) ReplaceConsulWithResponse(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error) {
	rsp, err := c.ReplaceConsul(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceConsulResponse(rsp)
}

// GetServicesEndpointsWithResponse request returning *GetServicesEndpointsResponse
func (c *ClientWithResponses) GetServicesEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesEndpointsResponse, error) {
	rsp, err := c.GetServicesEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesEndpointsResponse(rsp)
}

// GetHaproxyEndpointsWithResponse request returning *GetHaproxyEndpointsResponse
func (c *ClientWithResponses) GetHaproxyEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyEndpointsResponse, error) {
	rsp, err := c.GetHaproxyEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHaproxyEndpointsResponse(rsp)
}

// GetConfigurationEndpointsWithResponse request returning *GetConfigurationEndpointsResponse
func (c *ClientWithResponses) GetConfigurationEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationEndpointsResponse, error) {
	rsp, err := c.GetConfigurationEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationEndpointsResponse(rsp)
}

// GetAcmeProvidersWithResponse request returning *GetAcmeProvidersResponse
func (c *ClientWithResponses) GetAcmeProvidersWithResponse(ctx context.Context, params *GetAcmeProvidersParams, reqEditors ...RequestEditorFn) (*GetAcmeProvidersResponse, error) {
	rsp, err := c.GetAcmeProviders(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAcmeProvidersResponse(rsp)
}

// CreateAcmeProviderWithBodyWithResponse request with arbitrary body returning *CreateAcmeProviderResponse
func (c *ClientWithResponses) CreateAcmeProviderWithBodyWithResponse(ctx context.Context, params *CreateAcmeProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAcmeProviderResponse, error) {
	rsp, err := c.CreateAcmeProviderWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAcmeProviderResponse(rsp)
}

func (c *ClientWithResponses) CreateAcmeProviderWithResponse(ctx context.Context, params *CreateAcmeProviderParams, body CreateAcmeProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAcmeProviderResponse, error) {
	rsp, err := c.CreateAcmeProvider(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAcmeProviderResponse(rsp)
}

// DeleteAcmeProviderWithResponse request returning *DeleteAcmeProviderResponse
func (c *ClientWithResponses) DeleteAcmeProviderWithResponse(ctx context.Context, name string, params *DeleteAcmeProviderParams, reqEditors ...RequestEditorFn) (*DeleteAcmeProviderResponse, error) {
	rsp, err := c.DeleteAcmeProvider(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAcmeProviderResponse(rsp)
}

// GetAcmeProviderWithResponse request returning *GetAcmeProviderResponse
func (c *ClientWithResponses) GetAcmeProviderWithResponse(ctx context.Context, name string, params *GetAcmeProviderParams, reqEditors ...RequestEditorFn) (*GetAcmeProviderResponse, error) {
	rsp, err := c.GetAcmeProvider(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAcmeProviderResponse(rsp)
}

// EditAcmeProviderWithBodyWithResponse request with arbitrary body returning *EditAcmeProviderResponse
func (c *ClientWithResponses) EditAcmeProviderWithBodyWithResponse(ctx context.Context, name string, params *EditAcmeProviderParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditAcmeProviderResponse, error) {
	rsp, err := c.EditAcmeProviderWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAcmeProviderResponse(rsp)
}

func (c *ClientWithResponses) EditAcmeProviderWithResponse(ctx context.Context, name string, params *EditAcmeProviderParams, body EditAcmeProviderJSONRequestBody, reqEditors ...RequestEditorFn) (*EditAcmeProviderResponse, error) {
	rsp, err := c.EditAcmeProvider(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditAcmeProviderResponse(rsp)
}

// GetBackendsWithResponse request returning *GetBackendsResponse
func (c *ClientWithResponses) GetBackendsWithResponse(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*GetBackendsResponse, error) {
	rsp, err := c.GetBackends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendsResponse(rsp)
}

// CreateBackendWithBodyWithResponse request with arbitrary body returning *CreateBackendResponse
func (c *ClientWithResponses) CreateBackendWithBodyWithResponse(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error) {
	rsp, err := c.CreateBackendWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateBackendWithResponse(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error) {
	rsp, err := c.CreateBackend(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendResponse(rsp)
}

// DeleteBackendWithResponse request returning *DeleteBackendResponse
func (c *ClientWithResponses) DeleteBackendWithResponse(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*DeleteBackendResponse, error) {
	rsp, err := c.DeleteBackend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackendResponse(rsp)
}

// GetBackendWithResponse request returning *GetBackendResponse
func (c *ClientWithResponses) GetBackendWithResponse(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*GetBackendResponse, error) {
	rsp, err := c.GetBackend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendResponse(rsp)
}

// ReplaceBackendWithBodyWithResponse request with arbitrary body returning *ReplaceBackendResponse
func (c *ClientWithResponses) ReplaceBackendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error) {
	rsp, err := c.ReplaceBackendWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBackendWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error) {
	rsp, err := c.ReplaceBackend(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendResponse(rsp)
}

// GetAllAclBackendWithResponse request returning *GetAllAclBackendResponse
func (c *ClientWithResponses) GetAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*GetAllAclBackendResponse, error) {
	rsp, err := c.GetAllAclBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclBackendResponse(rsp)
}

// ReplaceAllAclBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclBackendResponse
func (c *ClientWithResponses) ReplaceAllAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error) {
	rsp, err := c.ReplaceAllAclBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error) {
	rsp, err := c.ReplaceAllAclBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclBackendResponse(rsp)
}

// DeleteAclBackendWithResponse request returning *DeleteAclBackendResponse
func (c *ClientWithResponses) DeleteAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*DeleteAclBackendResponse, error) {
	rsp, err := c.DeleteAclBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclBackendResponse(rsp)
}

// GetAclBackendWithResponse request returning *GetAclBackendResponse
func (c *ClientWithResponses) GetAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*GetAclBackendResponse, error) {
	rsp, err := c.GetAclBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclBackendResponse(rsp)
}

// CreateAclBackendWithBodyWithResponse request with arbitrary body returning *CreateAclBackendResponse
func (c *ClientWithResponses) CreateAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error) {
	rsp, err := c.CreateAclBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error) {
	rsp, err := c.CreateAclBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclBackendResponse(rsp)
}

// ReplaceAclBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAclBackendResponse
func (c *ClientWithResponses) ReplaceAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error) {
	rsp, err := c.ReplaceAclBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error) {
	rsp, err := c.ReplaceAclBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclBackendResponse(rsp)
}

// GetAllFilterBackendWithResponse request returning *GetAllFilterBackendResponse
func (c *ClientWithResponses) GetAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*GetAllFilterBackendResponse, error) {
	rsp, err := c.GetAllFilterBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllFilterBackendResponse(rsp)
}

// ReplaceAllFilterBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllFilterBackendResponse
func (c *ClientWithResponses) ReplaceAllFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error) {
	rsp, err := c.ReplaceAllFilterBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error) {
	rsp, err := c.ReplaceAllFilterBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterBackendResponse(rsp)
}

// DeleteFilterBackendWithResponse request returning *DeleteFilterBackendResponse
func (c *ClientWithResponses) DeleteFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*DeleteFilterBackendResponse, error) {
	rsp, err := c.DeleteFilterBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFilterBackendResponse(rsp)
}

// GetFilterBackendWithResponse request returning *GetFilterBackendResponse
func (c *ClientWithResponses) GetFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*GetFilterBackendResponse, error) {
	rsp, err := c.GetFilterBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterBackendResponse(rsp)
}

// CreateFilterBackendWithBodyWithResponse request with arbitrary body returning *CreateFilterBackendResponse
func (c *ClientWithResponses) CreateFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error) {
	rsp, err := c.CreateFilterBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error) {
	rsp, err := c.CreateFilterBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterBackendResponse(rsp)
}

// ReplaceFilterBackendWithBodyWithResponse request with arbitrary body returning *ReplaceFilterBackendResponse
func (c *ClientWithResponses) ReplaceFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error) {
	rsp, err := c.ReplaceFilterBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error) {
	rsp, err := c.ReplaceFilterBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterBackendResponse(rsp)
}

// GetAllHTTPAfterResponseRuleBackendWithResponse request returning *GetAllHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPAfterResponseRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPAfterResponseRuleBackendResponse(rsp)
}

// ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleBackendResponse(rsp)
}

// DeleteHTTPAfterResponseRuleBackendWithResponse request returning *DeleteHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPAfterResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPAfterResponseRuleBackendResponse(rsp)
}

// GetHTTPAfterResponseRuleBackendWithResponse request returning *GetHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) GetHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.GetHTTPAfterResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPAfterResponseRuleBackendResponse(rsp)
}

// CreateHTTPAfterResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleBackendResponse(rsp)
}

// ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleBackendResponse(rsp)
}

// GetAllHTTPCheckBackendWithResponse request returning *GetAllHTTPCheckBackendResponse
func (c *ClientWithResponses) GetAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckBackendResponse, error) {
	rsp, err := c.GetAllHTTPCheckBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPCheckBackendResponse(rsp)
}

// ReplaceAllHTTPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPCheckBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckBackendResponse(rsp)
}

// DeleteHTTPCheckBackendWithResponse request returning *DeleteHTTPCheckBackendResponse
func (c *ClientWithResponses) DeleteHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckBackendResponse, error) {
	rsp, err := c.DeleteHTTPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPCheckBackendResponse(rsp)
}

// GetHTTPCheckBackendWithResponse request returning *GetHTTPCheckBackendResponse
func (c *ClientWithResponses) GetHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckBackendResponse, error) {
	rsp, err := c.GetHTTPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPCheckBackendResponse(rsp)
}

// CreateHTTPCheckBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPCheckBackendResponse
func (c *ClientWithResponses) CreateHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error) {
	rsp, err := c.CreateHTTPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error) {
	rsp, err := c.CreateHTTPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckBackendResponse(rsp)
}

// ReplaceHTTPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPCheckBackendResponse
func (c *ClientWithResponses) ReplaceHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceHTTPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceHTTPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckBackendResponse(rsp)
}

// GetAllHTTPErrorRuleBackendWithResponse request returning *GetAllHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPErrorRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPErrorRuleBackendResponse(rsp)
}

// ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleBackendResponse(rsp)
}

// DeleteHTTPErrorRuleBackendWithResponse request returning *DeleteHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPErrorRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorRuleBackendResponse(rsp)
}

// GetHTTPErrorRuleBackendWithResponse request returning *GetHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) GetHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.GetHTTPErrorRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorRuleBackendResponse(rsp)
}

// CreateHTTPErrorRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleBackendResponse(rsp)
}

// ReplaceHTTPErrorRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleBackendResponse(rsp)
}

// GetAllHTTPRequestRuleBackendWithResponse request returning *GetAllHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPRequestRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPRequestRuleBackendResponse(rsp)
}

// ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleBackendResponse(rsp)
}

// DeleteHTTPRequestRuleBackendWithResponse request returning *DeleteHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPRequestRuleBackendResponse(rsp)
}

// GetHTTPRequestRuleBackendWithResponse request returning *GetHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) GetHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.GetHTTPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPRequestRuleBackendResponse(rsp)
}

// CreateHTTPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleBackendResponse(rsp)
}

// ReplaceHTTPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleBackendResponse(rsp)
}

// GetAllHTTPResponseRuleBackendWithResponse request returning *GetAllHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPResponseRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPResponseRuleBackendResponse(rsp)
}

// ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleBackendResponse(rsp)
}

// DeleteHTTPResponseRuleBackendWithResponse request returning *DeleteHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPResponseRuleBackendResponse(rsp)
}

// GetHTTPResponseRuleBackendWithResponse request returning *GetHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) GetHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.GetHTTPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPResponseRuleBackendResponse(rsp)
}

// CreateHTTPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleBackendResponse(rsp)
}

// ReplaceHTTPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleBackendResponse(rsp)
}

// GetAllLogTargetBackendWithResponse request returning *GetAllLogTargetBackendResponse
func (c *ClientWithResponses) GetAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetBackendResponse, error) {
	rsp, err := c.GetAllLogTargetBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetBackendResponse(rsp)
}

// ReplaceAllLogTargetBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetBackendResponse
func (c *ClientWithResponses) ReplaceAllLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetBackendResponse(rsp)
}

// DeleteLogTargetBackendWithResponse request returning *DeleteLogTargetBackendResponse
func (c *ClientWithResponses) DeleteLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetBackendResponse, error) {
	rsp, err := c.DeleteLogTargetBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetBackendResponse(rsp)
}

// GetLogTargetBackendWithResponse request returning *GetLogTargetBackendResponse
func (c *ClientWithResponses) GetLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetLogTargetBackendResponse, error) {
	rsp, err := c.GetLogTargetBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetBackendResponse(rsp)
}

// CreateLogTargetBackendWithBodyWithResponse request with arbitrary body returning *CreateLogTargetBackendResponse
func (c *ClientWithResponses) CreateLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error) {
	rsp, err := c.CreateLogTargetBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error) {
	rsp, err := c.CreateLogTargetBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetBackendResponse(rsp)
}

// ReplaceLogTargetBackendWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetBackendResponse
func (c *ClientWithResponses) ReplaceLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceLogTargetBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceLogTargetBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetBackendResponse(rsp)
}

// GetServerSwitchingRulesWithResponse request returning *GetServerSwitchingRulesResponse
func (c *ClientWithResponses) GetServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRulesResponse, error) {
	rsp, err := c.GetServerSwitchingRules(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerSwitchingRulesResponse(rsp)
}

// ReplaceServerSwitchingRulesWithBodyWithResponse request with arbitrary body returning *ReplaceServerSwitchingRulesResponse
func (c *ClientWithResponses) ReplaceServerSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRulesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRules(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRulesResponse(rsp)
}

// DeleteServerSwitchingRuleWithResponse request returning *DeleteServerSwitchingRuleResponse
func (c *ClientWithResponses) DeleteServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteServerSwitchingRuleResponse, error) {
	rsp, err := c.DeleteServerSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerSwitchingRuleResponse(rsp)
}

// GetServerSwitchingRuleWithResponse request returning *GetServerSwitchingRuleResponse
func (c *ClientWithResponses) GetServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRuleResponse, error) {
	rsp, err := c.GetServerSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerSwitchingRuleResponse(rsp)
}

// CreateServerSwitchingRuleWithBodyWithResponse request with arbitrary body returning *CreateServerSwitchingRuleResponse
func (c *ClientWithResponses) CreateServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error) {
	rsp, err := c.CreateServerSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error) {
	rsp, err := c.CreateServerSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerSwitchingRuleResponse(rsp)
}

// ReplaceServerSwitchingRuleWithBodyWithResponse request with arbitrary body returning *ReplaceServerSwitchingRuleResponse
func (c *ClientWithResponses) ReplaceServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRuleResponse(rsp)
}

// GetServerTemplatesWithResponse request returning *GetServerTemplatesResponse
func (c *ClientWithResponses) GetServerTemplatesWithResponse(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*GetServerTemplatesResponse, error) {
	rsp, err := c.GetServerTemplates(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerTemplatesResponse(rsp)
}

// CreateServerTemplateWithBodyWithResponse request with arbitrary body returning *CreateServerTemplateResponse
func (c *ClientWithResponses) CreateServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error) {
	rsp, err := c.CreateServerTemplateWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateServerTemplateWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error) {
	rsp, err := c.CreateServerTemplate(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerTemplateResponse(rsp)
}

// DeleteServerTemplateWithResponse request returning *DeleteServerTemplateResponse
func (c *ClientWithResponses) DeleteServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*DeleteServerTemplateResponse, error) {
	rsp, err := c.DeleteServerTemplate(ctx, parentName, prefix, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerTemplateResponse(rsp)
}

// GetServerTemplateWithResponse request returning *GetServerTemplateResponse
func (c *ClientWithResponses) GetServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*GetServerTemplateResponse, error) {
	rsp, err := c.GetServerTemplate(ctx, parentName, prefix, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerTemplateResponse(rsp)
}

// ReplaceServerTemplateWithBodyWithResponse request with arbitrary body returning *ReplaceServerTemplateResponse
func (c *ClientWithResponses) ReplaceServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error) {
	rsp, err := c.ReplaceServerTemplateWithBody(ctx, parentName, prefix, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerTemplateResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error) {
	rsp, err := c.ReplaceServerTemplate(ctx, parentName, prefix, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerTemplateResponse(rsp)
}

// GetAllServerBackendWithResponse request returning *GetAllServerBackendResponse
func (c *ClientWithResponses) GetAllServerBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*GetAllServerBackendResponse, error) {
	rsp, err := c.GetAllServerBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerBackendResponse(rsp)
}

// CreateServerBackendWithBodyWithResponse request with arbitrary body returning *CreateServerBackendResponse
func (c *ClientWithResponses) CreateServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error) {
	rsp, err := c.CreateServerBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateServerBackendWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error) {
	rsp, err := c.CreateServerBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerBackendResponse(rsp)
}

// DeleteServerBackendWithResponse request returning *DeleteServerBackendResponse
func (c *ClientWithResponses) DeleteServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*DeleteServerBackendResponse, error) {
	rsp, err := c.DeleteServerBackend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerBackendResponse(rsp)
}

// GetServerBackendWithResponse request returning *GetServerBackendResponse
func (c *ClientWithResponses) GetServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*GetServerBackendResponse, error) {
	rsp, err := c.GetServerBackend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerBackendResponse(rsp)
}

// ReplaceServerBackendWithBodyWithResponse request with arbitrary body returning *ReplaceServerBackendResponse
func (c *ClientWithResponses) ReplaceServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error) {
	rsp, err := c.ReplaceServerBackendWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error) {
	rsp, err := c.ReplaceServerBackend(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerBackendResponse(rsp)
}

// GetStickRulesWithResponse request returning *GetStickRulesResponse
func (c *ClientWithResponses) GetStickRulesWithResponse(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*GetStickRulesResponse, error) {
	rsp, err := c.GetStickRules(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickRulesResponse(rsp)
}

// ReplaceStickRulesWithBodyWithResponse request with arbitrary body returning *ReplaceStickRulesResponse
func (c *ClientWithResponses) ReplaceStickRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error) {
	rsp, err := c.ReplaceStickRulesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStickRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error) {
	rsp, err := c.ReplaceStickRules(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRulesResponse(rsp)
}

// DeleteStickRuleWithResponse request returning *DeleteStickRuleResponse
func (c *ClientWithResponses) DeleteStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*DeleteStickRuleResponse, error) {
	rsp, err := c.DeleteStickRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStickRuleResponse(rsp)
}

// GetStickRuleWithResponse request returning *GetStickRuleResponse
func (c *ClientWithResponses) GetStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*GetStickRuleResponse, error) {
	rsp, err := c.GetStickRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickRuleResponse(rsp)
}

// CreateStickRuleWithBodyWithResponse request with arbitrary body returning *CreateStickRuleResponse
func (c *ClientWithResponses) CreateStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error) {
	rsp, err := c.CreateStickRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStickRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error) {
	rsp, err := c.CreateStickRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStickRuleResponse(rsp)
}

// ReplaceStickRuleWithBodyWithResponse request with arbitrary body returning *ReplaceStickRuleResponse
func (c *ClientWithResponses) ReplaceStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error) {
	rsp, err := c.ReplaceStickRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error) {
	rsp, err := c.ReplaceStickRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRuleResponse(rsp)
}

// GetAllTCPCheckBackendWithResponse request returning *GetAllTCPCheckBackendResponse
func (c *ClientWithResponses) GetAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckBackendResponse, error) {
	rsp, err := c.GetAllTCPCheckBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPCheckBackendResponse(rsp)
}

// ReplaceAllTCPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPCheckBackendResponse
func (c *ClientWithResponses) ReplaceAllTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckBackendResponse(rsp)
}

// DeleteTCPCheckBackendWithResponse request returning *DeleteTCPCheckBackendResponse
func (c *ClientWithResponses) DeleteTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckBackendResponse, error) {
	rsp, err := c.DeleteTCPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPCheckBackendResponse(rsp)
}

// GetTCPCheckBackendWithResponse request returning *GetTCPCheckBackendResponse
func (c *ClientWithResponses) GetTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetTCPCheckBackendResponse, error) {
	rsp, err := c.GetTCPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPCheckBackendResponse(rsp)
}

// CreateTCPCheckBackendWithBodyWithResponse request with arbitrary body returning *CreateTCPCheckBackendResponse
func (c *ClientWithResponses) CreateTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error) {
	rsp, err := c.CreateTCPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error) {
	rsp, err := c.CreateTCPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckBackendResponse(rsp)
}

// ReplaceTCPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPCheckBackendResponse
func (c *ClientWithResponses) ReplaceTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceTCPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceTCPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckBackendResponse(rsp)
}

// GetAllTCPRequestRuleBackendWithResponse request returning *GetAllTCPRequestRuleBackendResponse
func (c *ClientWithResponses) GetAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleBackendResponse, error) {
	rsp, err := c.GetAllTCPRequestRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPRequestRuleBackendResponse(rsp)
}

// ReplaceAllTCPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleBackendResponse(rsp)
}

// DeleteTCPRequestRuleBackendWithResponse request returning *DeleteTCPRequestRuleBackendResponse
func (c *ClientWithResponses) DeleteTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleBackendResponse, error) {
	rsp, err := c.DeleteTCPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPRequestRuleBackendResponse(rsp)
}

// GetTCPRequestRuleBackendWithResponse request returning *GetTCPRequestRuleBackendResponse
func (c *ClientWithResponses) GetTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleBackendResponse, error) {
	rsp, err := c.GetTCPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPRequestRuleBackendResponse(rsp)
}

// CreateTCPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateTCPRequestRuleBackendResponse
func (c *ClientWithResponses) CreateTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleBackendResponse(rsp)
}

// ReplaceTCPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleBackendResponse(rsp)
}

// GetAllTCPResponseRuleBackendWithResponse request returning *GetAllTCPResponseRuleBackendResponse
func (c *ClientWithResponses) GetAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPResponseRuleBackendResponse, error) {
	rsp, err := c.GetAllTCPResponseRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPResponseRuleBackendResponse(rsp)
}

// ReplaceAllTCPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPResponseRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPResponseRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPResponseRuleBackendResponse(rsp)
}

// DeleteTCPResponseRuleBackendWithResponse request returning *DeleteTCPResponseRuleBackendResponse
func (c *ClientWithResponses) DeleteTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPResponseRuleBackendResponse, error) {
	rsp, err := c.DeleteTCPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPResponseRuleBackendResponse(rsp)
}

// GetTCPResponseRuleBackendWithResponse request returning *GetTCPResponseRuleBackendResponse
func (c *ClientWithResponses) GetTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPResponseRuleBackendResponse, error) {
	rsp, err := c.GetTCPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPResponseRuleBackendResponse(rsp)
}

// CreateTCPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateTCPResponseRuleBackendResponse
func (c *ClientWithResponses) CreateTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateTCPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateTCPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPResponseRuleBackendResponse(rsp)
}

// ReplaceTCPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPResponseRuleBackendResponse(rsp)
}

// GetCachesWithResponse request returning *GetCachesResponse
func (c *ClientWithResponses) GetCachesWithResponse(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*GetCachesResponse, error) {
	rsp, err := c.GetCaches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCachesResponse(rsp)
}

// CreateCacheWithBodyWithResponse request with arbitrary body returning *CreateCacheResponse
func (c *ClientWithResponses) CreateCacheWithBodyWithResponse(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error) {
	rsp, err := c.CreateCacheWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCacheResponse(rsp)
}

func (c *ClientWithResponses) CreateCacheWithResponse(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error) {
	rsp, err := c.CreateCache(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCacheResponse(rsp)
}

// DeleteCacheWithResponse request returning *DeleteCacheResponse
func (c *ClientWithResponses) DeleteCacheWithResponse(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*DeleteCacheResponse, error) {
	rsp, err := c.DeleteCache(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCacheResponse(rsp)
}

// GetCacheWithResponse request returning *GetCacheResponse
func (c *ClientWithResponses) GetCacheWithResponse(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*GetCacheResponse, error) {
	rsp, err := c.GetCache(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCacheResponse(rsp)
}

// ReplaceCacheWithBodyWithResponse request with arbitrary body returning *ReplaceCacheResponse
func (c *ClientWithResponses) ReplaceCacheWithBodyWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error) {
	rsp, err := c.ReplaceCacheWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCacheResponse(rsp)
}

func (c *ClientWithResponses) ReplaceCacheWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error) {
	rsp, err := c.ReplaceCache(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCacheResponse(rsp)
}

// GetCrtLoadsWithResponse request returning *GetCrtLoadsResponse
func (c *ClientWithResponses) GetCrtLoadsWithResponse(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*GetCrtLoadsResponse, error) {
	rsp, err := c.GetCrtLoads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtLoadsResponse(rsp)
}

// CreateCrtLoadWithBodyWithResponse request with arbitrary body returning *CreateCrtLoadResponse
func (c *ClientWithResponses) CreateCrtLoadWithBodyWithResponse(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error) {
	rsp, err := c.CreateCrtLoadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtLoadResponse(rsp)
}

func (c *ClientWithResponses) CreateCrtLoadWithResponse(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error) {
	rsp, err := c.CreateCrtLoad(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtLoadResponse(rsp)
}

// DeleteCrtLoadWithResponse request returning *DeleteCrtLoadResponse
func (c *ClientWithResponses) DeleteCrtLoadWithResponse(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*DeleteCrtLoadResponse, error) {
	rsp, err := c.DeleteCrtLoad(ctx, certificate, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCrtLoadResponse(rsp)
}

// GetCrtLoadWithResponse request returning *GetCrtLoadResponse
func (c *ClientWithResponses) GetCrtLoadWithResponse(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*GetCrtLoadResponse, error) {
	rsp, err := c.GetCrtLoad(ctx, certificate, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtLoadResponse(rsp)
}

// ReplaceCrtLoadWithBodyWithResponse request with arbitrary body returning *ReplaceCrtLoadResponse
func (c *ClientWithResponses) ReplaceCrtLoadWithBodyWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error) {
	rsp, err := c.ReplaceCrtLoadWithBody(ctx, certificate, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCrtLoadResponse(rsp)
}

func (c *ClientWithResponses) ReplaceCrtLoadWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error) {
	rsp, err := c.ReplaceCrtLoad(ctx, certificate, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCrtLoadResponse(rsp)
}

// GetCrtStoresWithResponse request returning *GetCrtStoresResponse
func (c *ClientWithResponses) GetCrtStoresWithResponse(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*GetCrtStoresResponse, error) {
	rsp, err := c.GetCrtStores(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtStoresResponse(rsp)
}

// CreateCrtStoreWithBodyWithResponse request with arbitrary body returning *CreateCrtStoreResponse
func (c *ClientWithResponses) CreateCrtStoreWithBodyWithResponse(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error) {
	rsp, err := c.CreateCrtStoreWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtStoreResponse(rsp)
}

func (c *ClientWithResponses) CreateCrtStoreWithResponse(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error) {
	rsp, err := c.CreateCrtStore(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtStoreResponse(rsp)
}

// DeleteCrtStoreWithResponse request returning *DeleteCrtStoreResponse
func (c *ClientWithResponses) DeleteCrtStoreWithResponse(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*DeleteCrtStoreResponse, error) {
	rsp, err := c.DeleteCrtStore(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCrtStoreResponse(rsp)
}

// GetCrtStoreWithResponse request returning *GetCrtStoreResponse
func (c *ClientWithResponses) GetCrtStoreWithResponse(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*GetCrtStoreResponse, error) {
	rsp, err := c.GetCrtStore(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtStoreResponse(rsp)
}

// EditCrtStoreWithBodyWithResponse request with arbitrary body returning *EditCrtStoreResponse
func (c *ClientWithResponses) EditCrtStoreWithBodyWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error) {
	rsp, err := c.EditCrtStoreWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCrtStoreResponse(rsp)
}

func (c *ClientWithResponses) EditCrtStoreWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error) {
	rsp, err := c.EditCrtStore(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCrtStoreResponse(rsp)
}

// GetDefaultsSectionsWithResponse request returning *GetDefaultsSectionsResponse
func (c *ClientWithResponses) GetDefaultsSectionsWithResponse(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionsResponse, error) {
	rsp, err := c.GetDefaultsSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultsSectionsResponse(rsp)
}

// AddDefaultsSectionWithBodyWithResponse request with arbitrary body returning *AddDefaultsSectionResponse
func (c *ClientWithResponses) AddDefaultsSectionWithBodyWithResponse(ctx context.Context, params *AddDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddDefaultsSectionResponse, error) {
	rsp, err := c.AddDefaultsSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDefaultsSectionResponse(rsp)
}

func (c *ClientWithResponses) AddDefaultsSectionWithResponse(ctx context.Context, params *AddDefaultsSectionParams, body AddDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddDefaultsSectionResponse, error) {
	rsp, err := c.AddDefaultsSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddDefaultsSectionResponse(rsp)
}

// CreateDefaultsSectionWithBodyWithResponse request with arbitrary body returning *CreateDefaultsSectionResponse
func (c *ClientWithResponses) CreateDefaultsSectionWithBodyWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error) {
	rsp, err := c.CreateDefaultsSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDefaultsSectionResponse(rsp)
}

func (c *ClientWithResponses) CreateDefaultsSectionWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error) {
	rsp, err := c.CreateDefaultsSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDefaultsSectionResponse(rsp)
}

// DeleteDefaultsSectionWithResponse request returning *DeleteDefaultsSectionResponse
func (c *ClientWithResponses) DeleteDefaultsSectionWithResponse(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*DeleteDefaultsSectionResponse, error) {
	rsp, err := c.DeleteDefaultsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDefaultsSectionResponse(rsp)
}

// GetDefaultsSectionWithResponse request returning *GetDefaultsSectionResponse
func (c *ClientWithResponses) GetDefaultsSectionWithResponse(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionResponse, error) {
	rsp, err := c.GetDefaultsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultsSectionResponse(rsp)
}

// ReplaceDefaultsSectionWithBodyWithResponse request with arbitrary body returning *ReplaceDefaultsSectionResponse
func (c *ClientWithResponses) ReplaceDefaultsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error) {
	rsp, err := c.ReplaceDefaultsSectionWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDefaultsSectionResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDefaultsSectionWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error) {
	rsp, err := c.ReplaceDefaultsSection(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDefaultsSectionResponse(rsp)
}

// GetAllAclDefaultsWithResponse request returning *GetAllAclDefaultsResponse
func (c *ClientWithResponses) GetAllAclDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllAclDefaultsResponse, error) {
	rsp, err := c.GetAllAclDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclDefaultsResponse(rsp)
}

// ReplaceAllAclDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclDefaultsResponse
func (c *ClientWithResponses) ReplaceAllAclDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclDefaultsResponse, error) {
	rsp, err := c.ReplaceAllAclDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclDefaultsParams, body ReplaceAllAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclDefaultsResponse, error) {
	rsp, err := c.ReplaceAllAclDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclDefaultsResponse(rsp)
}

// DeleteAclDefaultsWithResponse request returning *DeleteAclDefaultsResponse
func (c *ClientWithResponses) DeleteAclDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteAclDefaultsResponse, error) {
	rsp, err := c.DeleteAclDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclDefaultsResponse(rsp)
}

// GetAclDefaultsWithResponse request returning *GetAclDefaultsResponse
func (c *ClientWithResponses) GetAclDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclDefaultsParams, reqEditors ...RequestEditorFn) (*GetAclDefaultsResponse, error) {
	rsp, err := c.GetAclDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclDefaultsResponse(rsp)
}

// CreateAclDefaultsWithBodyWithResponse request with arbitrary body returning *CreateAclDefaultsResponse
func (c *ClientWithResponses) CreateAclDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclDefaultsResponse, error) {
	rsp, err := c.CreateAclDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateAclDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclDefaultsParams, body CreateAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclDefaultsResponse, error) {
	rsp, err := c.CreateAclDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclDefaultsResponse(rsp)
}

// ReplaceAclDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAclDefaultsResponse
func (c *ClientWithResponses) ReplaceAclDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclDefaultsResponse, error) {
	rsp, err := c.ReplaceAclDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclDefaultsParams, body ReplaceAclDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclDefaultsResponse, error) {
	rsp, err := c.ReplaceAclDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclDefaultsResponse(rsp)
}

// GetAllHTTPAfterResponseRuleDefaultsWithResponse request returning *GetAllHTTPAfterResponseRuleDefaultsResponse
func (c *ClientWithResponses) GetAllHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleDefaultsResponse, error) {
	rsp, err := c.GetAllHTTPAfterResponseRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPAfterResponseRuleDefaultsResponse(rsp)
}

// ReplaceAllHTTPAfterResponseRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPAfterResponseRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleDefaultsParams, body ReplaceAllHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleDefaultsResponse(rsp)
}

// DeleteHTTPAfterResponseRuleDefaultsWithResponse request returning *DeleteHTTPAfterResponseRuleDefaultsResponse
func (c *ClientWithResponses) DeleteHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleDefaultsResponse, error) {
	rsp, err := c.DeleteHTTPAfterResponseRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPAfterResponseRuleDefaultsResponse(rsp)
}

// GetHTTPAfterResponseRuleDefaultsWithResponse request returning *GetHTTPAfterResponseRuleDefaultsResponse
func (c *ClientWithResponses) GetHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleDefaultsResponse, error) {
	rsp, err := c.GetHTTPAfterResponseRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPAfterResponseRuleDefaultsResponse(rsp)
}

// CreateHTTPAfterResponseRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateHTTPAfterResponseRuleDefaultsResponse
func (c *ClientWithResponses) CreateHTTPAfterResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleDefaultsParams, body CreateHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleDefaultsResponse(rsp)
}

// ReplaceHTTPAfterResponseRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPAfterResponseRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleDefaultsParams, body ReplaceHTTPAfterResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleDefaultsResponse(rsp)
}

// GetAllHTTPCheckDefaultsWithResponse request returning *GetAllHTTPCheckDefaultsResponse
func (c *ClientWithResponses) GetAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckDefaultsResponse, error) {
	rsp, err := c.GetAllHTTPCheckDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPCheckDefaultsResponse(rsp)
}

// ReplaceAllHTTPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceAllHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckDefaultsResponse(rsp)
}

// DeleteHTTPCheckDefaultsWithResponse request returning *DeleteHTTPCheckDefaultsResponse
func (c *ClientWithResponses) DeleteHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckDefaultsResponse, error) {
	rsp, err := c.DeleteHTTPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPCheckDefaultsResponse(rsp)
}

// GetHTTPCheckDefaultsWithResponse request returning *GetHTTPCheckDefaultsResponse
func (c *ClientWithResponses) GetHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckDefaultsResponse, error) {
	rsp, err := c.GetHTTPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPCheckDefaultsResponse(rsp)
}

// CreateHTTPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *CreateHTTPCheckDefaultsResponse
func (c *ClientWithResponses) CreateHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error) {
	rsp, err := c.CreateHTTPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error) {
	rsp, err := c.CreateHTTPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckDefaultsResponse(rsp)
}

// ReplaceHTTPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckDefaultsResponse(rsp)
}

// GetAllHTTPErrorRuleDefaultsWithResponse request returning *GetAllHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) GetAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.GetAllHTTPErrorRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPErrorRuleDefaultsResponse(rsp)
}

// ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleDefaultsResponse(rsp)
}

// DeleteHTTPErrorRuleDefaultsWithResponse request returning *DeleteHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) DeleteHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.DeleteHTTPErrorRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorRuleDefaultsResponse(rsp)
}

// GetHTTPErrorRuleDefaultsWithResponse request returning *GetHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) GetHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.GetHTTPErrorRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorRuleDefaultsResponse(rsp)
}

// CreateHTTPErrorRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) CreateHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleDefaultsResponse(rsp)
}

// ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleDefaultsResponse(rsp)
}

// GetAllHTTPRequestRuleDefaultsWithResponse request returning *GetAllHTTPRequestRuleDefaultsResponse
func (c *ClientWithResponses) GetAllHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleDefaultsResponse, error) {
	rsp, err := c.GetAllHTTPRequestRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPRequestRuleDefaultsResponse(rsp)
}

// ReplaceAllHTTPRequestRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPRequestRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleDefaultsParams, body ReplaceAllHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleDefaultsResponse(rsp)
}

// DeleteHTTPRequestRuleDefaultsWithResponse request returning *DeleteHTTPRequestRuleDefaultsResponse
func (c *ClientWithResponses) DeleteHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleDefaultsResponse, error) {
	rsp, err := c.DeleteHTTPRequestRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPRequestRuleDefaultsResponse(rsp)
}

// GetHTTPRequestRuleDefaultsWithResponse request returning *GetHTTPRequestRuleDefaultsResponse
func (c *ClientWithResponses) GetHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleDefaultsResponse, error) {
	rsp, err := c.GetHTTPRequestRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPRequestRuleDefaultsResponse(rsp)
}

// CreateHTTPRequestRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateHTTPRequestRuleDefaultsResponse
func (c *ClientWithResponses) CreateHTTPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleDefaultsParams, body CreateHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleDefaultsResponse(rsp)
}

// ReplaceHTTPRequestRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPRequestRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceHTTPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleDefaultsParams, body ReplaceHTTPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleDefaultsResponse(rsp)
}

// GetAllHTTPResponseRuleDefaultsWithResponse request returning *GetAllHTTPResponseRuleDefaultsResponse
func (c *ClientWithResponses) GetAllHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleDefaultsResponse, error) {
	rsp, err := c.GetAllHTTPResponseRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPResponseRuleDefaultsResponse(rsp)
}

// ReplaceAllHTTPResponseRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPResponseRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleDefaultsParams, body ReplaceAllHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleDefaultsResponse(rsp)
}

// DeleteHTTPResponseRuleDefaultsWithResponse request returning *DeleteHTTPResponseRuleDefaultsResponse
func (c *ClientWithResponses) DeleteHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleDefaultsResponse, error) {
	rsp, err := c.DeleteHTTPResponseRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPResponseRuleDefaultsResponse(rsp)
}

// GetHTTPResponseRuleDefaultsWithResponse request returning *GetHTTPResponseRuleDefaultsResponse
func (c *ClientWithResponses) GetHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleDefaultsResponse, error) {
	rsp, err := c.GetHTTPResponseRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPResponseRuleDefaultsResponse(rsp)
}

// CreateHTTPResponseRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateHTTPResponseRuleDefaultsResponse
func (c *ClientWithResponses) CreateHTTPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleDefaultsParams, body CreateHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleDefaultsResponse(rsp)
}

// ReplaceHTTPResponseRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPResponseRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceHTTPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleDefaultsParams, body ReplaceHTTPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleDefaultsResponse(rsp)
}

// GetAllLogTargetDefaultsWithResponse request returning *GetAllLogTargetDefaultsResponse
func (c *ClientWithResponses) GetAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetDefaultsResponse, error) {
	rsp, err := c.GetAllLogTargetDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetDefaultsResponse(rsp)
}

// ReplaceAllLogTargetDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetDefaultsResponse
func (c *ClientWithResponses) ReplaceAllLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceAllLogTargetDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceAllLogTargetDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetDefaultsResponse(rsp)
}

// DeleteLogTargetDefaultsWithResponse request returning *DeleteLogTargetDefaultsResponse
func (c *ClientWithResponses) DeleteLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetDefaultsResponse, error) {
	rsp, err := c.DeleteLogTargetDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetDefaultsResponse(rsp)
}

// GetLogTargetDefaultsWithResponse request returning *GetLogTargetDefaultsResponse
func (c *ClientWithResponses) GetLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetLogTargetDefaultsResponse, error) {
	rsp, err := c.GetLogTargetDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetDefaultsResponse(rsp)
}

// CreateLogTargetDefaultsWithBodyWithResponse request with arbitrary body returning *CreateLogTargetDefaultsResponse
func (c *ClientWithResponses) CreateLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error) {
	rsp, err := c.CreateLogTargetDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error) {
	rsp, err := c.CreateLogTargetDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetDefaultsResponse(rsp)
}

// ReplaceLogTargetDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetDefaultsResponse
func (c *ClientWithResponses) ReplaceLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceLogTargetDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceLogTargetDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetDefaultsResponse(rsp)
}

// GetAllQUICInitialRuleDefaultsWithResponse request returning *GetAllQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) GetAllQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.GetAllQUICInitialRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllQUICInitialRuleDefaultsResponse(rsp)
}

// ReplaceAllQUICInitialRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllQUICInitialRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllQUICInitialRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleDefaultsParams, body ReplaceAllQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllQUICInitialRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllQUICInitialRuleDefaultsResponse(rsp)
}

// DeleteQUICInitialRuleDefaultsWithResponse request returning *DeleteQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) DeleteQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.DeleteQUICInitialRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQUICInitialRuleDefaultsResponse(rsp)
}

// GetQUICInitialRuleDefaultsWithResponse request returning *GetQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) GetQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.GetQUICInitialRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQUICInitialRuleDefaultsResponse(rsp)
}

// CreateQUICInitialRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) CreateQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.CreateQUICInitialRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQUICInitialRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleDefaultsParams, body CreateQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.CreateQUICInitialRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQUICInitialRuleDefaultsResponse(rsp)
}

// ReplaceQUICInitialRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceQUICInitialRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceQUICInitialRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceQUICInitialRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceQUICInitialRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceQUICInitialRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleDefaultsParams, body ReplaceQUICInitialRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceQUICInitialRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceQUICInitialRuleDefaultsResponse(rsp)
}

// GetAllTCPCheckDefaultsWithResponse request returning *GetAllTCPCheckDefaultsResponse
func (c *ClientWithResponses) GetAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckDefaultsResponse, error) {
	rsp, err := c.GetAllTCPCheckDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPCheckDefaultsResponse(rsp)
}

// ReplaceAllTCPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceAllTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckDefaultsResponse(rsp)
}

// DeleteTCPCheckDefaultsWithResponse request returning *DeleteTCPCheckDefaultsResponse
func (c *ClientWithResponses) DeleteTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckDefaultsResponse, error) {
	rsp, err := c.DeleteTCPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPCheckDefaultsResponse(rsp)
}

// GetTCPCheckDefaultsWithResponse request returning *GetTCPCheckDefaultsResponse
func (c *ClientWithResponses) GetTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPCheckDefaultsResponse, error) {
	rsp, err := c.GetTCPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPCheckDefaultsResponse(rsp)
}

// CreateTCPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *CreateTCPCheckDefaultsResponse
func (c *ClientWithResponses) CreateTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error) {
	rsp, err := c.CreateTCPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error) {
	rsp, err := c.CreateTCPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckDefaultsResponse(rsp)
}

// ReplaceTCPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceTCPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckDefaultsResponse(rsp)
}

// GetAllTCPRequestRuleDefaultsWithResponse request returning *GetAllTCPRequestRuleDefaultsResponse
func (c *ClientWithResponses) GetAllTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleDefaultsResponse, error) {
	rsp, err := c.GetAllTCPRequestRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPRequestRuleDefaultsResponse(rsp)
}

// ReplaceAllTCPRequestRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPRequestRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllTCPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleDefaultsParams, body ReplaceAllTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleDefaultsResponse(rsp)
}

// DeleteTCPRequestRuleDefaultsWithResponse request returning *DeleteTCPRequestRuleDefaultsResponse
func (c *ClientWithResponses) DeleteTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleDefaultsResponse, error) {
	rsp, err := c.DeleteTCPRequestRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPRequestRuleDefaultsResponse(rsp)
}

// GetTCPRequestRuleDefaultsWithResponse request returning *GetTCPRequestRuleDefaultsResponse
func (c *ClientWithResponses) GetTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleDefaultsResponse, error) {
	rsp, err := c.GetTCPRequestRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPRequestRuleDefaultsResponse(rsp)
}

// CreateTCPRequestRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateTCPRequestRuleDefaultsResponse
func (c *ClientWithResponses) CreateTCPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleDefaultsResponse, error) {
	rsp, err := c.CreateTCPRequestRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleDefaultsParams, body CreateTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleDefaultsResponse, error) {
	rsp, err := c.CreateTCPRequestRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleDefaultsResponse(rsp)
}

// ReplaceTCPRequestRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceTCPRequestRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceTCPRequestRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPRequestRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleDefaultsParams, body ReplaceTCPRequestRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleDefaultsResponse(rsp)
}

// GetAllTCPResponseRuleDefaultsWithResponse request returning *GetAllTCPResponseRuleDefaultsResponse
func (c *ClientWithResponses) GetAllTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPResponseRuleDefaultsResponse, error) {
	rsp, err := c.GetAllTCPResponseRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPResponseRuleDefaultsResponse(rsp)
}

// ReplaceAllTCPResponseRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPResponseRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllTCPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPResponseRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPResponseRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleDefaultsParams, body ReplaceAllTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPResponseRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPResponseRuleDefaultsResponse(rsp)
}

// DeleteTCPResponseRuleDefaultsWithResponse request returning *DeleteTCPResponseRuleDefaultsResponse
func (c *ClientWithResponses) DeleteTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPResponseRuleDefaultsResponse, error) {
	rsp, err := c.DeleteTCPResponseRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPResponseRuleDefaultsResponse(rsp)
}

// GetTCPResponseRuleDefaultsWithResponse request returning *GetTCPResponseRuleDefaultsResponse
func (c *ClientWithResponses) GetTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPResponseRuleDefaultsResponse, error) {
	rsp, err := c.GetTCPResponseRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPResponseRuleDefaultsResponse(rsp)
}

// CreateTCPResponseRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateTCPResponseRuleDefaultsResponse
func (c *ClientWithResponses) CreateTCPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleDefaultsResponse, error) {
	rsp, err := c.CreateTCPResponseRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPResponseRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleDefaultsParams, body CreateTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleDefaultsResponse, error) {
	rsp, err := c.CreateTCPResponseRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPResponseRuleDefaultsResponse(rsp)
}

// ReplaceTCPResponseRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceTCPResponseRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceTCPResponseRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPResponseRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPResponseRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPResponseRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleDefaultsParams, body ReplaceTCPResponseRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPResponseRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPResponseRuleDefaultsResponse(rsp)
}

// GetFCGIAppsWithResponse request returning *GetFCGIAppsResponse
func (c *ClientWithResponses) GetFCGIAppsWithResponse(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*GetFCGIAppsResponse, error) {
	rsp, err := c.GetFCGIApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFCGIAppsResponse(rsp)
}

// CreateFCGIAppWithBodyWithResponse request with arbitrary body returning *CreateFCGIAppResponse
func (c *ClientWithResponses) CreateFCGIAppWithBodyWithResponse(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error) {
	rsp, err := c.CreateFCGIAppWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) CreateFCGIAppWithResponse(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error) {
	rsp, err := c.CreateFCGIApp(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFCGIAppResponse(rsp)
}

// DeleteFCGIAppWithResponse request returning *DeleteFCGIAppResponse
func (c *ClientWithResponses) DeleteFCGIAppWithResponse(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteFCGIAppResponse, error) {
	rsp, err := c.DeleteFCGIApp(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFCGIAppResponse(rsp)
}

// GetFCGIAppWithResponse request returning *GetFCGIAppResponse
func (c *ClientWithResponses) GetFCGIAppWithResponse(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*GetFCGIAppResponse, error) {
	rsp, err := c.GetFCGIApp(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFCGIAppResponse(rsp)
}

// ReplaceFCGIAppWithBodyWithResponse request with arbitrary body returning *ReplaceFCGIAppResponse
func (c *ClientWithResponses) ReplaceFCGIAppWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error) {
	rsp, err := c.ReplaceFCGIAppWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFCGIAppWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error) {
	rsp, err := c.ReplaceFCGIApp(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFCGIAppResponse(rsp)
}

// GetAllAclFCGIAppWithResponse request returning *GetAllAclFCGIAppResponse
func (c *ClientWithResponses) GetAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAllAclFCGIAppResponse, error) {
	rsp, err := c.GetAllAclFCGIApp(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclFCGIAppResponse(rsp)
}

// ReplaceAllAclFCGIAppWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclFCGIAppResponse
func (c *ClientWithResponses) ReplaceAllAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAllAclFCGIAppWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAllAclFCGIApp(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFCGIAppResponse(rsp)
}

// DeleteAclFCGIAppWithResponse request returning *DeleteAclFCGIAppResponse
func (c *ClientWithResponses) DeleteAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteAclFCGIAppResponse, error) {
	rsp, err := c.DeleteAclFCGIApp(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclFCGIAppResponse(rsp)
}

// GetAclFCGIAppWithResponse request returning *GetAclFCGIAppResponse
func (c *ClientWithResponses) GetAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAclFCGIAppResponse, error) {
	rsp, err := c.GetAclFCGIApp(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclFCGIAppResponse(rsp)
}

// CreateAclFCGIAppWithBodyWithResponse request with arbitrary body returning *CreateAclFCGIAppResponse
func (c *ClientWithResponses) CreateAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error) {
	rsp, err := c.CreateAclFCGIAppWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) CreateAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error) {
	rsp, err := c.CreateAclFCGIApp(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFCGIAppResponse(rsp)
}

// ReplaceAclFCGIAppWithBodyWithResponse request with arbitrary body returning *ReplaceAclFCGIAppResponse
func (c *ClientWithResponses) ReplaceAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAclFCGIAppWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAclFCGIApp(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFCGIAppResponse(rsp)
}

// GetFrontendsWithResponse request returning *GetFrontendsResponse
func (c *ClientWithResponses) GetFrontendsWithResponse(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*GetFrontendsResponse, error) {
	rsp, err := c.GetFrontends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFrontendsResponse(rsp)
}

// CreateFrontendWithBodyWithResponse request with arbitrary body returning *CreateFrontendResponse
func (c *ClientWithResponses) CreateFrontendWithBodyWithResponse(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error) {
	rsp, err := c.CreateFrontendWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateFrontendWithResponse(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error) {
	rsp, err := c.CreateFrontend(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFrontendResponse(rsp)
}

// DeleteFrontendWithResponse request returning *DeleteFrontendResponse
func (c *ClientWithResponses) DeleteFrontendWithResponse(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFrontendResponse, error) {
	rsp, err := c.DeleteFrontend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFrontendResponse(rsp)
}

// GetFrontendWithResponse request returning *GetFrontendResponse
func (c *ClientWithResponses) GetFrontendWithResponse(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*GetFrontendResponse, error) {
	rsp, err := c.GetFrontend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFrontendResponse(rsp)
}

// ReplaceFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceFrontendResponse
func (c *ClientWithResponses) ReplaceFrontendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error) {
	rsp, err := c.ReplaceFrontendWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFrontendWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error) {
	rsp, err := c.ReplaceFrontend(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFrontendResponse(rsp)
}

// GetAllAclFrontendWithResponse request returning *GetAllAclFrontendResponse
func (c *ClientWithResponses) GetAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAllAclFrontendResponse, error) {
	rsp, err := c.GetAllAclFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclFrontendResponse(rsp)
}

// ReplaceAllAclFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclFrontendResponse
func (c *ClientWithResponses) ReplaceAllAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error) {
	rsp, err := c.ReplaceAllAclFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error) {
	rsp, err := c.ReplaceAllAclFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFrontendResponse(rsp)
}

// DeleteAclFrontendWithResponse request returning *DeleteAclFrontendResponse
func (c *ClientWithResponses) DeleteAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*DeleteAclFrontendResponse, error) {
	rsp, err := c.DeleteAclFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclFrontendResponse(rsp)
}

// GetAclFrontendWithResponse request returning *GetAclFrontendResponse
func (c *ClientWithResponses) GetAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAclFrontendResponse, error) {
	rsp, err := c.GetAclFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclFrontendResponse(rsp)
}

// CreateAclFrontendWithBodyWithResponse request with arbitrary body returning *CreateAclFrontendResponse
func (c *ClientWithResponses) CreateAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error) {
	rsp, err := c.CreateAclFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error) {
	rsp, err := c.CreateAclFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFrontendResponse(rsp)
}

// ReplaceAclFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAclFrontendResponse
func (c *ClientWithResponses) ReplaceAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error) {
	rsp, err := c.ReplaceAclFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error) {
	rsp, err := c.ReplaceAclFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFrontendResponse(rsp)
}

// GetBackendSwitchingRulesWithResponse request returning *GetBackendSwitchingRulesResponse
func (c *ClientWithResponses) GetBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRulesResponse, error) {
	rsp, err := c.GetBackendSwitchingRules(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendSwitchingRulesResponse(rsp)
}

// ReplaceBackendSwitchingRulesWithBodyWithResponse request with arbitrary body returning *ReplaceBackendSwitchingRulesResponse
func (c *ClientWithResponses) ReplaceBackendSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRulesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRules(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRulesResponse(rsp)
}

// DeleteBackendSwitchingRuleWithResponse request returning *DeleteBackendSwitchingRuleResponse
func (c *ClientWithResponses) DeleteBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteBackendSwitchingRuleResponse, error) {
	rsp, err := c.DeleteBackendSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackendSwitchingRuleResponse(rsp)
}

// GetBackendSwitchingRuleWithResponse request returning *GetBackendSwitchingRuleResponse
func (c *ClientWithResponses) GetBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRuleResponse, error) {
	rsp, err := c.GetBackendSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendSwitchingRuleResponse(rsp)
}

// CreateBackendSwitchingRuleWithBodyWithResponse request with arbitrary body returning *CreateBackendSwitchingRuleResponse
func (c *ClientWithResponses) CreateBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error) {
	rsp, err := c.CreateBackendSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error) {
	rsp, err := c.CreateBackendSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendSwitchingRuleResponse(rsp)
}

// ReplaceBackendSwitchingRuleWithBodyWithResponse request with arbitrary body returning *ReplaceBackendSwitchingRuleResponse
func (c *ClientWithResponses) ReplaceBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRuleResponse(rsp)
}

// GetAllBindFrontendWithResponse request returning *GetAllBindFrontendResponse
func (c *ClientWithResponses) GetAllBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*GetAllBindFrontendResponse, error) {
	rsp, err := c.GetAllBindFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBindFrontendResponse(rsp)
}

// CreateBindFrontendWithBodyWithResponse request with arbitrary body returning *CreateBindFrontendResponse
func (c *ClientWithResponses) CreateBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error) {
	rsp, err := c.CreateBindFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error) {
	rsp, err := c.CreateBindFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindFrontendResponse(rsp)
}

// DeleteBindFrontendWithResponse request returning *DeleteBindFrontendResponse
func (c *ClientWithResponses) DeleteBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*DeleteBindFrontendResponse, error) {
	rsp, err := c.DeleteBindFrontend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBindFrontendResponse(rsp)
}

// GetBindFrontendWithResponse request returning *GetBindFrontendResponse
func (c *ClientWithResponses) GetBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*GetBindFrontendResponse, error) {
	rsp, err := c.GetBindFrontend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindFrontendResponse(rsp)
}

// ReplaceBindFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceBindFrontendResponse
func (c *ClientWithResponses) ReplaceBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error) {
	rsp, err := c.ReplaceBindFrontendWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error) {
	rsp, err := c.ReplaceBindFrontend(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindFrontendResponse(rsp)
}

// GetDeclareCapturesWithResponse request returning *GetDeclareCapturesResponse
func (c *ClientWithResponses) GetDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*GetDeclareCapturesResponse, error) {
	rsp, err := c.GetDeclareCaptures(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeclareCapturesResponse(rsp)
}

// ReplaceDeclareCapturesWithBodyWithResponse request with arbitrary body returning *ReplaceDeclareCapturesResponse
func (c *ClientWithResponses) ReplaceDeclareCapturesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error) {
	rsp, err := c.ReplaceDeclareCapturesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCapturesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error) {
	rsp, err := c.ReplaceDeclareCaptures(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCapturesResponse(rsp)
}

// DeleteDeclareCaptureWithResponse request returning *DeleteDeclareCaptureResponse
func (c *ClientWithResponses) DeleteDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*DeleteDeclareCaptureResponse, error) {
	rsp, err := c.DeleteDeclareCapture(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeclareCaptureResponse(rsp)
}

// GetDeclareCaptureWithResponse request returning *GetDeclareCaptureResponse
func (c *ClientWithResponses) GetDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*GetDeclareCaptureResponse, error) {
	rsp, err := c.GetDeclareCapture(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeclareCaptureResponse(rsp)
}

// CreateDeclareCaptureWithBodyWithResponse request with arbitrary body returning *CreateDeclareCaptureResponse
func (c *ClientWithResponses) CreateDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error) {
	rsp, err := c.CreateDeclareCaptureWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeclareCaptureResponse(rsp)
}

func (c *ClientWithResponses) CreateDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error) {
	rsp, err := c.CreateDeclareCapture(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeclareCaptureResponse(rsp)
}

// ReplaceDeclareCaptureWithBodyWithResponse request with arbitrary body returning *ReplaceDeclareCaptureResponse
func (c *ClientWithResponses) ReplaceDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error) {
	rsp, err := c.ReplaceDeclareCaptureWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCaptureResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error) {
	rsp, err := c.ReplaceDeclareCapture(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCaptureResponse(rsp)
}

// GetAllFilterFrontendWithResponse request returning *GetAllFilterFrontendResponse
func (c *ClientWithResponses) GetAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetAllFilterFrontendResponse, error) {
	rsp, err := c.GetAllFilterFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllFilterFrontendResponse(rsp)
}

// ReplaceAllFilterFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllFilterFrontendResponse
func (c *ClientWithResponses) ReplaceAllFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error) {
	rsp, err := c.ReplaceAllFilterFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error) {
	rsp, err := c.ReplaceAllFilterFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterFrontendResponse(rsp)
}

// DeleteFilterFrontendWithResponse request returning *DeleteFilterFrontendResponse
func (c *ClientWithResponses) DeleteFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFilterFrontendResponse, error) {
	rsp, err := c.DeleteFilterFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFilterFrontendResponse(rsp)
}

// GetFilterFrontendWithResponse request returning *GetFilterFrontendResponse
func (c *ClientWithResponses) GetFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetFilterFrontendResponse, error) {
	rsp, err := c.GetFilterFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterFrontendResponse(rsp)
}

// CreateFilterFrontendWithBodyWithResponse request with arbitrary body returning *CreateFilterFrontendResponse
func (c *ClientWithResponses) CreateFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error) {
	rsp, err := c.CreateFilterFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error) {
	rsp, err := c.CreateFilterFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterFrontendResponse(rsp)
}

// ReplaceFilterFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceFilterFrontendResponse
func (c *ClientWithResponses) ReplaceFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error) {
	rsp, err := c.ReplaceFilterFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error) {
	rsp, err := c.ReplaceFilterFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterFrontendResponse(rsp)
}

// GetAllHTTPAfterResponseRuleFrontendWithResponse request returning *GetAllHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPAfterResponseRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPAfterResponseRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleFrontendResponse(rsp)
}

// DeleteHTTPAfterResponseRuleFrontendWithResponse request returning *DeleteHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPAfterResponseRuleFrontendResponse(rsp)
}

// GetHTTPAfterResponseRuleFrontendWithResponse request returning *GetHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPAfterResponseRuleFrontendResponse(rsp)
}

// CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleFrontendResponse(rsp)
}

// ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleFrontendResponse(rsp)
}

// GetAllHTTPErrorRuleFrontendWithResponse request returning *GetAllHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPErrorRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPErrorRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleFrontendResponse(rsp)
}

// DeleteHTTPErrorRuleFrontendWithResponse request returning *DeleteHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPErrorRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorRuleFrontendResponse(rsp)
}

// GetHTTPErrorRuleFrontendWithResponse request returning *GetHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPErrorRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorRuleFrontendResponse(rsp)
}

// CreateHTTPErrorRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleFrontendResponse(rsp)
}

// ReplaceHTTPErrorRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleFrontendResponse(rsp)
}

// GetAllHTTPRequestRuleFrontendWithResponse request returning *GetAllHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPRequestRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPRequestRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleFrontendResponse(rsp)
}

// DeleteHTTPRequestRuleFrontendWithResponse request returning *DeleteHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPRequestRuleFrontendResponse(rsp)
}

// GetHTTPRequestRuleFrontendWithResponse request returning *GetHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPRequestRuleFrontendResponse(rsp)
}

// CreateHTTPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleFrontendResponse(rsp)
}

// ReplaceHTTPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleFrontendResponse(rsp)
}

// GetAllHTTPResponseRuleFrontendWithResponse request returning *GetAllHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPResponseRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPResponseRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleFrontendResponse(rsp)
}

// DeleteHTTPResponseRuleFrontendWithResponse request returning *DeleteHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPResponseRuleFrontendResponse(rsp)
}

// GetHTTPResponseRuleFrontendWithResponse request returning *GetHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPResponseRuleFrontendResponse(rsp)
}

// CreateHTTPResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleFrontendResponse(rsp)
}

// ReplaceHTTPResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleFrontendResponse(rsp)
}

// GetAllLogTargetFrontendWithResponse request returning *GetAllLogTargetFrontendResponse
func (c *ClientWithResponses) GetAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetFrontendResponse, error) {
	rsp, err := c.GetAllLogTargetFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetFrontendResponse(rsp)
}

// ReplaceAllLogTargetFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetFrontendResponse
func (c *ClientWithResponses) ReplaceAllLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetFrontendResponse(rsp)
}

// DeleteLogTargetFrontendWithResponse request returning *DeleteLogTargetFrontendResponse
func (c *ClientWithResponses) DeleteLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetFrontendResponse, error) {
	rsp, err := c.DeleteLogTargetFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetFrontendResponse(rsp)
}

// GetLogTargetFrontendWithResponse request returning *GetLogTargetFrontendResponse
func (c *ClientWithResponses) GetLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetLogTargetFrontendResponse, error) {
	rsp, err := c.GetLogTargetFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetFrontendResponse(rsp)
}

// CreateLogTargetFrontendWithBodyWithResponse request with arbitrary body returning *CreateLogTargetFrontendResponse
func (c *ClientWithResponses) CreateLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error) {
	rsp, err := c.CreateLogTargetFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error) {
	rsp, err := c.CreateLogTargetFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetFrontendResponse(rsp)
}

// ReplaceLogTargetFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetFrontendResponse
func (c *ClientWithResponses) ReplaceLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceLogTargetFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceLogTargetFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetFrontendResponse(rsp)
}

// GetAllQUICInitialRuleFrontendWithResponse request returning *GetAllQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) GetAllQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.GetAllQUICInitialRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllQUICInitialRuleFrontendResponse(rsp)
}

// ReplaceAllQUICInitialRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllQUICInitialRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllQUICInitialRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllQUICInitialRuleFrontendParams, body ReplaceAllQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllQUICInitialRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllQUICInitialRuleFrontendResponse(rsp)
}

// DeleteQUICInitialRuleFrontendWithResponse request returning *DeleteQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) DeleteQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.DeleteQUICInitialRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteQUICInitialRuleFrontendResponse(rsp)
}

// GetQUICInitialRuleFrontendWithResponse request returning *GetQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) GetQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetQUICInitialRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.GetQUICInitialRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetQUICInitialRuleFrontendResponse(rsp)
}

// CreateQUICInitialRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) CreateQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.CreateQUICInitialRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQUICInitialRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateQUICInitialRuleFrontendParams, body CreateQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.CreateQUICInitialRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateQUICInitialRuleFrontendResponse(rsp)
}

// ReplaceQUICInitialRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceQUICInitialRuleFrontendResponse
func (c *ClientWithResponses) ReplaceQUICInitialRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.ReplaceQUICInitialRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceQUICInitialRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceQUICInitialRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceQUICInitialRuleFrontendParams, body ReplaceQUICInitialRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceQUICInitialRuleFrontendResponse, error) {
	rsp, err := c.ReplaceQUICInitialRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceQUICInitialRuleFrontendResponse(rsp)
}

// GetAllSSLFrontUsesWithResponse request returning *GetAllSSLFrontUsesResponse
func (c *ClientWithResponses) GetAllSSLFrontUsesWithResponse(ctx context.Context, parentName ParentName, params *GetAllSSLFrontUsesParams, reqEditors ...RequestEditorFn) (*GetAllSSLFrontUsesResponse, error) {
	rsp, err := c.GetAllSSLFrontUses(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSSLFrontUsesResponse(rsp)
}

// CreateSSLFrontUseWithBodyWithResponse request with arbitrary body returning *CreateSSLFrontUseResponse
func (c *ClientWithResponses) CreateSSLFrontUseWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateSSLFrontUseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSSLFrontUseResponse, error) {
	rsp, err := c.CreateSSLFrontUseWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSSLFrontUseResponse(rsp)
}

func (c *ClientWithResponses) CreateSSLFrontUseWithResponse(ctx context.Context, parentName ParentName, params *CreateSSLFrontUseParams, body CreateSSLFrontUseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSSLFrontUseResponse, error) {
	rsp, err := c.CreateSSLFrontUse(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSSLFrontUseResponse(rsp)
}

// DeleteSSLFrontUseWithResponse request returning *DeleteSSLFrontUseResponse
func (c *ClientWithResponses) DeleteSSLFrontUseWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteSSLFrontUseParams, reqEditors ...RequestEditorFn) (*DeleteSSLFrontUseResponse, error) {
	rsp, err := c.DeleteSSLFrontUse(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSSLFrontUseResponse(rsp)
}

// GetSSLFrontUseWithResponse request returning *GetSSLFrontUseResponse
func (c *ClientWithResponses) GetSSLFrontUseWithResponse(ctx context.Context, parentName ParentName, index int, params *GetSSLFrontUseParams, reqEditors ...RequestEditorFn) (*GetSSLFrontUseResponse, error) {
	rsp, err := c.GetSSLFrontUse(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSSLFrontUseResponse(rsp)
}

// ReplaceSSLFrontUseWithBodyWithResponse request with arbitrary body returning *ReplaceSSLFrontUseResponse
func (c *ClientWithResponses) ReplaceSSLFrontUseWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSSLFrontUseResponse, error) {
	rsp, err := c.ReplaceSSLFrontUseWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSSLFrontUseResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSSLFrontUseWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceSSLFrontUseParams, body ReplaceSSLFrontUseJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSSLFrontUseResponse, error) {
	rsp, err := c.ReplaceSSLFrontUse(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSSLFrontUseResponse(rsp)
}

// GetAllTCPRequestRuleFrontendWithResponse request returning *GetAllTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetAllTCPRequestRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPRequestRuleFrontendResponse(rsp)
}

// ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleFrontendResponse(rsp)
}

// DeleteTCPRequestRuleFrontendWithResponse request returning *DeleteTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) DeleteTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.DeleteTCPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPRequestRuleFrontendResponse(rsp)
}

// GetTCPRequestRuleFrontendWithResponse request returning *GetTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetTCPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPRequestRuleFrontendResponse(rsp)
}

// CreateTCPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) CreateTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleFrontendResponse(rsp)
}

// ReplaceTCPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleFrontendResponse(rsp)
}

// GetGlobalWithResponse request returning *GetGlobalResponse
func (c *ClientWithResponses) GetGlobalWithResponse(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error) {
	rsp, err := c.GetGlobal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalResponse(rsp)
}

// ReplaceGlobalWithBodyWithResponse request with arbitrary body returning *ReplaceGlobalResponse
func (c *ClientWithResponses) ReplaceGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error) {
	rsp, err := c.ReplaceGlobalWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGlobalResponse(rsp)
}

func (c *ClientWithResponses) ReplaceGlobalWithResponse(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error) {
	rsp, err := c.ReplaceGlobal(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGlobalResponse(rsp)
}

// GetAllLogTargetGlobalWithResponse request returning *GetAllLogTargetGlobalResponse
func (c *ClientWithResponses) GetAllLogTargetGlobalWithResponse(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetGlobalResponse, error) {
	rsp, err := c.GetAllLogTargetGlobal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetGlobalResponse(rsp)
}

// ReplaceAllLogTargetGlobalWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetGlobalResponse
func (c *ClientWithResponses) ReplaceAllLogTargetGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceAllLogTargetGlobalWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetGlobalResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetGlobalWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceAllLogTargetGlobal(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetGlobalResponse(rsp)
}

// DeleteLogTargetGlobalWithResponse request returning *DeleteLogTargetGlobalResponse
func (c *ClientWithResponses) DeleteLogTargetGlobalWithResponse(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetGlobalResponse, error) {
	rsp, err := c.DeleteLogTargetGlobal(ctx, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetGlobalResponse(rsp)
}

// GetLogTargetGlobalWithResponse request returning *GetLogTargetGlobalResponse
func (c *ClientWithResponses) GetLogTargetGlobalWithResponse(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetLogTargetGlobalResponse, error) {
	rsp, err := c.GetLogTargetGlobal(ctx, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetGlobalResponse(rsp)
}

// CreateLogTargetGlobalWithBodyWithResponse request with arbitrary body returning *CreateLogTargetGlobalResponse
func (c *ClientWithResponses) CreateLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error) {
	rsp, err := c.CreateLogTargetGlobalWithBody(ctx, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetGlobalResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetGlobalWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error) {
	rsp, err := c.CreateLogTargetGlobal(ctx, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetGlobalResponse(rsp)
}

// ReplaceLogTargetGlobalWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetGlobalResponse
func (c *ClientWithResponses) ReplaceLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceLogTargetGlobalWithBody(ctx, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetGlobalResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetGlobalWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceLogTargetGlobal(ctx, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetGlobalResponse(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsResponse
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error) {
	rsp, err := c.GetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// ReplaceGroupWithBodyWithResponse request with arbitrary body returning *ReplaceGroupResponse
func (c *ClientWithResponses) ReplaceGroupWithBodyWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error) {
	rsp, err := c.ReplaceGroupWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGroupResponse(rsp)
}

func (c *ClientWithResponses) ReplaceGroupWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error) {
	rsp, err := c.ReplaceGroup(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGroupResponse(rsp)
}

// GetHTTPErrorsSectionsWithResponse request returning *GetHTTPErrorsSectionsResponse
func (c *ClientWithResponses) GetHTTPErrorsSectionsWithResponse(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionsResponse, error) {
	rsp, err := c.GetHTTPErrorsSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorsSectionsResponse(rsp)
}

// CreateHTTPErrorsSectionWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorsSectionResponse
func (c *ClientWithResponses) CreateHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error) {
	rsp, err := c.CreateHTTPErrorsSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorsSectionResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorsSectionWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error) {
	rsp, err := c.CreateHTTPErrorsSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorsSectionResponse(rsp)
}

// DeleteHTTPErrorsSectionWithResponse request returning *DeleteHTTPErrorsSectionResponse
func (c *ClientWithResponses) DeleteHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorsSectionResponse, error) {
	rsp, err := c.DeleteHTTPErrorsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorsSectionResponse(rsp)
}

// GetHTTPErrorsSectionWithResponse request returning *GetHTTPErrorsSectionResponse
func (c *ClientWithResponses) GetHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionResponse, error) {
	rsp, err := c.GetHTTPErrorsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorsSectionResponse(rsp)
}

// ReplaceHTTPErrorsSectionWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorsSectionResponse
func (c *ClientWithResponses) ReplaceHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error) {
	rsp, err := c.ReplaceHTTPErrorsSectionWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorsSectionResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error) {
	rsp, err := c.ReplaceHTTPErrorsSection(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorsSectionResponse(rsp)
}

// GetLogForwardsWithResponse request returning *GetLogForwardsResponse
func (c *ClientWithResponses) GetLogForwardsWithResponse(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*GetLogForwardsResponse, error) {
	rsp, err := c.GetLogForwards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogForwardsResponse(rsp)
}

// CreateLogForwardWithBodyWithResponse request with arbitrary body returning *CreateLogForwardResponse
func (c *ClientWithResponses) CreateLogForwardWithBodyWithResponse(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error) {
	rsp, err := c.CreateLogForwardWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateLogForwardWithResponse(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error) {
	rsp, err := c.CreateLogForward(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogForwardResponse(rsp)
}

// DeleteLogForwardWithResponse request returning *DeleteLogForwardResponse
func (c *ClientWithResponses) DeleteLogForwardWithResponse(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogForwardResponse, error) {
	rsp, err := c.DeleteLogForward(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogForwardResponse(rsp)
}

// GetLogForwardWithResponse request returning *GetLogForwardResponse
func (c *ClientWithResponses) GetLogForwardWithResponse(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogForwardResponse, error) {
	rsp, err := c.GetLogForward(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogForwardResponse(rsp)
}

// ReplaceLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceLogForwardResponse
func (c *ClientWithResponses) ReplaceLogForwardWithBodyWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error) {
	rsp, err := c.ReplaceLogForwardWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogForwardWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error) {
	rsp, err := c.ReplaceLogForward(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogForwardResponse(rsp)
}

// GetAllBindLogForwardWithResponse request returning *GetAllBindLogForwardResponse
func (c *ClientWithResponses) GetAllBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllBindLogForwardResponse, error) {
	rsp, err := c.GetAllBindLogForward(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBindLogForwardResponse(rsp)
}

// CreateBindLogForwardWithBodyWithResponse request with arbitrary body returning *CreateBindLogForwardResponse
func (c *ClientWithResponses) CreateBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error) {
	rsp, err := c.CreateBindLogForwardWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error) {
	rsp, err := c.CreateBindLogForward(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindLogForwardResponse(rsp)
}

// DeleteBindLogForwardWithResponse request returning *DeleteBindLogForwardResponse
func (c *ClientWithResponses) DeleteBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteBindLogForwardResponse, error) {
	rsp, err := c.DeleteBindLogForward(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBindLogForwardResponse(rsp)
}

// GetBindLogForwardWithResponse request returning *GetBindLogForwardResponse
func (c *ClientWithResponses) GetBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetBindLogForwardResponse, error) {
	rsp, err := c.GetBindLogForward(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindLogForwardResponse(rsp)
}

// ReplaceBindLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceBindLogForwardResponse
func (c *ClientWithResponses) ReplaceBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error) {
	rsp, err := c.ReplaceBindLogForwardWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error) {
	rsp, err := c.ReplaceBindLogForward(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindLogForwardResponse(rsp)
}

// GetDgramBindsWithResponse request returning *GetDgramBindsResponse
func (c *ClientWithResponses) GetDgramBindsWithResponse(ctx context.Context, parentName ParentName, params *GetDgramBindsParams, reqEditors ...RequestEditorFn) (*GetDgramBindsResponse, error) {
	rsp, err := c.GetDgramBinds(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDgramBindsResponse(rsp)
}

// CreateDgramBindWithBodyWithResponse request with arbitrary body returning *CreateDgramBindResponse
func (c *ClientWithResponses) CreateDgramBindWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDgramBindResponse, error) {
	rsp, err := c.CreateDgramBindWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDgramBindResponse(rsp)
}

func (c *ClientWithResponses) CreateDgramBindWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindParams, body CreateDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDgramBindResponse, error) {
	rsp, err := c.CreateDgramBind(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDgramBindResponse(rsp)
}

// DeleteDgramBindWithResponse request returning *DeleteDgramBindResponse
func (c *ClientWithResponses) DeleteDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindParams, reqEditors ...RequestEditorFn) (*DeleteDgramBindResponse, error) {
	rsp, err := c.DeleteDgramBind(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDgramBindResponse(rsp)
}

// GetDgramBindWithResponse request returning *GetDgramBindResponse
func (c *ClientWithResponses) GetDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *GetDgramBindParams, reqEditors ...RequestEditorFn) (*GetDgramBindResponse, error) {
	rsp, err := c.GetDgramBind(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDgramBindResponse(rsp)
}

// ReplaceDgramBindWithBodyWithResponse request with arbitrary body returning *ReplaceDgramBindResponse
func (c *ClientWithResponses) ReplaceDgramBindWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDgramBindResponse, error) {
	rsp, err := c.ReplaceDgramBindWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDgramBindResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDgramBindWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindParams, body ReplaceDgramBindJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDgramBindResponse, error) {
	rsp, err := c.ReplaceDgramBind(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDgramBindResponse(rsp)
}

// GetAllLogTargetLogForwardWithResponse request returning *GetAllLogTargetLogForwardResponse
func (c *ClientWithResponses) GetAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetLogForwardResponse, error) {
	rsp, err := c.GetAllLogTargetLogForward(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetLogForwardResponse(rsp)
}

// ReplaceAllLogTargetLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetLogForwardResponse
func (c *ClientWithResponses) ReplaceAllLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceAllLogTargetLogForwardWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceAllLogTargetLogForward(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetLogForwardResponse(rsp)
}

// DeleteLogTargetLogForwardWithResponse request returning *DeleteLogTargetLogForwardResponse
func (c *ClientWithResponses) DeleteLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetLogForwardResponse, error) {
	rsp, err := c.DeleteLogTargetLogForward(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetLogForwardResponse(rsp)
}

// GetLogTargetLogForwardWithResponse request returning *GetLogTargetLogForwardResponse
func (c *ClientWithResponses) GetLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogTargetLogForwardResponse, error) {
	rsp, err := c.GetLogTargetLogForward(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetLogForwardResponse(rsp)
}

// CreateLogTargetLogForwardWithBodyWithResponse request with arbitrary body returning *CreateLogTargetLogForwardResponse
func (c *ClientWithResponses) CreateLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error) {
	rsp, err := c.CreateLogTargetLogForwardWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error) {
	rsp, err := c.CreateLogTargetLogForward(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetLogForwardResponse(rsp)
}

// ReplaceLogTargetLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetLogForwardResponse
func (c *ClientWithResponses) ReplaceLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceLogTargetLogForwardWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceLogTargetLogForward(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetLogForwardResponse(rsp)
}

// GetLogProfilesWithResponse request returning *GetLogProfilesResponse
func (c *ClientWithResponses) GetLogProfilesWithResponse(ctx context.Context, params *GetLogProfilesParams, reqEditors ...RequestEditorFn) (*GetLogProfilesResponse, error) {
	rsp, err := c.GetLogProfiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogProfilesResponse(rsp)
}

// CreateLogProfileWithBodyWithResponse request with arbitrary body returning *CreateLogProfileResponse
func (c *ClientWithResponses) CreateLogProfileWithBodyWithResponse(ctx context.Context, params *CreateLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogProfileResponse, error) {
	rsp, err := c.CreateLogProfileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogProfileResponse(rsp)
}

func (c *ClientWithResponses) CreateLogProfileWithResponse(ctx context.Context, params *CreateLogProfileParams, body CreateLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogProfileResponse, error) {
	rsp, err := c.CreateLogProfile(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogProfileResponse(rsp)
}

// DeleteLogProfileWithResponse request returning *DeleteLogProfileResponse
func (c *ClientWithResponses) DeleteLogProfileWithResponse(ctx context.Context, name string, params *DeleteLogProfileParams, reqEditors ...RequestEditorFn) (*DeleteLogProfileResponse, error) {
	rsp, err := c.DeleteLogProfile(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogProfileResponse(rsp)
}

// GetLogProfileWithResponse request returning *GetLogProfileResponse
func (c *ClientWithResponses) GetLogProfileWithResponse(ctx context.Context, name string, params *GetLogProfileParams, reqEditors ...RequestEditorFn) (*GetLogProfileResponse, error) {
	rsp, err := c.GetLogProfile(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogProfileResponse(rsp)
}

// EditLogProfileWithBodyWithResponse request with arbitrary body returning *EditLogProfileResponse
func (c *ClientWithResponses) EditLogProfileWithBodyWithResponse(ctx context.Context, name string, params *EditLogProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditLogProfileResponse, error) {
	rsp, err := c.EditLogProfileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLogProfileResponse(rsp)
}

func (c *ClientWithResponses) EditLogProfileWithResponse(ctx context.Context, name string, params *EditLogProfileParams, body EditLogProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*EditLogProfileResponse, error) {
	rsp, err := c.EditLogProfile(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditLogProfileResponse(rsp)
}

// GetMailerEntriesWithResponse request returning *GetMailerEntriesResponse
func (c *ClientWithResponses) GetMailerEntriesWithResponse(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*GetMailerEntriesResponse, error) {
	rsp, err := c.GetMailerEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailerEntriesResponse(rsp)
}

// CreateMailerEntryWithBodyWithResponse request with arbitrary body returning *CreateMailerEntryResponse
func (c *ClientWithResponses) CreateMailerEntryWithBodyWithResponse(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error) {
	rsp, err := c.CreateMailerEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailerEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateMailerEntryWithResponse(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error) {
	rsp, err := c.CreateMailerEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailerEntryResponse(rsp)
}

// DeleteMailerEntryWithResponse request returning *DeleteMailerEntryResponse
func (c *ClientWithResponses) DeleteMailerEntryWithResponse(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*DeleteMailerEntryResponse, error) {
	rsp, err := c.DeleteMailerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMailerEntryResponse(rsp)
}

// GetMailerEntryWithResponse request returning *GetMailerEntryResponse
func (c *ClientWithResponses) GetMailerEntryWithResponse(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*GetMailerEntryResponse, error) {
	rsp, err := c.GetMailerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailerEntryResponse(rsp)
}

// ReplaceMailerEntryWithBodyWithResponse request with arbitrary body returning *ReplaceMailerEntryResponse
func (c *ClientWithResponses) ReplaceMailerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error) {
	rsp, err := c.ReplaceMailerEntryWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceMailerEntryResponse(rsp)
}

func (c *ClientWithResponses) ReplaceMailerEntryWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error) {
	rsp, err := c.ReplaceMailerEntry(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceMailerEntryResponse(rsp)
}

// GetMailersSectionsWithResponse request returning *GetMailersSectionsResponse
func (c *ClientWithResponses) GetMailersSectionsWithResponse(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*GetMailersSectionsResponse, error) {
	rsp, err := c.GetMailersSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailersSectionsResponse(rsp)
}

// CreateMailersSectionWithBodyWithResponse request with arbitrary body returning *CreateMailersSectionResponse
func (c *ClientWithResponses) CreateMailersSectionWithBodyWithResponse(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error) {
	rsp, err := c.CreateMailersSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailersSectionResponse(rsp)
}

func (c *ClientWithResponses) CreateMailersSectionWithResponse(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error) {
	rsp, err := c.CreateMailersSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailersSectionResponse(rsp)
}

// DeleteMailersSectionWithResponse request returning *DeleteMailersSectionResponse
func (c *ClientWithResponses) DeleteMailersSectionWithResponse(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*DeleteMailersSectionResponse, error) {
	rsp, err := c.DeleteMailersSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMailersSectionResponse(rsp)
}

// GetMailersSectionWithResponse request returning *GetMailersSectionResponse
func (c *ClientWithResponses) GetMailersSectionWithResponse(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*GetMailersSectionResponse, error) {
	rsp, err := c.GetMailersSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailersSectionResponse(rsp)
}

// EditMailersSectionWithBodyWithResponse request with arbitrary body returning *EditMailersSectionResponse
func (c *ClientWithResponses) EditMailersSectionWithBodyWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error) {
	rsp, err := c.EditMailersSectionWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMailersSectionResponse(rsp)
}

func (c *ClientWithResponses) EditMailersSectionWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error) {
	rsp, err := c.EditMailersSection(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMailersSectionResponse(rsp)
}

// GetNameserversWithResponse request returning *GetNameserversResponse
func (c *ClientWithResponses) GetNameserversWithResponse(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*GetNameserversResponse, error) {
	rsp, err := c.GetNameservers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNameserversResponse(rsp)
}

// CreateNameserverWithBodyWithResponse request with arbitrary body returning *CreateNameserverResponse
func (c *ClientWithResponses) CreateNameserverWithBodyWithResponse(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error) {
	rsp, err := c.CreateNameserverWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNameserverResponse(rsp)
}

func (c *ClientWithResponses) CreateNameserverWithResponse(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error) {
	rsp, err := c.CreateNameserver(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNameserverResponse(rsp)
}

// DeleteNameserverWithResponse request returning *DeleteNameserverResponse
func (c *ClientWithResponses) DeleteNameserverWithResponse(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*DeleteNameserverResponse, error) {
	rsp, err := c.DeleteNameserver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNameserverResponse(rsp)
}

// GetNameserverWithResponse request returning *GetNameserverResponse
func (c *ClientWithResponses) GetNameserverWithResponse(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*GetNameserverResponse, error) {
	rsp, err := c.GetNameserver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNameserverResponse(rsp)
}

// ReplaceNameserverWithBodyWithResponse request with arbitrary body returning *ReplaceNameserverResponse
func (c *ClientWithResponses) ReplaceNameserverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error) {
	rsp, err := c.ReplaceNameserverWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceNameserverResponse(rsp)
}

func (c *ClientWithResponses) ReplaceNameserverWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error) {
	rsp, err := c.ReplaceNameserver(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceNameserverResponse(rsp)
}

// GetPeerEntriesWithResponse request returning *GetPeerEntriesResponse
func (c *ClientWithResponses) GetPeerEntriesWithResponse(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*GetPeerEntriesResponse, error) {
	rsp, err := c.GetPeerEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerEntriesResponse(rsp)
}

// CreatePeerEntryWithBodyWithResponse request with arbitrary body returning *CreatePeerEntryResponse
func (c *ClientWithResponses) CreatePeerEntryWithBodyWithResponse(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error) {
	rsp, err := c.CreatePeerEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerEntryResponse(rsp)
}

func (c *ClientWithResponses) CreatePeerEntryWithResponse(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error) {
	rsp, err := c.CreatePeerEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerEntryResponse(rsp)
}

// DeletePeerEntryWithResponse request returning *DeletePeerEntryResponse
func (c *ClientWithResponses) DeletePeerEntryWithResponse(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*DeletePeerEntryResponse, error) {
	rsp, err := c.DeletePeerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePeerEntryResponse(rsp)
}

// GetPeerEntryWithResponse request returning *GetPeerEntryResponse
func (c *ClientWithResponses) GetPeerEntryWithResponse(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*GetPeerEntryResponse, error) {
	rsp, err := c.GetPeerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerEntryResponse(rsp)
}

// ReplacePeerEntryWithBodyWithResponse request with arbitrary body returning *ReplacePeerEntryResponse
func (c *ClientWithResponses) ReplacePeerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error) {
	rsp, err := c.ReplacePeerEntryWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplacePeerEntryResponse(rsp)
}

func (c *ClientWithResponses) ReplacePeerEntryWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error) {
	rsp, err := c.ReplacePeerEntry(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplacePeerEntryResponse(rsp)
}

// GetPeerSectionsWithResponse request returning *GetPeerSectionsResponse
func (c *ClientWithResponses) GetPeerSectionsWithResponse(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*GetPeerSectionsResponse, error) {
	rsp, err := c.GetPeerSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerSectionsResponse(rsp)
}

// CreatePeerWithBodyWithResponse request with arbitrary body returning *CreatePeerResponse
func (c *ClientWithResponses) CreatePeerWithBodyWithResponse(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error) {
	rsp, err := c.CreatePeerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerResponse(rsp)
}

func (c *ClientWithResponses) CreatePeerWithResponse(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error) {
	rsp, err := c.CreatePeer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerResponse(rsp)
}

// DeletePeerWithResponse request returning *DeletePeerResponse
func (c *ClientWithResponses) DeletePeerWithResponse(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*DeletePeerResponse, error) {
	rsp, err := c.DeletePeer(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePeerResponse(rsp)
}

// GetPeerSectionWithResponse request returning *GetPeerSectionResponse
func (c *ClientWithResponses) GetPeerSectionWithResponse(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*GetPeerSectionResponse, error) {
	rsp, err := c.GetPeerSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerSectionResponse(rsp)
}

// GetAllBindPeerWithResponse request returning *GetAllBindPeerResponse
func (c *ClientWithResponses) GetAllBindPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*GetAllBindPeerResponse, error) {
	rsp, err := c.GetAllBindPeer(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBindPeerResponse(rsp)
}

// CreateBindPeerWithBodyWithResponse request with arbitrary body returning *CreateBindPeerResponse
func (c *ClientWithResponses) CreateBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error) {
	rsp, err := c.CreateBindPeerWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindPeerResponse(rsp)
}

func (c *ClientWithResponses) CreateBindPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error) {
	rsp, err := c.CreateBindPeer(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindPeerResponse(rsp)
}

// DeleteBindPeerWithResponse request returning *DeleteBindPeerResponse
func (c *ClientWithResponses) DeleteBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*DeleteBindPeerResponse, error) {
	rsp, err := c.DeleteBindPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBindPeerResponse(rsp)
}

// GetBindPeerWithResponse request returning *GetBindPeerResponse
func (c *ClientWithResponses) GetBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*GetBindPeerResponse, error) {
	rsp, err := c.GetBindPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindPeerResponse(rsp)
}

// ReplaceBindPeerWithBodyWithResponse request with arbitrary body returning *ReplaceBindPeerResponse
func (c *ClientWithResponses) ReplaceBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error) {
	rsp, err := c.ReplaceBindPeerWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error) {
	rsp, err := c.ReplaceBindPeer(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindPeerResponse(rsp)
}

// GetAllLogTargetPeerWithResponse request returning *GetAllLogTargetPeerResponse
func (c *ClientWithResponses) GetAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetPeerResponse, error) {
	rsp, err := c.GetAllLogTargetPeer(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetPeerResponse(rsp)
}

// ReplaceAllLogTargetPeerWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetPeerResponse
func (c *ClientWithResponses) ReplaceAllLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceAllLogTargetPeerWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceAllLogTargetPeer(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetPeerResponse(rsp)
}

// DeleteLogTargetPeerWithResponse request returning *DeleteLogTargetPeerResponse
func (c *ClientWithResponses) DeleteLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetPeerResponse, error) {
	rsp, err := c.DeleteLogTargetPeer(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetPeerResponse(rsp)
}

// GetLogTargetPeerWithResponse request returning *GetLogTargetPeerResponse
func (c *ClientWithResponses) GetLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetLogTargetPeerResponse, error) {
	rsp, err := c.GetLogTargetPeer(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetPeerResponse(rsp)
}

// CreateLogTargetPeerWithBodyWithResponse request with arbitrary body returning *CreateLogTargetPeerResponse
func (c *ClientWithResponses) CreateLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error) {
	rsp, err := c.CreateLogTargetPeerWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetPeerResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error) {
	rsp, err := c.CreateLogTargetPeer(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetPeerResponse(rsp)
}

// ReplaceLogTargetPeerWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetPeerResponse
func (c *ClientWithResponses) ReplaceLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceLogTargetPeerWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceLogTargetPeer(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetPeerResponse(rsp)
}

// GetAllServerPeerWithResponse request returning *GetAllServerPeerResponse
func (c *ClientWithResponses) GetAllServerPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*GetAllServerPeerResponse, error) {
	rsp, err := c.GetAllServerPeer(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerPeerResponse(rsp)
}

// CreateServerPeerWithBodyWithResponse request with arbitrary body returning *CreateServerPeerResponse
func (c *ClientWithResponses) CreateServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error) {
	rsp, err := c.CreateServerPeerWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerPeerResponse(rsp)
}

func (c *ClientWithResponses) CreateServerPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error) {
	rsp, err := c.CreateServerPeer(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerPeerResponse(rsp)
}

// DeleteServerPeerWithResponse request returning *DeleteServerPeerResponse
func (c *ClientWithResponses) DeleteServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*DeleteServerPeerResponse, error) {
	rsp, err := c.DeleteServerPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerPeerResponse(rsp)
}

// GetServerPeerWithResponse request returning *GetServerPeerResponse
func (c *ClientWithResponses) GetServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*GetServerPeerResponse, error) {
	rsp, err := c.GetServerPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerPeerResponse(rsp)
}

// ReplaceServerPeerWithBodyWithResponse request with arbitrary body returning *ReplaceServerPeerResponse
func (c *ClientWithResponses) ReplaceServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error) {
	rsp, err := c.ReplaceServerPeerWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error) {
	rsp, err := c.ReplaceServerPeer(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerPeerResponse(rsp)
}

// GetTablesWithResponse request returning *GetTablesResponse
func (c *ClientWithResponses) GetTablesWithResponse(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error) {
	rsp, err := c.GetTables(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTablesResponse(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableResponse
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTableWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTable(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

// DeleteTableWithResponse request returning *DeleteTableResponse
func (c *ClientWithResponses) DeleteTableWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error) {
	rsp, err := c.DeleteTable(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTableResponse(rsp)
}

// GetTableWithResponse request returning *GetTableResponse
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error) {
	rsp, err := c.GetTable(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResponse(rsp)
}

// ReplaceTableWithBodyWithResponse request with arbitrary body returning *ReplaceTableResponse
func (c *ClientWithResponses) ReplaceTableWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error) {
	rsp, err := c.ReplaceTableWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTableResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTableWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error) {
	rsp, err := c.ReplaceTable(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTableResponse(rsp)
}

// GetProgramsWithResponse request returning *GetProgramsResponse
func (c *ClientWithResponses) GetProgramsWithResponse(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error) {
	rsp, err := c.GetPrograms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramsResponse(rsp)
}

// CreateProgramWithBodyWithResponse request with arbitrary body returning *CreateProgramResponse
func (c *ClientWithResponses) CreateProgramWithBodyWithResponse(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error) {
	rsp, err := c.CreateProgramWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResponse(rsp)
}

func (c *ClientWithResponses) CreateProgramWithResponse(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error) {
	rsp, err := c.CreateProgram(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResponse(rsp)
}

// DeleteProgramWithResponse request returning *DeleteProgramResponse
func (c *ClientWithResponses) DeleteProgramWithResponse(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*DeleteProgramResponse, error) {
	rsp, err := c.DeleteProgram(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramResponse(rsp)
}

// GetProgramWithResponse request returning *GetProgramResponse
func (c *ClientWithResponses) GetProgramWithResponse(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error) {
	rsp, err := c.GetProgram(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramResponse(rsp)
}

// ReplaceProgramWithBodyWithResponse request with arbitrary body returning *ReplaceProgramResponse
func (c *ClientWithResponses) ReplaceProgramWithBodyWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error) {
	rsp, err := c.ReplaceProgramWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceProgramResponse(rsp)
}

func (c *ClientWithResponses) ReplaceProgramWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error) {
	rsp, err := c.ReplaceProgram(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceProgramResponse(rsp)
}

// GetHAProxyConfigurationWithResponse request returning *GetHAProxyConfigurationResponse
func (c *ClientWithResponses) GetHAProxyConfigurationWithResponse(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*GetHAProxyConfigurationResponse, error) {
	rsp, err := c.GetHAProxyConfiguration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHAProxyConfigurationResponse(rsp)
}

// PostHAProxyConfigurationWithBodyWithResponse request with arbitrary body returning *PostHAProxyConfigurationResponse
func (c *ClientWithResponses) PostHAProxyConfigurationWithBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error) {
	rsp, err := c.PostHAProxyConfigurationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHAProxyConfigurationResponse(rsp)
}

func (c *ClientWithResponses) PostHAProxyConfigurationWithTextBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error) {
	rsp, err := c.PostHAProxyConfigurationWithTextBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHAProxyConfigurationResponse(rsp)
}

// GetResolversWithResponse request returning *GetResolversResponse
func (c *ClientWithResponses) GetResolversWithResponse(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*GetResolversResponse, error) {
	rsp, err := c.GetResolvers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResolversResponse(rsp)
}

// CreateResolverWithBodyWithResponse request with arbitrary body returning *CreateResolverResponse
func (c *ClientWithResponses) CreateResolverWithBodyWithResponse(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error) {
	rsp, err := c.CreateResolverWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResolverResponse(rsp)
}

func (c *ClientWithResponses) CreateResolverWithResponse(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error) {
	rsp, err := c.CreateResolver(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResolverResponse(rsp)
}

// DeleteResolverWithResponse request returning *DeleteResolverResponse
func (c *ClientWithResponses) DeleteResolverWithResponse(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*DeleteResolverResponse, error) {
	rsp, err := c.DeleteResolver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResolverResponse(rsp)
}

// GetResolverWithResponse request returning *GetResolverResponse
func (c *ClientWithResponses) GetResolverWithResponse(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*GetResolverResponse, error) {
	rsp, err := c.GetResolver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResolverResponse(rsp)
}

// ReplaceResolverWithBodyWithResponse request with arbitrary body returning *ReplaceResolverResponse
func (c *ClientWithResponses) ReplaceResolverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error) {
	rsp, err := c.ReplaceResolverWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResolverResponse(rsp)
}

func (c *ClientWithResponses) ReplaceResolverWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error) {
	rsp, err := c.ReplaceResolver(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResolverResponse(rsp)
}

// GetRingsWithResponse request returning *GetRingsResponse
func (c *ClientWithResponses) GetRingsWithResponse(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*GetRingsResponse, error) {
	rsp, err := c.GetRings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRingsResponse(rsp)
}

// CreateRingWithBodyWithResponse request with arbitrary body returning *CreateRingResponse
func (c *ClientWithResponses) CreateRingWithBodyWithResponse(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRingResponse, error) {
	rsp, err := c.CreateRingWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRingResponse(rsp)
}

func (c *ClientWithResponses) CreateRingWithResponse(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRingResponse, error) {
	rsp, err := c.CreateRing(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRingResponse(rsp)
}

// DeleteRingWithResponse request returning *DeleteRingResponse
func (c *ClientWithResponses) DeleteRingWithResponse(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*DeleteRingResponse, error) {
	rsp, err := c.DeleteRing(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRingResponse(rsp)
}

// GetRingWithResponse request returning *GetRingResponse
func (c *ClientWithResponses) GetRingWithResponse(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*GetRingResponse, error) {
	rsp, err := c.GetRing(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRingResponse(rsp)
}

// ReplaceRingWithBodyWithResponse request with arbitrary body returning *ReplaceRingResponse
func (c *ClientWithResponses) ReplaceRingWithBodyWithResponse(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error) {
	rsp, err := c.ReplaceRingWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRingResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRingWithResponse(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error) {
	rsp, err := c.ReplaceRing(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRingResponse(rsp)
}

// GetAllServerRingWithResponse request returning *GetAllServerRingResponse
func (c *ClientWithResponses) GetAllServerRingWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*GetAllServerRingResponse, error) {
	rsp, err := c.GetAllServerRing(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerRingResponse(rsp)
}

// CreateServerRingWithBodyWithResponse request with arbitrary body returning *CreateServerRingResponse
func (c *ClientWithResponses) CreateServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error) {
	rsp, err := c.CreateServerRingWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerRingResponse(rsp)
}

func (c *ClientWithResponses) CreateServerRingWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error) {
	rsp, err := c.CreateServerRing(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerRingResponse(rsp)
}

// DeleteServerRingWithResponse request returning *DeleteServerRingResponse
func (c *ClientWithResponses) DeleteServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*DeleteServerRingResponse, error) {
	rsp, err := c.DeleteServerRing(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerRingResponse(rsp)
}

// GetServerRingWithResponse request returning *GetServerRingResponse
func (c *ClientWithResponses) GetServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*GetServerRingResponse, error) {
	rsp, err := c.GetServerRing(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerRingResponse(rsp)
}

// ReplaceServerRingWithBodyWithResponse request with arbitrary body returning *ReplaceServerRingResponse
func (c *ClientWithResponses) ReplaceServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error) {
	rsp, err := c.ReplaceServerRingWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerRingResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error) {
	rsp, err := c.ReplaceServerRing(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerRingResponse(rsp)
}

// DeleteTracesWithResponse request returning *DeleteTracesResponse
func (c *ClientWithResponses) DeleteTracesWithResponse(ctx context.Context, params *DeleteTracesParams, reqEditors ...RequestEditorFn) (*DeleteTracesResponse, error) {
	rsp, err := c.DeleteTraces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTracesResponse(rsp)
}

// GetTracesWithResponse request returning *GetTracesResponse
func (c *ClientWithResponses) GetTracesWithResponse(ctx context.Context, params *GetTracesParams, reqEditors ...RequestEditorFn) (*GetTracesResponse, error) {
	rsp, err := c.GetTraces(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracesResponse(rsp)
}

// CreateTracesWithBodyWithResponse request with arbitrary body returning *CreateTracesResponse
func (c *ClientWithResponses) CreateTracesWithBodyWithResponse(ctx context.Context, params *CreateTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTracesResponse, error) {
	rsp, err := c.CreateTracesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTracesResponse(rsp)
}

func (c *ClientWithResponses) CreateTracesWithResponse(ctx context.Context, params *CreateTracesParams, body CreateTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTracesResponse, error) {
	rsp, err := c.CreateTraces(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTracesResponse(rsp)
}

// ReplaceTracesWithBodyWithResponse request with arbitrary body returning *ReplaceTracesResponse
func (c *ClientWithResponses) ReplaceTracesWithBodyWithResponse(ctx context.Context, params *ReplaceTracesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTracesResponse, error) {
	rsp, err := c.ReplaceTracesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTracesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTracesWithResponse(ctx context.Context, params *ReplaceTracesParams, body ReplaceTracesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTracesResponse, error) {
	rsp, err := c.ReplaceTraces(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTracesResponse(rsp)
}

// DeleteTraceEntryWithBodyWithResponse request with arbitrary body returning *DeleteTraceEntryResponse
func (c *ClientWithResponses) DeleteTraceEntryWithBodyWithResponse(ctx context.Context, params *DeleteTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTraceEntryResponse, error) {
	rsp, err := c.DeleteTraceEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTraceEntryResponse(rsp)
}

func (c *ClientWithResponses) DeleteTraceEntryWithResponse(ctx context.Context, params *DeleteTraceEntryParams, body DeleteTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTraceEntryResponse, error) {
	rsp, err := c.DeleteTraceEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTraceEntryResponse(rsp)
}

// CreateTraceEntryWithBodyWithResponse request with arbitrary body returning *CreateTraceEntryResponse
func (c *ClientWithResponses) CreateTraceEntryWithBodyWithResponse(ctx context.Context, params *CreateTraceEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTraceEntryResponse, error) {
	rsp, err := c.CreateTraceEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTraceEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateTraceEntryWithResponse(ctx context.Context, params *CreateTraceEntryParams, body CreateTraceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTraceEntryResponse, error) {
	rsp, err := c.CreateTraceEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTraceEntryResponse(rsp)
}

// GetUserlistsWithResponse request returning *GetUserlistsResponse
func (c *ClientWithResponses) GetUserlistsWithResponse(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*GetUserlistsResponse, error) {
	rsp, err := c.GetUserlists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserlistsResponse(rsp)
}

// CreateUserlistWithBodyWithResponse request with arbitrary body returning *CreateUserlistResponse
func (c *ClientWithResponses) CreateUserlistWithBodyWithResponse(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error) {
	rsp, err := c.CreateUserlistWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserlistResponse(rsp)
}

func (c *ClientWithResponses) CreateUserlistWithResponse(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error) {
	rsp, err := c.CreateUserlist(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserlistResponse(rsp)
}

// DeleteUserlistWithResponse request returning *DeleteUserlistResponse
func (c *ClientWithResponses) DeleteUserlistWithResponse(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*DeleteUserlistResponse, error) {
	rsp, err := c.DeleteUserlist(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserlistResponse(rsp)
}

// GetUserlistWithResponse request returning *GetUserlistResponse
func (c *ClientWithResponses) GetUserlistWithResponse(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*GetUserlistResponse, error) {
	rsp, err := c.GetUserlist(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserlistResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ReplaceUserWithBodyWithResponse request with arbitrary body returning *ReplaceUserResponse
func (c *ClientWithResponses) ReplaceUserWithBodyWithResponse(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error) {
	rsp, err := c.ReplaceUserWithBody(ctx, username, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceUserResponse(rsp)
}

func (c *ClientWithResponses) ReplaceUserWithResponse(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error) {
	rsp, err := c.ReplaceUser(ctx, username, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceUserResponse(rsp)
}

// GetConfigurationVersionWithResponse request returning *GetConfigurationVersionResponse
func (c *ClientWithResponses) GetConfigurationVersionWithResponse(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetConfigurationVersionResponse, error) {
	rsp, err := c.GetConfigurationVersion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationVersionResponse(rsp)
}

// GetReloadsWithResponse request returning *GetReloadsResponse
func (c *ClientWithResponses) GetReloadsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReloadsResponse, error) {
	rsp, err := c.GetReloads(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReloadsResponse(rsp)
}

// GetReloadWithResponse request returning *GetReloadResponse
func (c *ClientWithResponses) GetReloadWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReloadResponse, error) {
	rsp, err := c.GetReload(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReloadResponse(rsp)
}

// GetRuntimeEndpointsWithResponse request returning *GetRuntimeEndpointsResponse
func (c *ClientWithResponses) GetRuntimeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeEndpointsResponse, error) {
	rsp, err := c.GetRuntimeEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeEndpointsResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsWithResponse request returning *GetServicesHaproxyRuntimeAclsResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAcls(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsIdWithResponse request returning *GetServicesHaproxyRuntimeAclsIdResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsIdResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAclsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsIdResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse request returning *GetServicesHaproxyRuntimeAclsParentNameEntriesResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAclsParentNameEntries(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp)
}

// PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse request with arbitrary body returning *PostServicesHaproxyRuntimeAclsParentNameEntriesResponse
func (c *ClientWithResponses) PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	rsp, err := c.PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp)
}

func (c *ClientWithResponses) PostServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	rsp, err := c.PostServicesHaproxyRuntimeAclsParentNameEntries(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp)
}

// AddPayloadRuntimeACLWithBodyWithResponse request with arbitrary body returning *AddPayloadRuntimeACLResponse
func (c *ClientWithResponses) AddPayloadRuntimeACLWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error) {
	rsp, err := c.AddPayloadRuntimeACLWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeACLResponse(rsp)
}

func (c *ClientWithResponses) AddPayloadRuntimeACLWithResponse(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error) {
	rsp, err := c.AddPayloadRuntimeACL(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeACLResponse(rsp)
}

// DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request returning *DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse
func (c *ClientWithResponses) DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	rsp, err := c.DeleteServicesHaproxyRuntimeAclsParentNameEntriesId(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request returning *GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAclsParentNameEntriesId(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp)
}

// GetAcmeStatusWithResponse request returning *GetAcmeStatusResponse
func (c *ClientWithResponses) GetAcmeStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAcmeStatusResponse, error) {
	rsp, err := c.GetAcmeStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAcmeStatusResponse(rsp)
}

// RenewAcmeCertificateWithResponse request returning *RenewAcmeCertificateResponse
func (c *ClientWithResponses) RenewAcmeCertificateWithResponse(ctx context.Context, params *RenewAcmeCertificateParams, reqEditors ...RequestEditorFn) (*RenewAcmeCertificateResponse, error) {
	rsp, err := c.RenewAcmeCertificate(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenewAcmeCertificateResponse(rsp)
}

// GetAllRuntimeServerWithResponse request returning *GetAllRuntimeServerResponse
func (c *ClientWithResponses) GetAllRuntimeServerWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetAllRuntimeServerResponse, error) {
	rsp, err := c.GetAllRuntimeServer(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRuntimeServerResponse(rsp)
}

// AddRuntimeServerWithBodyWithResponse request with arbitrary body returning *AddRuntimeServerResponse
func (c *ClientWithResponses) AddRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error) {
	rsp, err := c.AddRuntimeServerWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuntimeServerResponse(rsp)
}

func (c *ClientWithResponses) AddRuntimeServerWithResponse(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error) {
	rsp, err := c.AddRuntimeServer(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuntimeServerResponse(rsp)
}

// DeleteRuntimeServerWithResponse request returning *DeleteRuntimeServerResponse
func (c *ClientWithResponses) DeleteRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*DeleteRuntimeServerResponse, error) {
	rsp, err := c.DeleteRuntimeServer(ctx, parentName, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuntimeServerResponse(rsp)
}

// GetRuntimeServerWithResponse request returning *GetRuntimeServerResponse
func (c *ClientWithResponses) GetRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*GetRuntimeServerResponse, error) {
	rsp, err := c.GetRuntimeServer(ctx, parentName, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeServerResponse(rsp)
}

// ReplaceRuntimeServerWithBodyWithResponse request with arbitrary body returning *ReplaceRuntimeServerResponse
func (c *ClientWithResponses) ReplaceRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error) {
	rsp, err := c.ReplaceRuntimeServerWithBody(ctx, parentName, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeServerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error) {
	rsp, err := c.ReplaceRuntimeServer(ctx, parentName, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeServerResponse(rsp)
}

// GetHaproxyProcessInfoWithResponse request returning *GetHaproxyProcessInfoResponse
func (c *ClientWithResponses) GetHaproxyProcessInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyProcessInfoResponse, error) {
	rsp, err := c.GetHaproxyProcessInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHaproxyProcessInfoResponse(rsp)
}

// GetAllRuntimeMapFilesWithResponse request returning *GetAllRuntimeMapFilesResponse
func (c *ClientWithResponses) GetAllRuntimeMapFilesWithResponse(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*GetAllRuntimeMapFilesResponse, error) {
	rsp, err := c.GetAllRuntimeMapFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRuntimeMapFilesResponse(rsp)
}

// ClearRuntimeMapWithResponse request returning *ClearRuntimeMapResponse
func (c *ClientWithResponses) ClearRuntimeMapWithResponse(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*ClearRuntimeMapResponse, error) {
	rsp, err := c.ClearRuntimeMap(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearRuntimeMapResponse(rsp)
}

// GetOneRuntimeMapWithResponse request returning *GetOneRuntimeMapResponse
func (c *ClientWithResponses) GetOneRuntimeMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneRuntimeMapResponse, error) {
	rsp, err := c.GetOneRuntimeMap(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneRuntimeMapResponse(rsp)
}

// AddPayloadRuntimeMapWithBodyWithResponse request with arbitrary body returning *AddPayloadRuntimeMapResponse
func (c *ClientWithResponses) AddPayloadRuntimeMapWithBodyWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error) {
	rsp, err := c.AddPayloadRuntimeMapWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeMapResponse(rsp)
}

func (c *ClientWithResponses) AddPayloadRuntimeMapWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error) {
	rsp, err := c.AddPayloadRuntimeMap(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeMapResponse(rsp)
}

// ShowRuntimeMapWithResponse request returning *ShowRuntimeMapResponse
func (c *ClientWithResponses) ShowRuntimeMapWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*ShowRuntimeMapResponse, error) {
	rsp, err := c.ShowRuntimeMap(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowRuntimeMapResponse(rsp)
}

// AddMapEntryWithBodyWithResponse request with arbitrary body returning *AddMapEntryResponse
func (c *ClientWithResponses) AddMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error) {
	rsp, err := c.AddMapEntryWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMapEntryResponse(rsp)
}

func (c *ClientWithResponses) AddMapEntryWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error) {
	rsp, err := c.AddMapEntry(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMapEntryResponse(rsp)
}

// DeleteRuntimeMapEntryWithResponse request returning *DeleteRuntimeMapEntryResponse
func (c *ClientWithResponses) DeleteRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*DeleteRuntimeMapEntryResponse, error) {
	rsp, err := c.DeleteRuntimeMapEntry(ctx, parentName, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuntimeMapEntryResponse(rsp)
}

// GetRuntimeMapEntryWithResponse request returning *GetRuntimeMapEntryResponse
func (c *ClientWithResponses) GetRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetRuntimeMapEntryResponse, error) {
	rsp, err := c.GetRuntimeMapEntry(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeMapEntryResponse(rsp)
}

// ReplaceRuntimeMapEntryWithBodyWithResponse request with arbitrary body returning *ReplaceRuntimeMapEntryResponse
func (c *ClientWithResponses) ReplaceRuntimeMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error) {
	rsp, err := c.ReplaceRuntimeMapEntryWithBody(ctx, parentName, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeMapEntryResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error) {
	rsp, err := c.ReplaceRuntimeMapEntry(ctx, parentName, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeMapEntryResponse(rsp)
}

// GetAllCaFilesWithResponse request returning *GetAllCaFilesResponse
func (c *ClientWithResponses) GetAllCaFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCaFilesResponse, error) {
	rsp, err := c.GetAllCaFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCaFilesResponse(rsp)
}

// CreateCaFileWithBodyWithResponse request with arbitrary body returning *CreateCaFileResponse
func (c *ClientWithResponses) CreateCaFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCaFileResponse, error) {
	rsp, err := c.CreateCaFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCaFileResponse(rsp)
}

// DeleteCaFileWithResponse request returning *DeleteCaFileResponse
func (c *ClientWithResponses) DeleteCaFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteCaFileResponse, error) {
	rsp, err := c.DeleteCaFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCaFileResponse(rsp)
}

// GetCaFileWithResponse request returning *GetCaFileResponse
func (c *ClientWithResponses) GetCaFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetCaFileResponse, error) {
	rsp, err := c.GetCaFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaFileResponse(rsp)
}

// SetCaFileWithBodyWithResponse request with arbitrary body returning *SetCaFileResponse
func (c *ClientWithResponses) SetCaFileWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCaFileResponse, error) {
	rsp, err := c.SetCaFileWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCaFileResponse(rsp)
}

// AddCaEntryWithBodyWithResponse request with arbitrary body returning *AddCaEntryResponse
func (c *ClientWithResponses) AddCaEntryWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCaEntryResponse, error) {
	rsp, err := c.AddCaEntryWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCaEntryResponse(rsp)
}

// GetCaEntryWithResponse request returning *GetCaEntryResponse
func (c *ClientWithResponses) GetCaEntryWithResponse(ctx context.Context, name string, index int, reqEditors ...RequestEditorFn) (*GetCaEntryResponse, error) {
	rsp, err := c.GetCaEntry(ctx, name, index, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaEntryResponse(rsp)
}

// GetAllCertsWithResponse request returning *GetAllCertsResponse
func (c *ClientWithResponses) GetAllCertsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCertsResponse, error) {
	rsp, err := c.GetAllCerts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCertsResponse(rsp)
}

// CreateCertWithBodyWithResponse request with arbitrary body returning *CreateCertResponse
func (c *ClientWithResponses) CreateCertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCertResponse, error) {
	rsp, err := c.CreateCertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCertResponse(rsp)
}

// DeleteCertWithResponse request returning *DeleteCertResponse
func (c *ClientWithResponses) DeleteCertWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteCertResponse, error) {
	rsp, err := c.DeleteCert(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCertResponse(rsp)
}

// GetCertWithResponse request returning *GetCertResponse
func (c *ClientWithResponses) GetCertWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetCertResponse, error) {
	rsp, err := c.GetCert(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertResponse(rsp)
}

// ReplaceCertWithBodyWithResponse request with arbitrary body returning *ReplaceCertResponse
func (c *ClientWithResponses) ReplaceCertWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCertResponse, error) {
	rsp, err := c.ReplaceCertWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCertResponse(rsp)
}

// GetAllCrlWithResponse request returning *GetAllCrlResponse
func (c *ClientWithResponses) GetAllCrlWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCrlResponse, error) {
	rsp, err := c.GetAllCrl(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCrlResponse(rsp)
}

// CreateCrlWithBodyWithResponse request with arbitrary body returning *CreateCrlResponse
func (c *ClientWithResponses) CreateCrlWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrlResponse, error) {
	rsp, err := c.CreateCrlWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrlResponse(rsp)
}

// DeleteCrlWithResponse request returning *DeleteCrlResponse
func (c *ClientWithResponses) DeleteCrlWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteCrlResponse, error) {
	rsp, err := c.DeleteCrl(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCrlResponse(rsp)
}

// GetCrlWithResponse request returning *GetCrlResponse
func (c *ClientWithResponses) GetCrlWithResponse(ctx context.Context, name string, params *GetCrlParams, reqEditors ...RequestEditorFn) (*GetCrlResponse, error) {
	rsp, err := c.GetCrl(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrlResponse(rsp)
}

// ReplaceCrlWithBodyWithResponse request with arbitrary body returning *ReplaceCrlResponse
func (c *ClientWithResponses) ReplaceCrlWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCrlResponse, error) {
	rsp, err := c.ReplaceCrlWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCrlResponse(rsp)
}

// GetAllCrtListsWithResponse request returning *GetAllCrtListsResponse
func (c *ClientWithResponses) GetAllCrtListsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllCrtListsResponse, error) {
	rsp, err := c.GetAllCrtLists(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCrtListsResponse(rsp)
}

// DeleteCrtListEntryWithResponse request returning *DeleteCrtListEntryResponse
func (c *ClientWithResponses) DeleteCrtListEntryWithResponse(ctx context.Context, params *DeleteCrtListEntryParams, reqEditors ...RequestEditorFn) (*DeleteCrtListEntryResponse, error) {
	rsp, err := c.DeleteCrtListEntry(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCrtListEntryResponse(rsp)
}

// GetAllCrtListEntriesWithResponse request returning *GetAllCrtListEntriesResponse
func (c *ClientWithResponses) GetAllCrtListEntriesWithResponse(ctx context.Context, params *GetAllCrtListEntriesParams, reqEditors ...RequestEditorFn) (*GetAllCrtListEntriesResponse, error) {
	rsp, err := c.GetAllCrtListEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllCrtListEntriesResponse(rsp)
}

// AddCrtListEntryWithBodyWithResponse request with arbitrary body returning *AddCrtListEntryResponse
func (c *ClientWithResponses) AddCrtListEntryWithBodyWithResponse(ctx context.Context, params *AddCrtListEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCrtListEntryResponse, error) {
	rsp, err := c.AddCrtListEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCrtListEntryResponse(rsp)
}

func (c *ClientWithResponses) AddCrtListEntryWithResponse(ctx context.Context, params *AddCrtListEntryParams, body AddCrtListEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCrtListEntryResponse, error) {
	rsp, err := c.AddCrtListEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCrtListEntryResponse(rsp)
}

// GetStickTablesWithResponse request returning *GetStickTablesResponse
func (c *ClientWithResponses) GetStickTablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStickTablesResponse, error) {
	rsp, err := c.GetStickTables(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickTablesResponse(rsp)
}

// GetStickTableWithResponse request returning *GetStickTableResponse
func (c *ClientWithResponses) GetStickTableWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetStickTableResponse, error) {
	rsp, err := c.GetStickTable(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickTableResponse(rsp)
}

// GetStickTableEntriesWithResponse request returning *GetStickTableEntriesResponse
func (c *ClientWithResponses) GetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*GetStickTableEntriesResponse, error) {
	rsp, err := c.GetStickTableEntries(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickTableEntriesResponse(rsp)
}

// SetStickTableEntriesWithBodyWithResponse request with arbitrary body returning *SetStickTableEntriesResponse
func (c *ClientWithResponses) SetStickTableEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error) {
	rsp, err := c.SetStickTableEntriesWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetStickTableEntriesResponse(rsp)
}

func (c *ClientWithResponses) SetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error) {
	rsp, err := c.SetStickTableEntries(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetStickTableEntriesResponse(rsp)
}

// GetSitesWithResponse request returning *GetSitesResponse
func (c *ClientWithResponses) GetSitesWithResponse(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*GetSitesResponse, error) {
	rsp, err := c.GetSites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitesResponse(rsp)
}

// CreateSiteWithBodyWithResponse request with arbitrary body returning *CreateSiteResponse
func (c *ClientWithResponses) CreateSiteWithBodyWithResponse(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSiteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

func (c *ClientWithResponses) CreateSiteWithResponse(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSite(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

// DeleteSiteWithResponse request returning *DeleteSiteResponse
func (c *ClientWithResponses) DeleteSiteWithResponse(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error) {
	rsp, err := c.DeleteSite(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSiteResponse(rsp)
}

// GetSiteWithResponse request returning *GetSiteResponse
func (c *ClientWithResponses) GetSiteWithResponse(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*GetSiteResponse, error) {
	rsp, err := c.GetSite(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSiteResponse(rsp)
}

// ReplaceSiteWithBodyWithResponse request with arbitrary body returning *ReplaceSiteResponse
func (c *ClientWithResponses) ReplaceSiteWithBodyWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error) {
	rsp, err := c.ReplaceSiteWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSiteResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSiteWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error) {
	rsp, err := c.ReplaceSite(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSiteResponse(rsp)
}

// GetSpoeEndpointsWithResponse request returning *GetSpoeEndpointsResponse
func (c *ClientWithResponses) GetSpoeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpoeEndpointsResponse, error) {
	rsp, err := c.GetSpoeEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeEndpointsResponse(rsp)
}

// GetAllSpoeFilesWithResponse request returning *GetAllSpoeFilesResponse
func (c *ClientWithResponses) GetAllSpoeFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSpoeFilesResponse, error) {
	rsp, err := c.GetAllSpoeFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeFilesResponse(rsp)
}

// CreateSpoeWithBodyWithResponse request with arbitrary body returning *CreateSpoeResponse
func (c *ClientWithResponses) CreateSpoeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeResponse, error) {
	rsp, err := c.CreateSpoeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeResponse(rsp)
}

// DeleteSpoeFileWithResponse request returning *DeleteSpoeFileResponse
func (c *ClientWithResponses) DeleteSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteSpoeFileResponse, error) {
	rsp, err := c.DeleteSpoeFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeFileResponse(rsp)
}

// GetOneSpoeFileWithResponse request returning *GetOneSpoeFileResponse
func (c *ClientWithResponses) GetOneSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneSpoeFileResponse, error) {
	rsp, err := c.GetOneSpoeFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneSpoeFileResponse(rsp)
}

// GetAllSpoeScopeWithResponse request returning *GetAllSpoeScopeResponse
func (c *ClientWithResponses) GetAllSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetAllSpoeScopeResponse, error) {
	rsp, err := c.GetAllSpoeScope(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeScopeResponse(rsp)
}

// CreateSpoeScopeWithBodyWithResponse request with arbitrary body returning *CreateSpoeScopeResponse
func (c *ClientWithResponses) CreateSpoeScopeWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error) {
	rsp, err := c.CreateSpoeScopeWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeScopeResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error) {
	rsp, err := c.CreateSpoeScope(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeScopeResponse(rsp)
}

// DeleteSpoeScopeWithResponse request returning *DeleteSpoeScopeResponse
func (c *ClientWithResponses) DeleteSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*DeleteSpoeScopeResponse, error) {
	rsp, err := c.DeleteSpoeScope(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeScopeResponse(rsp)
}

// GetSpoeScopeWithResponse request returning *GetSpoeScopeResponse
func (c *ClientWithResponses) GetSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetSpoeScopeResponse, error) {
	rsp, err := c.GetSpoeScope(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeScopeResponse(rsp)
}

// GetAllSpoeAgentWithResponse request returning *GetAllSpoeAgentResponse
func (c *ClientWithResponses) GetAllSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetAllSpoeAgentResponse, error) {
	rsp, err := c.GetAllSpoeAgent(ctx, parentName, scopeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeAgentResponse(rsp)
}

// CreateSpoeAgentWithBodyWithResponse request with arbitrary body returning *CreateSpoeAgentResponse
func (c *ClientWithResponses) CreateSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error) {
	rsp, err := c.CreateSpoeAgentWithBody(ctx, parentName, scopeName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeAgentResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error) {
	rsp, err := c.CreateSpoeAgent(ctx, parentName, scopeName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeAgentResponse(rsp)
}

// DeleteSpoeAgentWithResponse request returning *DeleteSpoeAgentResponse
func (c *ClientWithResponses) DeleteSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*DeleteSpoeAgentResponse, error) {
	rsp, err := c.DeleteSpoeAgent(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeAgentResponse(rsp)
}

// GetSpoeAgentWithResponse request returning *GetSpoeAgentResponse
func (c *ClientWithResponses) GetSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetSpoeAgentResponse, error) {
	rsp, err := c.GetSpoeAgent(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeAgentResponse(rsp)
}

// ReplaceSpoeAgentWithBodyWithResponse request with arbitrary body returning *ReplaceSpoeAgentResponse
func (c *ClientWithResponses) ReplaceSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error) {
	rsp, err := c.ReplaceSpoeAgentWithBody(ctx, parentName, scopeName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeAgentResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error) {
	rsp, err := c.ReplaceSpoeAgent(ctx, parentName, scopeName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeAgentResponse(rsp)
}

// GetAllSpoeGroupWithResponse request returning *GetAllSpoeGroupResponse
func (c *ClientWithResponses) GetAllSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetAllSpoeGroupResponse, error) {
	rsp, err := c.GetAllSpoeGroup(ctx, parentName, scopeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeGroupResponse(rsp)
}

// CreateSpoeGroupWithBodyWithResponse request with arbitrary body returning *CreateSpoeGroupResponse
func (c *ClientWithResponses) CreateSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error) {
	rsp, err := c.CreateSpoeGroupWithBody(ctx, parentName, scopeName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error) {
	rsp, err := c.CreateSpoeGroup(ctx, parentName, scopeName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeGroupResponse(rsp)
}

// DeleteSpoeGroupWithResponse request returning *DeleteSpoeGroupResponse
func (c *ClientWithResponses) DeleteSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*DeleteSpoeGroupResponse, error) {
	rsp, err := c.DeleteSpoeGroup(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeGroupResponse(rsp)
}

// GetSpoeGroupWithResponse request returning *GetSpoeGroupResponse
func (c *ClientWithResponses) GetSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetSpoeGroupResponse, error) {
	rsp, err := c.GetSpoeGroup(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeGroupResponse(rsp)
}

// ReplaceSpoeGroupWithBodyWithResponse request with arbitrary body returning *ReplaceSpoeGroupResponse
func (c *ClientWithResponses) ReplaceSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error) {
	rsp, err := c.ReplaceSpoeGroupWithBody(ctx, parentName, scopeName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeGroupResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error) {
	rsp, err := c.ReplaceSpoeGroup(ctx, parentName, scopeName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeGroupResponse(rsp)
}

// GetAllSpoeMessageWithResponse request returning *GetAllSpoeMessageResponse
func (c *ClientWithResponses) GetAllSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetAllSpoeMessageResponse, error) {
	rsp, err := c.GetAllSpoeMessage(ctx, parentName, scopeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeMessageResponse(rsp)
}

// CreateSpoeMessageWithBodyWithResponse request with arbitrary body returning *CreateSpoeMessageResponse
func (c *ClientWithResponses) CreateSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error) {
	rsp, err := c.CreateSpoeMessageWithBody(ctx, parentName, scopeName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeMessageResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error) {
	rsp, err := c.CreateSpoeMessage(ctx, parentName, scopeName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeMessageResponse(rsp)
}

// DeleteSpoeMessageWithResponse request returning *DeleteSpoeMessageResponse
func (c *ClientWithResponses) DeleteSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*DeleteSpoeMessageResponse, error) {
	rsp, err := c.DeleteSpoeMessage(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeMessageResponse(rsp)
}

// GetSpoeMessageWithResponse request returning *GetSpoeMessageResponse
func (c *ClientWithResponses) GetSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetSpoeMessageResponse, error) {
	rsp, err := c.GetSpoeMessage(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeMessageResponse(rsp)
}

// ReplaceSpoeMessageWithBodyWithResponse request with arbitrary body returning *ReplaceSpoeMessageResponse
func (c *ClientWithResponses) ReplaceSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error) {
	rsp, err := c.ReplaceSpoeMessageWithBody(ctx, parentName, scopeName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeMessageResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error) {
	rsp, err := c.ReplaceSpoeMessage(ctx, parentName, scopeName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeMessageResponse(rsp)
}

// GetAllSpoeTransactionWithResponse request returning *GetAllSpoeTransactionResponse
func (c *ClientWithResponses) GetAllSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*GetAllSpoeTransactionResponse, error) {
	rsp, err := c.GetAllSpoeTransaction(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeTransactionResponse(rsp)
}

// StartSpoeTransactionWithResponse request returning *StartSpoeTransactionResponse
func (c *ClientWithResponses) StartSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*StartSpoeTransactionResponse, error) {
	rsp, err := c.StartSpoeTransaction(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartSpoeTransactionResponse(rsp)
}

// DeleteSpoeTransactionWithResponse request returning *DeleteSpoeTransactionResponse
func (c *ClientWithResponses) DeleteSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteSpoeTransactionResponse, error) {
	rsp, err := c.DeleteSpoeTransaction(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeTransactionResponse(rsp)
}

// GetSpoeTransactionWithResponse request returning *GetSpoeTransactionResponse
func (c *ClientWithResponses) GetSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetSpoeTransactionResponse, error) {
	rsp, err := c.GetSpoeTransaction(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeTransactionResponse(rsp)
}

// CommitSpoeTransactionWithResponse request returning *CommitSpoeTransactionResponse
func (c *ClientWithResponses) CommitSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*CommitSpoeTransactionResponse, error) {
	rsp, err := c.CommitSpoeTransaction(ctx, parentName, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitSpoeTransactionResponse(rsp)
}

// GetSpoeConfigurationVersionWithResponse request returning *GetSpoeConfigurationVersionResponse
func (c *ClientWithResponses) GetSpoeConfigurationVersionWithResponse(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetSpoeConfigurationVersionResponse, error) {
	rsp, err := c.GetSpoeConfigurationVersion(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeConfigurationVersionResponse(rsp)
}

// GetStatsEndpointsWithResponse request returning *GetStatsEndpointsResponse
func (c *ClientWithResponses) GetStatsEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsEndpointsResponse, error) {
	rsp, err := c.GetStatsEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsEndpointsResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// GetStorageEndpointsWithResponse request returning *GetStorageEndpointsResponse
func (c *ClientWithResponses) GetStorageEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageEndpointsResponse, error) {
	rsp, err := c.GetStorageEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageEndpointsResponse(rsp)
}

// GetAllStorageGeneralFilesWithResponse request returning *GetAllStorageGeneralFilesResponse
func (c *ClientWithResponses) GetAllStorageGeneralFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageGeneralFilesResponse, error) {
	rsp, err := c.GetAllStorageGeneralFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageGeneralFilesResponse(rsp)
}

// CreateStorageGeneralFileWithBodyWithResponse request with arbitrary body returning *CreateStorageGeneralFileResponse
func (c *ClientWithResponses) CreateStorageGeneralFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageGeneralFileResponse, error) {
	rsp, err := c.CreateStorageGeneralFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageGeneralFileResponse(rsp)
}

// DeleteStorageGeneralFileWithResponse request returning *DeleteStorageGeneralFileResponse
func (c *ClientWithResponses) DeleteStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageGeneralFileResponse, error) {
	rsp, err := c.DeleteStorageGeneralFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageGeneralFileResponse(rsp)
}

// GetOneStorageGeneralFileWithResponse request returning *GetOneStorageGeneralFileResponse
func (c *ClientWithResponses) GetOneStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageGeneralFileResponse, error) {
	rsp, err := c.GetOneStorageGeneralFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageGeneralFileResponse(rsp)
}

// ReplaceStorageGeneralFileWithBodyWithResponse request with arbitrary body returning *ReplaceStorageGeneralFileResponse
func (c *ClientWithResponses) ReplaceStorageGeneralFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageGeneralFileResponse, error) {
	rsp, err := c.ReplaceStorageGeneralFileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageGeneralFileResponse(rsp)
}

// GetAllStorageMapFilesWithResponse request returning *GetAllStorageMapFilesResponse
func (c *ClientWithResponses) GetAllStorageMapFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageMapFilesResponse, error) {
	rsp, err := c.GetAllStorageMapFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageMapFilesResponse(rsp)
}

// CreateStorageMapFileWithBodyWithResponse request with arbitrary body returning *CreateStorageMapFileResponse
func (c *ClientWithResponses) CreateStorageMapFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageMapFileResponse, error) {
	rsp, err := c.CreateStorageMapFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageMapFileResponse(rsp)
}

// DeleteStorageMapWithResponse request returning *DeleteStorageMapResponse
func (c *ClientWithResponses) DeleteStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageMapResponse, error) {
	rsp, err := c.DeleteStorageMap(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageMapResponse(rsp)
}

// GetOneStorageMapWithResponse request returning *GetOneStorageMapResponse
func (c *ClientWithResponses) GetOneStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageMapResponse, error) {
	rsp, err := c.GetOneStorageMap(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageMapResponse(rsp)
}

// ReplaceStorageMapFileWithBodyWithResponse request with arbitrary body returning *ReplaceStorageMapFileResponse
func (c *ClientWithResponses) ReplaceStorageMapFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error) {
	rsp, err := c.ReplaceStorageMapFileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageMapFileResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStorageMapFileWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error) {
	rsp, err := c.ReplaceStorageMapFileWithTextBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageMapFileResponse(rsp)
}

// GetAllStorageSSLCertificatesWithResponse request returning *GetAllStorageSSLCertificatesResponse
func (c *ClientWithResponses) GetAllStorageSSLCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageSSLCertificatesResponse, error) {
	rsp, err := c.GetAllStorageSSLCertificates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageSSLCertificatesResponse(rsp)
}

// CreateStorageSSLCertificateWithBodyWithResponse request with arbitrary body returning *CreateStorageSSLCertificateResponse
func (c *ClientWithResponses) CreateStorageSSLCertificateWithBodyWithResponse(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCertificateResponse, error) {
	rsp, err := c.CreateStorageSSLCertificateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageSSLCertificateResponse(rsp)
}

// DeleteStorageSSLCertificateWithResponse request returning *DeleteStorageSSLCertificateResponse
func (c *ClientWithResponses) DeleteStorageSSLCertificateWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCertificateResponse, error) {
	rsp, err := c.DeleteStorageSSLCertificate(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageSSLCertificateResponse(rsp)
}

// GetOneStorageSSLCertificateWithResponse request returning *GetOneStorageSSLCertificateResponse
func (c *ClientWithResponses) GetOneStorageSSLCertificateWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageSSLCertificateResponse, error) {
	rsp, err := c.GetOneStorageSSLCertificate(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageSSLCertificateResponse(rsp)
}

// ReplaceStorageSSLCertificateWithBodyWithResponse request with arbitrary body returning *ReplaceStorageSSLCertificateResponse
func (c *ClientWithResponses) ReplaceStorageSSLCertificateWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error) {
	rsp, err := c.ReplaceStorageSSLCertificateWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageSSLCertificateResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStorageSSLCertificateWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error) {
	rsp, err := c.ReplaceStorageSSLCertificateWithTextBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageSSLCertificateResponse(rsp)
}

// GetAllStorageSSLCrtListFilesWithResponse request returning *GetAllStorageSSLCrtListFilesResponse
func (c *ClientWithResponses) GetAllStorageSSLCrtListFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageSSLCrtListFilesResponse, error) {
	rsp, err := c.GetAllStorageSSLCrtListFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageSSLCrtListFilesResponse(rsp)
}

// CreateStorageSSLCrtListFileWithBodyWithResponse request with arbitrary body returning *CreateStorageSSLCrtListFileResponse
func (c *ClientWithResponses) CreateStorageSSLCrtListFileWithBodyWithResponse(ctx context.Context, params *CreateStorageSSLCrtListFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCrtListFileResponse, error) {
	rsp, err := c.CreateStorageSSLCrtListFileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageSSLCrtListFileResponse(rsp)
}

// DeleteStorageSSLCrtListFileWithResponse request returning *DeleteStorageSSLCrtListFileResponse
func (c *ClientWithResponses) DeleteStorageSSLCrtListFileWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCrtListFileParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCrtListFileResponse, error) {
	rsp, err := c.DeleteStorageSSLCrtListFile(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageSSLCrtListFileResponse(rsp)
}

// GetOneStorageSSLCrtListFileWithResponse request returning *GetOneStorageSSLCrtListFileResponse
func (c *ClientWithResponses) GetOneStorageSSLCrtListFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageSSLCrtListFileResponse, error) {
	rsp, err := c.GetOneStorageSSLCrtListFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageSSLCrtListFileResponse(rsp)
}

// ReplaceStorageSSLCrtListFileWithBodyWithResponse request with arbitrary body returning *ReplaceStorageSSLCrtListFileResponse
func (c *ClientWithResponses) ReplaceStorageSSLCrtListFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCrtListFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCrtListFileResponse, error) {
	rsp, err := c.ReplaceStorageSSLCrtListFileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageSSLCrtListFileResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStorageSSLCrtListFileWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCrtListFileParams, body ReplaceStorageSSLCrtListFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCrtListFileResponse, error) {
	rsp, err := c.ReplaceStorageSSLCrtListFileWithTextBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageSSLCrtListFileResponse(rsp)
}

// DeleteStorageSSLCrtListEntryWithResponse request returning *DeleteStorageSSLCrtListEntryResponse
func (c *ClientWithResponses) DeleteStorageSSLCrtListEntryWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCrtListEntryParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCrtListEntryResponse, error) {
	rsp, err := c.DeleteStorageSSLCrtListEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageSSLCrtListEntryResponse(rsp)
}

// GetStorageSSLCrtListEntriesWithResponse request returning *GetStorageSSLCrtListEntriesResponse
func (c *ClientWithResponses) GetStorageSSLCrtListEntriesWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetStorageSSLCrtListEntriesResponse, error) {
	rsp, err := c.GetStorageSSLCrtListEntries(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageSSLCrtListEntriesResponse(rsp)
}

// CreateStorageSSLCrtListEntryWithBodyWithResponse request with arbitrary body returning *CreateStorageSSLCrtListEntryResponse
func (c *ClientWithResponses) CreateStorageSSLCrtListEntryWithBodyWithResponse(ctx context.Context, name string, params *CreateStorageSSLCrtListEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCrtListEntryResponse, error) {
	rsp, err := c.CreateStorageSSLCrtListEntryWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageSSLCrtListEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateStorageSSLCrtListEntryWithResponse(ctx context.Context, name string, params *CreateStorageSSLCrtListEntryParams, body CreateStorageSSLCrtListEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStorageSSLCrtListEntryResponse, error) {
	rsp, err := c.CreateStorageSSLCrtListEntry(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageSSLCrtListEntryResponse(rsp)
}

// GetTransactionsWithResponse request returning *GetTransactionsResponse
func (c *ClientWithResponses) GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error) {
	rsp, err := c.GetTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsResponse(rsp)
}

// StartTransactionWithResponse request returning *StartTransactionResponse
func (c *ClientWithResponses) StartTransactionWithResponse(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*StartTransactionResponse, error) {
	rsp, err := c.StartTransaction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartTransactionResponse(rsp)
}

// DeleteTransactionWithResponse request returning *DeleteTransactionResponse
func (c *ClientWithResponses) DeleteTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error) {
	rsp, err := c.DeleteTransaction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionResponse(rsp)
}

// GetTransactionWithResponse request returning *GetTransactionResponse
func (c *ClientWithResponses) GetTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error) {
	rsp, err := c.GetTransaction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionResponse(rsp)
}

// CommitTransactionWithResponse request returning *CommitTransactionResponse
func (c *ClientWithResponses) CommitTransactionWithResponse(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error) {
	rsp, err := c.CommitTransaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitTransactionResponse(rsp)
}

// GetSpecificationWithResponse request returning *GetSpecificationResponse
func (c *ClientWithResponses) GetSpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpecificationResponse, error) {
	rsp, err := c.GetSpecification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpecificationResponse(rsp)
}

// GetOpenapiv3SpecificationWithResponse request returning *GetOpenapiv3SpecificationResponse
func (c *ClientWithResponses) GetOpenapiv3SpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiv3SpecificationResponse, error) {
	rsp, err := c.GetOpenapiv3Specification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiv3SpecificationResponse(rsp)
}

// ParseGetAPIEndpointsResponse parses an HTTP response from a GetAPIEndpointsWithResponse call
func ParseGetAPIEndpointsResponse(rsp *http.Response) (*GetAPIEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostClusterResponse parses an HTTP response from a PostClusterWithResponse call
func ParsePostClusterResponse(rsp *http.Response) (*PostClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditClusterResponse parses an HTTP response from a EditClusterWithResponse call
func ParseEditClusterResponse(rsp *http.Response) (*EditClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInitiateCertificateRefreshResponse parses an HTTP response from a InitiateCertificateRefreshWithResponse call
func ParseInitiateCertificateRefreshResponse(rsp *http.Response) (*InitiateCertificateRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitiateCertificateRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Health
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInfoResponse parses an HTTP response from a GetInfoWithResponse call
func ParseGetInfoResponse(rsp *http.Response) (*GetInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Info
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAWSRegionsResponse parses an HTTP response from a GetAWSRegionsWithResponse call
func ParseGetAWSRegionsResponse(rsp *http.Response) (*GetAWSRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAWSRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AwsRegions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAWSRegionResponse parses an HTTP response from a CreateAWSRegionWithResponse call
func ParseCreateAWSRegionResponse(rsp *http.Response) (*CreateAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AwsRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAWSRegionResponse parses an HTTP response from a DeleteAWSRegionWithResponse call
func ParseDeleteAWSRegionResponse(rsp *http.Response) (*DeleteAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAWSRegionResponse parses an HTTP response from a GetAWSRegionWithResponse call
func ParseGetAWSRegionResponse(rsp *http.Response) (*GetAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AwsRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAWSRegionResponse parses an HTTP response from a ReplaceAWSRegionWithResponse call
func ParseReplaceAWSRegionResponse(rsp *http.Response) (*ReplaceAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AwsRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConsulsResponse parses an HTTP response from a GetConsulsWithResponse call
func ParseGetConsulsResponse(rsp *http.Response) (*GetConsulsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsulsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consuls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateConsulResponse parses an HTTP response from a CreateConsulWithResponse call
func ParseCreateConsulResponse(rsp *http.Response) (*CreateConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Consul
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteConsulResponse parses an HTTP response from a DeleteConsulWithResponse call
func ParseDeleteConsulResponse(rsp *http.Response) (*DeleteConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConsulResponse parses an HTTP response from a GetConsulWithResponse call
func ParseGetConsulResponse(rsp *http.Response) (*GetConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consul
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceConsulResponse parses an HTTP response from a ReplaceConsulWithResponse call
func ParseReplaceConsulResponse(rsp *http.Response) (*ReplaceConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consul
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesEndpointsResponse parses an HTTP response from a GetServicesEndpointsWithResponse call
func ParseGetServicesEndpointsResponse(rsp *http.Response) (*GetServicesEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHaproxyEndpointsResponse parses an HTTP response from a GetHaproxyEndpointsWithResponse call
func ParseGetHaproxyEndpointsResponse(rsp *http.Response) (*GetHaproxyEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHaproxyEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationEndpointsResponse parses an HTTP response from a GetConfigurationEndpointsWithResponse call
func ParseGetConfigurationEndpointsResponse(rsp *http.Response) (*GetConfigurationEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAcmeProvidersResponse parses an HTTP response from a GetAcmeProvidersWithResponse call
func ParseGetAcmeProvidersResponse(rsp *http.Response) (*GetAcmeProvidersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAcmeProvidersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcmeProviders
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAcmeProviderResponse parses an HTTP response from a CreateAcmeProviderWithResponse call
func ParseCreateAcmeProviderResponse(rsp *http.Response) (*CreateAcmeProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAcmeProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AcmeProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AcmeProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAcmeProviderResponse parses an HTTP response from a DeleteAcmeProviderWithResponse call
func ParseDeleteAcmeProviderResponse(rsp *http.Response) (*DeleteAcmeProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAcmeProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAcmeProviderResponse parses an HTTP response from a GetAcmeProviderWithResponse call
func ParseGetAcmeProviderResponse(rsp *http.Response) (*GetAcmeProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAcmeProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcmeProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditAcmeProviderResponse parses an HTTP response from a EditAcmeProviderWithResponse call
func ParseEditAcmeProviderResponse(rsp *http.Response) (*EditAcmeProviderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditAcmeProviderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcmeProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest AcmeProvider
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendsResponse parses an HTTP response from a GetBackendsWithResponse call
func ParseGetBackendsResponse(rsp *http.Response) (*GetBackendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backends
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBackendResponse parses an HTTP response from a CreateBackendWithResponse call
func ParseCreateBackendResponse(rsp *http.Response) (*CreateBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBackendResponse parses an HTTP response from a DeleteBackendWithResponse call
func ParseDeleteBackendResponse(rsp *http.Response) (*DeleteBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendResponse parses an HTTP response from a GetBackendWithResponse call
func ParseGetBackendResponse(rsp *http.Response) (*GetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBackendResponse parses an HTTP response from a ReplaceBackendWithResponse call
func ParseReplaceBackendResponse(rsp *http.Response) (*ReplaceBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclBackendResponse parses an HTTP response from a GetAllAclBackendWithResponse call
func ParseGetAllAclBackendResponse(rsp *http.Response) (*GetAllAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclBackendResponse parses an HTTP response from a ReplaceAllAclBackendWithResponse call
func ParseReplaceAllAclBackendResponse(rsp *http.Response) (*ReplaceAllAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclBackendResponse parses an HTTP response from a DeleteAclBackendWithResponse call
func ParseDeleteAclBackendResponse(rsp *http.Response) (*DeleteAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclBackendResponse parses an HTTP response from a GetAclBackendWithResponse call
func ParseGetAclBackendResponse(rsp *http.Response) (*GetAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclBackendResponse parses an HTTP response from a CreateAclBackendWithResponse call
func ParseCreateAclBackendResponse(rsp *http.Response) (*CreateAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclBackendResponse parses an HTTP response from a ReplaceAclBackendWithResponse call
func ParseReplaceAclBackendResponse(rsp *http.Response) (*ReplaceAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllFilterBackendResponse parses an HTTP response from a GetAllFilterBackendWithResponse call
func ParseGetAllFilterBackendResponse(rsp *http.Response) (*GetAllFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllFilterBackendResponse parses an HTTP response from a ReplaceAllFilterBackendWithResponse call
func ParseReplaceAllFilterBackendResponse(rsp *http.Response) (*ReplaceAllFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFilterBackendResponse parses an HTTP response from a DeleteFilterBackendWithResponse call
func ParseDeleteFilterBackendResponse(rsp *http.Response) (*DeleteFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFilterBackendResponse parses an HTTP response from a GetFilterBackendWithResponse call
func ParseGetFilterBackendResponse(rsp *http.Response) (*GetFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFilterBackendResponse parses an HTTP response from a CreateFilterBackendWithResponse call
func ParseCreateFilterBackendResponse(rsp *http.Response) (*CreateFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFilterBackendResponse parses an HTTP response from a ReplaceFilterBackendWithResponse call
func ParseReplaceFilterBackendResponse(rsp *http.Response) (*ReplaceFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPAfterResponseRuleBackendResponse parses an HTTP response from a GetAllHTTPAfterResponseRuleBackendWithResponse call
func ParseGetAllHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*GetAllHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPAfterResponseRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPAfterResponseRuleBackendWithResponse call
func ParseReplaceAllHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPAfterResponseRuleBackendResponse parses an HTTP response from a DeleteHTTPAfterResponseRuleBackendWithResponse call
func ParseDeleteHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*DeleteHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPAfterResponseRuleBackendResponse parses an HTTP response from a GetHTTPAfterResponseRuleBackendWithResponse call
func ParseGetHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*GetHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPAfterResponseRuleBackendResponse parses an HTTP response from a CreateHTTPAfterResponseRuleBackendWithResponse call
func ParseCreateHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*CreateHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPAfterResponseRuleBackendResponse parses an HTTP response from a ReplaceHTTPAfterResponseRuleBackendWithResponse call
func ParseReplaceHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPCheckBackendResponse parses an HTTP response from a GetAllHTTPCheckBackendWithResponse call
func ParseGetAllHTTPCheckBackendResponse(rsp *http.Response) (*GetAllHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPCheckBackendResponse parses an HTTP response from a ReplaceAllHTTPCheckBackendWithResponse call
func ParseReplaceAllHTTPCheckBackendResponse(rsp *http.Response) (*ReplaceAllHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPCheckBackendResponse parses an HTTP response from a DeleteHTTPCheckBackendWithResponse call
func ParseDeleteHTTPCheckBackendResponse(rsp *http.Response) (*DeleteHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPCheckBackendResponse parses an HTTP response from a GetHTTPCheckBackendWithResponse call
func ParseGetHTTPCheckBackendResponse(rsp *http.Response) (*GetHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPCheckBackendResponse parses an HTTP response from a CreateHTTPCheckBackendWithResponse call
func ParseCreateHTTPCheckBackendResponse(rsp *http.Response) (*CreateHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPCheckBackendResponse parses an HTTP response from a ReplaceHTTPCheckBackendWithResponse call
func ParseReplaceHTTPCheckBackendResponse(rsp *http.Response) (*ReplaceHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPErrorRuleBackendResponse parses an HTTP response from a GetAllHTTPErrorRuleBackendWithResponse call
func ParseGetAllHTTPErrorRuleBackendResponse(rsp *http.Response) (*GetAllHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPErrorRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPErrorRuleBackendWithResponse call
func ParseReplaceAllHTTPErrorRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorRuleBackendResponse parses an HTTP response from a DeleteHTTPErrorRuleBackendWithResponse call
func ParseDeleteHTTPErrorRuleBackendResponse(rsp *http.Response) (*DeleteHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorRuleBackendResponse parses an HTTP response from a GetHTTPErrorRuleBackendWithResponse call
func ParseGetHTTPErrorRuleBackendResponse(rsp *http.Response) (*GetHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorRuleBackendResponse parses an HTTP response from a CreateHTTPErrorRuleBackendWithResponse call
func ParseCreateHTTPErrorRuleBackendResponse(rsp *http.Response) (*CreateHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorRuleBackendResponse parses an HTTP response from a ReplaceHTTPErrorRuleBackendWithResponse call
func ParseReplaceHTTPErrorRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPRequestRuleBackendResponse parses an HTTP response from a GetAllHTTPRequestRuleBackendWithResponse call
func ParseGetAllHTTPRequestRuleBackendResponse(rsp *http.Response) (*GetAllHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPRequestRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPRequestRuleBackendWithResponse call
func ParseReplaceAllHTTPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPRequestRuleBackendResponse parses an HTTP response from a DeleteHTTPRequestRuleBackendWithResponse call
func ParseDeleteHTTPRequestRuleBackendResponse(rsp *http.Response) (*DeleteHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPRequestRuleBackendResponse parses an HTTP response from a GetHTTPRequestRuleBackendWithResponse call
func ParseGetHTTPRequestRuleBackendResponse(rsp *http.Response) (*GetHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPRequestRuleBackendResponse parses an HTTP response from a CreateHTTPRequestRuleBackendWithResponse call
func ParseCreateHTTPRequestRuleBackendResponse(rsp *http.Response) (*CreateHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPRequestRuleBackendResponse parses an HTTP response from a ReplaceHTTPRequestRuleBackendWithResponse call
func ParseReplaceHTTPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPResponseRuleBackendResponse parses an HTTP response from a GetAllHTTPResponseRuleBackendWithResponse call
func ParseGetAllHTTPResponseRuleBackendResponse(rsp *http.Response) (*GetAllHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPResponseRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPResponseRuleBackendWithResponse call
func ParseReplaceAllHTTPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPResponseRuleBackendResponse parses an HTTP response from a DeleteHTTPResponseRuleBackendWithResponse call
func ParseDeleteHTTPResponseRuleBackendResponse(rsp *http.Response) (*DeleteHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPResponseRuleBackendResponse parses an HTTP response from a GetHTTPResponseRuleBackendWithResponse call
func ParseGetHTTPResponseRuleBackendResponse(rsp *http.Response) (*GetHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPResponseRuleBackendResponse parses an HTTP response from a CreateHTTPResponseRuleBackendWithResponse call
func ParseCreateHTTPResponseRuleBackendResponse(rsp *http.Response) (*CreateHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPResponseRuleBackendResponse parses an HTTP response from a ReplaceHTTPResponseRuleBackendWithResponse call
func ParseReplaceHTTPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetBackendResponse parses an HTTP response from a GetAllLogTargetBackendWithResponse call
func ParseGetAllLogTargetBackendResponse(rsp *http.Response) (*GetAllLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetBackendResponse parses an HTTP response from a ReplaceAllLogTargetBackendWithResponse call
func ParseReplaceAllLogTargetBackendResponse(rsp *http.Response) (*ReplaceAllLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetBackendResponse parses an HTTP response from a DeleteLogTargetBackendWithResponse call
func ParseDeleteLogTargetBackendResponse(rsp *http.Response) (*DeleteLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetBackendResponse parses an HTTP response from a GetLogTargetBackendWithResponse call
func ParseGetLogTargetBackendResponse(rsp *http.Response) (*GetLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetBackendResponse parses an HTTP response from a CreateLogTargetBackendWithResponse call
func ParseCreateLogTargetBackendResponse(rsp *http.Response) (*CreateLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetBackendResponse parses an HTTP response from a ReplaceLogTargetBackendWithResponse call
func ParseReplaceLogTargetBackendResponse(rsp *http.Response) (*ReplaceLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerSwitchingRulesResponse parses an HTTP response from a GetServerSwitchingRulesWithResponse call
func ParseGetServerSwitchingRulesResponse(rsp *http.Response) (*GetServerSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerSwitchingRulesResponse parses an HTTP response from a ReplaceServerSwitchingRulesWithResponse call
func ParseReplaceServerSwitchingRulesResponse(rsp *http.Response) (*ReplaceServerSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerSwitchingRuleResponse parses an HTTP response from a DeleteServerSwitchingRuleWithResponse call
func ParseDeleteServerSwitchingRuleResponse(rsp *http.Response) (*DeleteServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerSwitchingRuleResponse parses an HTTP response from a GetServerSwitchingRuleWithResponse call
func ParseGetServerSwitchingRuleResponse(rsp *http.Response) (*GetServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerSwitchingRuleResponse parses an HTTP response from a CreateServerSwitchingRuleWithResponse call
func ParseCreateServerSwitchingRuleResponse(rsp *http.Response) (*CreateServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerSwitchingRuleResponse parses an HTTP response from a ReplaceServerSwitchingRuleWithResponse call
func ParseReplaceServerSwitchingRuleResponse(rsp *http.Response) (*ReplaceServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerTemplatesResponse parses an HTTP response from a GetServerTemplatesWithResponse call
func ParseGetServerTemplatesResponse(rsp *http.Response) (*GetServerTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTemplates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerTemplateResponse parses an HTTP response from a CreateServerTemplateWithResponse call
func ParseCreateServerTemplateResponse(rsp *http.Response) (*CreateServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerTemplateResponse parses an HTTP response from a DeleteServerTemplateWithResponse call
func ParseDeleteServerTemplateResponse(rsp *http.Response) (*DeleteServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerTemplateResponse parses an HTTP response from a GetServerTemplateWithResponse call
func ParseGetServerTemplateResponse(rsp *http.Response) (*GetServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerTemplateResponse parses an HTTP response from a ReplaceServerTemplateWithResponse call
func ParseReplaceServerTemplateResponse(rsp *http.Response) (*ReplaceServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllServerBackendResponse parses an HTTP response from a GetAllServerBackendWithResponse call
func ParseGetAllServerBackendResponse(rsp *http.Response) (*GetAllServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Servers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerBackendResponse parses an HTTP response from a CreateServerBackendWithResponse call
func ParseCreateServerBackendResponse(rsp *http.Response) (*CreateServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerBackendResponse parses an HTTP response from a DeleteServerBackendWithResponse call
func ParseDeleteServerBackendResponse(rsp *http.Response) (*DeleteServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerBackendResponse parses an HTTP response from a GetServerBackendWithResponse call
func ParseGetServerBackendResponse(rsp *http.Response) (*GetServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerBackendResponse parses an HTTP response from a ReplaceServerBackendWithResponse call
func ParseReplaceServerBackendResponse(rsp *http.Response) (*ReplaceServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickRulesResponse parses an HTTP response from a GetStickRulesWithResponse call
func ParseGetStickRulesResponse(rsp *http.Response) (*GetStickRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStickRulesResponse parses an HTTP response from a ReplaceStickRulesWithResponse call
func ParseReplaceStickRulesResponse(rsp *http.Response) (*ReplaceStickRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStickRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest StickRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStickRuleResponse parses an HTTP response from a DeleteStickRuleWithResponse call
func ParseDeleteStickRuleResponse(rsp *http.Response) (*DeleteStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickRuleResponse parses an HTTP response from a GetStickRuleWithResponse call
func ParseGetStickRuleResponse(rsp *http.Response) (*GetStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStickRuleResponse parses an HTTP response from a CreateStickRuleWithResponse call
func ParseCreateStickRuleResponse(rsp *http.Response) (*CreateStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStickRuleResponse parses an HTTP response from a ReplaceStickRuleWithResponse call
func ParseReplaceStickRuleResponse(rsp *http.Response) (*ReplaceStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPCheckBackendResponse parses an HTTP response from a GetAllTCPCheckBackendWithResponse call
func ParseGetAllTCPCheckBackendResponse(rsp *http.Response) (*GetAllTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPCheckBackendResponse parses an HTTP response from a ReplaceAllTCPCheckBackendWithResponse call
func ParseReplaceAllTCPCheckBackendResponse(rsp *http.Response) (*ReplaceAllTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPCheckBackendResponse parses an HTTP response from a DeleteTCPCheckBackendWithResponse call
func ParseDeleteTCPCheckBackendResponse(rsp *http.Response) (*DeleteTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPCheckBackendResponse parses an HTTP response from a GetTCPCheckBackendWithResponse call
func ParseGetTCPCheckBackendResponse(rsp *http.Response) (*GetTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPCheckBackendResponse parses an HTTP response from a CreateTCPCheckBackendWithResponse call
func ParseCreateTCPCheckBackendResponse(rsp *http.Response) (*CreateTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPCheckBackendResponse parses an HTTP response from a ReplaceTCPCheckBackendWithResponse call
func ParseReplaceTCPCheckBackendResponse(rsp *http.Response) (*ReplaceTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPRequestRuleBackendResponse parses an HTTP response from a GetAllTCPRequestRuleBackendWithResponse call
func ParseGetAllTCPRequestRuleBackendResponse(rsp *http.Response) (*GetAllTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPRequestRuleBackendResponse parses an HTTP response from a ReplaceAllTCPRequestRuleBackendWithResponse call
func ParseReplaceAllTCPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceAllTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPRequestRuleBackendResponse parses an HTTP response from a DeleteTCPRequestRuleBackendWithResponse call
func ParseDeleteTCPRequestRuleBackendResponse(rsp *http.Response) (*DeleteTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPRequestRuleBackendResponse parses an HTTP response from a GetTCPRequestRuleBackendWithResponse call
func ParseGetTCPRequestRuleBackendResponse(rsp *http.Response) (*GetTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPRequestRuleBackendResponse parses an HTTP response from a CreateTCPRequestRuleBackendWithResponse call
func ParseCreateTCPRequestRuleBackendResponse(rsp *http.Response) (*CreateTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPRequestRuleBackendResponse parses an HTTP response from a ReplaceTCPRequestRuleBackendWithResponse call
func ParseReplaceTCPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPResponseRuleBackendResponse parses an HTTP response from a GetAllTCPResponseRuleBackendWithResponse call
func ParseGetAllTCPResponseRuleBackendResponse(rsp *http.Response) (*GetAllTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPResponseRuleBackendResponse parses an HTTP response from a ReplaceAllTCPResponseRuleBackendWithResponse call
func ParseReplaceAllTCPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceAllTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPResponseRuleBackendResponse parses an HTTP response from a DeleteTCPResponseRuleBackendWithResponse call
func ParseDeleteTCPResponseRuleBackendResponse(rsp *http.Response) (*DeleteTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPResponseRuleBackendResponse parses an HTTP response from a GetTCPResponseRuleBackendWithResponse call
func ParseGetTCPResponseRuleBackendResponse(rsp *http.Response) (*GetTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPResponseRuleBackendResponse parses an HTTP response from a CreateTCPResponseRuleBackendWithResponse call
func ParseCreateTCPResponseRuleBackendResponse(rsp *http.Response) (*CreateTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPResponseRuleBackendResponse parses an HTTP response from a ReplaceTCPResponseRuleBackendWithResponse call
func ParseReplaceTCPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCachesResponse parses an HTTP response from a GetCachesWithResponse call
func ParseGetCachesResponse(rsp *http.Response) (*GetCachesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCachesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Caches
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCacheResponse parses an HTTP response from a CreateCacheWithResponse call
func ParseCreateCacheResponse(rsp *http.Response) (*CreateCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCacheResponse parses an HTTP response from a DeleteCacheWithResponse call
func ParseDeleteCacheResponse(rsp *http.Response) (*DeleteCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCacheResponse parses an HTTP response from a GetCacheWithResponse call
func ParseGetCacheResponse(rsp *http.Response) (*GetCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceCacheResponse parses an HTTP response from a ReplaceCacheWithResponse call
func ParseReplaceCacheResponse(rsp *http.Response) (*ReplaceCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtLoadsResponse parses an HTTP response from a GetCrtLoadsWithResponse call
func ParseGetCrtLoadsResponse(rsp *http.Response) (*GetCrtLoadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtLoadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtLoads
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCrtLoadResponse parses an HTTP response from a CreateCrtLoadWithResponse call
func ParseCreateCrtLoadResponse(rsp *http.Response) (*CreateCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCrtLoadResponse parses an HTTP response from a DeleteCrtLoadWithResponse call
func ParseDeleteCrtLoadResponse(rsp *http.Response) (*DeleteCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtLoadResponse parses an HTTP response from a GetCrtLoadWithResponse call
func ParseGetCrtLoadResponse(rsp *http.Response) (*GetCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceCrtLoadResponse parses an HTTP response from a ReplaceCrtLoadWithResponse call
func ParseReplaceCrtLoadResponse(rsp *http.Response) (*ReplaceCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtStoresResponse parses an HTTP response from a GetCrtStoresWithResponse call
func ParseGetCrtStoresResponse(rsp *http.Response) (*GetCrtStoresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtStoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtStores
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCrtStoreResponse parses an HTTP response from a CreateCrtStoreWithResponse call
func ParseCreateCrtStoreResponse(rsp *http.Response) (*CreateCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCrtStoreResponse parses an HTTP response from a DeleteCrtStoreWithResponse call
func ParseDeleteCrtStoreResponse(rsp *http.Response) (*DeleteCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtStoreResponse parses an HTTP response from a GetCrtStoreWithResponse call
func ParseGetCrtStoreResponse(rsp *http.Response) (*GetCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditCrtStoreResponse parses an HTTP response from a EditCrtStoreWithResponse call
func ParseEditCrtStoreResponse(rsp *http.Response) (*EditCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDefaultsSectionsResponse parses an HTTP response from a GetDefaultsSectionsWithResponse call
func ParseGetDefaultsSectionsResponse(rsp *http.Response) (*GetDefaultsSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultsSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DefaultsSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddDefaultsSectionResponse parses an HTTP response from a AddDefaultsSectionWithResponse call
func ParseAddDefaultsSectionResponse(rsp *http.Response) (*AddDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDefaultsSectionResponse parses an HTTP response from a CreateDefaultsSectionWithResponse call
func ParseCreateDefaultsSectionResponse(rsp *http.Response) (*CreateDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDefaultsSectionResponse parses an HTTP response from a DeleteDefaultsSectionWithResponse call
func ParseDeleteDefaultsSectionResponse(rsp *http.Response) (*DeleteDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDefaultsSectionResponse parses an HTTP response from a GetDefaultsSectionWithResponse call
func ParseGetDefaultsSectionResponse(rsp *http.Response) (*GetDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDefaultsSectionResponse parses an HTTP response from a ReplaceDefaultsSectionWithResponse call
func ParseReplaceDefaultsSectionResponse(rsp *http.Response) (*ReplaceDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclDefaultsResponse parses an HTTP response from a GetAllAclDefaultsWithResponse call
func ParseGetAllAclDefaultsResponse(rsp *http.Response) (*GetAllAclDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclDefaultsResponse parses an HTTP response from a ReplaceAllAclDefaultsWithResponse call
func ParseReplaceAllAclDefaultsResponse(rsp *http.Response) (*ReplaceAllAclDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclDefaultsResponse parses an HTTP response from a DeleteAclDefaultsWithResponse call
func ParseDeleteAclDefaultsResponse(rsp *http.Response) (*DeleteAclDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclDefaultsResponse parses an HTTP response from a GetAclDefaultsWithResponse call
func ParseGetAclDefaultsResponse(rsp *http.Response) (*GetAclDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclDefaultsResponse parses an HTTP response from a CreateAclDefaultsWithResponse call
func ParseCreateAclDefaultsResponse(rsp *http.Response) (*CreateAclDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclDefaultsResponse parses an HTTP response from a ReplaceAclDefaultsWithResponse call
func ParseReplaceAclDefaultsResponse(rsp *http.Response) (*ReplaceAclDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPAfterResponseRuleDefaultsResponse parses an HTTP response from a GetAllHTTPAfterResponseRuleDefaultsWithResponse call
func ParseGetAllHTTPAfterResponseRuleDefaultsResponse(rsp *http.Response) (*GetAllHTTPAfterResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPAfterResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPAfterResponseRuleDefaultsResponse parses an HTTP response from a ReplaceAllHTTPAfterResponseRuleDefaultsWithResponse call
func ParseReplaceAllHTTPAfterResponseRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllHTTPAfterResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPAfterResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPAfterResponseRuleDefaultsResponse parses an HTTP response from a DeleteHTTPAfterResponseRuleDefaultsWithResponse call
func ParseDeleteHTTPAfterResponseRuleDefaultsResponse(rsp *http.Response) (*DeleteHTTPAfterResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPAfterResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPAfterResponseRuleDefaultsResponse parses an HTTP response from a GetHTTPAfterResponseRuleDefaultsWithResponse call
func ParseGetHTTPAfterResponseRuleDefaultsResponse(rsp *http.Response) (*GetHTTPAfterResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPAfterResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPAfterResponseRuleDefaultsResponse parses an HTTP response from a CreateHTTPAfterResponseRuleDefaultsWithResponse call
func ParseCreateHTTPAfterResponseRuleDefaultsResponse(rsp *http.Response) (*CreateHTTPAfterResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPAfterResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPAfterResponseRuleDefaultsResponse parses an HTTP response from a ReplaceHTTPAfterResponseRuleDefaultsWithResponse call
func ParseReplaceHTTPAfterResponseRuleDefaultsResponse(rsp *http.Response) (*ReplaceHTTPAfterResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPAfterResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPCheckDefaultsResponse parses an HTTP response from a GetAllHTTPCheckDefaultsWithResponse call
func ParseGetAllHTTPCheckDefaultsResponse(rsp *http.Response) (*GetAllHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPCheckDefaultsResponse parses an HTTP response from a ReplaceAllHTTPCheckDefaultsWithResponse call
func ParseReplaceAllHTTPCheckDefaultsResponse(rsp *http.Response) (*ReplaceAllHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPCheckDefaultsResponse parses an HTTP response from a DeleteHTTPCheckDefaultsWithResponse call
func ParseDeleteHTTPCheckDefaultsResponse(rsp *http.Response) (*DeleteHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPCheckDefaultsResponse parses an HTTP response from a GetHTTPCheckDefaultsWithResponse call
func ParseGetHTTPCheckDefaultsResponse(rsp *http.Response) (*GetHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPCheckDefaultsResponse parses an HTTP response from a CreateHTTPCheckDefaultsWithResponse call
func ParseCreateHTTPCheckDefaultsResponse(rsp *http.Response) (*CreateHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPCheckDefaultsResponse parses an HTTP response from a ReplaceHTTPCheckDefaultsWithResponse call
func ParseReplaceHTTPCheckDefaultsResponse(rsp *http.Response) (*ReplaceHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPErrorRuleDefaultsResponse parses an HTTP response from a GetAllHTTPErrorRuleDefaultsWithResponse call
func ParseGetAllHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*GetAllHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPErrorRuleDefaultsResponse parses an HTTP response from a ReplaceAllHTTPErrorRuleDefaultsWithResponse call
func ParseReplaceAllHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorRuleDefaultsResponse parses an HTTP response from a DeleteHTTPErrorRuleDefaultsWithResponse call
func ParseDeleteHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*DeleteHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorRuleDefaultsResponse parses an HTTP response from a GetHTTPErrorRuleDefaultsWithResponse call
func ParseGetHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*GetHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorRuleDefaultsResponse parses an HTTP response from a CreateHTTPErrorRuleDefaultsWithResponse call
func ParseCreateHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*CreateHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorRuleDefaultsResponse parses an HTTP response from a ReplaceHTTPErrorRuleDefaultsWithResponse call
func ParseReplaceHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*ReplaceHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPRequestRuleDefaultsResponse parses an HTTP response from a GetAllHTTPRequestRuleDefaultsWithResponse call
func ParseGetAllHTTPRequestRuleDefaultsResponse(rsp *http.Response) (*GetAllHTTPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPRequestRuleDefaultsResponse parses an HTTP response from a ReplaceAllHTTPRequestRuleDefaultsWithResponse call
func ParseReplaceAllHTTPRequestRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllHTTPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPRequestRuleDefaultsResponse parses an HTTP response from a DeleteHTTPRequestRuleDefaultsWithResponse call
func ParseDeleteHTTPRequestRuleDefaultsResponse(rsp *http.Response) (*DeleteHTTPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPRequestRuleDefaultsResponse parses an HTTP response from a GetHTTPRequestRuleDefaultsWithResponse call
func ParseGetHTTPRequestRuleDefaultsResponse(rsp *http.Response) (*GetHTTPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPRequestRuleDefaultsResponse parses an HTTP response from a CreateHTTPRequestRuleDefaultsWithResponse call
func ParseCreateHTTPRequestRuleDefaultsResponse(rsp *http.Response) (*CreateHTTPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPRequestRuleDefaultsResponse parses an HTTP response from a ReplaceHTTPRequestRuleDefaultsWithResponse call
func ParseReplaceHTTPRequestRuleDefaultsResponse(rsp *http.Response) (*ReplaceHTTPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPResponseRuleDefaultsResponse parses an HTTP response from a GetAllHTTPResponseRuleDefaultsWithResponse call
func ParseGetAllHTTPResponseRuleDefaultsResponse(rsp *http.Response) (*GetAllHTTPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPResponseRuleDefaultsResponse parses an HTTP response from a ReplaceAllHTTPResponseRuleDefaultsWithResponse call
func ParseReplaceAllHTTPResponseRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllHTTPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPResponseRuleDefaultsResponse parses an HTTP response from a DeleteHTTPResponseRuleDefaultsWithResponse call
func ParseDeleteHTTPResponseRuleDefaultsResponse(rsp *http.Response) (*DeleteHTTPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPResponseRuleDefaultsResponse parses an HTTP response from a GetHTTPResponseRuleDefaultsWithResponse call
func ParseGetHTTPResponseRuleDefaultsResponse(rsp *http.Response) (*GetHTTPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPResponseRuleDefaultsResponse parses an HTTP response from a CreateHTTPResponseRuleDefaultsWithResponse call
func ParseCreateHTTPResponseRuleDefaultsResponse(rsp *http.Response) (*CreateHTTPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPResponseRuleDefaultsResponse parses an HTTP response from a ReplaceHTTPResponseRuleDefaultsWithResponse call
func ParseReplaceHTTPResponseRuleDefaultsResponse(rsp *http.Response) (*ReplaceHTTPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetDefaultsResponse parses an HTTP response from a GetAllLogTargetDefaultsWithResponse call
func ParseGetAllLogTargetDefaultsResponse(rsp *http.Response) (*GetAllLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetDefaultsResponse parses an HTTP response from a ReplaceAllLogTargetDefaultsWithResponse call
func ParseReplaceAllLogTargetDefaultsResponse(rsp *http.Response) (*ReplaceAllLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetDefaultsResponse parses an HTTP response from a DeleteLogTargetDefaultsWithResponse call
func ParseDeleteLogTargetDefaultsResponse(rsp *http.Response) (*DeleteLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetDefaultsResponse parses an HTTP response from a GetLogTargetDefaultsWithResponse call
func ParseGetLogTargetDefaultsResponse(rsp *http.Response) (*GetLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetDefaultsResponse parses an HTTP response from a CreateLogTargetDefaultsWithResponse call
func ParseCreateLogTargetDefaultsResponse(rsp *http.Response) (*CreateLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetDefaultsResponse parses an HTTP response from a ReplaceLogTargetDefaultsWithResponse call
func ParseReplaceLogTargetDefaultsResponse(rsp *http.Response) (*ReplaceLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllQUICInitialRuleDefaultsResponse parses an HTTP response from a GetAllQUICInitialRuleDefaultsWithResponse call
func ParseGetAllQUICInitialRuleDefaultsResponse(rsp *http.Response) (*GetAllQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllQUICInitialRuleDefaultsResponse parses an HTTP response from a ReplaceAllQUICInitialRuleDefaultsWithResponse call
func ParseReplaceAllQUICInitialRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteQUICInitialRuleDefaultsResponse parses an HTTP response from a DeleteQUICInitialRuleDefaultsWithResponse call
func ParseDeleteQUICInitialRuleDefaultsResponse(rsp *http.Response) (*DeleteQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetQUICInitialRuleDefaultsResponse parses an HTTP response from a GetQUICInitialRuleDefaultsWithResponse call
func ParseGetQUICInitialRuleDefaultsResponse(rsp *http.Response) (*GetQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateQUICInitialRuleDefaultsResponse parses an HTTP response from a CreateQUICInitialRuleDefaultsWithResponse call
func ParseCreateQUICInitialRuleDefaultsResponse(rsp *http.Response) (*CreateQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceQUICInitialRuleDefaultsResponse parses an HTTP response from a ReplaceQUICInitialRuleDefaultsWithResponse call
func ParseReplaceQUICInitialRuleDefaultsResponse(rsp *http.Response) (*ReplaceQUICInitialRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceQUICInitialRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPCheckDefaultsResponse parses an HTTP response from a GetAllTCPCheckDefaultsWithResponse call
func ParseGetAllTCPCheckDefaultsResponse(rsp *http.Response) (*GetAllTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPCheckDefaultsResponse parses an HTTP response from a ReplaceAllTCPCheckDefaultsWithResponse call
func ParseReplaceAllTCPCheckDefaultsResponse(rsp *http.Response) (*ReplaceAllTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPCheckDefaultsResponse parses an HTTP response from a DeleteTCPCheckDefaultsWithResponse call
func ParseDeleteTCPCheckDefaultsResponse(rsp *http.Response) (*DeleteTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPCheckDefaultsResponse parses an HTTP response from a GetTCPCheckDefaultsWithResponse call
func ParseGetTCPCheckDefaultsResponse(rsp *http.Response) (*GetTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPCheckDefaultsResponse parses an HTTP response from a CreateTCPCheckDefaultsWithResponse call
func ParseCreateTCPCheckDefaultsResponse(rsp *http.Response) (*CreateTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPCheckDefaultsResponse parses an HTTP response from a ReplaceTCPCheckDefaultsWithResponse call
func ParseReplaceTCPCheckDefaultsResponse(rsp *http.Response) (*ReplaceTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPRequestRuleDefaultsResponse parses an HTTP response from a GetAllTCPRequestRuleDefaultsWithResponse call
func ParseGetAllTCPRequestRuleDefaultsResponse(rsp *http.Response) (*GetAllTCPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPRequestRuleDefaultsResponse parses an HTTP response from a ReplaceAllTCPRequestRuleDefaultsWithResponse call
func ParseReplaceAllTCPRequestRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllTCPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPRequestRuleDefaultsResponse parses an HTTP response from a DeleteTCPRequestRuleDefaultsWithResponse call
func ParseDeleteTCPRequestRuleDefaultsResponse(rsp *http.Response) (*DeleteTCPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPRequestRuleDefaultsResponse parses an HTTP response from a GetTCPRequestRuleDefaultsWithResponse call
func ParseGetTCPRequestRuleDefaultsResponse(rsp *http.Response) (*GetTCPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPRequestRuleDefaultsResponse parses an HTTP response from a CreateTCPRequestRuleDefaultsWithResponse call
func ParseCreateTCPRequestRuleDefaultsResponse(rsp *http.Response) (*CreateTCPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPRequestRuleDefaultsResponse parses an HTTP response from a ReplaceTCPRequestRuleDefaultsWithResponse call
func ParseReplaceTCPRequestRuleDefaultsResponse(rsp *http.Response) (*ReplaceTCPRequestRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPRequestRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPResponseRuleDefaultsResponse parses an HTTP response from a GetAllTCPResponseRuleDefaultsWithResponse call
func ParseGetAllTCPResponseRuleDefaultsResponse(rsp *http.Response) (*GetAllTCPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPResponseRuleDefaultsResponse parses an HTTP response from a ReplaceAllTCPResponseRuleDefaultsWithResponse call
func ParseReplaceAllTCPResponseRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllTCPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPResponseRuleDefaultsResponse parses an HTTP response from a DeleteTCPResponseRuleDefaultsWithResponse call
func ParseDeleteTCPResponseRuleDefaultsResponse(rsp *http.Response) (*DeleteTCPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPResponseRuleDefaultsResponse parses an HTTP response from a GetTCPResponseRuleDefaultsWithResponse call
func ParseGetTCPResponseRuleDefaultsResponse(rsp *http.Response) (*GetTCPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPResponseRuleDefaultsResponse parses an HTTP response from a CreateTCPResponseRuleDefaultsWithResponse call
func ParseCreateTCPResponseRuleDefaultsResponse(rsp *http.Response) (*CreateTCPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPResponseRuleDefaultsResponse parses an HTTP response from a ReplaceTCPResponseRuleDefaultsWithResponse call
func ParseReplaceTCPResponseRuleDefaultsResponse(rsp *http.Response) (*ReplaceTCPResponseRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPResponseRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFCGIAppsResponse parses an HTTP response from a GetFCGIAppsWithResponse call
func ParseGetFCGIAppsResponse(rsp *http.Response) (*GetFCGIAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFCGIAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FcgiApps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFCGIAppResponse parses an HTTP response from a CreateFCGIAppWithResponse call
func ParseCreateFCGIAppResponse(rsp *http.Response) (*CreateFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFCGIAppResponse parses an HTTP response from a DeleteFCGIAppWithResponse call
func ParseDeleteFCGIAppResponse(rsp *http.Response) (*DeleteFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFCGIAppResponse parses an HTTP response from a GetFCGIAppWithResponse call
func ParseGetFCGIAppResponse(rsp *http.Response) (*GetFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFCGIAppResponse parses an HTTP response from a ReplaceFCGIAppWithResponse call
func ParseReplaceFCGIAppResponse(rsp *http.Response) (*ReplaceFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclFCGIAppResponse parses an HTTP response from a GetAllAclFCGIAppWithResponse call
func ParseGetAllAclFCGIAppResponse(rsp *http.Response) (*GetAllAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclFCGIAppResponse parses an HTTP response from a ReplaceAllAclFCGIAppWithResponse call
func ParseReplaceAllAclFCGIAppResponse(rsp *http.Response) (*ReplaceAllAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclFCGIAppResponse parses an HTTP response from a DeleteAclFCGIAppWithResponse call
func ParseDeleteAclFCGIAppResponse(rsp *http.Response) (*DeleteAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclFCGIAppResponse parses an HTTP response from a GetAclFCGIAppWithResponse call
func ParseGetAclFCGIAppResponse(rsp *http.Response) (*GetAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclFCGIAppResponse parses an HTTP response from a CreateAclFCGIAppWithResponse call
func ParseCreateAclFCGIAppResponse(rsp *http.Response) (*CreateAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclFCGIAppResponse parses an HTTP response from a ReplaceAclFCGIAppWithResponse call
func ParseReplaceAclFCGIAppResponse(rsp *http.Response) (*ReplaceAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFrontendsResponse parses an HTTP response from a GetFrontendsWithResponse call
func ParseGetFrontendsResponse(rsp *http.Response) (*GetFrontendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFrontendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Frontends
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFrontendResponse parses an HTTP response from a CreateFrontendWithResponse call
func ParseCreateFrontendResponse(rsp *http.Response) (*CreateFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFrontendResponse parses an HTTP response from a DeleteFrontendWithResponse call
func ParseDeleteFrontendResponse(rsp *http.Response) (*DeleteFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFrontendResponse parses an HTTP response from a GetFrontendWithResponse call
func ParseGetFrontendResponse(rsp *http.Response) (*GetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFrontendResponse parses an HTTP response from a ReplaceFrontendWithResponse call
func ParseReplaceFrontendResponse(rsp *http.Response) (*ReplaceFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclFrontendResponse parses an HTTP response from a GetAllAclFrontendWithResponse call
func ParseGetAllAclFrontendResponse(rsp *http.Response) (*GetAllAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclFrontendResponse parses an HTTP response from a ReplaceAllAclFrontendWithResponse call
func ParseReplaceAllAclFrontendResponse(rsp *http.Response) (*ReplaceAllAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclFrontendResponse parses an HTTP response from a DeleteAclFrontendWithResponse call
func ParseDeleteAclFrontendResponse(rsp *http.Response) (*DeleteAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclFrontendResponse parses an HTTP response from a GetAclFrontendWithResponse call
func ParseGetAclFrontendResponse(rsp *http.Response) (*GetAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclFrontendResponse parses an HTTP response from a CreateAclFrontendWithResponse call
func ParseCreateAclFrontendResponse(rsp *http.Response) (*CreateAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclFrontendResponse parses an HTTP response from a ReplaceAclFrontendWithResponse call
func ParseReplaceAclFrontendResponse(rsp *http.Response) (*ReplaceAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendSwitchingRulesResponse parses an HTTP response from a GetBackendSwitchingRulesWithResponse call
func ParseGetBackendSwitchingRulesResponse(rsp *http.Response) (*GetBackendSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBackendSwitchingRulesResponse parses an HTTP response from a ReplaceBackendSwitchingRulesWithResponse call
func ParseReplaceBackendSwitchingRulesResponse(rsp *http.Response) (*ReplaceBackendSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBackendSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackendSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBackendSwitchingRuleResponse parses an HTTP response from a DeleteBackendSwitchingRuleWithResponse call
func ParseDeleteBackendSwitchingRuleResponse(rsp *http.Response) (*DeleteBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendSwitchingRuleResponse parses an HTTP response from a GetBackendSwitchingRuleWithResponse call
func ParseGetBackendSwitchingRuleResponse(rsp *http.Response) (*GetBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBackendSwitchingRuleResponse parses an HTTP response from a CreateBackendSwitchingRuleWithResponse call
func ParseCreateBackendSwitchingRuleResponse(rsp *http.Response) (*CreateBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBackendSwitchingRuleResponse parses an HTTP response from a ReplaceBackendSwitchingRuleWithResponse call
func ParseReplaceBackendSwitchingRuleResponse(rsp *http.Response) (*ReplaceBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllBindFrontendResponse parses an HTTP response from a GetAllBindFrontendWithResponse call
func ParseGetAllBindFrontendResponse(rsp *http.Response) (*GetAllBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBindFrontendResponse parses an HTTP response from a CreateBindFrontendWithResponse call
func ParseCreateBindFrontendResponse(rsp *http.Response) (*CreateBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBindFrontendResponse parses an HTTP response from a DeleteBindFrontendWithResponse call
func ParseDeleteBindFrontendResponse(rsp *http.Response) (*DeleteBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBindFrontendResponse parses an HTTP response from a GetBindFrontendWithResponse call
func ParseGetBindFrontendResponse(rsp *http.Response) (*GetBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBindFrontendResponse parses an HTTP response from a ReplaceBindFrontendWithResponse call
func ParseReplaceBindFrontendResponse(rsp *http.Response) (*ReplaceBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeclareCapturesResponse parses an HTTP response from a GetDeclareCapturesWithResponse call
func ParseGetDeclareCapturesResponse(rsp *http.Response) (*GetDeclareCapturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeclareCapturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Captures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDeclareCapturesResponse parses an HTTP response from a ReplaceDeclareCapturesWithResponse call
func ParseReplaceDeclareCapturesResponse(rsp *http.Response) (*ReplaceDeclareCapturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDeclareCapturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Captures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Captures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDeclareCaptureResponse parses an HTTP response from a DeleteDeclareCaptureWithResponse call
func ParseDeleteDeclareCaptureResponse(rsp *http.Response) (*DeleteDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeclareCaptureResponse parses an HTTP response from a GetDeclareCaptureWithResponse call
func ParseGetDeclareCaptureResponse(rsp *http.Response) (*GetDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDeclareCaptureResponse parses an HTTP response from a CreateDeclareCaptureWithResponse call
func ParseCreateDeclareCaptureResponse(rsp *http.Response) (*CreateDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDeclareCaptureResponse parses an HTTP response from a ReplaceDeclareCaptureWithResponse call
func ParseReplaceDeclareCaptureResponse(rsp *http.Response) (*ReplaceDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllFilterFrontendResponse parses an HTTP response from a GetAllFilterFrontendWithResponse call
func ParseGetAllFilterFrontendResponse(rsp *http.Response) (*GetAllFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllFilterFrontendResponse parses an HTTP response from a ReplaceAllFilterFrontendWithResponse call
func ParseReplaceAllFilterFrontendResponse(rsp *http.Response) (*ReplaceAllFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFilterFrontendResponse parses an HTTP response from a DeleteFilterFrontendWithResponse call
func ParseDeleteFilterFrontendResponse(rsp *http.Response) (*DeleteFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFilterFrontendResponse parses an HTTP response from a GetFilterFrontendWithResponse call
func ParseGetFilterFrontendResponse(rsp *http.Response) (*GetFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFilterFrontendResponse parses an HTTP response from a CreateFilterFrontendWithResponse call
func ParseCreateFilterFrontendResponse(rsp *http.Response) (*CreateFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFilterFrontendResponse parses an HTTP response from a ReplaceFilterFrontendWithResponse call
func ParseReplaceFilterFrontendResponse(rsp *http.Response) (*ReplaceFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a GetAllHTTPAfterResponseRuleFrontendWithResponse call
func ParseGetAllHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPAfterResponseRuleFrontendWithResponse call
func ParseReplaceAllHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a DeleteHTTPAfterResponseRuleFrontendWithResponse call
func ParseDeleteHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a GetHTTPAfterResponseRuleFrontendWithResponse call
func ParseGetHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*GetHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a CreateHTTPAfterResponseRuleFrontendWithResponse call
func ParseCreateHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*CreateHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a ReplaceHTTPAfterResponseRuleFrontendWithResponse call
func ParseReplaceHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPErrorRuleFrontendResponse parses an HTTP response from a GetAllHTTPErrorRuleFrontendWithResponse call
func ParseGetAllHTTPErrorRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPErrorRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPErrorRuleFrontendWithResponse call
func ParseReplaceAllHTTPErrorRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorRuleFrontendResponse parses an HTTP response from a DeleteHTTPErrorRuleFrontendWithResponse call
func ParseDeleteHTTPErrorRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorRuleFrontendResponse parses an HTTP response from a GetHTTPErrorRuleFrontendWithResponse call
func ParseGetHTTPErrorRuleFrontendResponse(rsp *http.Response) (*GetHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorRuleFrontendResponse parses an HTTP response from a CreateHTTPErrorRuleFrontendWithResponse call
func ParseCreateHTTPErrorRuleFrontendResponse(rsp *http.Response) (*CreateHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorRuleFrontendResponse parses an HTTP response from a ReplaceHTTPErrorRuleFrontendWithResponse call
func ParseReplaceHTTPErrorRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPRequestRuleFrontendResponse parses an HTTP response from a GetAllHTTPRequestRuleFrontendWithResponse call
func ParseGetAllHTTPRequestRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPRequestRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPRequestRuleFrontendWithResponse call
func ParseReplaceAllHTTPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPRequestRuleFrontendResponse parses an HTTP response from a DeleteHTTPRequestRuleFrontendWithResponse call
func ParseDeleteHTTPRequestRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPRequestRuleFrontendResponse parses an HTTP response from a GetHTTPRequestRuleFrontendWithResponse call
func ParseGetHTTPRequestRuleFrontendResponse(rsp *http.Response) (*GetHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPRequestRuleFrontendResponse parses an HTTP response from a CreateHTTPRequestRuleFrontendWithResponse call
func ParseCreateHTTPRequestRuleFrontendResponse(rsp *http.Response) (*CreateHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPRequestRuleFrontendResponse parses an HTTP response from a ReplaceHTTPRequestRuleFrontendWithResponse call
func ParseReplaceHTTPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPResponseRuleFrontendResponse parses an HTTP response from a GetAllHTTPResponseRuleFrontendWithResponse call
func ParseGetAllHTTPResponseRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPResponseRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPResponseRuleFrontendWithResponse call
func ParseReplaceAllHTTPResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPResponseRuleFrontendResponse parses an HTTP response from a DeleteHTTPResponseRuleFrontendWithResponse call
func ParseDeleteHTTPResponseRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPResponseRuleFrontendResponse parses an HTTP response from a GetHTTPResponseRuleFrontendWithResponse call
func ParseGetHTTPResponseRuleFrontendResponse(rsp *http.Response) (*GetHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPResponseRuleFrontendResponse parses an HTTP response from a CreateHTTPResponseRuleFrontendWithResponse call
func ParseCreateHTTPResponseRuleFrontendResponse(rsp *http.Response) (*CreateHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPResponseRuleFrontendResponse parses an HTTP response from a ReplaceHTTPResponseRuleFrontendWithResponse call
func ParseReplaceHTTPResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetFrontendResponse parses an HTTP response from a GetAllLogTargetFrontendWithResponse call
func ParseGetAllLogTargetFrontendResponse(rsp *http.Response) (*GetAllLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetFrontendResponse parses an HTTP response from a ReplaceAllLogTargetFrontendWithResponse call
func ParseReplaceAllLogTargetFrontendResponse(rsp *http.Response) (*ReplaceAllLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetFrontendResponse parses an HTTP response from a DeleteLogTargetFrontendWithResponse call
func ParseDeleteLogTargetFrontendResponse(rsp *http.Response) (*DeleteLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetFrontendResponse parses an HTTP response from a GetLogTargetFrontendWithResponse call
func ParseGetLogTargetFrontendResponse(rsp *http.Response) (*GetLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetFrontendResponse parses an HTTP response from a CreateLogTargetFrontendWithResponse call
func ParseCreateLogTargetFrontendResponse(rsp *http.Response) (*CreateLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetFrontendResponse parses an HTTP response from a ReplaceLogTargetFrontendWithResponse call
func ParseReplaceLogTargetFrontendResponse(rsp *http.Response) (*ReplaceLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllQUICInitialRuleFrontendResponse parses an HTTP response from a GetAllQUICInitialRuleFrontendWithResponse call
func ParseGetAllQUICInitialRuleFrontendResponse(rsp *http.Response) (*GetAllQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllQUICInitialRuleFrontendResponse parses an HTTP response from a ReplaceAllQUICInitialRuleFrontendWithResponse call
func ParseReplaceAllQUICInitialRuleFrontendResponse(rsp *http.Response) (*ReplaceAllQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteQUICInitialRuleFrontendResponse parses an HTTP response from a DeleteQUICInitialRuleFrontendWithResponse call
func ParseDeleteQUICInitialRuleFrontendResponse(rsp *http.Response) (*DeleteQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetQUICInitialRuleFrontendResponse parses an HTTP response from a GetQUICInitialRuleFrontendWithResponse call
func ParseGetQUICInitialRuleFrontendResponse(rsp *http.Response) (*GetQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateQUICInitialRuleFrontendResponse parses an HTTP response from a CreateQUICInitialRuleFrontendWithResponse call
func ParseCreateQUICInitialRuleFrontendResponse(rsp *http.Response) (*CreateQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceQUICInitialRuleFrontendResponse parses an HTTP response from a ReplaceQUICInitialRuleFrontendWithResponse call
func ParseReplaceQUICInitialRuleFrontendResponse(rsp *http.Response) (*ReplaceQUICInitialRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceQUICInitialRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest QUICInitialRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSSLFrontUsesResponse parses an HTTP response from a GetAllSSLFrontUsesWithResponse call
func ParseGetAllSSLFrontUsesResponse(rsp *http.Response) (*GetAllSSLFrontUsesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSSLFrontUsesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SSLFrontUses
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSSLFrontUseResponse parses an HTTP response from a CreateSSLFrontUseWithResponse call
func ParseCreateSSLFrontUseResponse(rsp *http.Response) (*CreateSSLFrontUseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSSLFrontUseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SSLFrontUse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SSLFrontUse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSSLFrontUseResponse parses an HTTP response from a DeleteSSLFrontUseWithResponse call
func ParseDeleteSSLFrontUseResponse(rsp *http.Response) (*DeleteSSLFrontUseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSSLFrontUseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSSLFrontUseResponse parses an HTTP response from a GetSSLFrontUseWithResponse call
func ParseGetSSLFrontUseResponse(rsp *http.Response) (*GetSSLFrontUseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSSLFrontUseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SSLFrontUse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSSLFrontUseResponse parses an HTTP response from a ReplaceSSLFrontUseWithResponse call
func ParseReplaceSSLFrontUseResponse(rsp *http.Response) (*ReplaceSSLFrontUseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSSLFrontUseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SSLFrontUse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SSLFrontUse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPRequestRuleFrontendResponse parses an HTTP response from a GetAllTCPRequestRuleFrontendWithResponse call
func ParseGetAllTCPRequestRuleFrontendResponse(rsp *http.Response) (*GetAllTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPRequestRuleFrontendResponse parses an HTTP response from a ReplaceAllTCPRequestRuleFrontendWithResponse call
func ParseReplaceAllTCPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceAllTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPRequestRuleFrontendResponse parses an HTTP response from a DeleteTCPRequestRuleFrontendWithResponse call
func ParseDeleteTCPRequestRuleFrontendResponse(rsp *http.Response) (*DeleteTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPRequestRuleFrontendResponse parses an HTTP response from a GetTCPRequestRuleFrontendWithResponse call
func ParseGetTCPRequestRuleFrontendResponse(rsp *http.Response) (*GetTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPRequestRuleFrontendResponse parses an HTTP response from a CreateTCPRequestRuleFrontendWithResponse call
func ParseCreateTCPRequestRuleFrontendResponse(rsp *http.Response) (*CreateTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPRequestRuleFrontendResponse parses an HTTP response from a ReplaceTCPRequestRuleFrontendWithResponse call
func ParseReplaceTCPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGlobalResponse parses an HTTP response from a GetGlobalWithResponse call
func ParseGetGlobalResponse(rsp *http.Response) (*GetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceGlobalResponse parses an HTTP response from a ReplaceGlobalWithResponse call
func ParseReplaceGlobalResponse(rsp *http.Response) (*ReplaceGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetGlobalResponse parses an HTTP response from a GetAllLogTargetGlobalWithResponse call
func ParseGetAllLogTargetGlobalResponse(rsp *http.Response) (*GetAllLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetGlobalResponse parses an HTTP response from a ReplaceAllLogTargetGlobalWithResponse call
func ParseReplaceAllLogTargetGlobalResponse(rsp *http.Response) (*ReplaceAllLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetGlobalResponse parses an HTTP response from a DeleteLogTargetGlobalWithResponse call
func ParseDeleteLogTargetGlobalResponse(rsp *http.Response) (*DeleteLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetGlobalResponse parses an HTTP response from a GetLogTargetGlobalWithResponse call
func ParseGetLogTargetGlobalResponse(rsp *http.Response) (*GetLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetGlobalResponse parses an HTTP response from a CreateLogTargetGlobalWithResponse call
func ParseCreateLogTargetGlobalResponse(rsp *http.Response) (*CreateLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetGlobalResponse parses an HTTP response from a ReplaceLogTargetGlobalWithResponse call
func ParseReplaceLogTargetGlobalResponse(rsp *http.Response) (*ReplaceLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupsResponse parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsResponse(rsp *http.Response) (*GetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Groups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceGroupResponse parses an HTTP response from a ReplaceGroupWithResponse call
func ParseReplaceGroupResponse(rsp *http.Response) (*ReplaceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorsSectionsResponse parses an HTTP response from a GetHTTPErrorsSectionsWithResponse call
func ParseGetHTTPErrorsSectionsResponse(rsp *http.Response) (*GetHTTPErrorsSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorsSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorsSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorsSectionResponse parses an HTTP response from a CreateHTTPErrorsSectionWithResponse call
func ParseCreateHTTPErrorsSectionResponse(rsp *http.Response) (*CreateHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorsSectionResponse parses an HTTP response from a DeleteHTTPErrorsSectionWithResponse call
func ParseDeleteHTTPErrorsSectionResponse(rsp *http.Response) (*DeleteHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorsSectionResponse parses an HTTP response from a GetHTTPErrorsSectionWithResponse call
func ParseGetHTTPErrorsSectionResponse(rsp *http.Response) (*GetHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorsSectionResponse parses an HTTP response from a ReplaceHTTPErrorsSectionWithResponse call
func ParseReplaceHTTPErrorsSectionResponse(rsp *http.Response) (*ReplaceHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogForwardsResponse parses an HTTP response from a GetLogForwardsWithResponse call
func ParseGetLogForwardsResponse(rsp *http.Response) (*GetLogForwardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogForwardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogForwards
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogForwardResponse parses an HTTP response from a CreateLogForwardWithResponse call
func ParseCreateLogForwardResponse(rsp *http.Response) (*CreateLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogForwardResponse parses an HTTP response from a DeleteLogForwardWithResponse call
func ParseDeleteLogForwardResponse(rsp *http.Response) (*DeleteLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogForwardResponse parses an HTTP response from a GetLogForwardWithResponse call
func ParseGetLogForwardResponse(rsp *http.Response) (*GetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogForwardResponse parses an HTTP response from a ReplaceLogForwardWithResponse call
func ParseReplaceLogForwardResponse(rsp *http.Response) (*ReplaceLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllBindLogForwardResponse parses an HTTP response from a GetAllBindLogForwardWithResponse call
func ParseGetAllBindLogForwardResponse(rsp *http.Response) (*GetAllBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBindLogForwardResponse parses an HTTP response from a CreateBindLogForwardWithResponse call
func ParseCreateBindLogForwardResponse(rsp *http.Response) (*CreateBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBindLogForwardResponse parses an HTTP response from a DeleteBindLogForwardWithResponse call
func ParseDeleteBindLogForwardResponse(rsp *http.Response) (*DeleteBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBindLogForwardResponse parses an HTTP response from a GetBindLogForwardWithResponse call
func ParseGetBindLogForwardResponse(rsp *http.Response) (*GetBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBindLogForwardResponse parses an HTTP response from a ReplaceBindLogForwardWithResponse call
func ParseReplaceBindLogForwardResponse(rsp *http.Response) (*ReplaceBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDgramBindsResponse parses an HTTP response from a GetDgramBindsWithResponse call
func ParseGetDgramBindsResponse(rsp *http.Response) (*GetDgramBindsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDgramBindsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBinds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDgramBindResponse parses an HTTP response from a CreateDgramBindWithResponse call
func ParseCreateDgramBindResponse(rsp *http.Response) (*CreateDgramBindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDgramBindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDgramBindResponse parses an HTTP response from a DeleteDgramBindWithResponse call
func ParseDeleteDgramBindResponse(rsp *http.Response) (*DeleteDgramBindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDgramBindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDgramBindResponse parses an HTTP response from a GetDgramBindWithResponse call
func ParseGetDgramBindResponse(rsp *http.Response) (*GetDgramBindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDgramBindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDgramBindResponse parses an HTTP response from a ReplaceDgramBindWithResponse call
func ParseReplaceDgramBindResponse(rsp *http.Response) (*ReplaceDgramBindResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDgramBindResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetLogForwardResponse parses an HTTP response from a GetAllLogTargetLogForwardWithResponse call
func ParseGetAllLogTargetLogForwardResponse(rsp *http.Response) (*GetAllLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetLogForwardResponse parses an HTTP response from a ReplaceAllLogTargetLogForwardWithResponse call
func ParseReplaceAllLogTargetLogForwardResponse(rsp *http.Response) (*ReplaceAllLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetLogForwardResponse parses an HTTP response from a DeleteLogTargetLogForwardWithResponse call
func ParseDeleteLogTargetLogForwardResponse(rsp *http.Response) (*DeleteLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetLogForwardResponse parses an HTTP response from a GetLogTargetLogForwardWithResponse call
func ParseGetLogTargetLogForwardResponse(rsp *http.Response) (*GetLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetLogForwardResponse parses an HTTP response from a CreateLogTargetLogForwardWithResponse call
func ParseCreateLogTargetLogForwardResponse(rsp *http.Response) (*CreateLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetLogForwardResponse parses an HTTP response from a ReplaceLogTargetLogForwardWithResponse call
func ParseReplaceLogTargetLogForwardResponse(rsp *http.Response) (*ReplaceLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogProfilesResponse parses an HTTP response from a GetLogProfilesWithResponse call
func ParseGetLogProfilesResponse(rsp *http.Response) (*GetLogProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogProfiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogProfileResponse parses an HTTP response from a CreateLogProfileWithResponse call
func ParseCreateLogProfileResponse(rsp *http.Response) (*CreateLogProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogProfileResponse parses an HTTP response from a DeleteLogProfileWithResponse call
func ParseDeleteLogProfileResponse(rsp *http.Response) (*DeleteLogProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogProfileResponse parses an HTTP response from a GetLogProfileWithResponse call
func ParseGetLogProfileResponse(rsp *http.Response) (*GetLogProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditLogProfileResponse parses an HTTP response from a EditLogProfileWithResponse call
func ParseEditLogProfileResponse(rsp *http.Response) (*EditLogProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditLogProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailerEntriesResponse parses an HTTP response from a GetMailerEntriesWithResponse call
func ParseGetMailerEntriesResponse(rsp *http.Response) (*GetMailerEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailerEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailerEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateMailerEntryResponse parses an HTTP response from a CreateMailerEntryWithResponse call
func ParseCreateMailerEntryResponse(rsp *http.Response) (*CreateMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMailerEntryResponse parses an HTTP response from a DeleteMailerEntryWithResponse call
func ParseDeleteMailerEntryResponse(rsp *http.Response) (*DeleteMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailerEntryResponse parses an HTTP response from a GetMailerEntryWithResponse call
func ParseGetMailerEntryResponse(rsp *http.Response) (*GetMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceMailerEntryResponse parses an HTTP response from a ReplaceMailerEntryWithResponse call
func ParseReplaceMailerEntryResponse(rsp *http.Response) (*ReplaceMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailersSectionsResponse parses an HTTP response from a GetMailersSectionsWithResponse call
func ParseGetMailersSectionsResponse(rsp *http.Response) (*GetMailersSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailersSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailersSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateMailersSectionResponse parses an HTTP response from a CreateMailersSectionWithResponse call
func ParseCreateMailersSectionResponse(rsp *http.Response) (*CreateMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMailersSectionResponse parses an HTTP response from a DeleteMailersSectionWithResponse call
func ParseDeleteMailersSectionResponse(rsp *http.Response) (*DeleteMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailersSectionResponse parses an HTTP response from a GetMailersSectionWithResponse call
func ParseGetMailersSectionResponse(rsp *http.Response) (*GetMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditMailersSectionResponse parses an HTTP response from a EditMailersSectionWithResponse call
func ParseEditMailersSectionResponse(rsp *http.Response) (*EditMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetNameserversResponse parses an HTTP response from a GetNameserversWithResponse call
func ParseGetNameserversResponse(rsp *http.Response) (*GetNameserversResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNameserversResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nameservers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNameserverResponse parses an HTTP response from a CreateNameserverWithResponse call
func ParseCreateNameserverResponse(rsp *http.Response) (*CreateNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteNameserverResponse parses an HTTP response from a DeleteNameserverWithResponse call
func ParseDeleteNameserverResponse(rsp *http.Response) (*DeleteNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetNameserverResponse parses an HTTP response from a GetNameserverWithResponse call
func ParseGetNameserverResponse(rsp *http.Response) (*GetNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceNameserverResponse parses an HTTP response from a ReplaceNameserverWithResponse call
func ParseReplaceNameserverResponse(rsp *http.Response) (*ReplaceNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerEntriesResponse parses an HTTP response from a GetPeerEntriesWithResponse call
func ParseGetPeerEntriesResponse(rsp *http.Response) (*GetPeerEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePeerEntryResponse parses an HTTP response from a CreatePeerEntryWithResponse call
func ParseCreatePeerEntryResponse(rsp *http.Response) (*CreatePeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePeerEntryResponse parses an HTTP response from a DeletePeerEntryWithResponse call
func ParseDeletePeerEntryResponse(rsp *http.Response) (*DeletePeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerEntryResponse parses an HTTP response from a GetPeerEntryWithResponse call
func ParseGetPeerEntryResponse(rsp *http.Response) (*GetPeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplacePeerEntryResponse parses an HTTP response from a ReplacePeerEntryWithResponse call
func ParseReplacePeerEntryResponse(rsp *http.Response) (*ReplacePeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplacePeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerSectionsResponse parses an HTTP response from a GetPeerSectionsWithResponse call
func ParseGetPeerSectionsResponse(rsp *http.Response) (*GetPeerSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePeerResponse parses an HTTP response from a CreatePeerWithResponse call
func ParseCreatePeerResponse(rsp *http.Response) (*CreatePeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PeerSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PeerSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePeerResponse parses an HTTP response from a DeletePeerWithResponse call
func ParseDeletePeerResponse(rsp *http.Response) (*DeletePeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerSectionResponse parses an HTTP response from a GetPeerSectionWithResponse call
func ParseGetPeerSectionResponse(rsp *http.Response) (*GetPeerSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllBindPeerResponse parses an HTTP response from a GetAllBindPeerWithResponse call
func ParseGetAllBindPeerResponse(rsp *http.Response) (*GetAllBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBindPeerResponse parses an HTTP response from a CreateBindPeerWithResponse call
func ParseCreateBindPeerResponse(rsp *http.Response) (*CreateBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBindPeerResponse parses an HTTP response from a DeleteBindPeerWithResponse call
func ParseDeleteBindPeerResponse(rsp *http.Response) (*DeleteBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBindPeerResponse parses an HTTP response from a GetBindPeerWithResponse call
func ParseGetBindPeerResponse(rsp *http.Response) (*GetBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBindPeerResponse parses an HTTP response from a ReplaceBindPeerWithResponse call
func ParseReplaceBindPeerResponse(rsp *http.Response) (*ReplaceBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetPeerResponse parses an HTTP response from a GetAllLogTargetPeerWithResponse call
func ParseGetAllLogTargetPeerResponse(rsp *http.Response) (*GetAllLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetPeerResponse parses an HTTP response from a ReplaceAllLogTargetPeerWithResponse call
func ParseReplaceAllLogTargetPeerResponse(rsp *http.Response) (*ReplaceAllLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetPeerResponse parses an HTTP response from a DeleteLogTargetPeerWithResponse call
func ParseDeleteLogTargetPeerResponse(rsp *http.Response) (*DeleteLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetPeerResponse parses an HTTP response from a GetLogTargetPeerWithResponse call
func ParseGetLogTargetPeerResponse(rsp *http.Response) (*GetLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetPeerResponse parses an HTTP response from a CreateLogTargetPeerWithResponse call
func ParseCreateLogTargetPeerResponse(rsp *http.Response) (*CreateLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetPeerResponse parses an HTTP response from a ReplaceLogTargetPeerWithResponse call
func ParseReplaceLogTargetPeerResponse(rsp *http.Response) (*ReplaceLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllServerPeerResponse parses an HTTP response from a GetAllServerPeerWithResponse call
func ParseGetAllServerPeerResponse(rsp *http.Response) (*GetAllServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Servers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerPeerResponse parses an HTTP response from a CreateServerPeerWithResponse call
func ParseCreateServerPeerResponse(rsp *http.Response) (*CreateServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerPeerResponse parses an HTTP response from a DeleteServerPeerWithResponse call
func ParseDeleteServerPeerResponse(rsp *http.Response) (*DeleteServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerPeerResponse parses an HTTP response from a GetServerPeerWithResponse call
func ParseGetServerPeerResponse(rsp *http.Response) (*GetServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerPeerResponse parses an HTTP response from a ReplaceServerPeerWithResponse call
func ParseReplaceServerPeerResponse(rsp *http.Response) (*ReplaceServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTablesResponse parses an HTTP response from a GetTablesWithResponse call
func ParseGetTablesResponse(rsp *http.Response) (*GetTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tables
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTableResponse parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableResponse(rsp *http.Response) (*CreateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTableResponse parses an HTTP response from a DeleteTableWithResponse call
func ParseDeleteTableResponse(rsp *http.Response) (*DeleteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTableResponse parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResponse(rsp *http.Response) (*GetTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTableResponse parses an HTTP response from a ReplaceTableWithResponse call
func ParseReplaceTableResponse(rsp *http.Response) (*ReplaceTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProgramsResponse parses an HTTP response from a GetProgramsWithResponse call
func ParseGetProgramsResponse(rsp *http.Response) (*GetProgramsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Programs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateProgramResponse parses an HTTP response from a CreateProgramWithResponse call
func ParseCreateProgramResponse(rsp *http.Response) (*CreateProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteProgramResponse parses an HTTP response from a DeleteProgramWithResponse call
func ParseDeleteProgramResponse(rsp *http.Response) (*DeleteProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProgramResponse parses an HTTP response from a GetProgramWithResponse call
func ParseGetProgramResponse(rsp *http.Response) (*GetProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceProgramResponse parses an HTTP response from a ReplaceProgramWithResponse call
func ParseReplaceProgramResponse(rsp *http.Response) (*ReplaceProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHAProxyConfigurationResponse parses an HTTP response from a GetHAProxyConfigurationWithResponse call
func ParseGetHAProxyConfigurationResponse(rsp *http.Response) (*GetHAProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHAProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostHAProxyConfigurationResponse parses an HTTP response from a PostHAProxyConfigurationWithResponse call
func ParsePostHAProxyConfigurationResponse(rsp *http.Response) (*PostHAProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostHAProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetResolversResponse parses an HTTP response from a GetResolversWithResponse call
func ParseGetResolversResponse(rsp *http.Response) (*GetResolversResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResolversResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resolvers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateResolverResponse parses an HTTP response from a CreateResolverWithResponse call
func ParseCreateResolverResponse(rsp *http.Response) (*CreateResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteResolverResponse parses an HTTP response from a DeleteResolverWithResponse call
func ParseDeleteResolverResponse(rsp *http.Response) (*DeleteResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetResolverResponse parses an HTTP response from a GetResolverWithResponse call
func ParseGetResolverResponse(rsp *http.Response) (*GetResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceResolverResponse parses an HTTP response from a ReplaceResolverWithResponse call
func ParseReplaceResolverResponse(rsp *http.Response) (*ReplaceResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRingsResponse parses an HTTP response from a GetRingsWithResponse call
func ParseGetRingsResponse(rsp *http.Response) (*GetRingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRingResponse parses an HTTP response from a CreateRingWithResponse call
func ParseCreateRingResponse(rsp *http.Response) (*CreateRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRingResponse parses an HTTP response from a DeleteRingWithResponse call
func ParseDeleteRingResponse(rsp *http.Response) (*DeleteRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRingResponse parses an HTTP response from a GetRingWithResponse call
func ParseGetRingResponse(rsp *http.Response) (*GetRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceRingResponse parses an HTTP response from a ReplaceRingWithResponse call
func ParseReplaceRingResponse(rsp *http.Response) (*ReplaceRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllServerRingResponse parses an HTTP response from a GetAllServerRingWithResponse call
func ParseGetAllServerRingResponse(rsp *http.Response) (*GetAllServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Servers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerRingResponse parses an HTTP response from a CreateServerRingWithResponse call
func ParseCreateServerRingResponse(rsp *http.Response) (*CreateServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerRingResponse parses an HTTP response from a DeleteServerRingWithResponse call
func ParseDeleteServerRingResponse(rsp *http.Response) (*DeleteServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerRingResponse parses an HTTP response from a GetServerRingWithResponse call
func ParseGetServerRingResponse(rsp *http.Response) (*GetServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerRingResponse parses an HTTP response from a ReplaceServerRingWithResponse call
func ParseReplaceServerRingResponse(rsp *http.Response) (*ReplaceServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTracesResponse parses an HTTP response from a DeleteTracesWithResponse call
func ParseDeleteTracesResponse(rsp *http.Response) (*DeleteTracesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTracesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTracesResponse parses an HTTP response from a GetTracesWithResponse call
func ParseGetTracesResponse(rsp *http.Response) (*GetTracesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTracesResponse parses an HTTP response from a CreateTracesWithResponse call
func ParseCreateTracesResponse(rsp *http.Response) (*CreateTracesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTracesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTracesResponse parses an HTTP response from a ReplaceTracesWithResponse call
func ParseReplaceTracesResponse(rsp *http.Response) (*ReplaceTracesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTracesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Traces
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTraceEntryResponse parses an HTTP response from a DeleteTraceEntryWithResponse call
func ParseDeleteTraceEntryResponse(rsp *http.Response) (*DeleteTraceEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTraceEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTraceEntryResponse parses an HTTP response from a CreateTraceEntryWithResponse call
func ParseCreateTraceEntryResponse(rsp *http.Response) (*CreateTraceEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTraceEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TraceEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TraceEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserlistsResponse parses an HTTP response from a GetUserlistsWithResponse call
func ParseGetUserlistsResponse(rsp *http.Response) (*GetUserlistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserlistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Userlists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserlistResponse parses an HTTP response from a CreateUserlistWithResponse call
func ParseCreateUserlistResponse(rsp *http.Response) (*CreateUserlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Userlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Userlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserlistResponse parses an HTTP response from a DeleteUserlistWithResponse call
func ParseDeleteUserlistResponse(rsp *http.Response) (*DeleteUserlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserlistResponse parses an HTTP response from a GetUserlistWithResponse call
func ParseGetUserlistResponse(rsp *http.Response) (*GetUserlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Userlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceUserResponse parses an HTTP response from a ReplaceUserWithResponse call
func ParseReplaceUserResponse(rsp *http.Response) (*ReplaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationVersionResponse parses an HTTP response from a GetConfigurationVersionWithResponse call
func ParseGetConfigurationVersionResponse(rsp *http.Response) (*GetConfigurationVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReloadsResponse parses an HTTP response from a GetReloadsWithResponse call
func ParseGetReloadsResponse(rsp *http.Response) (*GetReloadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReloadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reloads
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReloadResponse parses an HTTP response from a GetReloadWithResponse call
func ParseGetReloadResponse(rsp *http.Response) (*GetReloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRuntimeEndpointsResponse parses an HTTP response from a GetRuntimeEndpointsWithResponse call
func ParseGetRuntimeEndpointsResponse(rsp *http.Response) (*GetRuntimeEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsWithResponse call
func ParseGetServicesHaproxyRuntimeAclsResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsIdResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsIdWithResponse call
func ParseGetServicesHaproxyRuntimeAclsIdResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsParentNameEntriesResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse call
func ParseGetServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsParentNameEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFilesEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse parses an HTTP response from a PostServicesHaproxyRuntimeAclsParentNameEntriesWithResponse call
func ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp *http.Response) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostServicesHaproxyRuntimeAclsParentNameEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AclFileEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddPayloadRuntimeACLResponse parses an HTTP response from a AddPayloadRuntimeACLWithResponse call
func ParseAddPayloadRuntimeACLResponse(rsp *http.Response) (*AddPayloadRuntimeACLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPayloadRuntimeACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AclFilesEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse parses an HTTP response from a DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse call
func ParseDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp *http.Response) (*DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse call
func ParseGetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFileEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAcmeStatusResponse parses an HTTP response from a GetAcmeStatusWithResponse call
func ParseGetAcmeStatusResponse(rsp *http.Response) (*GetAcmeStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAcmeStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AcmeStatus
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRenewAcmeCertificateResponse parses an HTTP response from a RenewAcmeCertificateWithResponse call
func ParseRenewAcmeCertificateResponse(rsp *http.Response) (*RenewAcmeCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenewAcmeCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllRuntimeServerResponse parses an HTTP response from a GetAllRuntimeServerWithResponse call
func ParseGetAllRuntimeServerResponse(rsp *http.Response) (*GetAllRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeServers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddRuntimeServerResponse parses an HTTP response from a AddRuntimeServerWithResponse call
func ParseAddRuntimeServerResponse(rsp *http.Response) (*AddRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RuntimeAddServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRuntimeServerResponse parses an HTTP response from a DeleteRuntimeServerWithResponse call
func ParseDeleteRuntimeServerResponse(rsp *http.Response) (*DeleteRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRuntimeServerResponse parses an HTTP response from a GetRuntimeServerWithResponse call
func ParseGetRuntimeServerResponse(rsp *http.Response) (*GetRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceRuntimeServerResponse parses an HTTP response from a ReplaceRuntimeServerWithResponse call
func ParseReplaceRuntimeServerResponse(rsp *http.Response) (*ReplaceRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHaproxyProcessInfoResponse parses an HTTP response from a GetHaproxyProcessInfoWithResponse call
func ParseGetHaproxyProcessInfoResponse(rsp *http.Response) (*GetHaproxyProcessInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHaproxyProcessInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllRuntimeMapFilesResponse parses an HTTP response from a GetAllRuntimeMapFilesWithResponse call
func ParseGetAllRuntimeMapFilesResponse(rsp *http.Response) (*GetAllRuntimeMapFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRuntimeMapFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Maps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClearRuntimeMapResponse parses an HTTP response from a ClearRuntimeMapWithResponse call
func ParseClearRuntimeMapResponse(rsp *http.Response) (*ClearRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneRuntimeMapResponse parses an HTTP response from a GetOneRuntimeMapWithResponse call
func ParseGetOneRuntimeMapResponse(rsp *http.Response) (*GetOneRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Map
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddPayloadRuntimeMapResponse parses an HTTP response from a AddPayloadRuntimeMapWithResponse call
func ParseAddPayloadRuntimeMapResponse(rsp *http.Response) (*AddPayloadRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPayloadRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MapEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowRuntimeMapResponse parses an HTTP response from a ShowRuntimeMapWithResponse call
func ParseShowRuntimeMapResponse(rsp *http.Response) (*ShowRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MapEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddMapEntryResponse parses an HTTP response from a AddMapEntryWithResponse call
func ParseAddMapEntryResponse(rsp *http.Response) (*AddMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MapEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRuntimeMapEntryResponse parses an HTTP response from a DeleteRuntimeMapEntryWithResponse call
func ParseDeleteRuntimeMapEntryResponse(rsp *http.Response) (*DeleteRuntimeMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuntimeMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRuntimeMapEntryResponse parses an HTTP response from a GetRuntimeMapEntryWithResponse call
func ParseGetRuntimeMapEntryResponse(rsp *http.Response) (*GetRuntimeMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MapEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceRuntimeMapEntryResponse parses an HTTP response from a ReplaceRuntimeMapEntryWithResponse call
func ParseReplaceRuntimeMapEntryResponse(rsp *http.Response) (*ReplaceRuntimeMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRuntimeMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MapEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllCaFilesResponse parses an HTTP response from a GetAllCaFilesWithResponse call
func ParseGetAllCaFilesResponse(rsp *http.Response) (*GetAllCaFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCaFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCaFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCaFileResponse parses an HTTP response from a CreateCaFileWithResponse call
func ParseCreateCaFileResponse(rsp *http.Response) (*CreateCaFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCaFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCaFileResponse parses an HTTP response from a DeleteCaFileWithResponse call
func ParseDeleteCaFileResponse(rsp *http.Response) (*DeleteCaFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCaFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCaFileResponse parses an HTTP response from a GetCaFileWithResponse call
func ParseGetCaFileResponse(rsp *http.Response) (*GetCaFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCaFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetCaFileResponse parses an HTTP response from a SetCaFileWithResponse call
func ParseSetCaFileResponse(rsp *http.Response) (*SetCaFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCaFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddCaEntryResponse parses an HTTP response from a AddCaEntryWithResponse call
func ParseAddCaEntryResponse(rsp *http.Response) (*AddCaEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCaEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCaEntryResponse parses an HTTP response from a GetCaEntryWithResponse call
func ParseGetCaEntryResponse(rsp *http.Response) (*GetCaEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllCertsResponse parses an HTTP response from a GetAllCertsWithResponse call
func ParseGetAllCertsResponse(rsp *http.Response) (*GetAllCertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCertResponse parses an HTTP response from a CreateCertWithResponse call
func ParseCreateCertResponse(rsp *http.Response) (*CreateCertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCertResponse parses an HTTP response from a DeleteCertWithResponse call
func ParseDeleteCertResponse(rsp *http.Response) (*DeleteCertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCertResponse parses an HTTP response from a GetCertWithResponse call
func ParseGetCertResponse(rsp *http.Response) (*GetCertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceCertResponse parses an HTTP response from a ReplaceCertWithResponse call
func ParseReplaceCertResponse(rsp *http.Response) (*ReplaceCertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceCertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllCrlResponse parses an HTTP response from a GetAllCrlWithResponse call
func ParseGetAllCrlResponse(rsp *http.Response) (*GetAllCrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCrls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCrlResponse parses an HTTP response from a CreateCrlWithResponse call
func ParseCreateCrlResponse(rsp *http.Response) (*CreateCrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCrlResponse parses an HTTP response from a DeleteCrlWithResponse call
func ParseDeleteCrlResponse(rsp *http.Response) (*DeleteCrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrlResponse parses an HTTP response from a GetCrlWithResponse call
func ParseGetCrlResponse(rsp *http.Response) (*GetCrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCrlEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceCrlResponse parses an HTTP response from a ReplaceCrlWithResponse call
func ParseReplaceCrlResponse(rsp *http.Response) (*ReplaceCrlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceCrlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllCrtListsResponse parses an HTTP response from a GetAllCrtListsWithResponse call
func ParseGetAllCrtListsResponse(rsp *http.Response) (*GetAllCrtListsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCrtListsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCrtLists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCrtListEntryResponse parses an HTTP response from a DeleteCrtListEntryWithResponse call
func ParseDeleteCrtListEntryResponse(rsp *http.Response) (*DeleteCrtListEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCrtListEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllCrtListEntriesResponse parses an HTTP response from a GetAllCrtListEntriesWithResponse call
func ParseGetAllCrtListEntriesResponse(rsp *http.Response) (*GetAllCrtListEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllCrtListEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCrtListEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddCrtListEntryResponse parses an HTTP response from a AddCrtListEntryWithResponse call
func ParseAddCrtListEntryResponse(rsp *http.Response) (*AddCrtListEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCrtListEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickTablesResponse parses an HTTP response from a GetStickTablesWithResponse call
func ParseGetStickTablesResponse(rsp *http.Response) (*GetStickTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickTables
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickTableResponse parses an HTTP response from a GetStickTableWithResponse call
func ParseGetStickTableResponse(rsp *http.Response) (*GetStickTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickTable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickTableEntriesResponse parses an HTTP response from a GetStickTableEntriesWithResponse call
func ParseGetStickTableEntriesResponse(rsp *http.Response) (*GetStickTableEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickTableEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickTableEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetStickTableEntriesResponse parses an HTTP response from a SetStickTableEntriesWithResponse call
func ParseSetStickTableEntriesResponse(rsp *http.Response) (*SetStickTableEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetStickTableEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSitesResponse parses an HTTP response from a GetSitesWithResponse call
func ParseGetSitesResponse(rsp *http.Response) (*GetSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sites
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSiteResponse parses an HTTP response from a CreateSiteWithResponse call
func ParseCreateSiteResponse(rsp *http.Response) (*CreateSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSiteResponse parses an HTTP response from a DeleteSiteWithResponse call
func ParseDeleteSiteResponse(rsp *http.Response) (*DeleteSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSiteResponse parses an HTTP response from a GetSiteWithResponse call
func ParseGetSiteResponse(rsp *http.Response) (*GetSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSiteResponse parses an HTTP response from a ReplaceSiteWithResponse call
func ParseReplaceSiteResponse(rsp *http.Response) (*ReplaceSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeEndpointsResponse parses an HTTP response from a GetSpoeEndpointsWithResponse call
func ParseGetSpoeEndpointsResponse(rsp *http.Response) (*GetSpoeEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeFilesResponse parses an HTTP response from a GetAllSpoeFilesWithResponse call
func ParseGetAllSpoeFilesResponse(rsp *http.Response) (*GetAllSpoeFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeResponse parses an HTTP response from a CreateSpoeWithResponse call
func ParseCreateSpoeResponse(rsp *http.Response) (*CreateSpoeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeFileResponse parses an HTTP response from a DeleteSpoeFileWithResponse call
func ParseDeleteSpoeFileResponse(rsp *http.Response) (*DeleteSpoeFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneSpoeFileResponse parses an HTTP response from a GetOneSpoeFileWithResponse call
func ParseGetOneSpoeFileResponse(rsp *http.Response) (*GetOneSpoeFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneSpoeFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeScopeResponse parses an HTTP response from a GetAllSpoeScopeWithResponse call
func ParseGetAllSpoeScopeResponse(rsp *http.Response) (*GetAllSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeScopes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeScopeResponse parses an HTTP response from a CreateSpoeScopeWithResponse call
func ParseCreateSpoeScopeResponse(rsp *http.Response) (*CreateSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeScope
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeScopeResponse parses an HTTP response from a DeleteSpoeScopeWithResponse call
func ParseDeleteSpoeScopeResponse(rsp *http.Response) (*DeleteSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeScopeResponse parses an HTTP response from a GetSpoeScopeWithResponse call
func ParseGetSpoeScopeResponse(rsp *http.Response) (*GetSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeScope
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeAgentResponse parses an HTTP response from a GetAllSpoeAgentWithResponse call
func ParseGetAllSpoeAgentResponse(rsp *http.Response) (*GetAllSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeAgents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeAgentResponse parses an HTTP response from a CreateSpoeAgentWithResponse call
func ParseCreateSpoeAgentResponse(rsp *http.Response) (*CreateSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeAgent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeAgentResponse parses an HTTP response from a DeleteSpoeAgentWithResponse call
func ParseDeleteSpoeAgentResponse(rsp *http.Response) (*DeleteSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeAgentResponse parses an HTTP response from a GetSpoeAgentWithResponse call
func ParseGetSpoeAgentResponse(rsp *http.Response) (*GetSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeAgent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSpoeAgentResponse parses an HTTP response from a ReplaceSpoeAgentWithResponse call
func ParseReplaceSpoeAgentResponse(rsp *http.Response) (*ReplaceSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeAgent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeGroupResponse parses an HTTP response from a GetAllSpoeGroupWithResponse call
func ParseGetAllSpoeGroupResponse(rsp *http.Response) (*GetAllSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeGroupResponse parses an HTTP response from a CreateSpoeGroupWithResponse call
func ParseCreateSpoeGroupResponse(rsp *http.Response) (*CreateSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeGroupResponse parses an HTTP response from a DeleteSpoeGroupWithResponse call
func ParseDeleteSpoeGroupResponse(rsp *http.Response) (*DeleteSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeGroupResponse parses an HTTP response from a GetSpoeGroupWithResponse call
func ParseGetSpoeGroupResponse(rsp *http.Response) (*GetSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSpoeGroupResponse parses an HTTP response from a ReplaceSpoeGroupWithResponse call
func ParseReplaceSpoeGroupResponse(rsp *http.Response) (*ReplaceSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeMessageResponse parses an HTTP response from a GetAllSpoeMessageWithResponse call
func ParseGetAllSpoeMessageResponse(rsp *http.Response) (*GetAllSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeMessages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeMessageResponse parses an HTTP response from a CreateSpoeMessageWithResponse call
func ParseCreateSpoeMessageResponse(rsp *http.Response) (*CreateSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeMessageResponse parses an HTTP response from a DeleteSpoeMessageWithResponse call
func ParseDeleteSpoeMessageResponse(rsp *http.Response) (*DeleteSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeMessageResponse parses an HTTP response from a GetSpoeMessageWithResponse call
func ParseGetSpoeMessageResponse(rsp *http.Response) (*GetSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSpoeMessageResponse parses an HTTP response from a ReplaceSpoeMessageWithResponse call
func ParseReplaceSpoeMessageResponse(rsp *http.Response) (*ReplaceSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeTransactionResponse parses an HTTP response from a GetAllSpoeTransactionWithResponse call
func ParseGetAllSpoeTransactionResponse(rsp *http.Response) (*GetAllSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeTransactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartSpoeTransactionResponse parses an HTTP response from a StartSpoeTransactionWithResponse call
func ParseStartSpoeTransactionResponse(rsp *http.Response) (*StartSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Code    *int    `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeTransactionResponse parses an HTTP response from a DeleteSpoeTransactionWithResponse call
func ParseDeleteSpoeTransactionResponse(rsp *http.Response) (*DeleteSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeTransactionResponse parses an HTTP response from a GetSpoeTransactionWithResponse call
func ParseGetSpoeTransactionResponse(rsp *http.Response) (*GetSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitSpoeTransactionResponse parses an HTTP response from a CommitSpoeTransactionWithResponse call
func ParseCommitSpoeTransactionResponse(rsp *http.Response) (*CommitSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeConfigurationVersionResponse parses an HTTP response from a GetSpoeConfigurationVersionWithResponse call
func ParseGetSpoeConfigurationVersionResponse(rsp *http.Response) (*GetSpoeConfigurationVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeConfigurationVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatsEndpointsResponse parses an HTTP response from a GetStatsEndpointsWithResponse call
func ParseGetStatsEndpointsResponse(rsp *http.Response) (*GetStatsEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NativeStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest NativeStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStorageEndpointsResponse parses an HTTP response from a GetStorageEndpointsWithResponse call
func ParseGetStorageEndpointsResponse(rsp *http.Response) (*GetStorageEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStorageEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageGeneralFilesResponse parses an HTTP response from a GetAllStorageGeneralFilesWithResponse call
func ParseGetAllStorageGeneralFilesResponse(rsp *http.Response) (*GetAllStorageGeneralFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageGeneralFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GeneralFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageGeneralFileResponse parses an HTTP response from a CreateStorageGeneralFileWithResponse call
func ParseCreateStorageGeneralFileResponse(rsp *http.Response) (*CreateStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GeneralFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageGeneralFileResponse parses an HTTP response from a DeleteStorageGeneralFileWithResponse call
func ParseDeleteStorageGeneralFileResponse(rsp *http.Response) (*DeleteStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageGeneralFileResponse parses an HTTP response from a GetOneStorageGeneralFileWithResponse call
func ParseGetOneStorageGeneralFileResponse(rsp *http.Response) (*GetOneStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageGeneralFileResponse parses an HTTP response from a ReplaceStorageGeneralFileWithResponse call
func ParseReplaceStorageGeneralFileResponse(rsp *http.Response) (*ReplaceStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageMapFilesResponse parses an HTTP response from a GetAllStorageMapFilesWithResponse call
func ParseGetAllStorageMapFilesResponse(rsp *http.Response) (*GetAllStorageMapFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageMapFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Maps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageMapFileResponse parses an HTTP response from a CreateStorageMapFileWithResponse call
func ParseCreateStorageMapFileResponse(rsp *http.Response) (*CreateStorageMapFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageMapFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Map
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageMapResponse parses an HTTP response from a DeleteStorageMapWithResponse call
func ParseDeleteStorageMapResponse(rsp *http.Response) (*DeleteStorageMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageMapResponse parses an HTTP response from a GetOneStorageMapWithResponse call
func ParseGetOneStorageMapResponse(rsp *http.Response) (*GetOneStorageMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageMapFileResponse parses an HTTP response from a ReplaceStorageMapFileWithResponse call
func ParseReplaceStorageMapFileResponse(rsp *http.Response) (*ReplaceStorageMapFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageMapFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageSSLCertificatesResponse parses an HTTP response from a GetAllStorageSSLCertificatesWithResponse call
func ParseGetAllStorageSSLCertificatesResponse(rsp *http.Response) (*GetAllStorageSSLCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageSSLCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageSSLCertificateResponse parses an HTTP response from a CreateStorageSSLCertificateWithResponse call
func ParseCreateStorageSSLCertificateResponse(rsp *http.Response) (*CreateStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageSSLCertificateResponse parses an HTTP response from a DeleteStorageSSLCertificateWithResponse call
func ParseDeleteStorageSSLCertificateResponse(rsp *http.Response) (*DeleteStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageSSLCertificateResponse parses an HTTP response from a GetOneStorageSSLCertificateWithResponse call
func ParseGetOneStorageSSLCertificateResponse(rsp *http.Response) (*GetOneStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageSSLCertificateResponse parses an HTTP response from a ReplaceStorageSSLCertificateWithResponse call
func ParseReplaceStorageSSLCertificateResponse(rsp *http.Response) (*ReplaceStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageSSLCrtListFilesResponse parses an HTTP response from a GetAllStorageSSLCrtListFilesWithResponse call
func ParseGetAllStorageSSLCrtListFilesResponse(rsp *http.Response) (*GetAllStorageSSLCrtListFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageSSLCrtListFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCrtListFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageSSLCrtListFileResponse parses an HTTP response from a CreateStorageSSLCrtListFileWithResponse call
func ParseCreateStorageSSLCrtListFileResponse(rsp *http.Response) (*CreateStorageSSLCrtListFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageSSLCrtListFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SslCrtListFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SslCrtListFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageSSLCrtListFileResponse parses an HTTP response from a DeleteStorageSSLCrtListFileWithResponse call
func ParseDeleteStorageSSLCrtListFileResponse(rsp *http.Response) (*DeleteStorageSSLCrtListFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageSSLCrtListFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageSSLCrtListFileResponse parses an HTTP response from a GetOneStorageSSLCrtListFileWithResponse call
func ParseGetOneStorageSSLCrtListFileResponse(rsp *http.Response) (*GetOneStorageSSLCrtListFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageSSLCrtListFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageSSLCrtListFileResponse parses an HTTP response from a ReplaceStorageSSLCrtListFileWithResponse call
func ParseReplaceStorageSSLCrtListFileResponse(rsp *http.Response) (*ReplaceStorageSSLCrtListFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageSSLCrtListFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCrtListFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SslCrtListFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageSSLCrtListEntryResponse parses an HTTP response from a DeleteStorageSSLCrtListEntryWithResponse call
func ParseDeleteStorageSSLCrtListEntryResponse(rsp *http.Response) (*DeleteStorageSSLCrtListEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageSSLCrtListEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStorageSSLCrtListEntriesResponse parses an HTTP response from a GetStorageSSLCrtListEntriesWithResponse call
func ParseGetStorageSSLCrtListEntriesResponse(rsp *http.Response) (*GetStorageSSLCrtListEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStorageSSLCrtListEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCrtListEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageSSLCrtListEntryResponse parses an HTTP response from a CreateStorageSSLCrtListEntryWithResponse call
func ParseCreateStorageSSLCrtListEntryResponse(rsp *http.Response) (*CreateStorageSSLCrtListEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageSSLCrtListEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SslCrtListEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTransactionsResponse parses an HTTP response from a GetTransactionsWithResponse call
func ParseGetTransactionsResponse(rsp *http.Response) (*GetTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartTransactionResponse parses an HTTP response from a StartTransactionWithResponse call
func ParseStartTransactionResponse(rsp *http.Response) (*StartTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Code    *int    `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTransactionResponse parses an HTTP response from a DeleteTransactionWithResponse call
func ParseDeleteTransactionResponse(rsp *http.Response) (*DeleteTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTransactionResponse parses an HTTP response from a GetTransactionWithResponse call
func ParseGetTransactionResponse(rsp *http.Response) (*GetTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitTransactionResponse parses an HTTP response from a CommitTransactionWithResponse call
func ParseCommitTransactionResponse(rsp *http.Response) (*CommitTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpecificationResponse parses an HTTP response from a GetSpecificationWithResponse call
func ParseGetSpecificationResponse(rsp *http.Response) (*GetSpecificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpecificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOpenapiv3SpecificationResponse parses an HTTP response from a GetOpenapiv3SpecificationWithResponse call
func ParseGetOpenapiv3SpecificationResponse(rsp *http.Response) (*GetOpenapiv3SpecificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiv3SpecificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+z9C3Mbt7IoCv8V1JzzVZKzSJl62bGrvrpHke3EN4qtI8pr79qRzxQ4A5JYGgJjACOJ",
	"ydZ/v4UGME8MOcOH7WRp71oxRQKNBtBoNPr5ZxDxRcoZYUoGr/4MUizwgigi4K8pFxEJBUk4jvXfMZGR",
	"oKminAWvgndTJIkaoJgjjKApMk3hK8YVusdU6V+QmhMUcTals0yQ2DYbxiTBywN0jpluPCEokyRG93PC",
	"kBKYSRzpkRCVSKYkolNK4gHCEkVzzGZEIlpthwWBUXGaJpTEKKaCRCpZIsXzwbFueRAMAqpn8DkjYhkM",
	"AoYXJHhVne4gkNGcLLCZ9xRniQpeTXEiySBQy1S3n3CeEMyCx8dBMM2SJJQkMmvTWCoW0wgrjfMUFsOh",
	"PJ2SSEn4Kp8jiuY00YskeSYiIvWU70mStGFdHrkn1ikWhKnQQKojfQk/IvjRDp1iNS9GLvceBIJ8zqgg",
	"cfBKiYyUEbEDSyUom8G48pama+mKcUso6J4miaYPyqiiWJEY4akiAmVpjBVpWZfyGD2XpURVIfVh+Bpx",
	"s49l+rufE0HQPUH3mClNdDiOoRFPiSU8L63fESHrdN5GojXMVqzyIHgYsixJ8CQhdq6Pg8CO1ZzSPy0S",
	"gJY+stGcRLeUzapHxyHb99SWf5ljiaj6TiJ+X8Brma/D1zNRyhSZEeGf6aOmR5lyJglwsrNEEBwv3zxQ",
	"aRhdxJkiTOmPwC8imN6zf0mzOMVo/1OQafAq+B/PCkb5zPwqnxEhuAge9WjV1byunGd3khE2WCBi0BgE",
	"c4Jjy2vPy8s8/GfbPlWaoSlNCFqxRvmR0yj+hOMr8jkjUu1/AX7CetpmsC88zdfmfL8B1PY+0Z8JIwIn",
	"yAz3haf6nquzKCKpMqT/lag6yjnBHLM4IfFXWIa3PGPxV1uBeyxB8pgCFl909o/uZxgNRwn8E8dUA8LJ",
	"pdCXj6KaC9r7rjmjTBJ9n2lSkhKdc6YET9CF5lHo+7Pzix9QKvgdjbUogqYJeaCThCDJkwywVRylREy5",
	"WNwwu/xI3lMVzfX1gVmMZuaQGFFM4VuCYhJRPTuJJlhfH5wh15U8KIEjReIbNhV8ATeoZSUD+4dh7IgL",
	"hNkSEXZHBWcLwhROkFRYZfLgRi9cWpo9LE4u6aRYKSL0Avzf3//vzY389I//GQyaV2gkqCLC7ljHPgui",
	"cIwVbt+IfB/55F8kUiBy3OEkI35hqRCsfi/mUMbt0yBQVGkOEJydX6ALyogsMHODDKCzJq0m+elub/Uv",
	"9TWrNPPIGEY6anwtFRd4RvLlbk6qjLAduRXfkDAllk2sPzCCXH/0BtrU8Tf46Vv3A0uWTjRt4Lti9R2i",
	"3sFaUZaeNRYCL/U5ExlTdKHfAAkybQcBVWQh17GlfP886ycRwC9wwvBnGSVYRroSNdtCf+SMNDDti6jd",
	"OC+6bywyXoQ9OP5ydin4wxL2INEUjqAD+j7iwnCEWILQHSX25UfviPyhB8p1POEcrVjWBQkjTWlTeNqF",
	"hvE0ER/D93pJMZKUzRJNR7+9QaW+CBidXe0DD+NakPa3JQCzv6L7OY3mlt/qdxI8vIuBDrxMrvjdczGV",
	"sLSMpwGAPKRU72VIPei9dpeanl1SmTX0Wx60glyG8VqcoKEZILYT1DcRVsGrQH8x1EvqG0EQRu5x0gVn",
	"vYiMPCiUJpgxuPihrxdzTVBxlpA4tK08D2sLJoat12+t0oRKsLtNRNMd8ZMdcc9UoBGF5e0AEarmRKCb",
	"4CpjjLLZTaDv0Ztg7PC+CTzzqhyNGvFawvdywwUJrewgegomr8mUMoIwM8g7KPqIO/IuYyERzhRfYEUj",
	"LWh4zlDEM6bCW7L0aTrU3D7f4VHvVsx2QrdkCe9ZxQVIt409aEy0Npf342ICTh8WMzkcHaJojpOEsBlp",
	"hXuHjSi5RpgoelUH13KcpoM7LKh+J0iUYqllLi2LFXjk+H2vlqlZRHR2+U7PXf6goU6o8nC399liQoSG",
	"r3+v7A5m6Gp8Vt6kYBAsKKOLbBG8OhwdnQyC4t1euZnd214/7flCM/BU2dtbM6x8yfzMMP8daXAHSF/9",
	"aK5Uquep5VE7ZSwIklmacqGMxoUwjdnvgW0bDALTEiSsBtvkTOFIeWV5/QMiC0yTfLvLBOXlwpm4893N",
	"5/C9VbJQNQdgb85fj8+ALAGOB5y5ArlPbPp4deH2vnK0vpMo73WA3nKByANepAl5dcP0ishXz55pghxK",
	"hWeUzYZ3o6MDnNKDhChJWCSWqTrgYvYsh2KE8EJsdlBWic+3ZGm+q6N9vUyBn8GsCzIrbdvV+CwYBLA2",
	"3h1b4NQDdk7QAqf25nSaxsweEDjyJRbKbwlD39+S5Q9ASGqeLSapoP4t3ewl4FfG1neq7S4WJJPEz+Wu",
	"BSwctIAppYLe6YMK7I1JRXCsF9iuLDzeECP3WhQsnw7C9InVfDCm0nz8NFjzbrHoFlT5qXahXDrmue4a",
	"8RwRx+HKkpA86C75lXn3Y4uk10G6S5KCUCo3U126646WR76s38T127dA+16+pYkz5VRvQy99/GoOlqYO",
	"LLW8r4gYoEzLrDAxI46U9B9YIXeiYx7JA3wvD/AC/8HZQcQXz6KEPkv0AqhngkyJICwiz0h09MwMOyFD",
	"TXSYRUQezNUi+R8cMJHBqgdaTWutv3ZCjsHYTiFYR5F6CRzcTz6iu5dXZOaXuP9jjAT8VlWO6zNiOKaV",
	"OIiU+iiCDSH4X7X/u3jx83UwCHCS8PuEShW8+t1uTKDwbFjG71Xwzq7Uq1/wHWWzV9dzKl9d41nw+Enf",
	"92zZhPDqTaEXKUGKyR1JeArf6s7uNNsLGFAdaSJN705CHMeCSBm8CiyvKJmdBOhr4qEk4o5GxgJk1ivI",
	"5JBgqYaH8KUSy1CTPs9U8OpwEEgSCaLCYn08iyP5BbzHGkJceUl9+2KVWJqW3732CuilBW8cZiDtpTnG",
	"/zG2FCXz28BRGNzARygnX2vs6Xy0i5NZZzd+gafY4F1iTGeMC7JHpFerjnLC+7NhgnN6pdr2ZqVrP7bb",
	"Wxcg/Uq6tQqgKrU3VpkkJFJWRHh3eXeCbFNY2LE5AOg1lRG/I2IJFi7LSZ34N8HRLWEx0qeFCESsAsnd",
	"qcXxSrNJQiOv/NKiTSsOnvenyvFrfelSpm9OUKJQNpwQdU8IPKkxSrMk0XeAVcLKXHjM2WBFrh94DHSe",
	"I+87vGNoVjrD/hc2LGEoE65kOMGSVKy6hyM/AqU+M8Hv1TykLBJkYY0F3boUkqkdLSAP5qBQnJS2M6GM",
	"YAH3QfFzVyEpX9NC0KruYo1cy6JUeUvarzS56k6zirUefMHek48VPDwSiT0DwMmT5MMU7qtVsG0Hs8mP",
	"gz89Cn3HFtfo9oBpGWbYqcu0YHVaxAnB3yB0lodQZAnpBKetcwEZ7OzdYUHzojdYqnqiU/Qp4Niz3RNS",
	"uVcZ1kar1FyfhM9ChcWMqE5QiuayfH6dJao7Ot6eZZj6pgPJdtXLrsMIDo7xiYHvtgRpICka3faYbt7c",
	"XO2RI8rOEPIuOYDe9FTvVILUl5oavaTRX1bZ4aemy4K5oUHJoh9z4KMCvliCsMIdq8FZtfgz40MrF1sw",
	"JX6X31E9tJ/O2uHEhlXvjPjOLH7wCs5fNL8N9NiJFvQMr51xQdV8EbwKBM9YLPiEAruecnGPRTw1jhK5",
	"QJZ/sic6mt+G4BgIRLggas51q5/f6PdLJmjwKnhmMCg5GAW/XF9fPjs8OARNCI+JRa/ky6T3elIsV425",
	"T7hQnEUJN4vXS/swgKdCqkLK7nBC47DCYfqC0xscU5kmeOl22bhdoHcGPNJzRVcOfDF8xiSekvCO8gR2",
	"ToaU7QuXjzAW+mc+lpbpmogV1PJnRd9pyCaJcTp0e7lYys9J/lc6K/8lSExl/pdcOABSJsM5SRI+NH+r",
	"yMHrNJX4TlNtjM6hi3mtaRLJUrmLlUoS9JOF9lg5I6ulENMMNM+aL5ak6Q76aysrDjNGtcC4kOZbd5YL",
	"pTaJbiMczXdBEucFMNBUL1ItKdo3wqq5lpsaHTcjkdrTjDm/pWQ9RtAKHpQANrQ33Zp+tdbrHqSeRXxd",
	"av9Y2gDvgzVeMrygUWjQdU+cLi4jZsVSwmLCoqXxYdIwDixI/Y1V3sDC6bsMTAshTohYexuWm657dRvJ",
	"MPdf6CT/Q5/cK6GuFijuRXCQe2vdHXz6ghyQDKeCL8JCVt0AGdkZm7eCLzSXfGNGWoFbwqPj0VEnFBIe",
	"BZVux726PWiiwUmTUW/IDt5YgAVbrQ4RRnyxwOZl1plkVw2Bzi3A5lDgQr6zcS41NCPJRCRMtfDhU5Nd",
	"z6lEU0qSGFGJYpIKEoESiTI0xXccDJgVGCBpDsDI42xCgiz4nemD0TRTmYCAB4Jl028q4mY13cbRqRaV",
	"WOLe62sZOGdGVrRcOA6V9dtdzzyY9Xkqu+M/Pq4aBF1r4HV1BEAqj/7JJ/kWi+luBI80/FYv7aXdnfp2",
	"5UJ9fsT/XdeyWLf6gq1gZeWmF1SqFhZWlfVX6j6Klrqf4Iv6eT0b/hce/jEavhyGB69a7LjTLEm0+NBB",
	"ZngcBLOMxpuMMj8MIyxJiON/Zfo1wWeZLAkIvflmZfvNqyW/fc3zxbv7vxyiM8AA/aQxAJWwmdgcy3lo",
	"JchwiiNl1n/9ikBHLYtpUCGeTimjalmeFE7u8VLfWAv8ACsNnz5npGLRKq2Vhug0mCvVMXlD+wAcTrLp",
	"lIihKMIHvtjK6geMGd6N7pCKBU8dSkMlME2s+mTL2/K14Kl7OAFwdO2Au6EZN8FrX3wlEn6PNJEIDP6N",
	"CLAo8MokGc7Vw3q0NhNMW5DNVZnmtUA5C13LygsTnvIWU3NGh5XvbglJhzihd2SLlXPIaGAhANvN66Xz",
	"rtWfOYBNKogiLAaszAz3RTnFiPzhy9MnjIqgU121/A3sgiB6npHSOIXzWIB/eoVlOIarV4kkRBl7DFzQ",
	"XVjHlR2gyj5+gXAQ9B4GK3DJqtofPJvByxsGz3k7I3ewIhJPd3EqpCZCjWxoYlRW7Eb7LK/nBJnuyDRy",
	"xk7FkR7AhLMaQyd08eoR1xkESq1zg/D6a9MYtbd8CVSBPD0FdvkUeAdrWxJtPYv99BiorFxjyVa8Bipt",
	"VzwHKHOzU6FUgthDuaXo9K6AisYWKhjycBw6q5rCihgNj4tFcoPOEj4BM3rCI/iXceYXZRM+0wwsUXNn",
	"d9oe9ws+05w6UXOjWyiZIGd9wr/wQ1n2MOJ4xzuvitBv+IEusgXS0BBAQwbaxq6lPqnM6Ohh0Wd+r9ml",
	"/Fwob7pwb0+PkvdK3yce4wllsw3fc9UVfe9APQ4CLuiMMpwovm46pZaPg6B0s2yJTelAO+YnsmTt66zS",
	"9tHaZXrtj6cHmN/IlIgwwVJt84KuzRGAogssVelRDGS8H6MC2KVSrKL5ulUotbR+UvbcrBcyjDtORzPC",
	"lW6MzIVjeeCUsv3MvspjadIWgelB0+wOuBMT5PT5zk9hL7gu+kiEtda6P5jj1/YzrXT7NKERCXFmTvyW",
	"hD0GaOgsM1zBAt9GQeKFf1XoPPIhdmY4zscozMMy5enOzA7jlKeFyUGKOxWlt3j3b1J9f3nlMEvT1+eX",
	"6Fd9iZ7By7uESxgxtdnlPLYQ0DlTFYg0TshmB0WuHOddDPG3voOUD83UXbKXsQGwf3CFlQyd5/5aT6Ny",
	"49xTKU9fsdoOzKZ0FpZ7aEkYi5TuyT6tojSUCyyUU2zt4EhcRykaa5jo3MI0A33RY9E8D5Cex6Rz2sUk",
	"S9A08IwxkuxnjzJJwmk0oyFO007X3Fss1fnP71ApOYjfD7fkVes8w37C0punwPl5VR0Gt/T4KjJoaGC1",
	"LEz1oHe9DK5jHvz+Q9VPzLxfzYO59PAN/kSCfA6lTELJKBpSdH9/f2D7HUR8gR4D81x8CF6NOjpv/RVf",
	"6dDCuFwMDd5/BlNByFsbhW1INc/lFbwKZkSdnV/IQuOz1I9yl6HjcesIwA1N5I5c3xt38uasanOw7Wvz",
	"sHPoeDTGObVeZUmPQ7Ii0YP/ILSlffCegO7pH1qO8OO6mbbnh5i4VV03wZ7+9qUzV0NNerHIXdxq7pWF",
	"U2hxTKdUmHxdWM71P7HmxQnBUln7osAs5gv9IU6H1jNrUHYqzcVyIxnQaCiEdRLV/02M/N5uniQPZU+1",
	"dYe9Molc462R91sosJyjNw9lBzdnBOg9Wj3bYT56LFoGL4wAbmBNszFfYMpCDsFJDZ+srlNeM+hHSdBr",
	"GAhi4eEJCzsZxgLfS0/8S8eBLT14x76C39BrGOERSMZ5x/VmcB0wKQjSj02conP4Pd+CTNAwJqlxR9ps",
	"/pquvcN9FBS9Bth2oISwPQ1zQZgbJMVqviUprRwK8mQ4CtID3s95QvY02H8A7Mcy29gNybQd3WKcFpwS",
	"dGl+LuHk1Ghcqm32t9vIzumNG41AgcQCP4T3mH4JFH7DD+g/CJ3Nm3aNArAvoHpCe4V+URYXyp41knTt",
	"aivCOHPxNzg8enEwOhgdHAaD/SZyS7nxyc2H/nEERgETHfn89PT4tBotuV7dqEEOBWYzMrThcwXww+2A",
	"d4iLceKKC/hGemsaASm5LEJt7Etp/1712z4TOsGIkhFOiAgjmvojNG3L3NOh6dAMsd7hSCjV9nvKtpC0",
	"zy4u36NLwRWPeCKd1JfwmTcUN8KhtXUSIboIHFImPufvCIeSzlhuPtsSTIql3BSMT+OPpUznwkRs6kHu",
	"iKDTZWdsI5w3bWBM07l18dp0zgZCRhXZCkxCwW5KZziZbQVIJFtvo1A7IitRGN83BZHnMNoQgAvaKONS",
	"OAJ0Y9udUhNMiQgN+2iJhIji+Ta7Qh5SLkk4jWEahFXJtjSQ8YSWMrk73tBZBfr2cU/xy2oVz40CMeMv",
	"JRndXj/ZslRmIJXIu8PRhktgOu9rDQD64TaoHe4VtaNtUDvaK2rH26C2B6J22UPKiZVkp/dLC/HOKglw",
	"V9iLfhY8S9G71+Dsrj930labXs6HbpbROEwFmdKHTRwpfLl6fVYfHt0SZVGlcULCVLfcqdoeXJinOPKn",
	"M0nIHUnK/CaTAN7oLSHNOo4XFBIfFxK+beRzyHFxCHnjw6PjE5+k7UwoTSDSn2qxZz5p8DdN7bwL1HGa",
	"eltPHOLr6avIw1h4YQMMWhvMm5+F8dCJwpueBMbDCBcOtVuA+QYuwy5ib5O7aNwr9+WOgatEhorq0yk3",
	"56sOwldcpG/irt8O+68tDmyH/deWGLbD/msLFRtin/oTdFm3O/ukbD5xS2+FVHDju9TB7c7oJHLR4XNG",
	"o2EUDXEyq3g/RdmERhBmcC8I48EgmEwEeN5G/hxkAAgkvCF4wfkxhVYSBInKaMXVNAjcw6h1mDCKQo1v",
	"OMmE1K/tP+Amy9VdnTMIV/esuhS6+2N9QFCnUhbz+8qAJ4cvT45HJ5UkxoMNpKLbbljpRmbSuXffHRFU",
	"LUOeqTSrrCx4SmtctBQAxjdYyYqAZNusd5EwBm894NYKDvt1k0KkTMIIO93HZlr9jhqp8fgCnZ+ZKhNu",
	"5GrK+90Nb+FrAqo50I7HF3fHwSC4vhjfHR6M8k+H+aej/NOx90wAYMr2AtgIXHt53+9PJFJRGmqpv4dr",
	"ke415X6SVHNBsL+eSSE3hbdkKde0kXtby0Jy2h/4w/2CP9ov+P3Rcc1Hrkk/WUsxHHiY+n64O7l77gd1",
	"97zFimtK+NHp0sP8jV8lBM7kVrmOF8CK+RfJwB491iJj6Fnh5FKxGrU574BFaROvHVpzhKF+L5g8rVID",
	"xyuN47n+GRUlNKv2KM3L8Yy0mlZ9frS5vsPVXdRAzJrlcowHmPmp3MfkZMViWS7e49Fb7MzPrIsiKRUc",
	"8rjeYSP/tfDcMmvlCptbsSHFnYxenq5OH7vGBQ12z+dxBru+gjTN7/28r/KcWpXR0dgmnffSXqpfFU0P",
	"rISwmdf3ZOP9dLkdHF8oCjDmQQNrc9DaehIWudIyvyZRggVB53Y+3gWHn7qna3Jr89gcxv6U705jWZNM",
	"KiJCSZSibOZN2mx+0e85UwuJI4xsv2aRpQnnSiqBU5e7q2m/NV09vnSFw8GG6adxSiFLZJ4daW0PN/+W",
	"O6eW62wtuHLu1Pbg29JEvRBcwSLfM9e6RaxyVvB4Pth3bJmqTbRiFqfridnha4cvwVsTcXtuVveCz65h",
	"UdYE3dabt6URcwx37XZ0Wa06120BWnH1cEzL4AslFwVPEiIQZWbzWlJH1yNHTSGzoDgUn1oqU2UVYdhk",
	"LQFfcEFwNAf8B8E9pvqohjhNBb8zqbLXrJFnNu7Ae1lTNQVi0xd2KMjnisd6TJiiSu/07A+aQj6IaWJS",
	"tAt8P3R/eeXJ5s7nrlHV47X1aN3s3Xp0Oaxz5i80uJXrzMKvuJoGwYTbK6fDgi4o06JEaLetQzS1OTpo",
	"TP8wWfltaJ0MGnqWArbcGLarPd0AzqdTV/bcIyct09ombbLiAMUR9E4gbYvTo/dINgK6GicTqvuR3doe",
	"b8nSOuP2j/r7lSzRhRGNNpe6eZqJWavXbD1iHV1CawgSd7V8uhkbBYnuVnoD1+OUI0LvSO7f6yT1DqtU",
	"1VKKOytB5Vw/hkACJ7ivzjdjq8eS3h4/JYaWmhIJz4NBCc2cnUwow7YCVR3SvaCKhEbJ3q2yiOda8hC6",
	"zPrWZT6HTi6Lzsr0365ET9nFta2qjxEsXo6adXlGj4O+Yq1H6oQT6CsTiBd5nSbXKi9aqnheco2yIiwm",
	"EgTk9skSqTmVqCg0tE7c7VdrppxIJEx5QqNltcaH1Zv46lOaCjAGAgIIeq/MLkvkZFG4E7S8gxiPiZ2v",
	"JgsaE/2zSSLuSsXYeR7cMIT00K8gG73uKaFkYb2jbofZ8hXCBjyVTdh0CqWyOashSyX6LsVSi3PfAZwk",
	"WQsnSSowDFIVKAvK1kGBmqq5z0Le24GkEs1g+wXSS/c5w4krO/OdZ7/CBWXfIdBYwbIh9M4OoVGYY4kS",
	"ImUNbXeoTJlctgIwVbVp2LTy5ap4lkgwW5qiXqYmjj/SyT9OJ+f9FmJ1yjoNBvR0Oy6g1HSIsQ+C4pTY",
	"ZDK13DJQIK5fNaOKk8yOHpJ7LIMUlTl1h0pIf5fiRWYQSKlRrqi2B3ddN065DNoeh4H0eILMyIOnXOgV",
	"mWUJFqgIVKzXWrNgpL63NChvDSsoJNoZ/XVqjbZCUWUtaY1KW6QU6S1nq3/oqSc1Ms9jHQGvhjSvA1CT",
	"P5QSK5RReUnIzQSzqgbnTI+1Wsmjm7QpdkwU55dC1oRyrkHXNGpFuKgt4BGIlErb7U+UmRe9/1fNluOE",
	"tKi18UNCpy0/9nWl5LlVx+Mpw6Vqn0Ge5NPvmUAiq6/3v8+ragx4McA7QxKrYgT/3G7F3nxxchD7YDUE",
	"tTq3HMcS4Urxdagti22dYihdVFRRrcdVtdYVdoK4xqm1fqqWaiiWq8vxmyY+fXXV46IdwpQmpK24cWxp",
	"urUCsG2Qs+S8Fjlc1KVRYKX03MsMbf2l0fV4USkzXyH4D+fjS2R+XDlRf5X6UrnmVZ03U0vwSKYtCDsV",
	"3cpRdf8wS2PvBp+52vyoCtC2H/St7iQjlXgsPnTGSIzK1HRNF0QqvEgRkEj7BOopOkvkWr5FS6D1GUU4",
	"atOYu2O8glorRaIVNxDtgS6PNFY96rTm7KOb0KOb5/qWHvoJjROeEbQg0RwzKhf5BDCLLTuqzM89763I",
	"XFFn1JLHCFWSjGtvbi25FmXqQewiKpqj8fiiWXS75WhtBr1ULb0der7jXbZI7s1030WKbNjRPRTnpWrY",
	"3BVk3QAk+9CuIUZPGfaYTLJZOdNY7XpjnFm2WfgWHL08efn8xdHL0y5h1p8zSlqkGqm0wB3mgSn5CC+7",
	"AP6DCB7eY8FsHE0dvk9p6CIht4uar3mybEBqPQLELcqr48PdIXNx4s2iXt1mah+4bq6fmiOMS4W/CrVk",
	"N+iux64qzz7VkP1r1pAFr3DKqKI46Y5Ko9e/dV3V107dv2VhVQenfKK3Ka2amyFWSyN7qUO6qyyx/jKk",
	"ecrYb78I6o4XYlUN1PqqPNVm/bZrs+aJVPqb6X+ynf+darwm02remRWW/vOLt+iCWzdCCDvbW0JyC39f",
	"sDfPnFtbEUDTkyjajbF5ouhzC8Elis4h7jhRdD5Oe6LoYugdJ4ouxm5PFP3NFiFmCtJS+6ioY6paRVnG",
	"M4nGCisqFY1ksEV5Y5fgs69j/raZXndQYNkcuXB+FGbpTOB4F2zutWkMt+WzI/TRAl5fkJkzpaV5xsUC",
	"J7tAxABE7w3AYghNjLuB/53SfBm91wC3qin9dy4RHa7xNH+qI/1UR3qbOtLfcJVcb7VbI2LtYHfrRWyN",
	"ULSPKrtPxXO3W7BvsiauHdo8Z/c1trUbNgbvXPi22+J+lFrg+M/gS1S2dWO4OoiCT4jc1URMOUB0aYDu",
	"qzaut9gq4+HmNZI9U3nP0WuAt7OaunupUPvvUXh2p/Vkz+JGyVgTrFnjbpAwH7L9lkbb1XE3SmGzYrso",
	"WKu/6ayRASysSgY8Zm3PbSfnQLlMfsCUQs52qeJ8FycEnWvA6AOr6DP/+jVGVzwzip9D2S2xon7amdw6",
	"aPz6i1cxlUTTpiKlp1BPXglQFEn9UYQ2m+6gFNrnymZVgvzcvQhoWIf5TpGFxaPrgs/GgIf/kdW/ZmvC",
	"Z1jidEfLfzY+u9xPJVjLIAESki7YcIEpU5gyymaoEDRKeSBlLQ3mRgi4gmU5vJ1UoDXB3DZWoLUCLWdU",
	"cRFmgq4tPVtq+lS79ql27VPt2q1q145TEtHpEt3PCYTpafJfpAo+OpdOnCRLBFARRlP9LovLgtsXKnn7",
	"jZaohZRhrfaFvvVUTWbmMYB7qoC7pwq425SpfSo/+5cqP/tlqscWdSZ2VjzWuJUEf40itWuLz0bdH8q6",
	"t30n/3Vr1jL6OSMhjVufl74CXNAJvXuNpnl61gJQoQ7pAch2enxs+M7K1lK3ueOddE+B1vRq9TD/nhGE",
	"ccndr4HeinxrMTExqSrBst1b/F+SryygVF2z/3f84X1eE18/L3NH8E4PwgtoXcmvEBbeAV2SOdtetoKh",
	"EavgOc9Fx+L+rrXf2Xwm8CJ3NfdvZ8JnyNq8ELT3+3lvm0JidWWI/dfT3Un8+SYl3baDtyY5afkMwd6B",
	"+/1KSlh1sovt73ekCzJbg1B+mmteDPUMfyxG0EKCIoQu9LJipoBYF0RKPCOymerPY6y9uRn/43/r//j1",
	"Q/WCJGRBxAy05SboMxJUGZ0WZDMzkR76+a9MwhLKpjywISx+FUdhLevt1fOb6VviiT7nng31Ncs5l6o1",
	"VYN5SHRcx1r8kQ2hcjMHYKUwjjf6B3RmF7hBqITFKafMQxVv7C/6AgInfA9fquWLaQVQfO3TUBpMW7ub",
	"3z0dM+EJXoTaqjalRD65VWnv3jQaNVfHG86fJDbcl09R0bDjGc5R82DSXgybsDsqOFsQptrvZDCBKcLu",
	"VsTRr6jVXFOX2cIHeeD92h7/hJbeKDkHZk3WyEuYwBt259VfN7VLkihUWhl0hwXVbF62wW3TeJcXroOp",
	"cMHvCARieAdH5AF81jUhckYkkqAEoiQ2csdfeYfGnbdn3HFvxis3JmO9N0a27Eq+C1CrRMwy/bv0y3PG",
	"trKe0bck0ArOLt+hN9Y+U4vNtfr79RKJvX7XG4Qbodd6iKJ/+UqwKPnnm9eS8CJsb+6j0WhwAv87HJyM",
	"jgcno5PByeh0cDJ6MTgZ/Tg4ORwNTg6PBydHp4OTo5eD09FocDo6HJyOjgano+PB6ejkk2+2/qeEP5FH",
	"3RNNI59Xpyh5Hnrn4jW+7WtWHeLHt5PIO2TPyx0av9bWbjZDe8evJnXdaGDm4csEMo1m9CxNu4et2g4/",
	"7SJotUNk31mabhvU9/b853d6isVsf/LG5runx1ss1fnP7xBO04RGJmfX6idozCPBufKG++cJ/GIeAT9F",
	"uiniJkuBIAuuCNIC8AG6nhMEin3icjyZnA2TjCZxOa2hyUKnZSuHa95NovH51bvL6/Dtu4s3789+ewO5",
	"Ei7Prn8Jr6/O3o8vzq7fvD5A7yDbHEYLzGIMeQhsknNvJqkZUSEMKX2iqLk7uEBWGSbtzJSg5A4nGs3i",
	"iiklSi+MxxoNPINUYwf9E3VQFpOH1Wtvvi+8ftJUP+sg3hlh9PHqHVJzrC/j2IWQIplgOUff3wTPboIf",
	"dCctSTX3wCVUbGyE2we9B/l6M+QKaKxcb7DoO0t6rQoZSRJZGbFMpvdzouYmnyHjYELToFw+DLfaPCXM",
	"Tp4qJGHWOE+YcoDeTd1WxoPWocDHQtZBG6i27gZlM/PaoNJZ6zbYXuMSEhPRw7den3Pw4NDdut4y+CEU",
	"5LOsJstblZLTqlNKOSYjzqJMCDjleQo/Pf3KymGGjL7+wKWQ9C2wPUB2LHeCkOZm4W9n/xlevfk/YxRn",
	"epnKO0CkwpOEyrk+TQO9wXo8fkeEoDEx2BgiPEBvM6HJZcEFGbiEmWUUYk4kEFLM0SJLFE0T8kDZDMBC",
	"eTvjUFqBujY94YZagvRBwpnowYNklqZcqGrF0spMNt+By/8ch+cf3r/fcg/6nwcn19TpEmpa6IPsmUrQ",
	"OedmiqW0qv5+x+0SS1l4NnY4bymGFJOmUpb/kGmm1EiFqDgiD0rgSJVYO9z1cNUpuETVfKhBm0xH+quP",
	"V+8Obtj1PJMDdJONRscRZF+EjwQtMqnQHN8RpO65qwsiX0HPKRUSWKkrF1K7UAb5sCarZ70pIAO1Dw5u",
	"2LupOU8wwRhIIz9kKRFTLhZogVU01xRlZYSPV+/MGHnLqT563ltHmqv+3fu3H7wXf+BNsalK3gedN3xM",
	"1KXu1TU5u+c97eSm0vvrbf0QTlqsRFaU64ezFQPrqqPqddHKXhI+m8G+TNH4+vWbq6tc/2vEh3Y+ormQ",
	"1NvfKgagn3Jr1gA5SfQNU0SkgkpiGa2sD3ywyhzSjATCEU1skEq+4O47X+RQYTt0rc03PhnROL2W2v7s",
	"3GCbEX42Ob5radPd+y6LwgqWt9VfrK8wVp5rQXp5pbUFZQ3QrsRCspshZJ4/vbpDYJKR5YGv9Dfeo+nq",
	"eNmGY/332upVdgDbvXS4xgajQWtdp9r5KvH0pmHE6orM5chs7vXcn95afjUz1FeK0zp7jsfBDftgT0Oy",
	"HKAlz+C2nPIk4fdG0NACOUNn5xdDzQ3iIv35AFEt9NJojiIsSesJ1O+QDFK2Uf30SpZO2skh6XOpd+7g",
	"hv3GpapNw+Qfx4kgOF4ifIcpKJtWzMpgDfwfknWiG3DAvwnyW0hPFFBhBLKDU1mUp8uXzQ0P/EXjkGYi",
	"5ZJMsyRZIs1lFYkPbti5kTr1Atpk8dDtJjjL1JwL+gcgdRMM0E0AvGXY+EFfF3OeDifL4ZynlYkX47zn",
	"kOjSMrtimHOowKeGmoxuAoBVfGkKfd0ECOI91tEDmpAIZ2Yzl5V1jzi7I8KUXIYFcpfegUeHaCyeebmG",
	"KRQESjRn7Bhxb+jCJgeIQ2U9ztYxBTdynSGsGgRdW++zHjqryhXsK0xWFgWLV2nlPFYfJnA/SfOuHTgR",
	"BU2WVl4yl4EVmPQJVfiWIGx9RfSuGHQNBUqQxwxzSPisIO1v7Lj/XShnRRRJH6KiU7UMOSNhTGaCkBXe",
	"LZAVZlWhyTrKpoihbv84CPT7r7tvzGuscK69doZnExLmlI2dTEGQoLUCo5+Li32jLtEaXxeTpX3DnGGm",
	"s6xWYNHvHZM13tnbB/Y7YbIxSsj7WLF9wO9Bs+RKmob+N2S5gIpmL0OcpkUBFVP+HtLPw9M/k+b0bFTX",
	"2kU5V2k9N9QFbniTHXKCWXxPYzUPE7qgqgX9twY5o+TTV5QrwA9pYSdL9J0kapjDGgKs72x6XeCI4IxP",
	"WKTZmrWFRSjvgKCD4TB2h/c0/d+DyX1CF0OqH+7mI6Tah8UwB6+Pv1H/5bcpn8oJW2DyHn2k0YOVdGCT",
	"pXIPIs3YJ8S5dJEYVCBGKCKC8hhkIWI1qfAGn5CSEXLKhW44NHF9JunvHAu9me17Yp9Z5j4x9487WS6a",
	"aaFlKRbrO8DqFWxVII35QdChvv/G+9eoZOWW1yyIf32dxlnRhVu5PPu4u+pgot5lEVgRsyZ2O1oXeNWq",
	"wjXavrSA2oqlXdAkobbqSesKez1bK+veIMbaXTnYbmd8ddw8icaRedmVlVIiS+wim7YTItE9mBQSMGvI",
	"nBlhhpPlHyQeOC2W/hjxxcQohPTiub2VJCGRsgIPVK9DhCmTM9pkNbdCTcYKwvcfow7nxuxwB+axh8XX",
	"D/0n/rIP/rKhsp2yXLRr7keuvLJ6/sbmFBuiV8Iwh8kSSkjASpOHKMmMeUg/D7BUKMUQdwTbusBL2KgF",
	"ThIiYBOpfZes5WF/y02UKSehMUHv787Xg5grH4YjbEbZDkSMJvi8DmeNrZa0osppV4qafVIRHNfK+yHO",
	"yMDyR2pNPopGt0PTPzY2kaIkgDXNQXqHFVfit88sjeg/Jw9xtkjbolpWbod9HBTAdiNQtoLXzxTLFvwZ",
	"6rvD9EfWRARdYRbzBXpbDPPofSXtcexLO4anjo93O604H1RzVw6K9485je6117G2ftme4h4qLY/UFS74",
	"jtTBTIK+j7iwdn1ZqkSW63V+6Orda59Oj3Uc2z17qwnTatV7i0SCazNrQoI3FyfX0R5aRD11DS6ZQrYP",
	"f4BEeaeaaLb771mSfpsngmOK9KnZ4HrsqtaAzR8ayntqbJXdM7z7uxqoLiSkTVBZV5YiMO9jsL12QsZZ",
	"eovz0KmbOzr7r7rwVDfhi9RNkDIJ4YxA+qcucCo9dlo6oYNT5Ft7nLf2jHSMpMRUtil34GCsqiXdSEEc",
	"KD1592dbMrxGjrtStpmj0Wjk0r64PC92hgB7Wppmne99/coJ31rpgl1lxV+dLb4ibbmMPU7agj30Gz6e",
	"0sqvXjoVta3cU/r5bzr9/J4yxH8LGd9X1M33GftK7f9eCd+/QDr3p4zs//YZ2b90evFZRuNN+n21RONf",
	"KV/2Xy9p9YYy2hfPbt0Z2b9BGuzOe/J18mXvNM31dnP9lvJhf+mk0rt/eH2R7NHdor7//lmmv0RS6H/7",
	"XM1dZJS9JW3+BtMkW8WZitKVCZKnmCZdMyRD262SK/9NkiLvO0nrU9LVDklXt0rjCX4FYe66sFq3w6ZU",
	"s8aix98mD+gXVVn2TeO5+ShWsPkGs2Y2oibLtn1nbmnLpOkMH6uM/K5JvzR7ZZNKHR1fxswZYUTgJHf5",
	"ryLzs/kVZZKYFJhrcqk1AxX9qXGcTNkaV9dwILclD8p+XusFUqm4wLPChaY9n5pnoo1NKy+VZ+PASQLx",
	"KZrVYHVOr1bZCw9yoNhqdcYo4jy7uR6Y9m2OB9uYgL+godSGsubT38ZIaiCsySgTzV1CmQ1rD54bAI9W",
	"wA5lKgiO4frZtSkrk4qIUJJIkG4c89x0QWPTRQNJs3CBay+J2oqkWSi7DnD5EY2Ji/SJvOHQ/vAe3fbZ",
	"9VyvlYFQY8EO3CDHZ002uPPLj7/htEs2OI30bziVXgBtbxuNRcoTGlVUOuCBNAjIdEojCheiZpFCqmEG",
	"1/SQmfxnM8EzCPg8GkbRQ+0Ls0my/O1xvdmxt9lJvdmJa1b+stamaGHzIECtdHgqmuICncxglx/RpVmO",
	"x0GZZFqIKvdeK68eZDrUMo3g6TBKs2AQcJYs7Uf41q4ffG0/m9b5JEyP/E/zKxd5L/sZvldAb+4X+9cn",
	"f6aG9Qm/ijmtJ017SLqQ5pj4+7dRZozJonJbl81oZJLNuori1cblkBlXnbWa4bNvzdaVfp/mGWcdWWsO",
	"ndad2Cg2pnQG0WD2G9uvu7vm2svH5iV3RWT7WlWvyYP1ri8CVNScgGM1nLQVac1X746nj4bFpH2MhFO8",
	"oMlyi7vs9fuxTZiELKz2dK+r88o2u4BPaKpvyJikgkRYkTjMj5BsMYeaHuQhJYJqcDjp0KdeKHl9JYJm",
	"LeSVAbqrXRbbOhqTYUTCaDoDH2kiwhTb+o2bywm1q9VF9FflHmTGg2AnusgSrAhKOJshQRKO4xaRY1aR",
	"6lfoyn5+B+rOmbCJ1nc1myI/EVhT0ISoe0IYGr/7+eP46hDiRgTBCZJ8qoZS8bRlIvry2+Jg/Az9jS3V",
	"HrYUL6FKoRZ4Q8yW4YKoOW8x61dNsCvuSWcbbknO3SkJt029vYLR/XJ4jiUxZts1Kt9y07YbqGZgbn0j",
	"zg/DmIeMq8KoQJkkUSZICDnvp0SEhEW8JXJBgzgK77m4xYJnLLam7HsysWo/Y9Ru4QtzLOJQk4hxBN4l",
	"mf6CRYzGiqfobKpcx4atDIvYZOOpZakBQ1iYCnpHEzIjcQhJjJoNP2c02sB6oKLeanV/qtv6RfkLTOgK",
	"0L/Msb8E5PtAKEzXxhGwI6P1dSl5c4fNBLvroUGXDnLaFUkTHJEBEiTOIoK4QPrasenJ9AMb8SmSCqtM",
	"IoDqRALNzxBmyFlhvOdJ4zLFNPmm5wDl4TJBWiaRn+wpF7fhPWaqzecpbymJymi8si1EeZE4dGfB04JH",
	"OElJ91ASrw0pwkkusX0nkYYH+Q4OCqsei8NyOYXO0TJrjmvq8sx0CoPZItTlgs8QFN34xc3Cd0Qv+Ew3",
	"ytvo6We46xktNwV7nH6lDTUHr6hqV0hmv0EX9B/QBf3GjfPghoY4M3BoEpAauWcj0+D1nJRCcRVdgIhi",
	"oEOko8zEHb0jkKVLjwOWsol9cHaSqN7n4I2SxFQu5W2Ev8L1Up9mLRPaiM7/8/HdOUoFVzziiQEa+69r",
	"li1waBVGqb2RexIzj2Qamgj6riTj6/JY0VV0heTroiHRuHM+nMt3r4t0OOlRCHm1zNk3Jae9LCjVImnC",
	"o3Aad9uqS9sBvQUxWmRM01SIU1pl/t0UwRNqYjCNl8OfW1ZxqnEY1/2TTydcZh9XZhJnl+86XUamNTq7",
	"fFfXyxWA2uRPSVQYZ4vU2QybOyIhr7ZYIXiTh7Sb8ejNQ9mfvGeBDH92Thh7fbGLf2LRtdjFigIX/8Ri",
	"1TreYRFOFyufKN0tdm9zO91O1smO3Gml3i5U38WyZkXZBm/FskV4m9flhzE6xyme0ITCIrcMI5PORvVS",
	"09wg3/osMz9v5SsDDhLIgchh7qeOr3E2BEmw5alnLtoQXv1hQhlZZe/IdQPdtQAsW4RchJD+sxtV29tc",
	"IJOBtE7gBoca4DV0buSCHKd1lG5tLdBetoO6gNXyU2B5WeVmYowb31TlJKFx5O5K174uDlIPqbTR3sHo",
	"07/eF+Jd+wCodHBQehzyRnsH4w4L2QtIpYOD8kdCJ72gVDo8DoKsq/Lwo1EeZjblnKeT/lVu9aL7KA2Y",
	"eyxYOEl4dEviUAk8ndKo0Af1KNPYQ4WZ4KUt12ASqGAkVRbdIoXlLVKCzmaQ/AEVpQY9XO8+E9POpFFt",
	"XPGLMDbxNj+WnBf6Lep6E0Ax4PhVlZPurqBnF89DjYxcrxSt+/L8bFH3z112nXxPN55ZzqbLaPgceOZY",
	"zkNnAatJXhmLnB3KPcRkPFnoV9i/JkfBILhXz6GAZXR8BBUrGfG7mOaqagdmgVOTA9YY2SSVijDV4p8a",
	"0ymtenziO5xgFs1JF12iSfaR+GyKcwzO+2XQsFkxv2eQHfaW6U8dB2lJ+rChOwk45pfLrkgC2ehqhpZ6",
	"+hYIqoFueWhSkctF/lCN2TeZaV0W3Epa2+BPJEWEDl8eHRw+//FgdDB6dvgcPQaDYB6L3I0uWOCHIZ6R",
	"///x4enx89FoZH/P5TQtOw1NfWwu1HBMokxUk9ITNZznMQ7N7CV5Zbb95OOMSTLEUWLTL+kBb8nSPkj2",
	"P6Qvov/8V/QrWaLiLePynnQKo1hv+bbgWoLJbX2LccKVuSbzrCuEtV2vPTOQdhj+wmjp3dilhPvFlnz/",
	"/7yyfPvTP25uvr8Jvrd/wk79cBPc3Pzw33mLHzbwEei2UgY3mxP6r5Zg2hcFPhWEWOqze1eLCz87v6jF",
	"hOtzk8eFl/nDn9sfF2HsBo5JDPIvTItBmYMMNKN1f/jPlw3jKo6XRhcqs3wJbFfi9Btg4VCqm3e7kq1h",
	"MF3WAMZDv5mBHsuMewcLUdqIQXNVSijWNrDHerkisJWi+jupsj0IJE28AskG6ReJGiZ8NjQYmholON33",
	"vaZHXeDULrX+9Ckfeu83nHdwr7Elrd11Gj0As08Ec/xakYJiwWW0NnppyChcoebtuaTRUJ+oWRpp4oyG",
	"egqzVI1aVnYcjYlChe4Y2fLHgFT7Q3k7nCiLGn+MKn8dVpBvzsTh9/AFEHRIFMN2T5PzBfbunRmvtHFg",
	"GYd3rylPGLx6+fJluSbfaLQ9tnA27FBmYeBzKAiWrR6Jq/PDNgCCPrUepQi+8nw63QnLNc8OGMLr4Vm5",
	"nHCS8PsglzYt19ISeu2ecsxs0EEm2e3RqN2R1StlUOK3pcU2f9xhUXwaaq46qCyPLTNu28Vcw/U+w++w",
	"2BU3yxHzkv8/sUBVoxfYiHYlUFbWohWBgvXrwfdak+H31n0qdsbwKI2KjHj69XFZk5u2pLrIE5hcZf6o",
	"qPZUma2asTbNSFtG2/Uqke7uTj79zmNt5mfNmbeHXRknKuc63LSd787l3UXpG01HkrJ9gPZpNC4u36NL",
	"6wFi8sHyeLnZVQKpYC2ElZmj+gCD1Q8jvljYFEW9X1yubzkVAnlIzQcY6FO55spGmaor22dSZxUigbvY",
	"Ll58+PU8GAQXL67Gl/Dv+Hqs/31u/z45//C+zxXrRrezMYM/RAleYJPzB4vbjaaTA/T7PJBIi6/5OOg3",
	"PU6etrm7j6IgKhMsnLcXsO1EJbUAGU0wv1hMWnJT5FkKttvoXDORK+Dd7S7yT/NY8+up+SffUWE/fdpX",
	"KacOO5hrNDZ0oGvYDX55c/Y6GASXH6/1fz+M9T8/v9H/vb46O3+jvzy7Pv8lGASv31y8udZfnH94//7N",
	"uW7y4fL63Yf3403Iv2AWC8pCQaK7nehiy6eK37acZzjG9lg/N3+efPh120PMmUkQswnrrMGRWbQiFLMz",
	"pJxK/9wdaWqw3KRMzF9Nz09Pj08H/Y2vnc+sHjG0uG+wJlVY+t7cGgp4EOamru04kmR0e3xksgNE4LQM",
	"I68/aT/SUzxT3tN3/QE4zcVz9+EEPmx59hoBhx7xwfq5DjkbnoxOGvKE+QfeemTFU68ktvtM2oJuJzll",
	"gu5MCtvhA7N4xnz6Gk/M3yub8OnpkbkxLkRIuqnWKacrikPJo1t5si3L6fLqNQGdbe9ceGn0DbBxIaLN",
	"cda9KhvxTfVIMMkTvcZhOTnyLtIX2pzkV24A9NqBeByUhqXd0tz5QRrzdAEshSKfFQNseqcZJ03vnm+B",
	"+qWBC2MpUZVVV3iZVYGZjtarNupRIbcMZjy+QOdneYCABnVHBJ1W/FecH06JVj+1Cjjdx/2nGQjIEJxs",
	"XeLXncY1lga1qfDQtfXp9XiptTrh5GFsVXq3R7rK1vDwj7Phf42GL9E/bm6Gg47+fVYrX+MI1ma5Jhj2",
	"+vry3AXN1eq6bOMqBFA6ewiZ1q2OQZTF5CF4NSrMDidHp6V1Mer83Tjk2Sd6ZIrKd2H21R6li7v1xtHT",
	"tXmZSsnAbX6pQZBMh/ZTPmYyHboH9GMTy9KY7uA5Cq/AL3KlbzLwBu/UkqGlhrFr2oEVdBvCG+Oph0R2",
	"SARdC0zm8R4VN637k9NAx72uRQMB2NW6nsbD4Wg0GpzA/w4HJ6PjwcnoZHAyOh2cjF4MTkY/Dk4OR4OT",
	"w+OBPlMnRy8Hp6PR4HR0ODgdHQ1OR8eD09HJp12Y8krEUH9y2N+65TEZlJuXpRDIjr9atV8uWrVao18w",
	"sJWKfB/n6i5NlXjtY+tk1shVJrFuaAuo9+TZZzZPWLIsyliCty7i09I61MrEV+o0/P5nYB69msZcQaRn",
	"REXPrD9rqeDBM0kVOXx2MhodmBzQg6LzSefOJ7bzp7zHPZnoH4eHzVvgC9WU2FiruMYBvEtUogukK820",
	"dDQKMpWuyv7q45HTkvRWT8UuM6A7LqVzkHfsfQgKAn5cibpsOwbl8mbbCC4WTmfRxbXfo1fz/++66sf8",
	"n8NfzOEYnpvcUMPXRu9SyEluiQrPgq/hzqyHLzwXVnkZX+TviC/i9NwHsapLGM7UPBQEJ4vd2Ss1zBZj",
	"ZabmhCkaGQK8gnGheJqtGWwCAYtC9Zu4w+TAhgaM3w1IYRZjEeennlQ0VnWE+jpu9sbnp2rVZOTSM9QR",
	"MRXav+bSQOXd/erTzBjDTLZ6h0dzkjuoPnnwP3nw/5U8+GPClqHH3/C04m94BNLnlsT8OwwWuDTq9rG9",
	"MztAzIdWQwhJHDPpjCWTaAiuC/lfijuXuViq4tMQzIfmz2mlz7TcJxWUC6qWwyjBsvEln05N5lFwzxNR",
	"8akM3qkXP23C856CLp6CLr5o0MWcVrQse3IxwSJZDvVQLcWLKFNlqtI47ffe74TRXzYwJclwiHOtxn5W",
	"MMlwMZhNG7SBsJiDeQqm+asF02BxG/psMd+PHn4fDV+eDd/i4fTTP/5b//HpHz/sDklx24aluC0CLbbx",
	"VQv3v9T25gBNFo1IsZK5mHY4OjopyWlD8/dOIkP0iP41fE8jUqyhqaNL/6gaZKcCzxaEqSEkXYUUS+4b",
	"vSaQ4QGr+VBzSDKUCZZzMJbAl9BiGHPV+MJ+R0SkIcVEwx5mzBYBjEu/KT7MUv2HyUfxOSNiOZRcqOHE",
	"TmQHfDWf+xBqXT1WliOc2grBax0RqkvogDdnXlLud8PAhH9sjsPv/Zf6Uzck9eTC/XNTyCQ/yD9+LglA",
	"9qfyn58tswfkcpn120PPpVjs5QCxBjurvHVbVnpNeXnAZSnNozlbdjN3wfgAoLNsxtQk3C3N9nh0ODge",
	"HQ2OR8eD49GLwfHox0878OyEsVr9nK/sr+jcZgo1qPFV+ft3MdyHvIy6GbBu3kt4VNSfIVP6AAFlc7Ib",
	"DtcRyevc/KtR9Hpf7O5u7IhTfkPljkO7oM91ByP3Jgqe/B126e9Q1x45tP1z2JEHxKpBn3wirE+EHdpG",
	"DztWvU9NotuFVZtgTPw5r5YqVCrZUaw5vMuhJnwbIYyv0fX1RfCUGeApM8BuMwMQAbV6dqRGDDJJhham",
	"jbRIOQkJm1FG9vm4ZfFQjzS0yeu8K3D54Q16YzBxiPUvtrInvPLcqF8lxUGR+3YX0rYDV4bdkDLh0acJ",
	"X2WMQSYC43K+K+1kFQkuv4bWSPEWX8drLosjqASObkMZhbdkuT9ShFGGMvIj5H5Fv5JlBSdTsDjiGetT",
	"h2bVVdsRkbEe+NyOW8YoL7e8G3eOjuhc5yWbPelAjHOKNzEIeIsMSib/XrlCrLDo4rmSF2DoW5psG4Vx",
	"smRYANV4MKhpSAr7Zf7UGdhiPqsyknhVBsXfBnLdumdFqb3kMaly071YYzsmSil1t1rVQaHkHLTpYnqa",
	"e43aYo3pV+VBDo7lmE9md1rzuJREznpWl/xtkp+NaqaX8h0/CO4xVcMpF0PIzFD6e45ZLOf4Njeb19xz",
	"qpbrlQlkMkF3pA76vbQ2ZTr+5GISh7syLVfA7zpK8SkNTreowAqb/JbDFfWpCbEKE4Kl2sk9Wz2XZptM",
	"iXOXplsPuX3t516U40OqGZm1NlLyyrrxroweKPsYr4sfKPsRr4wg8DsQd3efrjg+P66Y1po4gp1lie6d",
	"H/pLZIb+e/lQf3t+0vU00U8eyk8eyk0PZam4+JI+yls5DTd9lr1+wztdpCcH4W/bQdi8n3frFVx2BPY+",
	"I59ccJ9ccJ/ynj+5lz65lz65l34b7qXfrqvn39AZa0sfoyfnrO2ds55cpHbtIvUlPaOeHKKeHKKeHKKe",
	"HKK+lkPU1/FX+moOSU/VYZ5cp55cp55cp74916myEWITrynjCOV1fFqjHf3SLkw7dUcqeSBVqjm1+Qn1",
	"9g7yOwXV3YD8Hj9PRaKe8nc/OcTswyGmS6msXkWyupfH2row1uqSWD2KYUXz25LevlavnfuspV+wUkxR",
	"NKFytNCn/+VJGrkigX0zd3VrOmyX/h0MNY3t/pkwInCCzi7fDdCHMcIsRnMs4nssCNJdxMLpGkvePTiF",
	"OUwymsRhjJUe7Wh0+HI4+nF4dHh9+OLV8eGr0+cHo9Hov4LSNIK7w4Ojg0N0coqPj3788SAmd/DeWkpF",
	"wLAcpVnoENV3TRK8CvTzLPn+6gd0zgX5/vq3HxB9MXxxOhp9ROeXH9H/RkcHL0Y///JHMAhYtgijFNJN",
	"a2rgUjlBxFiyF2SRg4+xwmmCGcEpDRdkwcUyeHVy8uL09PT4+QBM3PnXpy9ejp6fHB2+eK6FYYWT/JfD",
	"589/PDw9fDE6ff44CLjM67YEF5RlD+jk4PD0YDQ8/XE40ytNI/Q/np8MP04ypjI0/u0SXWcEnWUz9Bwd",
	"Hr46PHp1cog+Xp8jvZqBEf+DV4enz5+fjA5Pj04HQZaa7358cXwyemz6N5mdqX5Z3qe28/7aLYcmBQQ9",
	"UGwcrHKXLP03yBBraLXLCLY5ym+RdQReoZPq/MpUU8sobmjIc+ILUqnj+z5bTIhAfIoSPqMRTjSZlbKY",
	"Ovbvzx+f01xjGewv6H5OBEFqTnI/ACqRyBjzrkOVaKuz85JwQ5vzWCNmX4MqUf/ZaaolYq/P9cO4dV8d",
	"Tde7WKc+pH9FlKEFTRIqSQS3jKQsIuhNyqP5gWcjilNRhzoGikH257U6Uc88SzfRuwo7bKyHLWRzjwVc",
	"JDhJPkwh2fKqu6/UKZxgSSDBcu30UhbLVda+VfB1Z+NyMxN4EW4FqwABEDXqCosZUWFCzb26bqamufSt",
	"86e6h+oFn701C4PuqZojnCSIqu8kiuY0iQVhWjrhmYiIDFZXTCgg1bbJrPhmjrMJnyELpuoxGzRYspTZ",
	"ggzFNHp++uOLIVPTttwpNRdN6Ieu3p4PdUf0nrPhtcBMphhOyluBF/ZITXB0q99U62VWTQmcqWGKhSRD",
	"22c9Lq85+06hS90JXXDDlvBDxBnrNuZeMm0fvPLm2i6VGDEqsbJS8+jw5MXJj8fPT14MthDvVwrneR4g",
	"yzYu+Aw5+lvNNlaI4yVys3J4V+m6zJYevVj5MnTrXqk1cDaQek2mlOn3gEZrRtkM2aYaRcQZQVygBRcE",
	"SUVSedA4EoYX+C6OOyIEjQmSS6mnrP+n8AxJotBkibiaE4FudP+hwrOboPTcOPDfndvQXU0u0Jc3n8LN",
	"XZu3HntB2QVhMzWHioANTGAluuyVBRmaDl2I6zI3RHuJqwywfS/v51jp15wlNITRjN4RBjvY3EDQCjVg",
	"vZsiW/VpgJgBJeeab08IIguqFIkBtl7BKvQ+RaMeC4m0lXwMiZhmN4EmxxtjLB9WvjcQJTLvdb2hnAF2",
	"Dq8dEZSMV+CqxyvjO5RxjpoXB/9GXliS1L+C63p5XXEUEVBFYlCLRgk3YahFtWGo5WlozbyV3IM8MM/q",
	"oSCfi4/SfczLYkM6NBoNKTNhgxH0GMIVUfmz/Kv0Oj7XaR7m66d5NNa/dSB8D2u9oFLp8ww/O6mcI17e",
	"F3vOD/ow28p58/kUeKr9Ft1WIOp2+NK17I9UA5+KHNdTFLokYkiZVFgL544j8ikid3p4UCUogadTGjUZ",
	"CI5jYWu+bqZkNFVQVqjVAGXIXGelnJXtNM1NcUQTqirl0G4JGAEyCQLBAlOwOWCyAEHPRnabyyoYBEmq",
	"WzFyr/cmy6IUHGjzpkf6Ma30lwz+i7MYDkvha8uZbpPwCCcj9+HQfch/OnYfTtyHU/fhufvwooslcB+L",
	"2PBiAnQ0Q5lGx4fPT8yn05OjEyAKE/OsF3Fu4pm18KYvACq5borv+02kDfEGokWXmvirj4S9yDt4Rmww",
	"8m59rvezOhsmMaXs25lcjkktH+HKeee/NImiJA43r2RQjYYCs1mnMIANdsQOYawVuyfM5hzqoUKPtdfD",
	"tbkzWi5f99Rf+aIxjVrsCrrBBtaE0nXmRbjVeJBkuL3WacJxHKZEhGouCI69RKDbVH0PqzD6hAHUZSDo",
	"u6Yy5EWGLziOO8ocqQByCSFFRTvS7udOSDft+zYBRgT/rpX0aq3aZnlpUL/UrbtM1qe91Fc5ESFheU1W",
	"P5madsi160iEJejLMhn+ZqC9yaHVibDSsYHUbwUyUNALI/NNuU5YFznr5mbs374vVxGtW2F9j37WU0fN",
	"TdLC/ORd72XQSgXVWnyd9La1jm262yaVbaJ4rVJTF+WpJYuxwW5bBWoVmmfdNlGknqHEvmvGv11fIuPQ",
	"JlEmSYwmy9w2ojiShMWI6CE9qqQvSbElR79dlSy25YnzaWJmZlo3gWygd3SswRHBTyZp+bozsJYX5i37",
	"6SHrR+2xFVM/X0x97DA1Vega6qlyM89N3SrHUf/N7oSu6vB6aKR/0ps1WSqjg1yvDJeKCzxry7f4WFmY",
	"fIKebUvbby97wejTxRlBImNgVzPOYh23K/VdX6lceXmlbTfXB0aQno3jxNX9ojY2HccfWLL0R488DgLr",
	"4elxG7O+qe0rWR/ft5y+6pmudGZpBVEv5QvEHjZ3tN2HZcEZVVyEU0wTj6n7L5hBoM6oAFJ59E++/bDL",
	"YN1lmpLKUn5OwmhOonZ3H2P/CUueCblYKsjw5BAEBqn0J6+njiRixRmtY6ybWrdsr+3A/GYuOMrQlaWo",
	"1+/HDQNi2dXGCXDB4ehA/7/G2q4zk4dO5nl1evy4pY7ti5vpugiAHQz2KwTC0m1Y7ECwcu/kqs3raXor",
	"UcSjDxMfD2VYP3chzqvdSUL/KgtjG0yjKRpNcHSrX3j9chO40ILyznpMEFh1mH4+ldB08DwQLZLBoAhp",
	"mAqIr4v970W3jGOA6N3L+rB6uOJETSgLXp0cHz0/ffHjIJiAQPfjjy9fjg6PXo40W1qk4WSZQkYp+EO3",
	"d5+htftDSNeKsVCAe9XhUenPcIEfglcnp8/td4or+PPHo0EQR9yAjQX5HLw6gQ8a3uEgiKXewNEgIPDb",
	"6ckgmAuZhocPJs8V/HGk/zh8fmr/PIY/j+xfJ/qvU9f0VP/lgIANFcBQfe3qf5kiIiKp0mfo+OT5IEiw",
	"VGE0v9XP7ZMPv2p2NQL51cTVgOlHk5sGcHw0OhkEZvbP7acwoSYKcTSyX5iVMH+Tz3axTl4Wf5kWxy/1",
	"hPR34JGkZ3R68uLH54NARpnQf74cBDKHPggkdLOfbQxT8PESPNb1aus9PfJkAdvGnbgUfeOoF8LLNNfZ",
	"7Jzhmb6nXFDnhmg1AWrmsQ1CxXtjh0hNsSlgtDOAc4ITo6PaGUhB5W53ogivc3zv4/tfg0Hw7v27YBCM",
	"P5z/+ubqKhjAaYN/rj+A4/HFyfmH9/rfF+b7F+PrcfcQrwoeyYz3oAVH2LrrJLrdw2kBNtzFd2jS7cmt",
	"5VmQBnd4jAzAzY+R7b/bY2SA7vAYGYA7PUYG5A6PkQG49TF6br5/7r5/fjW+LB+vD7+ew7/u9xfu943P",
	"XTS/jfk928MBiua37o24iwVOaIgnYh/3YiFRbQE6Fwp9wCnbH+w+Cr/ewEGC3AvwXCLdnDpy4BWIRlDb",
	"JVQQ1HYGkN/SHq+dVprtFQPWHa4R+3c0Wc1YtsSzzALMS2QP1GhfNp2ck6WR0HeyPmS7xW7bQ7LdOtVw",
	"7Lg2fZGcY4bd9dD/1iqem102rXiPdm593Kv1Sa/Wp71a2/dwl/a0U3Lbx9qLeg8HCt7neKY2z7lU3uzi",
	"tb8raNF8tgeS1pClVWjuGvRku0uoDW49D4kCl0CrPrES9yDI2C3TMqJPCZ12pbnPoCDZ+Qw+53nAdw14",
	"OzmiFeyeLu6OwtRjWQG2oyuih9T1WFav7Wr4ioZuh0C3PXJt3FHsiQRktxMG9uJ4RzKZ7EZIj04T2qml",
	"uNvXU8/zQNfv59cf/kM/v99/uPgpGAS/nb17fw0unwie9V6+J7tRx+MgUHPBlUp2JQVDbhMSbyY3qT2R",
	"3j2hs/k+NuxekJjK/QBWu7+PHlfbe1b4rhiTmTPfVc0BJvjFZ+eyZv+zy3erzWAdzYGFaa+r22LZ2FV3",
	"GSj5ajXdO3kk0zBLY824W71abZCVWTXwVsqdtVq2bVWMqAGGPpyPL9FHGNnl5IC6Lc3hSwbq3D4XHB69",
	"yO3cHc3WzpCcA/lxNNjWqrw2u0ZpmiZZCtBZy24s8ENMEuxxjBkTJSHUyOKL4O1whxM0IeqeEIbUPUc4",
	"U3yBFY2Q2VLpAhElXtgVd/FaB9dzKm0YvXQlBozLQeFL1t99Ta5bg98s/q9hnlV3NedivqBs7TKYbdp+",
	"GdDXWgc7gZXrUHsWdAl7XDesSUfoy9Mg6IwynChPBgk3sAcX36VMHiCMsLtDiU1dtqHTexOVFcfRzvKa",
	"A0cgXXy7dSvn2d3PsyOHX3GPuyQVT/G6a0epUwMl6ArOaWgq+AJQk8gk6/t39OsZBHJuE2ls6wNeLK3P",
	"WwQ2pbf7d7nXfvN2bJNlo3kONkGlTOuPzk1nY2hlYVkTwMaAzNno5A0PFLAjX3gNq+QI3ySEzdKJlOGs",
	"ySdiLySTiGVdypZyWyi8ZP4u/BS79C582PLryRshV7pNmj9+WR4E3MPD+t8xJPmiVuRQDsCP7p5nSYwS",
	"egtx4DHV0CaZIjYjAI1uh0B0LvW8vGGKG3CGXVOGIIkoRJXbhAKa0tr662EIjubQ/YbFJEqwMCKKSQoA",
	"YG8CF91zgDT6WTRHEZZEDtCNnadukpKITvVFpubkhrE8iRVccpTd8eTOgabSj04+ZT1W0M3Zss5o10Ub",
	"lAl9zdW8WZxBhaHXLudwnIdJNS9nAaHLLFrxXppkchmmPEls1isPleOHUKaC4Nj4JsvtgkWqAR826c4i",
	"jdIsk3jWGgharx9jJHO3tueXH5HpXkB0GsPu0FIihqngEZGa8NNMIYBjk+AL+/orZQnqBBqdm5QUsP5F",
	"/+3QKw5DxFlkfWijxkApTStsaONRDCADVBIpd4W9NIsr9c/2EWNH+SOhk4VJjdd9ELzgGYMIrKuz3yDg",
	"iMwwxLHAAG78zDzrJ0tgSnok0Lpwog9Cx/RRVjWgAWQyz6JzEwCMm8CkjED2ZCGT5w9xhiCJoh3uTgt2",
	"cqsB3TBCydYhxxn7MHZ/x0RQzTZBJh/zBAsq0eEIclsk2ObWZnym77ZYuCx9G+FXggGe3ZAr0BSudikL",
	"+e3njFQiXTZZcwNkxaL/NH5thtvBBq/YXzOGIJkk7sWw0UDjD+HVm4/jN5cfrq4NTJkmNNp8mW6JYCRB",
	"KkoRQNIoOy2E5NEtUbJCmyYxAGWzUgLFLV/2b6Ab4gLZbnAkh9OMmRvRDITykatoKCxvK0p4nCkeDHaM",
	"jB4F7pIKFkZWBCUnyQXizileauU5TMTMWMMyAkV9gN6V9VYM8Nbmx2lc3+s56lkcGzlQYBbzBTN3ItAU",
	"gMm1WdZeoeFrwS3salz1KnZSIiR1dcQbsoqI09B4Q+0otXheFihOh9bNyl+WJ07ROfyeV5qsB32UQKzN",
	"CZDnum5Mf7Y+AqxnCJe98sLVuZJzGTWXfsp5QbuaFtwYK2XZEj4htTxzpU2inDjborkqbWlbaoj6sE3V",
	"PWTlCOGB0tGNuyY7d+ihRZGQZyrsbnx3Mmg4SWXY1cO80qm7t3m5Vw+jf0/3zIrvZWd+ked2I3GfTYqy",
	"Rag79mjezRnONpYy6QdfiN7te44RC56mJA4TPuvYY4ppQuIQZLMsfyl2cDfTHF8/ELvnTaVxQsI06rjl",
	"/+KTjqgkVCrNzTo274e0a92DwnWX/PnVrbl+DPUcQQtvPVr3oyPXpR9K+jmlxcYwf893Saa7ADJaTLq1",
	"Z5MiaVFbqnPToqtJrFbPNYdybaGAFB77Q0etQ1tNQ+uu0tg9HQRJk6WWvO+5uC1eoxshePnutRk5JTKc",
	"CtJxnU37TJKOHngp50mIk4RHnbcGuhh+0qODRqn7EPYyt6X7/etudAybLa4FYaigNCJZmVtfpviekRgV",
	"jbcjvQIOyI8JwZKsKXngShDY1t5yBz7dsshYmD/EOxiy+jGqvHmfy14zHhfufUuWfYYr9dRMpX9vqNEV",
	"JpzfZqns221BpSQ9ejmfvw3wzLtuNs28u9XChaC56N6/32i9CUDxNO0sWecKgg5NoTJELop365QB5mFH",
	"eSFjgL3zROrQoaXagzvY5nfw9OiUkGdt6ZJ1xUoGQf97vOX9ORN4scIsYhqsShgS8cUCs1hjl3I8XFAo",
	"0Tscugw2IzS0Xw4zkUD1plfPniki1YHL1GoLkAaLJXyyFnbLck1fCLDHQg05GwqScC1dlPRLkC9XA8gf",
	"4I0Y/BzP+lyv5wTZH5HiaALpiwbGbjtN8MxkFrY2Gm+C7LyAahMw/KTBiszqZ+xIWA4QnaKYTqfEFCKZ",
	"Y1ap0gJdD76+e0Vj3dtdHnlqFkuQSBDwlwJ7tyMjibBCBsoGSdjNHvsWWf+y2Rrrngdr/YIsQToKKpsg",
	"7QFqP1vd3TXdYfSkzP6c0SikjCqKk1z91sPq/38+vjtH70z/VWfZjitIaRJ/8WRQ0GLJ8IJGQ2JlUi2S",
	"22KIllnqWVrLZzAj6uz8QhaqtaXeiigxas3NkxU3lJLEqsTyZPlQqVMQ4zkE1W9sOfLOOktLluX9XuNf",
	"opvalle2El6D2rrTcJNQH/1YteQjW4mbFbX1fmMVzXt5F67hLbm+vNtF2slp0LwLVnJM+3vlDOrnqi1u",
	"dzgcHQ9PToJSqhnKQuAT+sg9+tPaVfKuxn+ePA71P0flf/yM3mAD1SilwovUX7orr9PQ5qBejcewj81B",
	"BfNBILMoIiQma5IuNRaqZYnlujXu6W9px/NgcmXBtaXTMxZUc1N18+1zPdr8+mq5wjbxXSsnBuviwHZl",
	"UdrWec3BKS9MbqSrDbkiPV3dFGAiXcMUL4FgXbbM3P/zx8OXRyX3z9PDI696lCdxyB526zADQPlE8oQo",
	"sg/QHaOH+8IVZNpR8dQX8k6S2Hoh3+GE7hjjL+y4DEXRzMEYaqL3+3jZkxNqycBlIV6Rs7qoR2Y7tqbv",
	"77QkBTDlrdW4q7JlOc9p8+RzDGQlr7dN+nL7gk3V0ZFeHq8ywcJSsEE17/7CX/S33TDseWxoIJ/WcVeN",
	"xi8GCw3F6mM6XjuUzdqunF35XHe5akDnvuU14wSYfEqbOUXr/mudoVdkevbl254TVOqDqH4gW2UCTio/",
	"GSC5PaJReix/dUGhmrzKDb5vqXXjCtyUat6YWjddnmrmeWSSxyqun/aCuEJLlCme44gmmX5dW/tSQjon",
	"QGmuk4tIM9VwoN4As55cCyIlnhGDR1zF4CtoRKzA0X+aH9zGV9J450Xq9ABDu6CNUvF5lUlbRG2nF58D",
	"Xjjqf6FqlXD+W1k+ZbNV7B6K6fVj9Xlq/WJ4L4s34miI4zhsS7I8Jso4tBcsAt3PCUOaAtkMYcTIPcrT",
	"MOuvLObfSZfge4NKZWvTlkMKyKHLDtoxZMt0MvHxm/gTVtQ1BpjzsmwU9nGjwat7t3RcHXm7iDADSxLm",
	"T9KPk4TfhyOhlF9sw0nKtvAVPLu4fI8uBVc84ol0VXeNnrmndmOjXXX9YAGGeUT1ZiAY7UGKto9MNh0v",
	"3HLpK6tuHf70V1uAdJ6JBtodxeAcIk82mSJN51Y4W3cO7Ro6T0o3ABxBCyajimwPSyShv8ZFPzgxv2d7",
	"YArgFBn2SixU3b1fIHOSca0FYMgAA+es7nlRayQhDmyIiCRRpugdQUZZhqwrMECXag8LMuUiIqGUyd3x",
	"BgRoeqtE3h2Otut+uF33o+26bzJ3k0PLegH3D4yudN/NLdWxlskeqGiBdSeGWUQ2WMnu9dzbI7dcbFUz",
	"iKurv0wL7MLPpw6asu6Oie59sXZzGN/4MDK++Ul0fQ+36Hu0Rd+N5puybW8ZPgGZvFIzFi+JgOq2+kOn",
	"WrYrR2DD3BG/MIQ4Vm48eq2sPQhkFseEDWNiShcusLgdxm3p+Tgb6gYkHroszw6+nGdKfzd0UXtr+lcl",
	"yby3ETJXAwGnQC38dj8K0KWfWy90STMxI2GexGV3zGsT5ttyjqvOj93FRNP+YTm8OxqWQoDzd2wpmmru",
	"NDgREWoYMffpluRfSjqDarfR8VEUgFOX+e/QCHpgqaefMzKk/oPVoYRnx/zqj9aSvemboeg8vDvasH8I",
	"/cO7o3Czd0QDRhixTcAk/B78Z3ZLvP3eU0aJ6rfXbrY44E7ZOxauG/v0hc2NL9D5WREwp4cnQtEpjayT",
	"445xsINofmU1P26FxuOLu+NgEFxfjO8OD0b5p8P801H+6bh18RaU7Qdw7iPac0eViQ3r2yuRoaIQoLq9",
	"zmjVZkCORH8pPiLotMJkGGckKOkctxzaDDDn3fyU2iCVEc3jGh2Gj70yLuq2vmDbuaaU+VEn7f6Vvk/B",
	"8EImJsIYSSUIXqDUqj4qXhjONn8Wx2jcWtPMqUzb1KUOihKYSQplxYxqtKT/bCtFZ3P0nULiJX16IBwX",
	"FhHH+rrKHbhwkv+WpXm1uh9HeSCvfi8d5n/ZBbknk1LWmZ0rZMsolx3ADO7wjtKnRWDql/o6vvE6vzc8",
	"q1WgBcsG0mXJzfvTjvJurROhPFTXleJWGQosqI2q6tXo2ucTVMG03TeoOBkrjZPd7LeWgG0kctOG2185",
	"0TXz9+6MbR1ybO63WOMa47TbYBuw4hhW1/KZhweH5fKZ9/f3JYb046icbzWnreq2NuOgn2w7T7ad3dl2",
	"9Bt7qJ/kw57H03QHcROAPFmXnqxLe7MumbLKks5wMtsAWs6ZimJNXWllR3atKBN3ZBvMv4xhbL1u/A0Y",
	"vyKesb+N8aseTkQlmlKSxIhKFJNUkAgrk8hwiu+4iSXWfQcQ6XRPkwRCxsiC23yHGE0zlQni4nx7RjpZ",
	"mrDj1rAuVP0boG06fz28D7fB+/Dr4X20Dd5HXw/v423w/tL0Pcsa0SudfPHmWM7DW7Lc1Aj7jdhwExJ2",
	"DKfuwekoo8VboQ6266NQw2joCKZZkiyHoCkoqwvM163Gqz0w84SDw2RHj0yb3zoXt3LzH5nhCNRIkSJq",
	"aO43v9F6S5N3nyj+fxMLuUxxi3WibBb/i1zTFXP8X+WOrvgB/FUu6IoDwl/ldq54PmyAdPl2//KoV20h",
	"T44bf03HDUiV1lsb+zfw+Ph7+2aQmIpOIUmXgkzpQymibshIvcbO94XsffDq2ad//PD9oP7N/2qJITcg",
	"U0GmVQM3Te/0OaXp3XPvHF2UI09VXRr/HtSxwzhLhzT9bzpjXJChMZj+dyogQsj++MP3gx6NV89ByF4a",
	"uVqOiVpGiXI4YSmtRJ5S4sm1pj8Ylc9kqJK7oQ279KVEaLoNGOa/LhaTaixMW196h9aSQYNge2XlN+I6",
	"5NTIm3nYGGX7HcXDApLHZPTkofTkobR+Rzfyj4bCMxv1EzRSw2Y9kZIVUEVpuOvMBt+6J9amvuYbO5pv",
	"7GW+sYv5k7fZ1/E2a1yvtvLCPVXRnLLZJpnP8tx0xnMjh4U0rKojB/o+4sJkN4qhVFYmydD2i6kgkIH+",
	"h3ryQ8h8CInQSgnNgj+RIJ9BtpGMoiFF9/f3B7bfQcQX6FEzf1Nmz3kFgX/IU8613eZcqy7xzsR56+nl",
	"FebrudkqKHyq+/ygcU6SkH+t6zlY4e1W81aq0rx1futE7PKHrj5y/qP6uGay6zzlQv3GTawA9QVc5qaf",
	"Y+avnbFfz7hsEXIRCsxmLSnMd2JkSs27f8PauLZ3DduBWbMOrnRjohBGbkM1xdk0gfSPwi8T8sDoVxWJ",
	"EewSUURAztUSzzW7FMw4nxlmWkfqVXA4PK64/rqpB1LceagyJ7Mm5XU/ZnmPft6ldUpvx062npPOSG6E",
	"WxMlLyZU9b2bx1TVruADpL/TWMIPksZEkwKWUC9To0MjAmpvnCRoisVCorzuCIKcMFi5dgc37C20sNCK",
	"Vg6QycmhOZ9bJg06r2FqvyvYoUMvIQoteXbDHPIESarJM88rWy/3OeUCLbggCMd3mEUkzycMNcCezTFo",
	"Mp5Vut0wwuKUU6bkwU3NzRSmDvxughNnjcTJjAuq5gst7vGMxYJPqKkSCcURoDR+xR3VzTEoUdLvTcf7",
	"uheru8zcETs5ff5Cc9NmvyNfv5CR+2rfT5DdN8S6q11+YCG2q5ZYQiAwg6cttqanExZlFcPSLKOEg90j",
	"f74djUaj6jo8NkQtu6glLW+tGmex1CtLKdtmVt7qJ7xVJDC3JnUZLNdfwQD2uAWrJbPe4t8uBzdiofFO",
	"uccinvK1tYBLLT0F7C0lqyj125o2TexUsNO+DHK9hr5YUDcLR+qDylJ+6piO2sJbkyROcyzNBjsiuc3K",
	"2WNZPTT+Q1rdyaHKGCOJflGWzi7YOuOh+xMamgWvfndLSDrECb0jXc6UG98Rcc4Lmkk/rq8vS84N6Dfd",
	"s17LqBOZuGrYHdZ/Fz4fFW+MPgen+Qhfk7xrTJX/xUK9kpO73AVePt30q276bsyH1sRF2iIjLlQazdtr",
	"FsZ8gan/3TMnScI71jIsdPitcUiewDj4LbS1hb0oxKLjbSVFVDnYsQhpat7jYL6ftrkZ8SjafogubzSf",
	"xVuo0uz7dS4QypVzdq2dz3z+gepDb9Fde7+0B0gNAplyEkLwjOd4X354g+C3dRmc5ZJFm8QmcKYoy8jQ",
	"56bRzMNedIw5UwmfDRkXC7yJPYmwGWVk2JLB1d5VQ0nU8A53xgoKfMj2g1dOnbyFE2ickN1ASvhsHU9K",
	"+Cw0Ci/nZjic6mf80Dloer0ch/eYKspmpq1sbbeiMrtpQIRY8bvJISr75OYdBIZ7h3pry1TXJh+1iEcl",
	"KLZw2NCVFNocEpRK2hLOHRZDv2KoA4yUpiShzPot9zxSdh2gfvQuqFOQmRbMhD6BcFD9Gw0eEFOBZ0Ob",
	"Pn4D1EtyRMd8zmWZKeeSwUr+KlsY7Bn8iPjUSEoRTyGRLPwGBu+u4kPByR9r2JkhfKKE7qMHaUPO/FbC",
	"oGlcKw/kmncQjGHolkJLAMtUWpJWWF99AW3CCrpsq8GvbVsLfu9B/2f4cUfbavCor7YZom1b7Zq0oJcn",
	"YO60vjhK1uGJIxMAicXMvw3gqdUUJ/+K9rASUTm0OXMcZAiPWA3UmM5Kv6io9oMR5pyPp/nO1Qn0wMl/",
	"agCybW0lF/jKPq0rsE0/26qbXsInNG5xohxVtp2p8kn2kO1v9ucdnSuHTf1kuWHazhYM24KiQcnqdCpQ",
	"TS+fsiWH6Zn3WZKY2Y1Ngz7zMyPWZ5cD8s4N0rngSHkLGkL/qpW93L6i0w7zsohHA1sF6cUxOT7+8XR4",
	"FI+i4cl0cjjE+OjF8OVx9P+x9+7NkeLYvuhXIRw3YmZi2+Xs6t6zz/T949zsrEc7xtXlXXbPnHOn+mRg",
	"UGayi4QcIO3y7qnvfkIvECAJCQQJiWIipss2SEJaz99aWuvx8fvvNpvXi++VmyOtma6LoiqaqllxWl2O",
	"eILpW3WPZXvEp3zmGRH1r0SD6saBqudcXf0Db+gataCcvPw+dYVqETPCbchcZFEidqVYyv397fXD7b3D",
	"5NThRoNfwEt6UU+ZOEb8Dhz8u9y4nWnibsFaLKny772/xWl+vHMpvpDHmCjuHm8ckixYs5WkR8BsXmU1",
	"JO9QEkyvZyP2t/lMEIoH+NB0edQQV5Cc6+3cIFoHaXoEAuynbh7id9IjPgvFl6TNPBBssHeDKG0uqcQf",
	"XkhtwYFeOwWtB8fb0/r1KM7W7oZcxyx1oMYOpXLlJmaWbXzlHdMs3l9l7hZF6JP9j5/Rgz/mTeVwjB+V",
	"S/rvOAKfLy7Iah7BJk7AKJaTgiTAMFFdUOzc79abINqCZH1IAoGcSXfu63//s8JzBBUpsyPk5nKDkFcX",
	"bYqRFmqqPD58y0lBhptVYGgcdR+hZd7ubl5dXLYiqwY5CjWigEOLv63dECphNwue8ECp9GmhINER2oxo",
	"kwjuNA1ZKdhCgjNSuCrFmXEVxHkSthXjq0+3qV5bI3OKc/Wp4RyScA2ivMuZ+r6S9154zXPLD3B2jT3S",
	"BDzFHraXwiDNHPRSvUmLSDl9u7wI3TRbHw8+0bSN3f0j8FXrebjCL8Cv0awgaaH4oLXyFFj+rSN0xVsl",
	"/FPtS4ZWuGIXqBb9TINt5GbHBKzlZkQh2XQJstR8XUysHyOAiPVthJvxiqi1UVokYQspkYQXAsZpkgrZ",
	"GlItxx2AYySZcwtpmri9leQXPodX10HGEG8JXgHLxTIrmC6J7rPGHjETvVwIlonHVdozkXjgLlNp6y4v",
	"wiACdS5iNXQUQJOemGES0FTcI/n+l5t3eAQBS6Xh+jGI/DX2MPmmMTPc/e1PQeRjz1F4/E18QbZU6uqh",
	"C6Ig8qp6quRmYOtsB4JK0cVXBjVYBxuMZ3Pp6cMHvJ9ypchsJ4ej0ACEoVhVFlJeT50/ekl2BX/+Uyse",
	"q3qdzTM2MJuqXGizWqEskEkBhJSuj7zGxMsUaiXHLX0paT9Iq6tQoJXjDavVkWxRMZKBUuoetMzbX1Us",
	"WAI9qpbEE9UHbCz6p1DJT1pyT1JH79vlBfD8ncDbzm21ihu0ur9z8B/Zfai9T4pLlV++S4InuIFfwIv0",
	"5ZY3AuJ1hTIYmonitefWHCP2gUMkyHNJD4JtoCC/9Fvg+4ylWmGTYxbv3SzwnPKA5PlL7fuXXhbyMsi2",
	"EfBLztJD7srnxo3oA2R0N73btMLLiLS7rPReYjX6woqM3yqeM5Fuzq9pST03dOW9v79Fb/6agpqY1XPv",
	"CuncYAsVM6YSc4ip51ENW+7BGk7sH8PyaZFbj/FmoxRkXK4+vHXu84GwtKaNiRvfJqAu6z+hDqnOG5Sf",
	"GGN7F+o7vSHl4+XJkMhYlFaBrY/9Br/sQNvRWZGXBYPKasKqjYxHqA2vUia2aQI0hnNPxqhNIavj2jQ0",
	"frc6JEOM+mN+POSJvqVBO+0B5+PJvY22VEEuMnHoojxwO8ooj16jDTpFN+qgkwjpg07TjkLo8DUaIcO2",
	"pRIyLodO6I3NbvvBbsQOZxiLrTecRCkDq3LUJ5UkwEvEbvG6MOtAWD1bKZmhom/S8C36Jq5e4uzeW7ID",
	"gmFSeaxnjYNcBzfb8eGG2PXX4GuWMCFIpUO9jV3feQtfxCATyaZM07BS+0J+9wA1bz+AhKY4OlFeI9Ir",
	"KlEip7FWjTJNQ0HmpvZccAJaBQ0+4pD8anIbYt0q+5hHbXCcXRJH8TF1Hm7vnZvrj05+TzzPQPjnEWBc",
	"Seko/hM+7dyjZ5w7erccD/UU+CBRHumOvsC8LKCdhhGcO/gWwoW9IwrehuAJhKWE9X9XAkewzGlbRaO8",
	"wr+hUfKWHBWwOf0SHNYpCDc4juyvPZfjLPE+HIQb7BX6zmp56bhfXOfrvy/+4iRxnDmrpeDyQ+Zm6do9",
	"4t0tC7WDm6bP/Ej3MRXh66woQk9d0nF+E06PrlrRNC9h4hwvq757EhxashvuVcbAfy+uUaBt+1bsK2N2",
	"h2H8DPkSRFCmogcbPRn0V/EuCa1/cob+PogUSQW+4CzRCwUNoF5PHS9+VpYiuIApTD9kFuaU8h2rS1Q+",
	"dt63KeRBchfSX42Qggs1/MuCc1WUOP4gNIMoAg7HwypFh4ze4jcKZg58wElZaxzn58AHzt/Ie1zRoLs3",
	"JbGivEfo9uQnOqNsr5grj/L7Tvjxqphp3JFP6IXy+8UoCkYmhxPy16Wsycy5SUC661LVVFTOD42f7uLn",
	"tQ9Sr/mLyu+EYAsiP9XZzvtd/OzckvfKo+1j/xgC/dE+kPfKo0XQWKNGfJvq9RWiQzUo8imOSbDWr4jC",
	"0SmB96VNYao3YBNEwHEdMrVzTPGVVS8BbgYcN8K5B7igM5oGegipk8FtQNEyl5TSyS+Pw9+6aRp7ARoB",
	"DpnAIV1iJVUKqRQfnSZe8bloXFuIymwhqnyvlZOMM6pBVJ+v2E74GC8vYtLHMQHMFQD6s2pqP/pr8RUs",
	"QAwpU1y6KmcPlRo1aChZkSr8ROljLskv0efSH+LosvIs/lD18GfB1t943yrJw0Bv5odXCV+gAR4QB99E",
	"OA+Hd38GlYGXASXoAfa0UYh6Da0zdK8s/zHBOD3+OT5mpb/Dn8kDqCg4/hv+5zGh/yRPbMMg83bkGfID",
	"/dPBw//P/GJB/sP86jvyn+JXGX4qI6UcoJVBJsh/JM+in0GSsH+GP7J/3rhByP4d/UweKJq/wn+nKXkO",
	"/TOhMY962a+vwjuJrIDKT4No/3/wdiS7+A1fFAdJEPtK41YdJTQW11HKT/GICtUrlHaoQFCQMBFdvkPf",
	"olcsRJhT0QwJVD8EXVRHNcIvmY3JVcNjELnJi+hSplKVtho/o88WCy/EyuJ8prf4D/SCUd5pFg2dkaE1",
	"ZE4x3csFf6mpQ+aUSx9RQtPHCBSWRXmZlXJHrEhROsyy1NF4hQomzVfUp8nFm8bTx0TjafWlgK8HtQcZ",
	"gavzvPpKoJDiFEz/ys9Vy0umqzBYlZWQQlBd1ELvG75Tf1Jv4PzpYXYoG3AqxcMoaV29N9R3uqy7NV/R",
	"nIYaGHpvqE8iuNFEUogE9cbWquVFc8NF/Wn1pR9THl4lUJeSBNBCA8my/Dh6Mm2hKIUqUmSeF15VidHA",
	"10OQNAENnz/7//bHffqv9F/7f+3+5f/pf4oq+CvVq+jWRZ3XKw11zlEDX36JnTv0NPLzvKd1jC76qLz6",
	"CXggeAIOuhrE2HrVjfryr7/+a/+vD//a/uu9aKfwq8zVISDJfq7aiFrGIfzFOgQt66o9vOBb0c9JkIE1",
	"biLUgLLx5K6IKagfjJEdrZu5NSZ4oJxUI3zvsM57hVfTnmjWNN1hL97vQe4MYncBfD3gf6S0YGjkX4Ub",
	"+i+y+aWf6J9xVaT8X6hTy+XFMaJ/4Z2YTot7TpP6/JOYYpURZqI27duVB1dL3UWtQ+kmKyBgtRn/0f1g",
	"sDdKJZD6CkTVQNHseExS1lIgTnQOCjeort+3v/2Pj39dXVxe3P7Hp/s79N/7h3v43z+Tn39YffxFJdJW",
	"n59sJ57+qxe6GKNZ793kS8tPyofkddRGf3PeFjM5H+BM3y4vSEMjM0cDjxx90w58XZsduaCpfAIypOk5",
	"8AQhulZrgrwwRsp206PLTPJ/4X9ghsp5Kcn/xTDUZWd5ItoCBQL6QFH7dnbFHnrtwHtSwqXkTBN/ETAs",
	"4lPCt3/GP/7w8a/duTSO1nldts4j0ZIdncdiEH+DBGCmG4A2o+A6lS2Ymj8a7cTYcZyik5wJYUA6o3Vd",
	"UxoaWQzioCuPlO/tRopZfMy4PPnw8dcHxI30Hz+gf3TmyCc3WYOvh8QI8f8jtyB/4wrAv7mJ8/brISGF",
	"q8j0plTcP0pWq3gFt/HWIReryQp0Wqx22haJYZ2fRl6B6vSrCdx10QywG59UC9fiZ5no5MPqzlmRdr11",
	"f4y6ROoZMYUX9Y0ziQR28PIUmi5drOBMJKcGhSEbGlgxZd+U+1alied895fXr7778/94tXi1uP7uz6hX",
	"VRD54OvFj4v804oU3nqqQN2hdD0PoDCfm2Wut7tKkyc4s3vIjgm4uLzw4yvSdTV3aK4ikKWeG4LkykMe",
	"P/k1lveXF+HRRSmjJJqVeleu71/hwFvqXQWRV/thUfrpO/wTpE4cgix+WFB3KT3E4IpWdYR/fHQj/znw",
	"s91VGOyDjP7WQ82Zi5+yOCU/+Gl2hTR2/iP516b0zoZ9J4y3VzjFFv/MPBcFHrigzU8DVErpygvdNK3+",
	"Mt5sUkDnwvkd5F/scoo5eaybBiHqlpvE6PNR76YrVFGeNMm7Sr0Sh+PSqLQXAB4uATRY5cfwy1S0C0V8",
	"hMKGoT5cFhrk4VwkAZBoyM9qjc4K/387bco7egaZYkQTWokoGTLy3cTPS8eDktKqrlZyfWGAxf5E33fQ",
	"+7g+IWeVtWj2uDaVSBgK/WmYwcKmJ0RmMQvVo1K+CbHCwzq3INriVFS69JSTr/V//vg/fyQFmn/7t8+f",
	"//j5gjbsRhr9T58vPn/+07/yJ/5kxAnt+cvv8Xd275pToR8VYTFEutqlCal2mpQ3g6Z8SdE3q06+EpWo",
	"ThNKsVCFVHf9VhdL/7goKuVqUHuDvNoesrWgN3kr6IyxaHojQBR3e3FI7pGDB8PtAoqLQvldqz1I4LdA",
	"uw7FFxJkRIEEbvmzm0T4U6M4wxZEEG1idAHk8bjNLRI9B1WMK7KWllTxfEPm5roYsy+gDxq1PFrToLDb",
	"o+vgiXKlDddedH/RV9RmV5W337yATFyQO6veFl//sbj6y/LqnXu1+e3f/gV/+O3f/mRmj3OLuuMnfXCT",
	"L87fKLW3DOcGHih2IEf0vlu8/oEB9K7wzwasl9yF0LWzfgk8UHwsEeHrvH9zKTr79APN4WvJp8QHpgtj",
	"dIaiEJOc2l3ecrr4DPLfJDUjdY2u91O+NmbBpMnMyJb6NzcJUAibyp0kzdZZFmrluorxJcYZFWzV/YPz",
	"8HCLq8esy7lTnZCtAiT4bSgteoPwFvIlkcetcNr2Y0ziJMNtyJt8NzLlG1R6BFbZGeYbuevz7kHm3OD5",
	"CtFIW5xqe+8iFmUQM47QpnvIXyK+G03ZkeAyBtfGoj3anjtpzZev7hCDNS4RYXCFVRSvu5TDpRrKy0Zj",
	"j3rVqPdLsWgE5aFenOsWwTjhshmEUJsc0LuoySZOlsEIe94YSv/GJE2805ECF0GUIpQZ39QkK62m7mVx",
	"ehqzFfq5Ha3WhzgthBUCcdfc7NRWyiUHhQ06zAgWYtxkJ7+VhRaPk0HpxZc2iqHZAu3lwx7gkA5OWl2R",
	"5edflVWuj3cwn3tZ/EdSYo7kLFK5Us3UFCj+MpMxhgCvyp2brGnB6t8NsRGNcBjbjr+5ifPuVMFfNvxS",
	"jlUb/LyyYT90RHnATyQtkEQ1RZiQLxuIFYWX2ZivJPMXDkceld5/ZQK6RbNi5UuttSD0N/EHNYWy8X3a",
	"7rFsUiVUOZhd3OM1Hc3OSCdE5VA2bUI+pkB056CyTkCY5Upjsd0y6mpDuDaEazQaKF9Kj0E/vfknEcur",
	"hs4qUksgjX4zTB82zGQqzCQ/hsHiSsrLGHEgSf4Nc44cnTIkYFL2Caw8femGYOQif5lBkiuof4fT6xX2",
	"58qxWgDG6OpLi1Lb+m7Bg+Epoh5YKPDxPlWDBHpWW/3dx7dOURW53LZ91It+XzRNt6hzM+os39EyzFyH",
	"BblI4OnxP/lHnQDmY29PNIg3o6BcHuHL55dPr4SXMWCPGDBjkKVGxIwM2AyZkQfbYmYs2vVN8lUS1Cxx",
	"PUkVqZB01CIP4KKP6J3USXMIU23F+Uzcbpjsn+utoQgCB+jsDnjCjFpGxdqZrGjE+qQPaCJkzIMMJFB+",
	"7oOIJEIzlWBFpQnRqCytlRZepzK0q5qgJTNmWsYpa3vDnLHaMQWk4H6LPW2o6vaAPxV/tLhJP+WpOfXp",
	"j4+Z72ZtW/avdLr1yxv1m+rRL2jPr9SZPztGYP143GzKnUYq5eDQ39MCgtWvo/ITHsK5pTghHTMBKG2m",
	"VAL6tc6In8gAeExakkb1fecevlCrSENGWqd7Nwyr5an1vx5OgvrCwuEc8unOHzdx4uzBPk5eoJ7KEjeI",
	"gO+kQXbEfST+VF/YITgA9W+8Cw7AkX5o4j09HjdrUoe15dmSIq60PJDKhLgnT7v5SCcenenyLo2tJsy7",
	"oOlMibPB2k1IsrfUpgPe0xpE8XG7UyMKOupb9I5zH3tfQCafI418Y1RyD/9PZTYDJKI8lyH6UJ7PAHE0",
	"zcUtQwWlfXh0JaI+jkNy72ztxRGjkIuGLckeNRg8JODq+1ffXT0et1z37fGIED8THnVVcidp5oCvwDti",
	"zUmm4LrOmzjxgL9+oXV6m/f39uhCV88DvvO/aUVcFGmIt1uSKN6xfRA6OjjNbbxNaUPZWzI8mS3NfJDw",
	"GhGampNMgHsw7cG+HTHCEWlPpg9IlTm/pu62lHTaAwnAaWkWqfT4SUZIf2vAyO2DbA2Zm37pawEPbvpF",
	"NrtQCog7YR4OIcjW/w2SeO3Fh5f1Jk6e3cQn9V86kj7udYJqJtP3EPXD6a7gdE4xHXrIzVz4K/QQXhqu",
	"oxbvD+u9+zUP/6m3DlvF+xxxv6WRObKY9cZNM/rFakUR3+A3HfjmFbNXzKCivVQfnLc9qKLwIQ7D9R4S",
	"GPZQS+Us8rNCsc8dSiBJfPjf3y4VOs3Xq37jOVCzXPJPN1vHkVcNRC0Wi8uGji6ohKsbhrGnthPvkPvm",
	"LOEb2GFa7dwIB6U2/hr4W7DOkgDKUOCbIFR/C67yAR24z5AkaYIzrrgM0vWXIAzX3uG4PiKxV9mHNs7C",
	"6u5XLEOdvwZh6JCZfGdV7py3+46lq2c/r+HV8cPxa06cUAat8GeCzce0xp0/PzzcXX/n7I9hFhxC8JVU",
	"0q0uMwWRP8Ay4TTKa3y9fgTr/EizXQLSXRy2tAbzdthuGL44kD4cN290UeQlOgc3zRyX6V5IF1AsKYiC",
	"LHDD9XMQ+fHzWt3xu8EvOvhFB76I9iA+ZtuYNI4pEROaDvJ10a5xnWYJKAf4FaQrt/EjGQm1ZOQsoVhB",
	"8vXxuGm37ehoX1PyJE52w5fXzPPd6/WmZ0qgroYOKWx6IIUg8uI9nxQ2A5ECZwnlFWRx5obs5PpnUF8M",
	"GrRYB24iCkU8uyJCTbyF9Uej3CPh0egOuD5ISLMHSgrVooDKy3mD88ycn9GopMo3cinxbALSa/35lCL/",
	"jimSmakL1ZHB6Xn/kp/3imlASwYsZtsk7h5ocFNllnfwdfYLxqbrXtd0XZYd1l4cfwmApDKOyHKGrzGF",
	"atBgYbw9JoH2YL9+uqmOtHe/7nDp55yWv3/9H3/+D6ktKZmioAFM2ikOI4RgfUAwx841Yyvew4GcGz8E",
	"VSMNTgY9v4THoKb8QDQxJm3nTRGb4niiYZBmIALJOm8FvnMTPy13k6J9lVGvqCuoAl0f/xtnWKjsyC2Z",
	"qGgajidi14AIc/3PIzgCA2eQz/gBDuv8JxzWWeKEfYxxkIJ/6wOUnPirOmkUPBxSG2Q4Mg+KSbOeUfs5",
	"SHg7c2Li6uzdr+QWghaz4Y1w3mIfEY8DXZrCaVQf6w6+55fHSgAqkK830Cf8knN/cMnHIQBpvYuzDkrm",
	"DiSEaJ3lPj5GKLiOoSncLCFLoW4J42c3M4Ex/xIjnDlzbuNn5+9uBhKS+FxR2+WJDQDAqhOTiOnac70d",
	"6LKxpFvlbRx/OR6cFRwuV30HABIMDBwPvpuV6b+NlYYud17hO4ZkSJYPkADfBdvdeuOvkZRTnsj5FVp7",
	"PwfbnfPujfMJvUtHDOPntgPCUyiN1xuG1mQOSBC0g5umkDtQ5KdiGSQAJRaT9ixlJOMvbGLx61awxr23",
	"A/4RgSi0KBcC9ALgO+4mA3iB5USEg5ukBJ0iq0szN8lwRuFgq3sEmzjBm5wAnKxTWypaYhBtsT5r6asU",
	"9goWjHgsJ4iw04ia58AVkgAymvMYoafWPjhkO3WSfXDTL2jkT8cIK0ucd7wDPmKC0M1oZlhXxRw/O7d4",
	"NIxWk62mjZ2ZO9ydtw0LjXw0hL1/AfETSNZxtoN6f7tmfatSWCsC6C4f/BIPp4dsjmGo9I0PZBbnI5zF",
	"ecDqB2WVpmWTUIjH//MYeGJQnoIGaPXr7OvaQErGf/56s3Ly0GWxSufhf9G4Yp6tkc8PJTyyoHuIZ5QX",
	"BKkUWbbS2EppYcRfXD8GftBhT+DMBU39FJDUQXTpnfEgS1NnX9fYejFxFohBv1KjpabQC781jNO044ei",
	"I0b6Afuyt3FK6k3FiQ+SQhV2hbWRYsxlKgl6HlyUfEAmg7KtgNzQIrLkpSsKhz71ExwJMWY+eIoSH9bx",
	"cwRKcVbqoJRvkauIATQTyaf4iIb9dnnRCyKQh9FyGyDlYgJU76OVlfS9UBClaSiWQ8iGbG9C3t/fVuxG",
	"WuqWpKB1G5pakTTdahUcdiBBCbZYoKEZs68VU1htcAZQgvuxCTxkkwYR/qKLovvR2t/hu3Hqg1M3+c3P",
	"zh3Nhs33CKUwrA9J8ORmAK9dsc/+/S3OZHDu8MvFUr+AlzA2YYzCOW7jrfNwe+/8FbwQF38DqA2prxxS",
	"0TQ02H5Lh+c314PeqBcnvhk6YsQvSg/+dnkRe+mBuDlI9uMbDJ1nu4FGy5MbOj+B7BmAyHl4jp08hOD8",
	"SpwgYn2mUFh/XN0XaegX1aUFUeelYavawNKE4ubJTVKxvNmG8aMbYuXeWjTQAh+p8x4Nh/Se4GwPSewZ",
	"m+4OA2my+RLwzwSkxmYkdTyu86sJkqlRk1BTE1PelMyXfY2MTcfkNounFNLcf4fBo5jm9mCfZ5XkRs9f",
	"dDHo/z8MHmlGVJ5lgiMotYDNd2wLp/+hPHopfsL72GOKLRt+zj/8K9KN6LFqLj7CelNuU852V0AObpo+",
	"x4kv6IbrQSuA80zejRZ/Du/WFa51v7j6y9X61Y/c+wCVeyP5QPWJmXUy90p+xTvE3WC4hWgnwvDj5uLH",
	"f8hz9ekb60cXSezfhdsu2lnZ6OQKJFlZ62EQQXCumHz7rXo55ldKQ89BtnPcMHSC7A+p4+2C0E9A5CQg",
	"jY+Jx7Yl5V5XoeOwm4q3SPHKSrxxXHR7A/4+S+LQ0MUlI/SGBqmQE7ZK3RTI6Cpt5l7NuyJHZqOry+H1",
	"js3pSEGGtFhKdRm8JTwfk02TS6Jjy4MM+0p///XTu1sHzupuQZQ5aCAUjL8g3VHXm0BYiq8CACFfNttR",
	"EwiPjaHXAN8cDCJ8lzWIozWVGY3jLp304HrgygcI6AG+Q68L4hk89+A+BmGQkZtk1UnWKYCeSCbskFid",
	"ztu50GN0IUeHofMI4Mkid52MBHCVf3JPMb9eiTMSEPO5QQQdebzABKTHEIeJDm7m7dS3dFn5VPQ62k20",
	"01wsjWqSIHu5h1RGctrdNPDW7hHjo4j8kGaBvy7obZdlB9r6FbK6G76JPQnpv4m94x5EGQ23HpOQjJL+",
	"eH3tx176aueijlWv4mR7TU+HVAzKXA9RANi7AXwvPR4OcZL9f/QVL95fUOmTT3mPH6pNtn95xbx3DZ9x",
	"w2vvmGbXYbwNIuyblpqx390gbABAORhtHTfynb0buVv4AxnLCaI0cyMPpK+gJfsU+CBPl3EYQrusiGI0",
	"DoBbc/k5omOlmQtFVeQ7YbxNX31G1+UI4+c7CtnlLnQj4Czvbi4uL/LbBxffv3qN3JsDiNxDgH6xePU9",
	"0taQFH78/eIaaU+Q1Q/sE8iOSZQ6bk5QSRxnDoj8QxxEWfrqgimkdONf/HjxHmTLu5u39AEMCyM6R1O9",
	"XizoKZLgIUK1cFrq9X+l+L4EFnNNQjBfBe2fzK78nlxILDdW5g2Xr++aIAlvUVdUxBDH/d5NXvKNEOwC",
	"PA93m0J19SZIvfgJJC+4ssq1Fx7TjFqSIcg4SvkN+r1DnnRSkEGywge+j59w8CSKfYASIZE4CaJtCBzS",
	"Uqy8/3i0FZkWHnJ+QRjaV+WpbyLHc1OE9+zjJwQhlkZ3/Nh5Bs4XAA5OnDgetCZr93gDONI/jwDBrYTr",
	"qs8UB0ohEzgm97Yo/5CKz7imlA0tqgpt/cC5KFrdVnwMPtpetKtwj/3qthoiG8HZMgRDT+q3b5dyFqRj",
	"IDuMw3XFkffGcGQJ6/wzBuO7ysfzNu8Qp5zdu4vTjLf95e2DT02aZcprxLgluvXhP0FrD5ohru8nUPs8",
	"70Dk/FeMDQ2X7o1gUcX7a/J+aWXtVgJ1bOtl5FXz6Bpk/ZyrVye0pQtChH6K/ZeeeahayOTrVZwE2wA6",
	"WXBpv+BtQNT/7cQMXhOo3s6NtgCFhX7Aa5Fz+0+uT6A2U0JCxORcMXHkSIm3fqAgJeBTQilhyersyEpE",
	"FXWyYiy9a6+IcCGHm6uWcBo3ystymBecBGwSkO5qpEefZ8Jnn/JHeedWno4MiypAPqH6HWhXvxc/GcWZ",
	"c4jTNHgMjRlDzR/N39kdcEPsf0oMJOI6+Q65OZs65DWOqfQz/UtvFE/mHsw+En883VLyzXhHqTMt28/l",
	"3c2ls3MT/9lNALKWP96zritvY29wPdjethWte7BNVdgBurs3zG/xFtML3D51CK/d57Rpz90wzG1F4DvL",
	"v987CdgGcSRwtP9+/wn/uc9Nd59TOot46zfH0CkqKps9BzciRcrijWSHmNMgt9tZX1zkHyx933GdCDwz",
	"Q736HK0S4IMoC9wwdeDhQ3FIlakTEBfgjZu5Bwq5OEHqJMcImbMBWvPb1escBsIYPwZfnZvlByeJQ+Dg",
	"HlXArx/uKgFuBvLzvejHaMhP1oC18F1fq6oyCg6KOB7aobbmwQ+LvzS/sgwT4Povb78ifN8QTfMITk66",
	"Qmly/Xvgf1NAltyImasCOD6+4KhTwCFC/DpLhFLPmJnj5g115A4u0kLEjwv8izqZid1JJYAnpwgC7ODj",
	"/aH5kH6Js3fxMfINYz2l3W4SSjJlEEPB8vd755PuubGaQePQAr+nQ1sMIxpEmugkxFCoLnVi4Lqmn8Ah",
	"dD0FJubTAnldix4+mWficeuuxcC6CyeZtdddJ6FnDhm20VteHKXHsDngVLbzVugtB9/84hvD+JFeLWGP",
	"TDE6M7i8Pa0t4ZRYJqXhRMYpfqgny5RQyZjMUnZJtVqkcLumb5GWzr09cyvapZDaSjNqm6Y5CUpVWnkO",
	"3CF6MOu0PPlYTFSdk24IS0Irte0p5lJb7wgnYKiKhcUYrdTaGXaxVLuwNRlCiygMM/SIddliOF1GTi7B",
	"5zFNS7WlOks1kqGWdzd16F2eHEUmT889Q4psh1KSFN26a5LxpnECNP8tASE0vho2/2c8/rnvvXBTNM7g",
	"upyPon4i+WROFuc5sJs4cVz/yY084Nezz+l6cSqq0L0rXprLAQq2rPt5Xrsezs2XH2rF42QrNwDfWa4+",
	"vHUOOLs1SbkwpLcHd8wDejkTTG+GdeBf9IssenuwLr5F1XC7vNiR6lg//l7uSXH1t6L8t6x1BUrKptkh",
	"Muvkm2E0gZxn7RApQcGzk8AFGASgiAHcPqbjDjeYxdBCZ1LQyONqfhTfEU5AGLt+bwk6JQIbV7ytvrLy",
	"Ud/GW+cuiRGlMiDH68Xr4dZQZhqcG+Tgal4klxefH+0Hjy5jM7z5Cf316uYNJxfnDb15kr9LBmvkx6lG",
	"HiG3HgperLC8ovq4/h26WWpAT1SSEM4mifecOkCCAKRUcJQnLM1CrilyHEPyF3XX8HJ0EqokDF43aZmx",
	"MAwXI3NZchxTGJdVjTzNyDWe3gWRXyN4EqEjdCe1k6ZD4oPZY2M1x05Cn5S+GqmTC9J9iP1gEyC7rbTF",
	"f0j5MWUuxb71g8xK5WnajQOyaOmBCnkxIXBrR04GW0XS40VB+iiYkKSrQ6qNQjAIBB2Dixj9RCfo39nc",
	"HMNwTd3fXvVivmszQCiYc38szpJSGjletYwG2kKElM7zah8oynKgs4wYsGhFnuYVFW1wOCZoo7SmMnHQ",
	"loo9ARqSmS2UYQjKeMx5sy4TNBSQDo6RCxI+gpEHt+GIoqwVoUjhE6hFMaaBYtDzGk2Oj4w9FJJ6mK5b",
	"ygReWF1nQt2DG3YW6uAYgg2k3JSN1IaSyetWVp+nibkY0sRks6isjTmpFDJjJubBRV3ZkKV57XphqnQD",
	"Yrm6dcIgQgXK3QzdRGXQjyBy0gPwgk0AfAdPwL8MFoZLL2zryTIrv6gXeIErZKVetXCLF65ptdDJRB7C",
	"uaErJVJjwbzVrZKCfd7FISiSIle3Kb7vDIUE+u02eAIRpNf8TIUX1YzS6gyiA2E6sqAAn3uWJWnWl0YU",
	"zX426tD0VT50ImlW4/luuu369yDywVdFSIWSheieAByqwFuaNR7NGgkVjfd8ftlNAvKnRvtdp9TYyKXV",
	"GWEz+RGPBpyhK+Jo20ZkRolhgkiRXVD6ybnzSs8Go0Vt+JfKJFTeGLLLSY12RskpGX6pOn3T7GOrDkZo",
	"vI4sEZrLyIW47Sv3ObRhwr4zniWCqMG5NattqZtrxdGZiqPFYOKoRyfaQsr9QcpCUdTe594EIe0A3Agp",
	"v8PPdgWU8TAnwun6tObpXs4PASaUwdAl/k0LCJgSWQcU+KQENj3lVSLbkSgwCSstc3rrGRGWrMGCwlz9",
	"lB9LCRbORUFnLaUHDpPVGIWGG0RL9ToXWoC1vs8VGyYHPBpkmHAaVws3QsMK7KIDDM+AU/q3JS04zAeH",
	"ZYTeiA4TYjOCDVt9MFqDdlT4sJidqdjtByAWz2sxYoMYsVQeNbi/JvUuGdZKpXOWSovhpFK/rrWFivuD",
	"isUSqb0Xvsuyw9rdZCBZ09Wsk2MI1NDjnx8e7pwlfNv5RNtXf4Jvd8WT4cBoXDosHPUM4WXx9s8PcBYS",
	"E9u2jEcXLRBpMeF2wKjHRLTT06UNrDAS9arFsMswdISE1i/QrbVOC33z86F/lhxeCQ4XiaUe9LIeXi76",
	"ArMIup7gK69VuELrvJwrxC488tGA7qIVKlkijah8K6bUwektP57GarfQPh/a78ROjdi/kGKNRAMsL52T",
	"MzGqAIKOGEGkVNEW/YQXdFZlAw4GAw7dpGQD/NGvzUEmsrLSysoRmFxCUhoabLHBkP6CIR2kZUdUxtsB",
	"74tGfAQ/byIisoIjnWsUhGzrvOIeDIFUCBedddvIBiG5jrGMU5LbRNUoS8Rj0pxi5lpWxNQAYQnxYmwg",
	"QhKIyA+oFnqgssKIYmsRYEAvmg8pyOUPx+bD67AOw1kHDvAhjytUgNYkVOBqAYFmJtINAWjzz2qK/DOM",
	"YWqhfQm0Lyd/NQAfk78xyN7qjrFbyeOD4oWMzsrnHkF34fwWZjcNszdILBUwfWVOXzPw+Tx09szl1mJ4",
	"udW/Q2/B7p7BbpnM6uj5Azi7bt4/WrI83V+95CRGHNGQ55zqz270TDP8GbKpEHN++m1hb5YiO2Lfp6bE",
	"iWrIGn2PSU82MN+SJ9gGgMMblmUxcQkmXj6qGjDOShRzKrIFQl6sk99XuQNK3iypOEYhsx7rOpw1XM6c",
	"9Lgw82JhUjNADTxX4y9dAH1mrDWg9WvhdAmcrsgZarg6Q47GwHWrcqZli48PapdLgppI7xF0l6/EIu+m",
	"kXdV4aYCwRvW+gwMbyXc7CTc4pQSbiCAwWL0PWP0StKtIxJB9lIXric7Za4+DxnwnOH68lbPFLAvEU6F",
	"rBkaaAval+myI2x/epqcqCrlUPqYtGkjIy551DoEet+4MovfS/D7ymnVAPyyfDGpOFuA+KXFGs92VxFd",
	"3DvhzKKs23HWWH7prMeF5rNLa7AR1BB9ZWbTBfVnyGeD2skW2pdA+xpsogbvl8jSGMBvddEU7fbxwfxN",
	"coEj6XuE+ptWY8F+02C/jrhTAfzNGwUM5m+F3kyF3uLUQm8wgMLi/z3j/8oCrzOU0a5Wv/kq/XMo0G9L",
	"89dpp0bd3evxm63Eb4vwmyT3cSlYlcL7nIqZg4QDbLH9TvGA8nlxAgImS7l1Lq3fc1H9tnU0bQXNWUUF",
	"xltDX1aasWXh/P5K5s+S24Y1nm1wQBoc0GAW1fBALwXxrV6aqDU/xhDBuCrf25r3J4gS6Mg9tThBnyXu",
	"rfSbr/RbnF76DYdf2HBB7+ECZcnXHukI4+06c5MtyNQCBbfx1nnAz3cNENzGWzzSGUYG2G2dX0SAIRKG",
	"bvPzbhECYMmuA/R/apKbnp6sEfJIFGQDgy1LVNgztt+wFovpc3Vc6XhKUD4rKIxoNj3snlmYUcy+WfiU",
	"V8Ssw7oD5wrSM4c8GnC+WJNQezei8YpMpIPCz4d/hrFMLdzOh9sVyL8RX2dozwiubnXHFEzkUQHockZn",
	"5XM/gLl8fguUGwTKVSRWg7ttWl+Toa3cmoncWgwvt/p35y3E3R/E3Siz2nv+8C2QrNPnIPN2QbTVyIMn",
	"Ysq5p++q5sKTpXAdl3u0nnxImiF9NmC3YL/nh3vjg64SD0PfHEpoAYbzp2mNi4+BPKenPWVEPxJNqs6X",
	"SxHx9oycq6/Qguj8xHjRqZUAdb7YMa1g9VB2/sI1AXeh1sXz8L67wQGprMc6IecKvPPpbzQYPHd5CpZE",
	"IzCvz3c1n1/T1j1vlhvcsLawPR+2b8sxjVg+n2MUYX0hr2Bc32qoaRr6o0L61cUEX/b3g/8rr8qGAgyG",
	"AlpLwQYEok+zQYxDWFk4D1m4GIssHBTosOGF/sIL7eRgZ0gkA/tD6GYq0YYKdowHcPIBTIQcHvLVnF+0",
	"odjpecUZqnRSo2l66GrOTWU4odamf/BqGyJ3bfLV2ICCHl2P0cMor42rT3NC6terkK3E+hMG/YmKfJBJ",
	"G3PK8/r3QwI2gWoooSrD+F4JHlLDLWFjCGIxJucCPCnfJcn/1uiT5IRkAwijCyDkRz2a0IEGyyrEC3pi",
	"rpqNeu6cNaBJbCME/AiBFmM0AWI98UUJC7NaZz7G+uKUxnrPsNdMrPWTAl4DGuptwa2OmNYyDPGnnGG9",
	"CLqxc8Sy6hCWFnRlGrGypSG0aHaEOJVE4/WKSlkwahAwiicuOqu069/Rj1qAE9/kh+O0RJkUL8kRWkaS",
	"hmvjk79YXGnCuNLI4CS+jlZFj4xwSg4ZnS+b9G9iWmxIhg0JLFE1KMgIkZfwH6sPztDaXQxn7fYL61g0",
	"p280x7ClmwXeF4270PfweSP3n+FA53frmdnOGV51LoiDpVJ60m1uNTPk1voq88kobYIKrUq/Y9Fqcr5a",
	"loiv7/vJ8rXYS8n83Fv2eMoXkRn5YESRad45LhZm+KJx/l1NpnqxAntZ4WwRnOKQx3OfOF+TUF03Xx1W",
	"Yx89ROf8OWcYI9QCO4Jrwc2E33wDuKA9Q9d+rb4Ys0E8rpimnMUZmdxTbFM6v41vmry8qyCrmu7pmtbR",
	"Vc/aSqwzlViL4SVW/267xah7vGLbJK3ae/iZd1h7O+B9UUOqH1Z3Dn68a0+qh9XdCg50himGzJ7OC64u",
	"qIOhU3rQLYBqON4KU1uHVlQnprTpKbsq/Y5E2cnZakmkEzrqnsFq+UosVs0voMmeTgmrZiSECUWmh1Tn",
	"MstsC6pGoVNeT7EKa8qfK1hdnPFosOp8SSJ93YhUq7GPTvOpFpyzmiLnDGKBWqyaj1U3En4jUl0QvpG2",
	"U1ZfjN4aHhVWLeVwRij3g1RLZ7dAtUGgullQNXjUhX402W1qLkp63uJqMbS46t1htyh1fyh1g6jq5tqT",
	"/dNIqobLIZujmlqNZ0VHTv4JT0aCYJPx4fBnimOX931+2dc1KioTN0MALfHtMol2g7lPT47T1JccIh+R",
	"3mxkwSWHTgdAwBvXZYFwMRBeOasqHl6WKwZVpz44XlqpaYxcRWLVjcXSkqxHcc6AeemoR4WbsyuTGwVK",
	"ILoym2li6fPjsCFNYouvi/F1dQZRAttLJGkKc7f6Z3oW+uhw+CaBUBfv/aHyTWux4LxhcF5Dyikg9eat",
	"gAKwt7JulrJucVpZNxQCYZH9fpF9VTnXFavAC9PG+fFrJmqoUCgVj3jW0H5pr+eK7bOUUyXsggZao/sl",
	"wuwK75+cJqeqUeuUPiqd2sSISx61DgLxN63MYvwSjVk+rDrGXxIvJhVnG5SfXazZmi2qootnSbKrst7H",
	"eSP97FmPDOpnltZgIyiC/arcplXiZaaMNqihbBF/GeKvzieKmD9LlmYqwlhtNFXLfYTAf4Ng4Mj6PqH/",
	"htVY7N849q8h75TQ/2az4KZdVRkr9WYs9RanlnqDYRQ2CtB3FEBV4inAGZ7r7YB+izsG1McjcH2hFR5c",
	"Fx8d0rcg3z8v4N2j50JJBx2UmkuA3nVSgI7HyWLNrnN4pq4UMT2VgrZtVMYzs6IKvaIT7slIFs9qDWMz",
	"hrFHOKzK28rKQKs5HBYHOR4t7gokAqYFAoFHkoO2/LFIcmskGZ/WaNBjEUMo4MRlZadD3NT6mQBl925e",
	"WbiWY45JyLIJpsBUqUON5GUra8du3i2GMu/6QgPmYN+dFAHoYt4l2RruSrO7n6dHxRsHvgHdfJBkwQYS",
	"BUh5+Qdw8DSLE8BVhUl2iyZukD13+MZ/PlZJDP3zCJKXQg6xE05WPeYnMi8AgkNTLEljalHDI5DMAFGW",
	"vFAwgkOTuQnH65IvQirIKnRJlk41AtKdoB4lDDEupKS0qApvFSTMkmJf6IlsJRZAMRdZZCQTFCvkU+sC",
	"SkfrXv/OjKoIrzAkhSz8tLQyfrflmigSIS9qAo6lcKg7xJ4BszRdwWZl6jniQHzZOB5giLs+gSHSiBV1",
	"YlWJ0TwF/pyJmW6BLH7eoRYjNaFb/ag8ioBZnWf9iJNBcvp+RG8w3TwcidMidepSUdGNQLyun6zDIh48",
	"YZlCgfrz8g7OKjBE7vHMo87kKTZoBmAaOVZWbORnxNAX+p0ESMNQV57b06hGc2jsnqid2eXx5Cp3bAgV",
	"syqxakHH1ic6JV6FhafMwVO1I+VzvZZa0Uv7qZmp/BQgMfQkECDlCfkeps39GS/mU5zYaGAeRWZpgHjq",
	"FE+8U0J/QqtpIjQ+iGlmARReJpAygXKhkw+xH2yCslT+Q8pLDxLQ6ls/yKxAnpDdOBBjFmddpqXjwbfW",
	"46QwCSQiXtQljYLdSJbV6eYQHYObPUs+J70nGMUAvubmGIZr6vn2qhDpl9PZ5pb/k1NPQX70vNWyfugA",
	"bS4iLX2/QlxjxjFaka15/ZWf2Jhgj/Kiqr4qoZCewA7Z3BbrMIR1VNlcKC+oYXxIgIdOmxBmLwIEg6BW",
	"hlgZYmXIucgQDZNXCyityZkOVyUbJY6Aes/VVe9u0U8ba31Tpa3RQK6qersxqa7GPpp3MM+UZYb3VC1y",
	"y0Nute1TQc4bHCdrTedkIKsezt3qXQxr9VJa7CsJbSbm70mT0GqSxYD5Wyp87XqhWo+I5eqWVEtX7AEt",
	"6gyx9MI3BX7YrfR+BR9Y3crSbV0vXJM/TyXyik5nfl0lclpjqH25um3RQGK5uu3UMsIksZ59kLSg1pGo",
	"SRH7LEvyrC/9KJrd9nvg93TGJ1Jq8YCZvpt202vkQMnCbJtmqRipKzG0AFsm9lyT7PIjHg3gQ1fE0beN",
	"GI8Sx+h0XJ4Bs/RsM1q0h3/RUULmjSkLOakZ6ZtsFcI47ddRxTYFnFwI3H7CmoJpbUTT4A0QmSRqcHDN",
	"6lvq6lp5dK7yaDGYPOrRkbYYc38Ys1AWtfe7d1l2WLubDCRt2hH//PBw5yzh29pdieXQMxwYjcs2WjgV",
	"vtenDyDe//mByUJqYuidSxgt4GYx5XbAoEdFtdPTog28MBLdqsWxqJexiNL6BbW11mmRbj7S/bPk8Er4",
	"t0gu9aCZ9WBy0ReYhc01JV95scIlWr/lXIF14ZGPBmgXrVDJFmmE4ltxpQ40bxnyRIa7RfT5iH4nfmrE",
	"/IUUayQGYJnprPyJUYUOdOQIIqVBWizrrMqGGwyGG7qJyQYIpF+rg0xkhaUVlmMwuoSkNDTgYiMi/UVE",
	"OojLjsiMtwPeF40oCX7eRFxkBUc621gI2dd5RT8YCqlQLjrstvENQnMdIxonpbeJKlKWisekO8XctawI",
	"qgGCE+LF2HCEJByRH1AtAEGFhRHV1iLMgF40H1hoEEAcsw8vxPoMZx0+wIc8roABWpNQhauFBZq5SDcQ",
	"oM9Aqyky0DC2qQX4JQC/nP7VYHxM/8aAe6s9Rm8ojw+QF3I6K6F7hN6F81uw3TTY3iCyVCD1lTmNzYDo",
	"M9HaMxdci+EFV/9OvYW8e4a8ZUKro/cP4Oy6dwDQkuWp/+q3ijHsiIY867R/dqdnmu3P0E2FmvPjbwt+",
	"syTZEQE/OSlOVEfWCHxMmrKB+5Y80TYAKN6wLIuMS5Dx8lHV4HFWpJhTki1w8mKd/O5BHbByBVHFsQuZ",
	"BVnv4axBc+akx4WcFwuTGgJqELoag+nC6HPjrQENYAuqS0B1RdZQQ9cZcjQGsVulMzFzfHyAu1wU1IR6",
	"j9C7fCUWfzeNv6tKNxUg3rDeZ8B4K+LmJ+IWpxRxA4EMFqnvGalXEm8d0Qiyl7qgPdkpcxV7yIBnDdqX",
	"93qmsH2Jcip0zRBBW+i+TJgdwfsREOVElSmH1MekTxs5cckj1yEw/MaVWRRfguJXTqsG45cFjEnV2QLK",
	"Ly3WeOa7kuzi3hFnVmU9j7NG9EtnPS5Mn11ag5Wghusrc5sutD9HRhvUVLYAvwTg1+ATNZC/RJbGYH6r",
	"jSZpuo8P7G8SDBxZ3yPg37QaC/mbhvx15J0K7G/eLGCQfyv15ir1FqeWeoOBFDYK0HMUQFnidYYz2tXw",
	"N1+9fxaF+23J/jrx1Mi7e51+sxX6bXF+o/Q+LhWrUpCfU0ZzkKCALcLfKSpQPi9OWMBkebfOJfd7Lrbf",
	"urimLas5q9jAeGvry+o1tiyo318p/Xmy27D2sw0RSEMEGtyiGiTopVC+1UxTNejHGCgYV0V8Wwv/BLEC",
	"HcGnFi3os/S9FX8zFn+L04u/4TAMGzToPWigLPraox1hvF1nbrIFmVq44DbeOg/4+a5hgtt4i0c6x/gA",
	"u6/ziwswVMIQbn7gLQIBLN11CACcnOampylrlDwSFdnAYcsSGfaM8DesxSL7XC1XOp4SoM9KCiO6TQ/B",
	"ZxZmFLlXkD7lJTELsR7BuUL1zCGPBqIv1iTU342YvCIX6WDxM2KgYYxTC7rzQXcF+m9E2RnaM4KuW+0x",
	"CSt5VDC6nNNZCd0PbC6f38LlBuFyFZHV4HKb1thkaCu45iK4FsMLrv5degt09wd0Nwqt9t7/P4+Btw6i",
	"IAvcUCMf/j9/vVk5N/g1JzGRDg9HJAOeazY8Z6/nB3rXKYeh6QoRtEDAOYTZAQgfCVFOT1+KSH0kelON",
	"E5dh6AhaZ/dd5V5tgRYx5+fCc4RABTqvCxqTKlQPRy+t1nwivLIMK6+vvirrZJwrtl4/69FA7LWlNVgL",
	"jXi7HrfpwO5zZbRBTWYLxfOheF0+acTl62RpBJ632miyJvyoIHslwTBc4rvSciyQbxDI1xZ4DTBCT3YB",
	"mcGKvTmLvYHtoTrVDAZT2ChAf1EAPYnXHs/IPNKgWC0U8LAinXY7hwAeVk3tvKfryDCbOi/MvyAPhlzp",
	"SbcA+OF4K0xuHYD9U5Pa9PRilYBHohDlfLUk8gn3/O8XspevxEL1fKiePZ0SQs+ICBOqTA+Sz4WWWSi+",
	"WeqUF1Qsw5r954q9F2c8Gsw9X5JIYzeC7Gr8owOut2Gd1RRZZxAj1KLofBS9kfIbYfOC8o3A5VZjjN8g",
	"HhUuLmVxRiz3A4NLZ7fwt0H4u1lSNXjVhYI0iXPPRk3PW14thpZXvTvtFrjuD7hukFXd3Hv9tq5wOa26",
	"uqIjJ/+EJyPBsc+8yWt94+eXyF4jozJ1d+vwWqfRbmC37e9qjspHpDmVurtWaWkAHNz2du0Ah8tau9YE",
	"i0HlqQ+R99fXVVVk1e1F21FqNrD5OJu6VlcmNwuUoPReOrrOk8WGtIotyi5G2dU5RAlyN9/L1WqgaRrp",
	"o0PjmyRCXcD3h83bLq4DQ/QaYk4Br++thasVdrMVdovTCruhUAiL7/eL76sKuq54hXbnVrw4vcatj673",
	"BUS+FN8/78atnM2eK8IvaNtaIYLWGL+ppq0jIcqp6tTRtmxV48Qlj1wHAfptv9YOOlPSrbUuX0yqzjZY",
	"f4dWrUKFyqD9+h2h6suyDsh54/2jbNRaW1qDlaAI+bfuvyazXufKaYPayhb3l+H+6oyiiPy3aNAqZBEG",
	"+7f6aIrG+wjh/wbJwJH2fQYAbG/WoSMAGgJPKQbQbBjcaBoGbBTAir2Zir3FqcXeYDiFjQX0HQtQFXkK",
	"kMbG2wZr93BQQPsr8C2D7r9bvb9xGApKuc4RfGoJZ9LFTPUFyuYYhusUoFf69U7g/qGPmhd+T0+chezJ",
	"+ar5FlWScbIY8bBX+1SRF0Gn65+aWqunVoRqXp0RGh2V7V5aU4VKGKroyVaXzG4tdDMWepSzOFdE6Kim",
	"698Rzq4Epkd1yZID5hxrPnXg0CLgXChixASLjGSuaU7+0miZ5+duAe8eAW/2zMYCdTewjAK0XaN9DZIv",
	"LLQzovfBDUELTnMMxya6bgJmupA1GcaK8vO1ShdDW6V9QSnzMEtPCqAYNEpLOSCuF6olTC5XtyRxqGM5",
	"36UXtnWBq4BuhdJXtyXZ988jSF4K4ed64Zr82aTA61M3o8OZX4JlTmoMsS9Xty1yKZer207ZkwZp9eyD",
	"DwWxjkQpirhnWZJmfelE0ew28ZFf4gCfSCnXEfN8R+Wml9JI6cJs2QKZGKnrMDS/jZWeLYJDj3g0mYp0",
	"RRx124jcKDGMTv2B8+eVni1Gi+Tw0wwlVN4Y9ctJzUgNAasORmm9jirOKGDkQtz2E2AUTGuDiwbT/2SC",
	"qMG7NattqZ9rxdGZiqPFYOKoRy/aosr9ocpCUaTidCfogP1OGXj5IPy4bj7FWaXe5V81L2h3w5xmHsMg",
	"v1Mzw+kILZLu6Dw2606VPMeVdldaVJlA6Nn2lnQnmdsaxoYM403BoBzZoKOOdLLuCokiS7b7Q0O2nVC2",
	"COjU5tpNA6nND2w0SK2cSxTg2pzedcicscTOhcaHt/YsLMtLsGsi6CZApBU909Q6K7fP1fBcDGt49pZX",
	"Nw/L86QQiEnDcwSZdW39XJtaZ1PrBk+tM0WsNrfO5tbZ3Lqecusk6m0suXWKhrwNX9rkOptcd+bMYrPr",
	"bHadVQg2vc6m19n0utGk11l5ZPPrbH6dza8z4XiTcp3r9DnIvF0QbTW63vyE33Xu6buqrW/oYrheBRk1",
	"H5T2RDmbtjeiLZ8ffiwgIIa+ecTQAl4WUWpbxHkUNDo9PSml/JHoTg3uXApJuGfEWmONFsTmg9jCcyvh",
	"2gLxY17f6mHfgsVrIuFiLYxn4n58g89RWZH1PM4VGheQ4GiAcv76VCyLRhy9BffVvHxtC/i8GW94c9si",
	"73zkvT3fNALzAr5RhOnFHIOBequtpmr/jwrKV5cWIjXQD9avvi4L/xuE/zuIwwaAol8rQoJTWKE4E6G4",
	"GI9QHBYIsTGI/mIQbQViF8gkaFMWAL3VMRSxDMOfgsg/VWZxr15RML+SAfibGVINVEsFwDfF6pf+Rb2A",
	"wCmpaoIaMhhZ/YBiQRXtF/RXN0A0pzX3DZr7aJNrAqKr7tKqIYBEjfj+qY4TQGB8qazhEPCgF1MtYj8Y",
	"Yh+MqfYAn9MU0HeD/PEeZGfNHH3bj5PG0HvRJAyQLiLwJlzIIH1TEMgqgDO0ZhfDWLO9ITeBLUTQJ05j",
	"3JL13EN2TIA+EOMDL0QIDB7ASYAXJ52hmTd41BVd1RlBM/lOzwudqdAJC9SUD7tF/meVBtvmfZ6Y6qan",
	"7Mq0PBKFJ2OwZRg6byrU0m8yp2w1NnuTq9z82gGVsjZr4sKA2tNL0Kwu0FBUF09Q+bwGi54SM3ncxnPP",
	"FuCpnvRosJ4KN8gVeyMA1BNv1WzKM2esASxYiw9J8CEtpmgMUFaZwmCs0qqbKVjYo4qPSvi/alv3FC2V",
	"rMAGTA0GTPWkWIPP3pNm5/ruVo6drRxbDCnHVjmq2Ss6YKHy/qByDRnWAUjYBGFGNr6xsMI7/GzXCr54",
	"mHPMXqSbOb+SCYQ02PrS6DctQHFKZR3K7p6Wwqan5Ep0O5aa9GJeWuYE1zMGLlmDhcC5Sis/lhLyncuC",
	"7opKD/AmyzFai7dJuFTaJ+AVWDv9bPsn4QMeDapNeI2riBtBbAV+0anEOwdW6d+etDUB+FC1jNIbkWlC",
	"bEaK8VqNMF6jdlwNPoX8TAVvT809hfNa1Nkg6iwVSA0+sEnNS1u/WbF0zmJpMZxY6te/tiByfyCyWCR1",
	"cMV3WXZYu5sMJGu6HI3yvD8/PNw5S/i284m8rVqgV44rw4HRuHRYOOo5wszi/Z8f8CykJobmuYTRApkW",
	"U24HrHpUVDs9ddrACyPRsFocuwxDR0hp/QLeWuu0EDi/hu/PksMrweIiudSHatbDzUWfYBZJ1xR95cUK",
	"l2g9mHOF2oVHPhrwXbRCJWOkEZ1vxZU6eL1lyBNZ7hbi50P8nfipMQYgpFgjUQHLTGflUIwqkKAjRxAp",
	"VfRFP2EGnVXZwIPBwEM3MdmAgfRrdZCJrLC0wnIMRpeQlIZGXGxQpL+gSAdx2RWaAXBhusES9DXyGIl6",
	"c3SMOKMhzzo+wu70TMMiDN1USDs//rZREJYkOwY/Tk6KE1W7NQIfk7pt4L4lT7QNENpoWJaNaEgiGuWj",
	"qgUyWJFiUEu2iFsUC+W5KJ2iFQqyimNPMguyHslZByeYkx5XTKJYmNQSUAtBqDGYbuBhbrw1oAVswwuS",
	"8IIia6hFExhyNBZEsEpnYvb4+EIFclFQE+o9hgfkK7FRAdNRAVXpphIEMKz3Gejfirj5ibjFKUXcQCiD",
	"RfF7RvGVxFtXOIJspi5sT7bK3OUGMuBZw/blvZ4pcF+inAphM0TQFrwvE2ZH+H4ERDlRbcoh9TEp1EZO",
	"XPLIdQgUv3FlFseX4PiV06oB+WUBY1R3tgDzS6s1fvtASXhx0+mYVVnf46wx/dJZjwvVZ5fWYCaoIfvK",
	"3KYL7s+R0Qa1lS3EL4H4NfhEDeYvkaUxoN9qo0na7uOD+5sEA0fW9wj5N63Ggv6mQX8deacC/Js3Cxjs",
	"30q9uUq9xaml3mAohY0D9BwHUJZ43fGMdgWPzJc6mkWVI1vfqE48NfruXtTIbDkjW8nIKL2PS8eqVC/i",
	"XDkeJCxgKxZ1iguUz4sTGDB6Fa5zfaKeKxO1vols7yDPKjow3kJEssutLasP9Vd3aJ7sNqwBbYME0iCB",
	"Breohgl6qSpkNdNULfoxhgrGVT7IFg46QbRAR/CpxQv6rBNkxd+Mxd/i9OJvOBDDhg16Dxsoi74OcEcY",
	"b9eZm2xBphYwuI23zgN+vmug4Dbe4pHOMULA7uv8IgMMlTCUmx94i1AAS3cdQgAnp7npqcoaJY9ERzZw",
	"2LJEhj1j/A1rsdg+V82VjqcE6bOSwoxy08PwmZUZxe4VxE95ScxCrE9wrmA9c8ijAemLNQkVeCMqr8hF",
	"Omj8jBhoGOvUwu582F2B/htxdob2jODrVntMwkweFZAu53RWQvcDnMvnt4C5QcBcRWQ1+NymNTYZ2gqu",
	"uQiuxfCCq3+f3kLd/UHdjUKrg/v/z2PgrYMoyAI31MiJ/89fb1bODX7NSUykxMMRyYDnmhHP2ev5wd51",
	"ymGIukIELTBwDmF2gMJHQpTTU5giUh+J4lTjxBM28lVboMXM+fnwHCFQAc/rgsaoDtVD0kvLNZ8MryzE",
	"yuurr8q6GeeKrtfPejQge21pDeZCI+Kux206wPtcGW1Qm9mC8XwwXpdPGpH5OlkaAeitNpqsDT8q0F5J",
	"MAyX/K60HAvlG4TytQVeA47Qk11AZrBib85ib2B7qE41g+EUNg7QXxxAT+J1ADTSNFyjv62PqUpAoALx",
	"3t/fIvn2a6oSFqCLEAUG2NHOKRpQ2eR5RQIqh0qpmPm1mpPCvFBXyZSy6F+82jaInBR2HRbr1yHkUfkI",
	"nJVVOIwhn54cg8Y1WKfAoFNQZly+WDGmGLVQ/qgkq3T6b4kVJB5cKqzE9I5n++N/gyS+enRT4P/JehVn",
	"CO2zRz4WUD9S4lMFLN88S70H2Qz5aTA7d9LofS+6i4Hw1ZiiAcfqQ8+Q0a2imaE1vjiNNd4XYDUnc/yU",
	"YFXUtymeeW0aOz6sWvZ1RCdP/gkPSIRWPazOvc1jfePnl8RaIyOGwssU0CKFtU6jHTJYx0GP01OjAiof",
	"iSpV4sElh1B7TltVWpfNWuUrTM5ZlXJWa4LFpPbUy1itLdVowqqqzCqvrrYmGyk/V0yrdtSjyVatrkxu",
	"FzTiW1p8ppOqOk8WG9IstnmqfJBLj0MaA8A1kjSSpGo10DSt9FFFn1UkQl3A9xOFVlmLDUQbDERrirkG",
	"gKAfO4BMYIXdbIXd4rTCbigYwuL8/SWl6gg6BcBiG8aPbtiI5ePHoGRDkGlpDK7D8x6Pq4t76kuNzTEM",
	"1ylAr/TrcZCtmgH6Lj1uhuDIITdpVP5wIvU4GOW01jetiNK8fmLpcSRaScwi+FR700DiiS36zVEjW8pj",
	"NU5WVhmjqNJvSFbYovvzLbo/fnVja+jbGvrzrKFf1zQjK5kvEh6jqRxqg562Av6AFfAnxw+2oL0taC8o",
	"aG9lu61Pb+vT2/r0p65Pb+WQLTdvy83bcvNyTzmJjwcWh60H5PATDWLkDt+4OaYgQZgakhtElPzzCJKX",
	"QpbQZ1TESX5C47LQya7NC5bNz3ZLKSIPAsBflKxunoGMn5ocHU1PK6HzGZVhzKyoEt2Df+jLHBbOai1h",
	"g5ZwWSxwpIKyFrr+Hd15KUO0PBhVSZKgMUvyo2zSkr9oiY65y6ozQmmx5BkNQCtinku5XdbEBO9nyAS9",
	"G362NooEmm1UBzkwwk/isqLdmqGDcy8Wk73lmM3ADj0pENLB8txl2WEN4OgpzbvUr6PLJKPB8a7QeA4d",
	"jhv5/Pnh4Q59VHpPZx1zMhp3m+YFf3BOliG54jzVoo/10Zwsrhe/FQUba+Qzwzw0Dk2OCvQQrq9MFBxK",
	"6AkPUVyQRUcMoiP10xUJjZbKiguaiPLaOLSGUmFdkgMLhyqy2hokER5WQRI10rtZS95iJn1hJpyjGw2A",
	"os5oCqluRvmEZ+1NjUkGti1t3hvvcp0OiTclnyhROK8dgzDvxCqCM7GAFyOwgI8H31rAk8dljBq/Ybxd",
	"b+Lk2U38TghNGG8dOo4oKf0dneecrqGXNnBe2A175uVcKXLSaqANs4NctEbaqoiZzF5R16DV0WV4l9ZV",
	"T60kh9xnjrdkBRa8MQTeMCJDJDE0lZYWUsNML3A08zRxOKrkwqFQ6IhJ1+Ix07lpSM9sNECMAuMoIDAs",
	"/euQfcl+OyOaP4mZaGEYHgyjROBN+Etb+i4u+Vi5ft5G6+IURmufF4LmYbWeFHDpw2gttSN4DKIW6At6",
	"q3uD6Z+CyO/gRY+4Jjne1nlhMvibCyqFp6sGw8A3TTaRPi1dTS/sAPd/VKhMsaAyzcCD7QuHEc1pARiD",
	"2TNok2siwoAK08JikLwRG+n6jaCbBA6Higc13W2DnKEQHHS2o4Fu+OymgNYY5JD3IDtz9ujbkLTXkyTX",
	"k0Qk3oTXGKRwMqpVAudp1i6GMWv7QmpmYNeeFKLpw6T1t4m7X7fDZtC7qggNgy9xNfcbONhPxLE/G3SG",
	"3d55YTQMcTA0m5+yGlxTDFLXkmwYRBu3KdZhIRtlEh4VcFNd1nDwjXxmC+IYBHEK/hfIEGPKTwvVYcSS",
	"jl0vVYF4dIlcska9RXZOgew08qACyNMHw7A2owV6jOkvC/cQuEeB7puQnz7IngxvFcWZWsiLIS3kvpCg",
	"2ZjIJ8WDeraOx9Bs7Txzdmx/tnH3Z7MZPbalm23pdjYt3dR03MjavOml6Z+oDYfFhGxnuPF2hpsDC9lm",
	"craZnKCZnNUgtv+c7T9ng6oT7D9nRZdtWWdb1lm023TLOnhShySGNqZ+uiObYYajdHSsvKo3lHg/L+/g",
	"zALP5I7OPuaS7aVtmgFATQ4XUhhzPgyNkd9KDHpse7PVviq0IbbW6eDzK8PObNPojOHSuuoqhRxan+aw",
	"ZAXWHjZsDxc8yOV6TdWiW66rKisEZbvEkLFQhJQnZaeyhbqmAfyyZzYq5LeBZQTY77sg8gVEj3zHlBKm",
	"xHiaDJkPZKNZdJZXa0uJRrlAx4fYDzZBVTj/IeVhHQJ6fesHmZXLkzMhB2NP9sTLVNVT+fL5GJQnkDlI",
	"YLyoyRwFU3LvBiFI1iDKkqCCUxwS4CHyINStjlyUB63k5ZVRWvxoShUzN8j6AT3zlixRrTN7ZVxZZ0zy",
	"6LpwnqeqpyuHOa90v8rHFyxRkM9LBVSRUzgTN8VjO3DsF1pSXUjD+jdE2RVOnLynp9UZunkZFTJUX1jF",
	"dCyopi9oqGkJFhsyiA2VNlskvrRVugAfkou+AjEqST6di0WNih3PoSH6WHofoKn2bEXsGQFaLMmMBtBS",
	"4vNLXTs8jkp2t2FmLVnhY+XUudn4L/ZOrSRfUpHNclSuic3yhKT+VCKZxOpE63acDk3UcTv6ynKakd9x",
	"0jwnsy5HwexmYEQGN6SCR57zhNdNG7ueV1vEyhbPE93LNU8d30u1sL1yChXYH7IX50N5CilWJ24ebNvN",
	"yAl3hBCbtMkupYpeEba5tPk9PchWZ/K6GNFXeEZAtrRLB8UmscQnapuYNSUcKx0PhqXCRh0grFS3meJZ",
	"kv/JjEub5MVL8lKjeUU8icn7akPyb/0gsyJ/Ftbu4iTW7hB5YvOyfU+ZK2bI6oUSAj5CNlfrRhsD5jDD",
	"cJX5L8w0aukwCUjj8AkkMkCaPjPh2A+7//OCf6ISSVDiLQhFrfxFMQpN4qJEIQnKYNiHmWpyJDm94Ehx",
	"UKOCi6rLKh98QSJ9gUXy+S1OZAonYnmdK2v0dKXWFT1GRuVwUE1KKUFC6iKLodwBgsgzkoxnBEExNDIa",
	"FKqZURWqwjEMpwk6WQYbiTVs8SoeXqXCHU3Fl1oyBxnBMoi1zYcCt5Rt875ylmZjnJ80Y8mIbX4AgiuP",
	"KkAW+7JC7wEAEmla9R3QvdrIDimTYGih0094Lh3WvFCv0qcX5E5J5kUN9UL0grOV60USWVrSvrdYLGSy",
	"lDs9/ZsTxbhuK1aXVSEA0PNNRfn0FhozmELFbDVfJmlqYC14jBFmOlcv5GoYD68uzcCAVy7gytOZCMsz",
	"gssKGhkNWtbItwpgWTGGQfZjrGDLeyc1se2NQtmNQgUGasLTelFfZHzLQ9bYHwhsUzX2+8LaZmPtnxRr",
	"M2bo864FauaMseMILYizvPjHfvksAbB60iI8aw3si+R66eFa9mafFmWOD4uSZBXD8+0ViLK3+fqHog6g",
	"FAMiMkFTJeljTx3u6PHFCoc07bW86YA848J3eEpSCdTRzX1izK1zIOnTmHM2b4mXt9RJsFebLj8Gka8f",
	"40dvNQf3NwmiCJ/LIcsw/CmI/Fa25IgbteINnZcbgr+5IEl4rmr+B3yzDudRutGPuJ+KoqaHnMGdH5VT",
	"UiyoTC3wSPtyRkRzWifEYDwcbXJNOHTRV1peCRIxOsEEsdbCg4plDIdwB7XrRi7EzsizQWc7Gs+Gz2EK",
	"no1B3ngPsrNljL7tRRtVlkSVRcTdFEo2SNtkVCv4z816XQxjvfYV5p2B+XrSAK9Ry7XoTK6At4Qh02Nb",
	"5RqFoJk/xlnyztznBrawezovyKVCIYI27M1a8nkXh8AJgzSDo7I09xxkO8To6I/b4AmgGxD5SYu05Knp",
	"bZp9E0tUPKK+iRLuWpZI0AmDCKS9qbqGtZyNxjOrwErHk2YCKdFdoV3/HkQ++KqIyDCr4tvnaLAiktys",
	"5vLm2zKxU28cTxZxA6fj2+oB+VOjsR5EGdiiq60WphkPTMMc8qj6dRPWEyntRtxGkYPqedJiM3EmzDOM",
	"NWoD13wsR4H2G0OGDO0RWVHQN/xmdarHIUOrNUZvFo8qTinnclYy9xOzlM9vI5cGI5cq4qrBvzatqcnQ",
	"VmjNQWgthhda/fvvFrDuD7BuFFgtXf22Ra3Je8349aPrfZEkCt6jcc4NvZ5nqep6mep7jRLVpEhZTV8S",
	"AtLPGDwdaU1PuY2w5LSkwGWvpaZtmelBLPBaKbt7zTJ2Ak2mlUHYWOBTKI5ESLVM6HCp2GaTnCU+fT+y",
	"gtFidlMApU2yyXuQnTWP9G9WWgiaD0HLSLwJzDFJ4WRYqwnO08JdDGfh9gXZ2GLNfcM1xq3bzH0MW5Rs",
	"xq8ZKNb8gOc/I4yG7Oi8IJqMHiOlS3SuagANetd0IWU8v8VnVIh1VPAMs6IyxaAT7QucEc5qsRmD2ExG",
	"mLIqJDrpLi1gBssa03WOBcKGR7/WGD9LWAYf7mhQGRGjKWAypjmE2njnxx69G5H2kqcElRGTeBMmY5rC",
	"ydBWCZyZTbsYyqbtC46Zg1F7UjSmiz2bxNvE3ZeRl0MCPOTdEHLVr+lLRqUi7JDEUFtc7d3I3dZwaL7/",
	"/B5kd3RxXSu29lr2jS5yZgV8i7PJ67nhU/6AD7kCushpii3siwemtX3bkA6p9YsHGnO5377K95IvH1Xl",
	"XnZNlTKS5MT7qtsrntmiKqZK9ua8JhQGGspIAKXIRQhTzZfQU34Ns1mGYMO7ocivSJ7wqdmW+p1IqV9y",
	"XuOp9tvMS5e6thoqBkw+lCF1HRaRWWiT4IkBjECbusIt+6tC0Dla0kTQRcclPTEvlfC00ZIV8ZMwSxdD",
	"mqW9tTqahV162j5HRszSxH1uTEz5eXkH3+SZlkHkHEI3iJwMfM14SpS8Wzr0Ib3WZsUIV36NPqJM3jUq",
	"qRLyR/qtTpqrwYryC49pBhKJ2sMPVHZWRfNdVjTrage8L+lxr6Ra9/6/Ox59QWeWnjEcE6fyHkQgcUMH",
	"M8+gtgjPQuDyDsOzZcYQ5/LcHdMdAZEII+uz412cKvJjRaxunBRkl04U043A1OM8B2HoPALHhyY4lNzI",
	"UjmmO0BrfOaPgAipYV/QTjH9EhzWvF3OqWPjhim4pLv+GMchcCNeB0dmtUSR0DUEUZAFbq5ljlEW7KHq",
	"QT3KsKn1v64+4V9fLcmv6ctIF8rXz1E17ZcfR+GL8+SGge9Cz7902JeoDFx8zNCqXoJo6wSZYGVwnDUd",
	"p+PabklBOrJHzvLuxvHi/d6NfFKZrqAjJwXwB7jbjy/OH/7fP9D1YYYsFljb8otutmQ/lqGGPDIKSraW",
	"g7+AZ4HixgxqNZW2pqobyK1Pp6sRbM+r8St69RNM0MBPxfGeMG52TjYXMpKEJpLE6lJxlEAah63KLTCx",
	"43wQLuD4KZ/inDrBFhs3ryBywpwmpTt6wmpJ+3SEPENfuyVsPp9tC6tKpqMKLJcXVRU3hDp6Ci3L5rax",
	"ZUOx5aRgUI6M0FFLWin6uWTp0BdWLFsEdGqDxtMIGucHNpqosZxLFBLua5pUs2/sudH68NafjR7zosdN",
	"hN2UZp/TtQ49k/et/D5bA3QxrAHaVxB5JhboSaPI3Q3QINp2w0TgAHyti4Y+KywEfdHMcBByijl5wRnV",
	"8I8g2rbAPOD4Fu9QIcVxYR0CcBmeZ28YR0/hGYtvUHwDM2OF91XVih6mAemkC57BlRscWrQ4xkRwDHhY",
	"48EwuJyggl0g+aeJV5wJLQ9rmVmMgotRCAi3EZvQpVuKS8xdDp+XgbgYxkDsDYM4fwvxtPhDRwNxhA0x",
	"WjmgtiGGbYjR3BDjFKRlG2LYhhgW4uixIYZEk42iIYaKQW7LoNuGGHNuiHGmPGIbYtiGGExDDKsJbEMM",
	"2xDDNsTQsW6zBEqlZgsWbebzLg6Bg19pLAiOBx57BbxzKsBdOpexmIPw+8oUw1YLxUTSYBhyxnCIbOJn",
	"Jg1Ge8MFwAifWnOsZo5JiINPaXx0EON4nNGE7VWmIeB6KC7NkOJYOqYIuaMiFPvqnSKc3+J4nflcyJkC",
	"9pa4Xw3Cgl/UfvR8PpKItDG5sBhOLvRWd34OAuGEXk9GmbImAJR9nmsQZUmg4vugjhnwHQe+8lJkMWp4",
	"Qm/hm3M1FtZo3wxIhjNw0AgNjadPUrEoHXOZbV7IfFYQkQsBFdZwHuqKl5buIjaZE2ycCAAf+FKL2zLS",
	"y/hMb3ZdYpp3fb8nTSue39rfJpsXymWFguo9piAJ0eI6XEnLB+GCP7/mU5wT/lNs3LzyvI7MaVKCoyes",
	"pp7oCPpX1fJ5rO+nSp6jUk3lRZUJhJ5tX4iQbG6rkwzqpGPBpBz5oKOStLK5cqmif5NNLFYEJGpvtE3D",
	"v8sPbDTOnZw5FLKxWpE5Y4SdC40Pb+jZzreS9CsjQp/1QbgEnDY2Y0GJTQWTsERcqfPNrHiqjYbwns3T",
	"/XCOafm2CaSPkv8hciCmR0PTw8bgxozO8xB5HX16HNbbGMjbQP+oiwNVzXP9O/wPx90Q+QsqdpRDx+Tb",
	"UcxftaTH3MXVmTko43JOeBpVZpJZPjiZ6WcdEgWHREjUJCuJm2FkCdvao/3mQUnt0b5yoGZgkJ703kdr",
	"E/SpkMJSAJDbnIgL95WO9G+54O4WNeuq0MgpB1EGtiqUWEiRE5d0EjWF0mqPg8leIc7uhKRtHG1HRt4U",
	"VFrHo/Za0xhPITY3DG949fs/Fd9f1NzFa5Lv9fXvgf+tccOhuVDeaifN3Owo2/DmIuBonMDnWwbo92IV",
	"fXCzDCTwtf/z+bP/+w/fruB/XrP/+bf/5+KyJjZ/650KlG3OEVwJ5p6pBg3hLosa/Aoi/xAHUZY6Wew8",
	"IhvUdzZx4rj+kxt5oOihmYIsC6JtylJ5/PhfwBOk0JCOj2/pBH2ye/4Vp2P42n4B5sPp8b0JUi9+gvav",
	"/ACvXS9UkLph6CxXt8jTSZ1jikopQ7OFnljsfQGZsKIBnPhnPC85qyWctcdjcr1wjRarw5I9gfKlzWOO",
	"CP6ObIfKIamJazfK50JhT9/Uad00SvV8Xpw+efOmlXQfUmpTKpmK3GYOtwsdlWoDMdcKVAirIqNNURd2",
	"46F/+Zasp1NdsiGIJl3TrdOinqm4bSzBgfxM+DQnT2uMqsn2uaBQJ567OB2YeszDLJRwRpgVz1taXbjj",
	"Y2TigZOLiuEvyGIlSSq4m8nk6sLnD+4LNJTrJLv0/Tv8N0qpq9tR02VFoI2MNKXiljmI4tpGC+o0G31l",
	"VmVaXefGYFPqJxSulWuAcAEoIy51ntzwqCOGi0J+ioKYZzVqll8qf9e7AQxMXs26ietzGsUs9PmLRO5J",
	"DUFKQvgQCCHdvOnNEpwkCS0GVM3nZ2u+tBWXCoAUqlSHwC4ESrneztm7kbsFvrNcfXjreCDJgg08K36q",
	"8NLbg3sKlvV46nuwJpjc2J1TtG33VfwQ7lOjLfUuTjzgJCACz26IsJJI4RQ+wefh+KviqSZwgnkU+x6S",
	"QLFXGrazGCgv5CP9FEiFySkzW9A21rZbeIRS1iMVHw2X0P9DDRIW1cony7ynteVGih2Qz1nrFsHvsZ9e",
	"vsFkx+lOdytVTzz9WklQnpdk+ux6aF5Cjs31/fUIy8GLlsctnNnFPdIWUyf19usk6TJkqFZ9Uk2+tSms",
	"nrtjzTxCOsrJ2WRkdXPVvCpOJfAp+VPV45TSl3ox8VoctH098akTTV+qd0qRegFVdKrmjZKXAhBlnYmM",
	"9lmbHqH1ZyeMsKC2AvkLKYPNuJxa3qGQ3rVNgCDaxA2OTJ6icUhiKEoc+E6yp3nmNelM0K87/PQNnKBH",
	"EiCLWqMPGSx7Rb4l9AhumN82nMPePTQ7lFRY7t0DzrtocBw/uId3JD1DKrluNg5iY8cN09hJd/Gzc4wo",
	"fpRP5oSx6+Nub2T1AqQhiLzw6IN1PkYp7zc/hY0bpiBPaHuM4xC4Uc+4I9rmiWjJ2mkzlPUBfocCSSnY",
	"8J/APn4CCKCAM5FQTGHJ0+k5BXpC4CYFqTVR2QcykGENKSBln9iyaEb0MX6QfhFQLLqQgK1fXo56QZvi",
	"+YL9HviBm4HwxUlfIi8lSfUoMbBp6jV8oyuXcFyRZeVQT33tTJXW6pSu0gS6wi9c4fgxAqel2J6l25Rc",
	"gOqB8U69KVkBvquerDA6KXUSqWHeRdi7h1GmWdTWVT/r8SVYMCTdSuO3TYQsxSqoaA4ix3W2wROIFOTr",
	"/S5+lnHaWFCTBrIYq7yEG19kx1eTFwuRqZO1KD7Mpe9/cA/tKv3KUxXOVfq9jFL2vYgk3+QTH2X0bExy",
	"KuakIaFJF8C1a0lOUSDsJFtITgHT1Y+w5V2z7t0Dp+QEwY36Al6ucVrgOCpvpBr00soZYnUFvdVAsfBA",
	"GlUZP/0NYRq8TNUwIIet7EvlURRId5hFvDjBK/BR7mOM88kCHxuDe/fQFC+xImwQm+SQwEPIiHmPzo4v",
	"/fCf6neH2Q3+Bxngt/wxfDl1VPGeRpsGE/CUQzsabKhp46RpuPZccoFU5W7s/f2ts1q2uR67DMOVS0MP",
	"/bXTZT9oHDdi2S1jY3H3t833ynC5SgpsMSNp7D0eA+/9hUyy7I9hFhzcJLvexMn+CnGuRLigXO3jAWES",
	"9YUv2VRLan7j0BeUdUHk4uTnkviBQgQ+88bN3CsqRJlp4N/3wR6QtzLwNbs+hG4Q1QQX+xZPfAm8rAqx",
	"MPs9VZ9ISEEiUlSWF1q5YMWkPDcnJ055MgVzHL2i7z8ISaFbApfZfKyGc7xsBPfY/Xx8wekwWiJ9ZMfW",
	"ixaZ0I15BeZW6MJJ224i9dVC3dyPgS76UXFjVl8LocwaSzTj14NP28VyacyUQmLjGyq4N74kDaDWhTSu",
	"T/FL31+5Ss7t9Ei+WoMSkxKp5QctvPwa2+htO3OagblDNPorayiEyJri6HZATyx3/XsQ+eCrUvGeknGd",
	"E5LAzjgld13K5kHfK0CryJ8aZyoKIfZu00yIcrl2TVnktKRdkCi0Oax6r6nDPEdgeTKqEO5AEw13pCcD",
	"PPLCbfCkahvXHfOoDqkPfoAkGw76mDzuwX7BtHEPCRF1kx9a4Ac7tW4JEkK6jYqPnWNocATVmRgLNFLe",
	"75boCLqNlCVHL0ONbdsdILRcxnZ6o7AnTF8b4x6UJgRyD7Iqq1LHWf3ECY4yhlO3CAgVTEeEO5xSMInh",
	"NQV6bdZHSagRwKN+O6W7BDzFmP+xFdcyspeEvRu6STiWiB7cl9WnWxPmLR3GeQ6yHUruyQlE28glZzCI",
	"jfvpdqq2Ld3wszBsmXPoKDz0onmftOuaEmsW0ai8fhEde+5WbNPZKpiwcVJP3G9xdtCQPc3B1bC3tyS1",
	"1wdfnSx2EvSxr5z7zE2g/ZY5371ybjZOFGfOIYmfAh/4l6U9cBNA3gIo5ZF/WRUjd8W69kEU7I/7ix+/",
	"u6yhdlCARccwdB9DgL+of7s7CSdzWeE9yHgxn0bibs5M5I/Ywlw/oVAaUlnnGzZyrS0y5Pexj0p0jNKS",
	"N6CJs3WIDAWde1lekl3ldnsLiDrJbtGcvQss+nEDW/BU+lCEGqqC0p6l3Q+MDTgrVMUKom1YK1WMr9Pl",
	"K9O3q9A5KofJvCRzmroImgmUFQGbpkKU602RoNhywgd00hFwouP+ESTO8w4kgKkMHaROCL1daBQEkeO5",
	"KXBS8AQStzAQ0p1L3kndPajW5+QtHs64xjOaNRrOujwzwwBuTvjtk9lyiUjP8ZCAFESZE0Rp4AMek6E7",
	"js7DDgQJsSg9N8obNmUxcQbgq/sGASrsxsBlvWJ6k+z320AyvI3laUqUU/Sl8GjQ4aoQkCAV6HAAUSUb",
	"qJM8Xvp+C2HcI0WYv9taIwZjl1x7lHUnbVFfupLaTKxy0yMLvC/rDCqOFuWG4csOfplfrh4+8IAH71Oe",
	"sB9xGlAXfamTf2p+EPkG6BwEg54pxBXzM2i20ZnlNEkSZtiphBCLHZxKOhJDNQaIpq+yHBpsbqSPVM0Q",
	"X+YO1yYI4fNwdRhzcKACePX5uFh870FiQ/8CDv4FXmiclH6Jrr6R36QAriEDvvP44njxfu+K7l6ieS+0",
	"3Ie/ghfneRd4O+cZOM9ulJVsjU2cCOb6Al70JvrgfqUuCmOx4m6hFJxEHUMPLtSfpIQg13GKj1F2IU0q",
	"rM3+cbNJQUa+NIh8nDzm7OJnZ+9GL06QgX0KtyD9EhzgwTWuIkYjXpwut7HgqlNZp3X54Lyt1WMpyQl5",
	"gNCJExK5dlzMz1dYtlNLAtEm+hX3DoZhDjd2JRly/xoTh96ZvsCTgpzGY7AS4ojZsZiIf31ZrD1peinf",
	"fuWuq73jboL27kHmvKXeS1sNlQZZC+VDW6ID30ED8LUNGvrUbeelxBbopM9eXuyA65N2H6Wm71d/K1r4",
	"y1raI7S2aCAvVh3f+stkSMmp5CSCflbrfRHgiwQEBq98mChBAU7QmQqaizrQbVV4FBdooC3N+3KXA5od",
	"N5IqUMWCKrQelPN9Xy9e9z5nmS1wWQ3H9TxwgDaeG/m0bTs5GVQ4mOE+3Lz96uZNnV5v3tB7Svm7ZLBG",
	"jpsewoBYksPMYlGv18oDkkYerCizPFtOX9hIMWhuXHVP5oDU5g9bMn9oIVNi7NdNymIsXMG3a+CpjaOA",
	"lpgLVLK9kfDTIGxi10yIqvs2oMZqP530+pqYJBsbmOhSJHnXytppGHSLYQw6tvCVteimUvJL06A7xM39",
	"YItrmiDyD3EQZRRyRPHuTZw493cf3xbdcOIN7WnC136HGLylI/UZLMqXO1wvF7pTtKcL2hjAfCw9ljdB",
	"6sVPIHmRHQ36P407Gu6TG6DMEDyvtK0LPIX+q6oV65/KtXHBNrIcBZmm+Z5G/m5xRYNAzEKcAw48VHLn",
	"A2peFpOL0Vns5Ama/aZ4Gq+6UZPaNTLLD4JgFLUDmWxxNjGN1elVRcpo+Pb51ELXnQiYRpMy/4bBa7Pl",
	"M4/ED80XxJM2jZ6o5ERws5qRnciiYzSIH9BpjtiY8izhdnJQ7Em4lyV6aSsryo1+vfjQMQ4E9xMPIzNa",
	"7uETndMOxgSBwC0l2zdmeu0rnFQcu7qRxcaU8vdldtVJqEYDougLcshpa1yRpMqyOISK/jrljiI18jQo",
	"ZrViMNg5R9spiMQ0mXFmmEd4yFOBEdWMyuK7RhPdKCigvWGJPymIFEzN/knmPEMhcqFozdaoQo1GBSr6",
	"L/mdu0W3XbvasngYyjMCE6UwbJfw8VNI2eLTp8495ODmakVzCK69SY0Go8laakb2+VPwSCx6dDbjs+iZ",
	"ZXEOERPUmVj0OXcMoYn0zX28PIG5H1QVqcz2nyBPC2nv/BwN/F3jcjRcQjH6jgbDWdoUS/wOS66TstWs",
	"pyPO/8oJgWvDNSSBMVpAm5VoPphlJ2s49p+Dpmo4TrkRo1wzGrIVt0l8PHRCLdAi8TCKKpdAF+/hOxa6",
	"6MIC5PRmCF0wVNcKrWCplsAVMqot4Irzp9qRaB10OOODK5hlcQ6RUNT08QopfxnVPfo4BdnkHKhQxyUm",
	"yLwiIjtDXAJ/17hwCbGKUYuAUoHQEpmwBDspU8wiE0JkoslgU4Em2jITg01YhrJW4gDYhJKVeAbgRM8W",
	"4h6kqbs1kCFMB1LOq/iAX7DwRBcuyI9vrrkVXLJrn11BhtPLr5gDJY9EGZHzGR9oUVoY5yApYZ1JngXD",
	"J/1mWlD+1itvwy4xBzHUAIxJMrOE4M4PxKBfNp4qNcyq2idY5BKi6nspgBiWaCdotFkoQ55kIeGoxlo7",
	"UobSADMsY1kbcjBIQ9WGnDaqIeftFmYjQ2apRtUcJAHKsoEd6ZXzwPxEW8ngMuS4XHmGOs2kmZsdpTej",
	"mXEMy5F3aDVoLcUcZEWC0t75Hwu6BNFxjzq7uUGIqjcF0fqQxNsEpClTbHmYFgLwkEsHOniNoCa6qNAs",
	"SyUSoIF2tEQuFHtauIIWJk5UDC7w6/W/4cv9klK5zBeRw04ckbLyWew8x8kXR1gyvrArGjWIrIb8d71R",
	"Eo+QHspck1Bv4vVftJYBvrr7QwjwOz64+PGH13+5vKAi7scLz42iOMMz1Cng0kmA6+2Aj5zUvfs12B/3",
	"jruPjxGix9cLBz74BEpkWFRDgisuV+HAi/id06QsX1OrEh0PcYw7CsQHUGYKY5XP+VskZ7mOKuP698BX",
	"xBWY12QQQn9cyhJs4PMNOfR7wyV52HlH43YrE4hqJoFc6HMd74kf9WJQcTvGwnIKh9+o8HnO6Cre74Os",
	"LOfBV+AdIemGzAagyAXfIHD26bYedkADT472utfVXpzONMjpNsRNioKsj5L6CquyxVg7leer8WRbw6Js",
	"TTwVIJxU0XDkDHlVqF9KB/633Mbuu+dGvVdQB1asmf38UpDcjbkYR1YVf22K4EXmZjq4BK1Ri94ritQK",
	"+r65WTqXor2VDdGq2gtfvY5c6EYJj+I9LpRM5snDhtKayehsG+o2fkQOlQPZAPrRW5DRKeLE+SM0QOJN",
	"Xrz90nl0vS/oH/ArQPIngcONuIoL45CRLi4vyFDwMTQWD825FCwXTlNbrryTrQYoTSbBcoY/V9HSG2Wg",
	"4xcChO7jj+GvBQ8pW83lxdcrHxxA5IPIQ9gyGuIVfQyP3q+5jElxjWWDnKP+fcBpb6IMJJEbOvdoExzC",
	"ncYaPqf4eEuNzODPQraNEwJX6JdC37mZc0wBIz7QYLgPI5TgaQbP/9IBr7avnL17SC+dNA3ZDvHpq1cC",
	"tkdDzUfw4p1rKXrRy9dbEIHEDTXOErpJezdyt8B3yNvoQGnhby7ejmd7jx/vvZA6WdbEaqkr73DBpJgP",
	"m6uru/l4lGiq4+KS2GT3xTXXa+c4WAX299UF03mMl2Bn6S72MpBdpVkC3H0/BdlV6ZhHxvU9qZZspwc6",
	"2ZrtupTLZQ8VCaiVySbiTmye+kH6RQhE8zhIaqfWDpksfD10AfjaQsYBOaudh0BsSnUeqQWF6ArKZegT",
	"KM3ELSc/kYOXaeGSNCxJsSYRPBEd3PrEuSpZmg1VnUpCxHHEJyyaEDVKympGs9IvwSEHlo02HZun3THt",
	"Dpe1fZ5yOpU2Y2vaLNAtbumy7d2Diqv2wT307qahr5i0d8ZupgmvjI6n3gSrdFqDtsPK18qY3hNrhtVA",
	"nDza/JB/9bl1x9KgxnYCq5WHla9B1bP64B6azJ/8DE/lSeULGJ8HVd9v054TdwaJxzS6A7Ueks7JmvSM",
	"8gnUPKJCK56Mek7pBTHas6kFZKfrFtP2O/LTPz9/g8Mummo7TcM1G3jT7at7f1uK29GFvJL7Hvf3tyt2",
	"0j5zzqofOM3Gu4J9buWVVAZr8DzKZ6WdAzUNDAi6O5VtmXIPYA2G4PJDZSeY2glGEy9br2QCaZandfaq",
	"xNxdMei0Qq4cmqpj1yRp5KQxMZuuycCqfh5xJMdlWgkWefK+0SICbOPpoosK6hRd8mxHQ9G/DWdhTeoC",
	"iiahyN3a6mhCW7jsxM5K7J3alV2c0nphHdATG1J0KfbuiqIDruWBNVtWSbYOkdmn52+zR4je13C4k+w2",
	"SLPeY37s500sP1Ntq1tGAqvjKbjdxYlpu90n9KOrH3rWjjRL6NyLg9XN6NOXbrsY6043udN19u0o97VC",
	"pTWO0vGoZUKkgTzOzKWufd8ofWrRKk9f90FMhm39ah3CrjnW4yBsGz2uedXadNJUVbA2oIZnPR/xd2au",
	"tbYx06t33Xo11sFWLlCo53Fp21rXNLdNxeaKUCbcCxZdKs6bwO56C0dRwvSSrA+pI0eBIDWz81WudJcD",
	"SB3mhW5hGETAiY77R5CgyjvQU0yyK2JL86aHb6zxG3rl7fqxHqeT8SI2DKYhEvhcSDgKEW0bg9MNQ7TH",
	"RAxAIlRh7OLaeZmrcZasCl9fhcyyJxHNodouz3iehPEpOGJyZi1huwg8EyJUpBcBiqejCIwTjFF70iBt",
	"vQhDFXQTANm2sbQcUfqCX3KacX2/ZJCebVWx099tqDCqjOu5pmPLata0VkevBa0fylURpTLk/GpTn7Ys",
	"tcIBM0Q2WFVqaRHKMy8x3aK6dJtWHqsOXTxsJevRVrJWKTbZX51qDb61Racbi07rF5xWE+cyDTyKY1sM",
	"JUyNNUZaTbMnkhrNSC2AE5SpPi25jqnmdPdy0wMTu8nQRc9VrfvdjMsJB0Z+WPxZ6YUl2mxqg/Vea5tn",
	"+hyAhwGt5krazhs3c5270I2As7y7cT4eQAT/Wx6DW1G7/ICJstZiI9OwP1j56Oq3FKWo2d9zNncNbV73",
	"EDx933Kbn75v3umPdI5z2vKn79V2Pf94uP1wQOAdkyB7QVrv0U0Db+0es93Fj//4DeocXHAY68RjEl78",
	"eLHLssOP19eLV+h/10/fo1B88be08sff8oX8TlXlcnWLXqI/etxGDx/cyN0G0ZYWnS6bFqnzR9d/ciMP",
	"+M4+9sGfCk38E6kszUxBfnX/HGTeLoi2n46hdEpap9p5DHQmDsqzrqDDWfpFeEwz5CPWqNp9FphQ+B7z",
	"HkSZeOKS9ihNmGS3NFui+NV9Fieldb0BXugmYOUesmMi3RhCuWllkcKVEQJOS7NtE3ef71Wl5/ndjeMe",
	"s9gnpXtLdX3p+3lZX2bQd6v3N8vDofQrhPIpHbPi17yj5cslY27D+NENVUd8j55mV/3zw8Pdage8L9Vf",
	"IiGQE271D2n1t0Q18174RORL9W83Ec6wqhDRbbx9FyfPbuJXfnuXxDjXo/TbBzeBgpv55Qc3CEGCozu1",
	"X6flXx1KP//i7gGteV789g7Uf66NfpfEUNyic+FSAdpkeGLEgCOm7SvnIXbcpzhAVJFmbpSRJ+Czz4A+",
	"HkROEGUgeXJDUtDbTZh+ro8hcJ53IPocobpB+KUrH4TuixOjJbxy/r4DKF6GjcosrnaDTZ296wNkZLLO",
	"gHNMQgfhjw422j5HudsAX9q4YQrgSoM0PQLHpeYfqi6Oh7hkXSRsIaKRb97A76L6x8F27Cvnf8dHx3Oj",
	"z1EGV3xM6fMpW9M8djy4o2g4jJZj89PNitFfOTeb8rcEqYNcJbheyNRJ4CPv7nOEXg5S1sYO9nvgB24G",
	"wpdXn6OCi7ARXKKcTyCNwwrdfMIl9hsVDaY4ZbF/XyNQ/Ju6tin9+QHsDyG6ilT+S+CBsoQTrDYNMpA6",
	"f0yD/SGsNhJGK3zl3KNHCF2mgY+CKS4GeXLZh+gTX3AIAd2D9HPkxVEEPOg0ZLETZM5T4FLxv6Y7FSeQ",
	"Gq7oj36QAASipqXjQcsofWbJUhH9oTBVSk/EoPrzQxkj5QQSSBFoN4hQngx9F7caYAbLAu9L7bTgLx+I",
	"/8H8FkfKmF89rOqC+2ElEsToL3w5XJvsIXE9kMqIoRxM4zmteVRtm8THA/BpghGLxyJGxwB6tgOfIxZT",
	"QWSSJW4Ojd99vH/AcsSjOQUed96X+OhEgFaJy0VVafh14BN5CJ9+hkIXyUPsqJWXeYmeySct4fV3vz6g",
	"JcE/kvk/R+hL3ZLDB+VODl8gqZSP6XI/Ay0+PtYWsw78y/JG7QF8I0j3cA7InIEXZOELGpxuAmqsQv2S",
	"CnpVYp0aaZPf/5qCBKWFffvt2/8NAAD//28rEt+TrAoA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
