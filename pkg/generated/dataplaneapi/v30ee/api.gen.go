// Package v30ee provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package v30ee

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Basic_authScopes = "basic_auth.Scopes"
)

// Defines values for ActionOperation.
const (
	ActionOperationRefreshVariables ActionOperation = "refresh_variables"
	ActionOperationReload           ActionOperation = "reload"
	ActionOperationRestart          ActionOperation = "restart"
	ActionOperationStart            ActionOperation = "start"
	ActionOperationStatus           ActionOperation = "status"
	ActionOperationStop             ActionOperation = "stop"
)

// Defines values for ActionService.
const (
	ActionServiceHaproxy    ActionService = "haproxy"
	ActionServiceKeepalived ActionService = "keepalived"
	ActionServiceSystem     ActionService = "system"
)

// Defines values for AlohaActionSuccess.
const (
	AlohaActionSuccessFailed     AlohaActionSuccess = "failed"
	AlohaActionSuccessSuccessful AlohaActionSuccess = "successful"
)

// Defines values for AlohaActionType.
const (
	AlohaActionTypePullConfig AlohaActionType = "pull_config"
	AlohaActionTypePushConfig AlohaActionType = "push_config"
)

// Defines values for AwsRegionIpv4Address.
const (
	AwsRegionIpv4AddressPrivate AwsRegionIpv4Address = "private"
	AwsRegionIpv4AddressPublic  AwsRegionIpv4Address = "public"
)

// Defines values for AwsRegionServerSlotsGrowthType.
const (
	AwsRegionServerSlotsGrowthTypeExponential AwsRegionServerSlotsGrowthType = "exponential"
	AwsRegionServerSlotsGrowthTypeLinear      AwsRegionServerSlotsGrowthType = "linear"
)

// Defines values for BackendAbortonclose.
const (
	BackendAbortoncloseDisabled BackendAbortonclose = "disabled"
	BackendAbortoncloseEnabled  BackendAbortonclose = "enabled"
)

// Defines values for BackendAcceptInvalidHttpResponse.
const (
	BackendAcceptInvalidHttpResponseDisabled BackendAcceptInvalidHttpResponse = "disabled"
	BackendAcceptInvalidHttpResponseEnabled  BackendAcceptInvalidHttpResponse = "enabled"
)

// Defines values for BackendAdvCheck.
const (
	BackendAdvCheckHttpchk     BackendAdvCheck = "httpchk"
	BackendAdvCheckLdapCheck   BackendAdvCheck = "ldap-check"
	BackendAdvCheckMysqlCheck  BackendAdvCheck = "mysql-check"
	BackendAdvCheckPgsqlCheck  BackendAdvCheck = "pgsql-check"
	BackendAdvCheckRedisCheck  BackendAdvCheck = "redis-check"
	BackendAdvCheckSmtpchk     BackendAdvCheck = "smtpchk"
	BackendAdvCheckSslHelloChk BackendAdvCheck = "ssl-hello-chk"
	BackendAdvCheckTcpCheck    BackendAdvCheck = "tcp-check"
)

// Defines values for BackendAllbackups.
const (
	BackendAllbackupsDisabled BackendAllbackups = "disabled"
	BackendAllbackupsEnabled  BackendAllbackups = "enabled"
)

// Defines values for BackendCheckcache.
const (
	BackendCheckcacheDisabled BackendCheckcache = "disabled"
	BackendCheckcacheEnabled  BackendCheckcache = "enabled"
)

// Defines values for BackendExternalCheck.
const (
	BackendExternalCheckDisabled BackendExternalCheck = "disabled"
	BackendExternalCheckEnabled  BackendExternalCheck = "enabled"
)

// Defines values for BackendForcePersistCond.
const (
	BackendForcePersistCondIf     BackendForcePersistCond = "if"
	BackendForcePersistCondUnless BackendForcePersistCond = "unless"
)

// Defines values for BackendForcePersistListCond.
const (
	BackendForcePersistListCondIf     BackendForcePersistListCond = "if"
	BackendForcePersistListCondUnless BackendForcePersistListCond = "unless"
)

// Defines values for BackendH1CaseAdjustBogusServer.
const (
	BackendH1CaseAdjustBogusServerDisabled BackendH1CaseAdjustBogusServer = "disabled"
	BackendH1CaseAdjustBogusServerEnabled  BackendH1CaseAdjustBogusServer = "enabled"
)

// Defines values for BackendHttpBufferRequest.
const (
	BackendHttpBufferRequestDisabled BackendHttpBufferRequest = "disabled"
	BackendHttpBufferRequestEnabled  BackendHttpBufferRequest = "enabled"
)

// Defines values for BackendHttpNoDelay.
const (
	BackendHttpNoDelayDisabled BackendHttpNoDelay = "disabled"
	BackendHttpNoDelayEnabled  BackendHttpNoDelay = "enabled"
)

// Defines values for BackendHttpUseHtx.
const (
	BackendHttpUseHtxDisabled BackendHttpUseHtx = "disabled"
	BackendHttpUseHtxEnabled  BackendHttpUseHtx = "enabled"
)

// Defines values for BackendHttpConnectionMode.
const (
	BackendHttpConnectionModeHttpKeepAlive   BackendHttpConnectionMode = "http-keep-alive"
	BackendHttpConnectionModeHttpServerClose BackendHttpConnectionMode = "http-server-close"
	BackendHttpConnectionModeHttpclose       BackendHttpConnectionMode = "httpclose"
)

// Defines values for BackendHttpPretendKeepalive.
const (
	BackendHttpPretendKeepaliveDisabled BackendHttpPretendKeepalive = "disabled"
	BackendHttpPretendKeepaliveEnabled  BackendHttpPretendKeepalive = "enabled"
)

// Defines values for BackendHttpProxy.
const (
	BackendHttpProxyDisabled BackendHttpProxy = "disabled"
	BackendHttpProxyEnabled  BackendHttpProxy = "enabled"
)

// Defines values for BackendHttpRestrictReqHdrNames.
const (
	BackendHttpRestrictReqHdrNamesDelete   BackendHttpRestrictReqHdrNames = "delete"
	BackendHttpRestrictReqHdrNamesPreserve BackendHttpRestrictReqHdrNames = "preserve"
	BackendHttpRestrictReqHdrNamesReject   BackendHttpRestrictReqHdrNames = "reject"
)

// Defines values for BackendHttpReuse.
const (
	BackendHttpReuseAggressive BackendHttpReuse = "aggressive"
	BackendHttpReuseAlways     BackendHttpReuse = "always"
	BackendHttpReuseNever      BackendHttpReuse = "never"
	BackendHttpReuseSafe       BackendHttpReuse = "safe"
)

// Defines values for BackendIgnorePersistCond.
const (
	BackendIgnorePersistCondIf     BackendIgnorePersistCond = "if"
	BackendIgnorePersistCondUnless BackendIgnorePersistCond = "unless"
)

// Defines values for BackendIgnorePersistListCond.
const (
	BackendIgnorePersistListCondIf     BackendIgnorePersistListCond = "if"
	BackendIgnorePersistListCondUnless BackendIgnorePersistListCond = "unless"
)

// Defines values for BackendIndependentStreams.
const (
	BackendIndependentStreamsDisabled BackendIndependentStreams = "disabled"
	BackendIndependentStreamsEnabled  BackendIndependentStreams = "enabled"
)

// Defines values for BackendLoadServerStateFromFile.
const (
	BackendLoadServerStateFromFileGlobal BackendLoadServerStateFromFile = "global"
	BackendLoadServerStateFromFileLocal  BackendLoadServerStateFromFile = "local"
	BackendLoadServerStateFromFileNone   BackendLoadServerStateFromFile = "none"
)

// Defines values for BackendLogHealthChecks.
const (
	BackendLogHealthChecksDisabled BackendLogHealthChecks = "disabled"
	BackendLogHealthChecksEnabled  BackendLogHealthChecks = "enabled"
)

// Defines values for BackendMode.
const (
	BackendModeHttp BackendMode = "http"
	BackendModeLog  BackendMode = "log"
	BackendModeTcp  BackendMode = "tcp"
)

// Defines values for BackendNolinger.
const (
	BackendNolingerDisabled BackendNolinger = "disabled"
	BackendNolingerEnabled  BackendNolinger = "enabled"
)

// Defines values for BackendPersist.
const (
	BackendPersistDisabled BackendPersist = "disabled"
	BackendPersistEnabled  BackendPersist = "enabled"
)

// Defines values for BackendPreferLastServer.
const (
	BackendPreferLastServerDisabled BackendPreferLastServer = "disabled"
	BackendPreferLastServerEnabled  BackendPreferLastServer = "enabled"
)

// Defines values for BackendSpliceAuto.
const (
	BackendSpliceAutoDisabled BackendSpliceAuto = "disabled"
	BackendSpliceAutoEnabled  BackendSpliceAuto = "enabled"
)

// Defines values for BackendSpliceRequest.
const (
	BackendSpliceRequestDisabled BackendSpliceRequest = "disabled"
	BackendSpliceRequestEnabled  BackendSpliceRequest = "enabled"
)

// Defines values for BackendSpliceResponse.
const (
	BackendSpliceResponseDisabled BackendSpliceResponse = "disabled"
	BackendSpliceResponseEnabled  BackendSpliceResponse = "enabled"
)

// Defines values for BackendSpopCheck.
const (
	BackendSpopCheckDisabled BackendSpopCheck = "disabled"
	BackendSpopCheckEnabled  BackendSpopCheck = "enabled"
)

// Defines values for BackendSrvtcpka.
const (
	BackendSrvtcpkaDisabled BackendSrvtcpka = "disabled"
	BackendSrvtcpkaEnabled  BackendSrvtcpka = "enabled"
)

// Defines values for BackendTcpSmartConnect.
const (
	BackendTcpSmartConnectDisabled BackendTcpSmartConnect = "disabled"
	BackendTcpSmartConnectEnabled  BackendTcpSmartConnect = "enabled"
)

// Defines values for BackendTcpka.
const (
	BackendTcpkaDisabled BackendTcpka = "disabled"
	BackendTcpkaEnabled  BackendTcpka = "enabled"
)

// Defines values for BackendTransparent.
const (
	BackendTransparentDisabled BackendTransparent = "disabled"
	BackendTransparentEnabled  BackendTransparent = "enabled"
)

// Defines values for BackendBaseAbortonclose.
const (
	BackendBaseAbortoncloseDisabled BackendBaseAbortonclose = "disabled"
	BackendBaseAbortoncloseEnabled  BackendBaseAbortonclose = "enabled"
)

// Defines values for BackendBaseAcceptInvalidHttpResponse.
const (
	BackendBaseAcceptInvalidHttpResponseDisabled BackendBaseAcceptInvalidHttpResponse = "disabled"
	BackendBaseAcceptInvalidHttpResponseEnabled  BackendBaseAcceptInvalidHttpResponse = "enabled"
)

// Defines values for BackendBaseAdvCheck.
const (
	BackendBaseAdvCheckHttpchk     BackendBaseAdvCheck = "httpchk"
	BackendBaseAdvCheckLdapCheck   BackendBaseAdvCheck = "ldap-check"
	BackendBaseAdvCheckMysqlCheck  BackendBaseAdvCheck = "mysql-check"
	BackendBaseAdvCheckPgsqlCheck  BackendBaseAdvCheck = "pgsql-check"
	BackendBaseAdvCheckRedisCheck  BackendBaseAdvCheck = "redis-check"
	BackendBaseAdvCheckSmtpchk     BackendBaseAdvCheck = "smtpchk"
	BackendBaseAdvCheckSslHelloChk BackendBaseAdvCheck = "ssl-hello-chk"
	BackendBaseAdvCheckTcpCheck    BackendBaseAdvCheck = "tcp-check"
)

// Defines values for BackendBaseAllbackups.
const (
	BackendBaseAllbackupsDisabled BackendBaseAllbackups = "disabled"
	BackendBaseAllbackupsEnabled  BackendBaseAllbackups = "enabled"
)

// Defines values for BackendBaseCheckcache.
const (
	BackendBaseCheckcacheDisabled BackendBaseCheckcache = "disabled"
	BackendBaseCheckcacheEnabled  BackendBaseCheckcache = "enabled"
)

// Defines values for BackendBaseExternalCheck.
const (
	BackendBaseExternalCheckDisabled BackendBaseExternalCheck = "disabled"
	BackendBaseExternalCheckEnabled  BackendBaseExternalCheck = "enabled"
)

// Defines values for BackendBaseForcePersistCond.
const (
	BackendBaseForcePersistCondIf     BackendBaseForcePersistCond = "if"
	BackendBaseForcePersistCondUnless BackendBaseForcePersistCond = "unless"
)

// Defines values for BackendBaseForcePersistListCond.
const (
	BackendBaseForcePersistListCondIf     BackendBaseForcePersistListCond = "if"
	BackendBaseForcePersistListCondUnless BackendBaseForcePersistListCond = "unless"
)

// Defines values for BackendBaseH1CaseAdjustBogusServer.
const (
	BackendBaseH1CaseAdjustBogusServerDisabled BackendBaseH1CaseAdjustBogusServer = "disabled"
	BackendBaseH1CaseAdjustBogusServerEnabled  BackendBaseH1CaseAdjustBogusServer = "enabled"
)

// Defines values for BackendBaseHttpBufferRequest.
const (
	BackendBaseHttpBufferRequestDisabled BackendBaseHttpBufferRequest = "disabled"
	BackendBaseHttpBufferRequestEnabled  BackendBaseHttpBufferRequest = "enabled"
)

// Defines values for BackendBaseHttpNoDelay.
const (
	BackendBaseHttpNoDelayDisabled BackendBaseHttpNoDelay = "disabled"
	BackendBaseHttpNoDelayEnabled  BackendBaseHttpNoDelay = "enabled"
)

// Defines values for BackendBaseHttpUseHtx.
const (
	BackendBaseHttpUseHtxDisabled BackendBaseHttpUseHtx = "disabled"
	BackendBaseHttpUseHtxEnabled  BackendBaseHttpUseHtx = "enabled"
)

// Defines values for BackendBaseHttpConnectionMode.
const (
	BackendBaseHttpConnectionModeHttpKeepAlive   BackendBaseHttpConnectionMode = "http-keep-alive"
	BackendBaseHttpConnectionModeHttpServerClose BackendBaseHttpConnectionMode = "http-server-close"
	BackendBaseHttpConnectionModeHttpclose       BackendBaseHttpConnectionMode = "httpclose"
)

// Defines values for BackendBaseHttpPretendKeepalive.
const (
	BackendBaseHttpPretendKeepaliveDisabled BackendBaseHttpPretendKeepalive = "disabled"
	BackendBaseHttpPretendKeepaliveEnabled  BackendBaseHttpPretendKeepalive = "enabled"
)

// Defines values for BackendBaseHttpProxy.
const (
	BackendBaseHttpProxyDisabled BackendBaseHttpProxy = "disabled"
	BackendBaseHttpProxyEnabled  BackendBaseHttpProxy = "enabled"
)

// Defines values for BackendBaseHttpRestrictReqHdrNames.
const (
	BackendBaseHttpRestrictReqHdrNamesDelete   BackendBaseHttpRestrictReqHdrNames = "delete"
	BackendBaseHttpRestrictReqHdrNamesPreserve BackendBaseHttpRestrictReqHdrNames = "preserve"
	BackendBaseHttpRestrictReqHdrNamesReject   BackendBaseHttpRestrictReqHdrNames = "reject"
)

// Defines values for BackendBaseHttpReuse.
const (
	BackendBaseHttpReuseAggressive BackendBaseHttpReuse = "aggressive"
	BackendBaseHttpReuseAlways     BackendBaseHttpReuse = "always"
	BackendBaseHttpReuseNever      BackendBaseHttpReuse = "never"
	BackendBaseHttpReuseSafe       BackendBaseHttpReuse = "safe"
)

// Defines values for BackendBaseIgnorePersistCond.
const (
	BackendBaseIgnorePersistCondIf     BackendBaseIgnorePersistCond = "if"
	BackendBaseIgnorePersistCondUnless BackendBaseIgnorePersistCond = "unless"
)

// Defines values for BackendBaseIgnorePersistListCond.
const (
	BackendBaseIgnorePersistListCondIf     BackendBaseIgnorePersistListCond = "if"
	BackendBaseIgnorePersistListCondUnless BackendBaseIgnorePersistListCond = "unless"
)

// Defines values for BackendBaseIndependentStreams.
const (
	BackendBaseIndependentStreamsDisabled BackendBaseIndependentStreams = "disabled"
	BackendBaseIndependentStreamsEnabled  BackendBaseIndependentStreams = "enabled"
)

// Defines values for BackendBaseLoadServerStateFromFile.
const (
	BackendBaseLoadServerStateFromFileGlobal BackendBaseLoadServerStateFromFile = "global"
	BackendBaseLoadServerStateFromFileLocal  BackendBaseLoadServerStateFromFile = "local"
	BackendBaseLoadServerStateFromFileNone   BackendBaseLoadServerStateFromFile = "none"
)

// Defines values for BackendBaseLogHealthChecks.
const (
	BackendBaseLogHealthChecksDisabled BackendBaseLogHealthChecks = "disabled"
	BackendBaseLogHealthChecksEnabled  BackendBaseLogHealthChecks = "enabled"
)

// Defines values for BackendBaseMode.
const (
	BackendBaseModeHttp BackendBaseMode = "http"
	BackendBaseModeLog  BackendBaseMode = "log"
	BackendBaseModeTcp  BackendBaseMode = "tcp"
)

// Defines values for BackendBaseNolinger.
const (
	BackendBaseNolingerDisabled BackendBaseNolinger = "disabled"
	BackendBaseNolingerEnabled  BackendBaseNolinger = "enabled"
)

// Defines values for BackendBasePersist.
const (
	BackendBasePersistDisabled BackendBasePersist = "disabled"
	BackendBasePersistEnabled  BackendBasePersist = "enabled"
)

// Defines values for BackendBasePreferLastServer.
const (
	BackendBasePreferLastServerDisabled BackendBasePreferLastServer = "disabled"
	BackendBasePreferLastServerEnabled  BackendBasePreferLastServer = "enabled"
)

// Defines values for BackendBaseSpliceAuto.
const (
	BackendBaseSpliceAutoDisabled BackendBaseSpliceAuto = "disabled"
	BackendBaseSpliceAutoEnabled  BackendBaseSpliceAuto = "enabled"
)

// Defines values for BackendBaseSpliceRequest.
const (
	BackendBaseSpliceRequestDisabled BackendBaseSpliceRequest = "disabled"
	BackendBaseSpliceRequestEnabled  BackendBaseSpliceRequest = "enabled"
)

// Defines values for BackendBaseSpliceResponse.
const (
	BackendBaseSpliceResponseDisabled BackendBaseSpliceResponse = "disabled"
	BackendBaseSpliceResponseEnabled  BackendBaseSpliceResponse = "enabled"
)

// Defines values for BackendBaseSpopCheck.
const (
	BackendBaseSpopCheckDisabled BackendBaseSpopCheck = "disabled"
	BackendBaseSpopCheckEnabled  BackendBaseSpopCheck = "enabled"
)

// Defines values for BackendBaseSrvtcpka.
const (
	BackendBaseSrvtcpkaDisabled BackendBaseSrvtcpka = "disabled"
	BackendBaseSrvtcpkaEnabled  BackendBaseSrvtcpka = "enabled"
)

// Defines values for BackendBaseTcpSmartConnect.
const (
	BackendBaseTcpSmartConnectDisabled BackendBaseTcpSmartConnect = "disabled"
	BackendBaseTcpSmartConnectEnabled  BackendBaseTcpSmartConnect = "enabled"
)

// Defines values for BackendBaseTcpka.
const (
	BackendBaseTcpkaDisabled BackendBaseTcpka = "disabled"
	BackendBaseTcpkaEnabled  BackendBaseTcpka = "enabled"
)

// Defines values for BackendBaseTransparent.
const (
	BackendBaseTransparentDisabled BackendBaseTransparent = "disabled"
	BackendBaseTransparentEnabled  BackendBaseTransparent = "enabled"
)

// Defines values for BackendSwitchingRuleCond.
const (
	BackendSwitchingRuleCondIf     BackendSwitchingRuleCond = "if"
	BackendSwitchingRuleCondUnless BackendSwitchingRuleCond = "unless"
)

// Defines values for BalanceAlgorithm.
const (
	BalanceAlgorithmFirst      BalanceAlgorithm = "first"
	BalanceAlgorithmHash       BalanceAlgorithm = "hash"
	BalanceAlgorithmHdr        BalanceAlgorithm = "hdr"
	BalanceAlgorithmLeastconn  BalanceAlgorithm = "leastconn"
	BalanceAlgorithmRandom     BalanceAlgorithm = "random"
	BalanceAlgorithmRdpCookie  BalanceAlgorithm = "rdp-cookie"
	BalanceAlgorithmRoundrobin BalanceAlgorithm = "roundrobin"
	BalanceAlgorithmSource     BalanceAlgorithm = "source"
	BalanceAlgorithmStaticRr   BalanceAlgorithm = "static-rr"
	BalanceAlgorithmUri        BalanceAlgorithm = "uri"
	BalanceAlgorithmUrlParam   BalanceAlgorithm = "url_param"
)

// Defines values for BindLevel.
const (
	BindLevelAdmin    BindLevel = "admin"
	BindLevelOperator BindLevel = "operator"
	BindLevelUser     BindLevel = "user"
)

// Defines values for BindQuicCcAlgo.
const (
	BindQuicCcAlgoCubic   BindQuicCcAlgo = "cubic"
	BindQuicCcAlgoNewreno BindQuicCcAlgo = "newreno"
)

// Defines values for BindQuicSocket.
const (
	BindQuicSocketConnection BindQuicSocket = "connection"
	BindQuicSocketListener   BindQuicSocket = "listener"
)

// Defines values for BindSeverityOutput.
const (
	BindSeverityOutputNone   BindSeverityOutput = "none"
	BindSeverityOutputNumber BindSeverityOutput = "number"
	BindSeverityOutputString BindSeverityOutput = "string"
)

// Defines values for BindSslMaxVer.
const (
	BindSslMaxVerSSLv3  BindSslMaxVer = "SSLv3"
	BindSslMaxVerTLSv10 BindSslMaxVer = "TLSv1.0"
	BindSslMaxVerTLSv11 BindSslMaxVer = "TLSv1.1"
	BindSslMaxVerTLSv12 BindSslMaxVer = "TLSv1.2"
	BindSslMaxVerTLSv13 BindSslMaxVer = "TLSv1.3"
)

// Defines values for BindSslMinVer.
const (
	BindSslMinVerSSLv3  BindSslMinVer = "SSLv3"
	BindSslMinVerTLSv10 BindSslMinVer = "TLSv1.0"
	BindSslMinVerTLSv11 BindSslMinVer = "TLSv1.1"
	BindSslMinVerTLSv12 BindSslMinVer = "TLSv1.2"
	BindSslMinVerTLSv13 BindSslMinVer = "TLSv1.3"
)

// Defines values for BindVerify.
const (
	BindVerifyNone     BindVerify = "none"
	BindVerifyOptional BindVerify = "optional"
	BindVerifyRequired BindVerify = "required"
)

// Defines values for BindParamsLevel.
const (
	BindParamsLevelAdmin    BindParamsLevel = "admin"
	BindParamsLevelOperator BindParamsLevel = "operator"
	BindParamsLevelUser     BindParamsLevel = "user"
)

// Defines values for BindParamsQuicCcAlgo.
const (
	BindParamsQuicCcAlgoCubic   BindParamsQuicCcAlgo = "cubic"
	BindParamsQuicCcAlgoNewreno BindParamsQuicCcAlgo = "newreno"
)

// Defines values for BindParamsQuicSocket.
const (
	BindParamsQuicSocketConnection BindParamsQuicSocket = "connection"
	BindParamsQuicSocketListener   BindParamsQuicSocket = "listener"
)

// Defines values for BindParamsSeverityOutput.
const (
	BindParamsSeverityOutputNone   BindParamsSeverityOutput = "none"
	BindParamsSeverityOutputNumber BindParamsSeverityOutput = "number"
	BindParamsSeverityOutputString BindParamsSeverityOutput = "string"
)

// Defines values for BindParamsSslMaxVer.
const (
	BindParamsSslMaxVerSSLv3  BindParamsSslMaxVer = "SSLv3"
	BindParamsSslMaxVerTLSv10 BindParamsSslMaxVer = "TLSv1.0"
	BindParamsSslMaxVerTLSv11 BindParamsSslMaxVer = "TLSv1.1"
	BindParamsSslMaxVerTLSv12 BindParamsSslMaxVer = "TLSv1.2"
	BindParamsSslMaxVerTLSv13 BindParamsSslMaxVer = "TLSv1.3"
)

// Defines values for BindParamsSslMinVer.
const (
	BindParamsSslMinVerSSLv3  BindParamsSslMinVer = "SSLv3"
	BindParamsSslMinVerTLSv10 BindParamsSslMinVer = "TLSv1.0"
	BindParamsSslMinVerTLSv11 BindParamsSslMinVer = "TLSv1.1"
	BindParamsSslMinVerTLSv12 BindParamsSslMinVer = "TLSv1.2"
	BindParamsSslMinVerTLSv13 BindParamsSslMinVer = "TLSv1.3"
)

// Defines values for BindParamsVerify.
const (
	BindParamsVerifyNone     BindParamsVerify = "none"
	BindParamsVerifyOptional BindParamsVerify = "optional"
	BindParamsVerifyRequired BindParamsVerify = "required"
)

// Defines values for BotmgmtProfileTrack.
const (
	BotmgmtProfileTrackDisable BotmgmtProfileTrack = "disable"
	BotmgmtProfileTrackEnable  BotmgmtProfileTrack = "enable"
	BotmgmtProfileTrackOff     BotmgmtProfileTrack = "off"
	BotmgmtProfileTrackOn      BotmgmtProfileTrack = "on"
)

// Defines values for CaptchaCustFormat.
const (
	CaptchaCustFormatJson   CaptchaCustFormat = "json"
	CaptchaCustFormatUrlEnc CaptchaCustFormat = "url-enc"
)

// Defines values for CaptchaCustScoreBased.
const (
	CaptchaCustScoreBasedDisabled CaptchaCustScoreBased = "disabled"
	CaptchaCustScoreBasedEnabled  CaptchaCustScoreBased = "enabled"
)

// Defines values for CaptchaIpCookie.
const (
	CaptchaIpCookieDisable CaptchaIpCookie = "disable"
	CaptchaIpCookieEnable  CaptchaIpCookie = "enable"
)

// Defines values for CaptchaScoreOnlyOnce.
const (
	CaptchaScoreOnlyOnceDisabled CaptchaScoreOnlyOnce = "disabled"
	CaptchaScoreOnlyOnceEnabled  CaptchaScoreOnlyOnce = "enabled"
)

// Defines values for CaptureType.
const (
	CaptureTypeRequest  CaptureType = "request"
	CaptureTypeResponse CaptureType = "response"
)

// Defines values for ClusterSettingsClusterLogTargetsProtocol.
const (
	ClusterSettingsClusterLogTargetsProtocolTcp ClusterSettingsClusterLogTargetsProtocol = "tcp"
	ClusterSettingsClusterLogTargetsProtocolUdp ClusterSettingsClusterLogTargetsProtocol = "udp"
)

// Defines values for ClusterSettingsMode.
const (
	ClusterSettingsModeCluster ClusterSettingsMode = "cluster"
	ClusterSettingsModeSingle  ClusterSettingsMode = "single"
)

// Defines values for ClusterSettingsStatus.
const (
	ClusterSettingsStatusActive          ClusterSettingsStatus = "active"
	ClusterSettingsStatusUnreachable     ClusterSettingsStatus = "unreachable"
	ClusterSettingsStatusWaitingApproval ClusterSettingsStatus = "waiting_approval"
)

// Defines values for CompressionAlgoReq.
const (
	CompressionAlgoReqDeflate    CompressionAlgoReq = "deflate"
	CompressionAlgoReqGzip       CompressionAlgoReq = "gzip"
	CompressionAlgoReqIdentity   CompressionAlgoReq = "identity"
	CompressionAlgoReqRawDeflate CompressionAlgoReq = "raw-deflate"
)

// Defines values for CompressionAlgorithms.
const (
	CompressionAlgorithmsDeflate    CompressionAlgorithms = "deflate"
	CompressionAlgorithmsGzip       CompressionAlgorithms = "gzip"
	CompressionAlgorithmsIdentity   CompressionAlgorithms = "identity"
	CompressionAlgorithmsRawDeflate CompressionAlgorithms = "raw-deflate"
)

// Defines values for CompressionAlgosRes.
const (
	CompressionAlgosResDeflate    CompressionAlgosRes = "deflate"
	CompressionAlgosResGzip       CompressionAlgosRes = "gzip"
	CompressionAlgosResIdentity   CompressionAlgosRes = "identity"
	CompressionAlgosResRawDeflate CompressionAlgosRes = "raw-deflate"
)

// Defines values for CompressionDirection.
const (
	CompressionDirectionBoth     CompressionDirection = "both"
	CompressionDirectionRequest  CompressionDirection = "request"
	CompressionDirectionResponse CompressionDirection = "response"
)

// Defines values for ConfigStickTableSrvkey.
const (
	ConfigStickTableSrvkeyAddr ConfigStickTableSrvkey = "addr"
	ConfigStickTableSrvkeyName ConfigStickTableSrvkey = "name"
)

// Defines values for ConfigStickTableType.
const (
	ConfigStickTableTypeBinary  ConfigStickTableType = "binary"
	ConfigStickTableTypeInteger ConfigStickTableType = "integer"
	ConfigStickTableTypeIp      ConfigStickTableType = "ip"
	ConfigStickTableTypeIpv6    ConfigStickTableType = "ipv6"
	ConfigStickTableTypeString  ConfigStickTableType = "string"
)

// Defines values for ConsulHealthCheckPolicy.
const (
	ConsulHealthCheckPolicyAll  ConsulHealthCheckPolicy = "all"
	ConsulHealthCheckPolicyAny  ConsulHealthCheckPolicy = "any"
	ConsulHealthCheckPolicyMin  ConsulHealthCheckPolicy = "min"
	ConsulHealthCheckPolicyNone ConsulHealthCheckPolicy = "none"
)

// Defines values for ConsulMode.
const (
	ConsulModeHttp  ConsulMode = "http"
	ConsulModeHttps ConsulMode = "https"
)

// Defines values for ConsulServerSlotsGrowthType.
const (
	ConsulServerSlotsGrowthTypeExponential ConsulServerSlotsGrowthType = "exponential"
	ConsulServerSlotsGrowthTypeLinear      ConsulServerSlotsGrowthType = "linear"
)

// Defines values for CookieType.
const (
	CookieTypeInsert  CookieType = "insert"
	CookieTypePrefix  CookieType = "prefix"
	CookieTypeRewrite CookieType = "rewrite"
)

// Defines values for CrtLoadOcspUpdate.
const (
	CrtLoadOcspUpdateDisabled CrtLoadOcspUpdate = "disabled"
	CrtLoadOcspUpdateEnabled  CrtLoadOcspUpdate = "enabled"
)

// Defines values for DefaultsAbortonclose.
const (
	DefaultsAbortoncloseDisabled DefaultsAbortonclose = "disabled"
	DefaultsAbortoncloseEnabled  DefaultsAbortonclose = "enabled"
)

// Defines values for DefaultsAcceptInvalidHttpRequest.
const (
	DefaultsAcceptInvalidHttpRequestDisabled DefaultsAcceptInvalidHttpRequest = "disabled"
	DefaultsAcceptInvalidHttpRequestEnabled  DefaultsAcceptInvalidHttpRequest = "enabled"
)

// Defines values for DefaultsAcceptInvalidHttpResponse.
const (
	DefaultsAcceptInvalidHttpResponseDisabled DefaultsAcceptInvalidHttpResponse = "disabled"
	DefaultsAcceptInvalidHttpResponseEnabled  DefaultsAcceptInvalidHttpResponse = "enabled"
)

// Defines values for DefaultsAdvCheck.
const (
	DefaultsAdvCheckHttpchk     DefaultsAdvCheck = "httpchk"
	DefaultsAdvCheckLdapCheck   DefaultsAdvCheck = "ldap-check"
	DefaultsAdvCheckMysqlCheck  DefaultsAdvCheck = "mysql-check"
	DefaultsAdvCheckPgsqlCheck  DefaultsAdvCheck = "pgsql-check"
	DefaultsAdvCheckRedisCheck  DefaultsAdvCheck = "redis-check"
	DefaultsAdvCheckSmtpchk     DefaultsAdvCheck = "smtpchk"
	DefaultsAdvCheckSslHelloChk DefaultsAdvCheck = "ssl-hello-chk"
	DefaultsAdvCheckTcpCheck    DefaultsAdvCheck = "tcp-check"
)

// Defines values for DefaultsAllbackups.
const (
	DefaultsAllbackupsDisabled DefaultsAllbackups = "disabled"
	DefaultsAllbackupsEnabled  DefaultsAllbackups = "enabled"
)

// Defines values for DefaultsCheckcache.
const (
	DefaultsCheckcacheDisabled DefaultsCheckcache = "disabled"
	DefaultsCheckcacheEnabled  DefaultsCheckcache = "enabled"
)

// Defines values for DefaultsClitcpka.
const (
	DefaultsClitcpkaDisabled DefaultsClitcpka = "disabled"
	DefaultsClitcpkaEnabled  DefaultsClitcpka = "enabled"
)

// Defines values for DefaultsContstats.
const (
	DefaultsContstatsEnabled DefaultsContstats = "enabled"
)

// Defines values for DefaultsDisableH2Upgrade.
const (
	DefaultsDisableH2UpgradeDisabled DefaultsDisableH2Upgrade = "disabled"
	DefaultsDisableH2UpgradeEnabled  DefaultsDisableH2Upgrade = "enabled"
)

// Defines values for DefaultsDontlogNormal.
const (
	DefaultsDontlogNormalDisabled DefaultsDontlogNormal = "disabled"
	DefaultsDontlogNormalEnabled  DefaultsDontlogNormal = "enabled"
)

// Defines values for DefaultsDontlognull.
const (
	DefaultsDontlognullDisabled DefaultsDontlognull = "disabled"
	DefaultsDontlognullEnabled  DefaultsDontlognull = "enabled"
)

// Defines values for DefaultsExternalCheck.
const (
	DefaultsExternalCheckDisabled DefaultsExternalCheck = "disabled"
	DefaultsExternalCheckEnabled  DefaultsExternalCheck = "enabled"
)

// Defines values for DefaultsH1CaseAdjustBogusClient.
const (
	DefaultsH1CaseAdjustBogusClientDisabled DefaultsH1CaseAdjustBogusClient = "disabled"
	DefaultsH1CaseAdjustBogusClientEnabled  DefaultsH1CaseAdjustBogusClient = "enabled"
)

// Defines values for DefaultsH1CaseAdjustBogusServer.
const (
	DefaultsH1CaseAdjustBogusServerDisabled DefaultsH1CaseAdjustBogusServer = "disabled"
	DefaultsH1CaseAdjustBogusServerEnabled  DefaultsH1CaseAdjustBogusServer = "enabled"
)

// Defines values for DefaultsHttpBufferRequest.
const (
	DefaultsHttpBufferRequestDisabled DefaultsHttpBufferRequest = "disabled"
	DefaultsHttpBufferRequestEnabled  DefaultsHttpBufferRequest = "enabled"
)

// Defines values for DefaultsHttpUseHtx.
const (
	DefaultsHttpUseHtxDisabled DefaultsHttpUseHtx = "disabled"
	DefaultsHttpUseHtxEnabled  DefaultsHttpUseHtx = "enabled"
)

// Defines values for DefaultsHttpConnectionMode.
const (
	DefaultsHttpConnectionModeHttpKeepAlive   DefaultsHttpConnectionMode = "http-keep-alive"
	DefaultsHttpConnectionModeHttpServerClose DefaultsHttpConnectionMode = "http-server-close"
	DefaultsHttpConnectionModeHttpclose       DefaultsHttpConnectionMode = "httpclose"
)

// Defines values for DefaultsHttpIgnoreProbes.
const (
	DefaultsHttpIgnoreProbesDisabled DefaultsHttpIgnoreProbes = "disabled"
	DefaultsHttpIgnoreProbesEnabled  DefaultsHttpIgnoreProbes = "enabled"
)

// Defines values for DefaultsHttpNoDelay.
const (
	DefaultsHttpNoDelayDisabled DefaultsHttpNoDelay = "disabled"
	DefaultsHttpNoDelayEnabled  DefaultsHttpNoDelay = "enabled"
)

// Defines values for DefaultsHttpPretendKeepalive.
const (
	DefaultsHttpPretendKeepaliveDisabled DefaultsHttpPretendKeepalive = "disabled"
	DefaultsHttpPretendKeepaliveEnabled  DefaultsHttpPretendKeepalive = "enabled"
)

// Defines values for DefaultsHttpRestrictReqHdrNames.
const (
	DefaultsHttpRestrictReqHdrNamesDelete   DefaultsHttpRestrictReqHdrNames = "delete"
	DefaultsHttpRestrictReqHdrNamesPreserve DefaultsHttpRestrictReqHdrNames = "preserve"
	DefaultsHttpRestrictReqHdrNamesReject   DefaultsHttpRestrictReqHdrNames = "reject"
)

// Defines values for DefaultsHttpReuse.
const (
	DefaultsHttpReuseAggressive DefaultsHttpReuse = "aggressive"
	DefaultsHttpReuseAlways     DefaultsHttpReuse = "always"
	DefaultsHttpReuseNever      DefaultsHttpReuse = "never"
	DefaultsHttpReuseSafe       DefaultsHttpReuse = "safe"
)

// Defines values for DefaultsHttpUseProxyHeader.
const (
	DefaultsHttpUseProxyHeaderDisabled DefaultsHttpUseProxyHeader = "disabled"
	DefaultsHttpUseProxyHeaderEnabled  DefaultsHttpUseProxyHeader = "enabled"
)

// Defines values for DefaultsHttpslog.
const (
	DefaultsHttpslogDisabled DefaultsHttpslog = "disabled"
	DefaultsHttpslogEnabled  DefaultsHttpslog = "enabled"
)

// Defines values for DefaultsIdleCloseOnResponse.
const (
	DefaultsIdleCloseOnResponseDisabled DefaultsIdleCloseOnResponse = "disabled"
	DefaultsIdleCloseOnResponseEnabled  DefaultsIdleCloseOnResponse = "enabled"
)

// Defines values for DefaultsIndependentStreams.
const (
	DefaultsIndependentStreamsDisabled DefaultsIndependentStreams = "disabled"
	DefaultsIndependentStreamsEnabled  DefaultsIndependentStreams = "enabled"
)

// Defines values for DefaultsLoadServerStateFromFile.
const (
	DefaultsLoadServerStateFromFileGlobal DefaultsLoadServerStateFromFile = "global"
	DefaultsLoadServerStateFromFileLocal  DefaultsLoadServerStateFromFile = "local"
	DefaultsLoadServerStateFromFileNone   DefaultsLoadServerStateFromFile = "none"
)

// Defines values for DefaultsLogHealthChecks.
const (
	DefaultsLogHealthChecksDisabled DefaultsLogHealthChecks = "disabled"
	DefaultsLogHealthChecksEnabled  DefaultsLogHealthChecks = "enabled"
)

// Defines values for DefaultsLogSeparateErrors.
const (
	DefaultsLogSeparateErrorsDisabled DefaultsLogSeparateErrors = "disabled"
	DefaultsLogSeparateErrorsEnabled  DefaultsLogSeparateErrors = "enabled"
)

// Defines values for DefaultsLogasap.
const (
	DefaultsLogasapDisabled DefaultsLogasap = "disabled"
	DefaultsLogasapEnabled  DefaultsLogasap = "enabled"
)

// Defines values for DefaultsMode.
const (
	DefaultsModeHttp DefaultsMode = "http"
	DefaultsModeLog  DefaultsMode = "log"
	DefaultsModeTcp  DefaultsMode = "tcp"
)

// Defines values for DefaultsNolinger.
const (
	DefaultsNolingerDisabled DefaultsNolinger = "disabled"
	DefaultsNolingerEnabled  DefaultsNolinger = "enabled"
)

// Defines values for DefaultsPersist.
const (
	DefaultsPersistDisabled DefaultsPersist = "disabled"
	DefaultsPersistEnabled  DefaultsPersist = "enabled"
)

// Defines values for DefaultsPreferLastServer.
const (
	DefaultsPreferLastServerDisabled DefaultsPreferLastServer = "disabled"
	DefaultsPreferLastServerEnabled  DefaultsPreferLastServer = "enabled"
)

// Defines values for DefaultsSocketStats.
const (
	DefaultsSocketStatsDisabled DefaultsSocketStats = "disabled"
	DefaultsSocketStatsEnabled  DefaultsSocketStats = "enabled"
)

// Defines values for DefaultsSpliceAuto.
const (
	DefaultsSpliceAutoDisabled DefaultsSpliceAuto = "disabled"
	DefaultsSpliceAutoEnabled  DefaultsSpliceAuto = "enabled"
)

// Defines values for DefaultsSpliceRequest.
const (
	DefaultsSpliceRequestDisabled DefaultsSpliceRequest = "disabled"
	DefaultsSpliceRequestEnabled  DefaultsSpliceRequest = "enabled"
)

// Defines values for DefaultsSpliceResponse.
const (
	DefaultsSpliceResponseDisabled DefaultsSpliceResponse = "disabled"
	DefaultsSpliceResponseEnabled  DefaultsSpliceResponse = "enabled"
)

// Defines values for DefaultsSrvtcpka.
const (
	DefaultsSrvtcpkaDisabled DefaultsSrvtcpka = "disabled"
	DefaultsSrvtcpkaEnabled  DefaultsSrvtcpka = "enabled"
)

// Defines values for DefaultsTcpSmartAccept.
const (
	DefaultsTcpSmartAcceptDisabled DefaultsTcpSmartAccept = "disabled"
	DefaultsTcpSmartAcceptEnabled  DefaultsTcpSmartAccept = "enabled"
)

// Defines values for DefaultsTcpSmartConnect.
const (
	DefaultsTcpSmartConnectDisabled DefaultsTcpSmartConnect = "disabled"
	DefaultsTcpSmartConnectEnabled  DefaultsTcpSmartConnect = "enabled"
)

// Defines values for DefaultsTcpka.
const (
	DefaultsTcpkaDisabled DefaultsTcpka = "disabled"
	DefaultsTcpkaEnabled  DefaultsTcpka = "enabled"
)

// Defines values for DefaultsTransparent.
const (
	DefaultsTransparentDisabled DefaultsTransparent = "disabled"
	DefaultsTransparentEnabled  DefaultsTransparent = "enabled"
)

// Defines values for DefaultsBaseAbortonclose.
const (
	DefaultsBaseAbortoncloseDisabled DefaultsBaseAbortonclose = "disabled"
	DefaultsBaseAbortoncloseEnabled  DefaultsBaseAbortonclose = "enabled"
)

// Defines values for DefaultsBaseAcceptInvalidHttpRequest.
const (
	DefaultsBaseAcceptInvalidHttpRequestDisabled DefaultsBaseAcceptInvalidHttpRequest = "disabled"
	DefaultsBaseAcceptInvalidHttpRequestEnabled  DefaultsBaseAcceptInvalidHttpRequest = "enabled"
)

// Defines values for DefaultsBaseAcceptInvalidHttpResponse.
const (
	DefaultsBaseAcceptInvalidHttpResponseDisabled DefaultsBaseAcceptInvalidHttpResponse = "disabled"
	DefaultsBaseAcceptInvalidHttpResponseEnabled  DefaultsBaseAcceptInvalidHttpResponse = "enabled"
)

// Defines values for DefaultsBaseAdvCheck.
const (
	DefaultsBaseAdvCheckHttpchk     DefaultsBaseAdvCheck = "httpchk"
	DefaultsBaseAdvCheckLdapCheck   DefaultsBaseAdvCheck = "ldap-check"
	DefaultsBaseAdvCheckMysqlCheck  DefaultsBaseAdvCheck = "mysql-check"
	DefaultsBaseAdvCheckPgsqlCheck  DefaultsBaseAdvCheck = "pgsql-check"
	DefaultsBaseAdvCheckRedisCheck  DefaultsBaseAdvCheck = "redis-check"
	DefaultsBaseAdvCheckSmtpchk     DefaultsBaseAdvCheck = "smtpchk"
	DefaultsBaseAdvCheckSslHelloChk DefaultsBaseAdvCheck = "ssl-hello-chk"
	DefaultsBaseAdvCheckTcpCheck    DefaultsBaseAdvCheck = "tcp-check"
)

// Defines values for DefaultsBaseAllbackups.
const (
	DefaultsBaseAllbackupsDisabled DefaultsBaseAllbackups = "disabled"
	DefaultsBaseAllbackupsEnabled  DefaultsBaseAllbackups = "enabled"
)

// Defines values for DefaultsBaseCheckcache.
const (
	DefaultsBaseCheckcacheDisabled DefaultsBaseCheckcache = "disabled"
	DefaultsBaseCheckcacheEnabled  DefaultsBaseCheckcache = "enabled"
)

// Defines values for DefaultsBaseClitcpka.
const (
	DefaultsBaseClitcpkaDisabled DefaultsBaseClitcpka = "disabled"
	DefaultsBaseClitcpkaEnabled  DefaultsBaseClitcpka = "enabled"
)

// Defines values for DefaultsBaseContstats.
const (
	DefaultsBaseContstatsEnabled DefaultsBaseContstats = "enabled"
)

// Defines values for DefaultsBaseDisableH2Upgrade.
const (
	DefaultsBaseDisableH2UpgradeDisabled DefaultsBaseDisableH2Upgrade = "disabled"
	DefaultsBaseDisableH2UpgradeEnabled  DefaultsBaseDisableH2Upgrade = "enabled"
)

// Defines values for DefaultsBaseDontlogNormal.
const (
	DefaultsBaseDontlogNormalDisabled DefaultsBaseDontlogNormal = "disabled"
	DefaultsBaseDontlogNormalEnabled  DefaultsBaseDontlogNormal = "enabled"
)

// Defines values for DefaultsBaseDontlognull.
const (
	DefaultsBaseDontlognullDisabled DefaultsBaseDontlognull = "disabled"
	DefaultsBaseDontlognullEnabled  DefaultsBaseDontlognull = "enabled"
)

// Defines values for DefaultsBaseExternalCheck.
const (
	DefaultsBaseExternalCheckDisabled DefaultsBaseExternalCheck = "disabled"
	DefaultsBaseExternalCheckEnabled  DefaultsBaseExternalCheck = "enabled"
)

// Defines values for DefaultsBaseH1CaseAdjustBogusClient.
const (
	DefaultsBaseH1CaseAdjustBogusClientDisabled DefaultsBaseH1CaseAdjustBogusClient = "disabled"
	DefaultsBaseH1CaseAdjustBogusClientEnabled  DefaultsBaseH1CaseAdjustBogusClient = "enabled"
)

// Defines values for DefaultsBaseH1CaseAdjustBogusServer.
const (
	DefaultsBaseH1CaseAdjustBogusServerDisabled DefaultsBaseH1CaseAdjustBogusServer = "disabled"
	DefaultsBaseH1CaseAdjustBogusServerEnabled  DefaultsBaseH1CaseAdjustBogusServer = "enabled"
)

// Defines values for DefaultsBaseHttpBufferRequest.
const (
	DefaultsBaseHttpBufferRequestDisabled DefaultsBaseHttpBufferRequest = "disabled"
	DefaultsBaseHttpBufferRequestEnabled  DefaultsBaseHttpBufferRequest = "enabled"
)

// Defines values for DefaultsBaseHttpUseHtx.
const (
	DefaultsBaseHttpUseHtxDisabled DefaultsBaseHttpUseHtx = "disabled"
	DefaultsBaseHttpUseHtxEnabled  DefaultsBaseHttpUseHtx = "enabled"
)

// Defines values for DefaultsBaseHttpConnectionMode.
const (
	DefaultsBaseHttpConnectionModeHttpKeepAlive   DefaultsBaseHttpConnectionMode = "http-keep-alive"
	DefaultsBaseHttpConnectionModeHttpServerClose DefaultsBaseHttpConnectionMode = "http-server-close"
	DefaultsBaseHttpConnectionModeHttpclose       DefaultsBaseHttpConnectionMode = "httpclose"
)

// Defines values for DefaultsBaseHttpIgnoreProbes.
const (
	DefaultsBaseHttpIgnoreProbesDisabled DefaultsBaseHttpIgnoreProbes = "disabled"
	DefaultsBaseHttpIgnoreProbesEnabled  DefaultsBaseHttpIgnoreProbes = "enabled"
)

// Defines values for DefaultsBaseHttpNoDelay.
const (
	DefaultsBaseHttpNoDelayDisabled DefaultsBaseHttpNoDelay = "disabled"
	DefaultsBaseHttpNoDelayEnabled  DefaultsBaseHttpNoDelay = "enabled"
)

// Defines values for DefaultsBaseHttpPretendKeepalive.
const (
	DefaultsBaseHttpPretendKeepaliveDisabled DefaultsBaseHttpPretendKeepalive = "disabled"
	DefaultsBaseHttpPretendKeepaliveEnabled  DefaultsBaseHttpPretendKeepalive = "enabled"
)

// Defines values for DefaultsBaseHttpRestrictReqHdrNames.
const (
	DefaultsBaseHttpRestrictReqHdrNamesDelete   DefaultsBaseHttpRestrictReqHdrNames = "delete"
	DefaultsBaseHttpRestrictReqHdrNamesPreserve DefaultsBaseHttpRestrictReqHdrNames = "preserve"
	DefaultsBaseHttpRestrictReqHdrNamesReject   DefaultsBaseHttpRestrictReqHdrNames = "reject"
)

// Defines values for DefaultsBaseHttpReuse.
const (
	DefaultsBaseHttpReuseAggressive DefaultsBaseHttpReuse = "aggressive"
	DefaultsBaseHttpReuseAlways     DefaultsBaseHttpReuse = "always"
	DefaultsBaseHttpReuseNever      DefaultsBaseHttpReuse = "never"
	DefaultsBaseHttpReuseSafe       DefaultsBaseHttpReuse = "safe"
)

// Defines values for DefaultsBaseHttpUseProxyHeader.
const (
	DefaultsBaseHttpUseProxyHeaderDisabled DefaultsBaseHttpUseProxyHeader = "disabled"
	DefaultsBaseHttpUseProxyHeaderEnabled  DefaultsBaseHttpUseProxyHeader = "enabled"
)

// Defines values for DefaultsBaseHttpslog.
const (
	DefaultsBaseHttpslogDisabled DefaultsBaseHttpslog = "disabled"
	DefaultsBaseHttpslogEnabled  DefaultsBaseHttpslog = "enabled"
)

// Defines values for DefaultsBaseIdleCloseOnResponse.
const (
	DefaultsBaseIdleCloseOnResponseDisabled DefaultsBaseIdleCloseOnResponse = "disabled"
	DefaultsBaseIdleCloseOnResponseEnabled  DefaultsBaseIdleCloseOnResponse = "enabled"
)

// Defines values for DefaultsBaseIndependentStreams.
const (
	DefaultsBaseIndependentStreamsDisabled DefaultsBaseIndependentStreams = "disabled"
	DefaultsBaseIndependentStreamsEnabled  DefaultsBaseIndependentStreams = "enabled"
)

// Defines values for DefaultsBaseLoadServerStateFromFile.
const (
	DefaultsBaseLoadServerStateFromFileGlobal DefaultsBaseLoadServerStateFromFile = "global"
	DefaultsBaseLoadServerStateFromFileLocal  DefaultsBaseLoadServerStateFromFile = "local"
	DefaultsBaseLoadServerStateFromFileNone   DefaultsBaseLoadServerStateFromFile = "none"
)

// Defines values for DefaultsBaseLogHealthChecks.
const (
	DefaultsBaseLogHealthChecksDisabled DefaultsBaseLogHealthChecks = "disabled"
	DefaultsBaseLogHealthChecksEnabled  DefaultsBaseLogHealthChecks = "enabled"
)

// Defines values for DefaultsBaseLogSeparateErrors.
const (
	DefaultsBaseLogSeparateErrorsDisabled DefaultsBaseLogSeparateErrors = "disabled"
	DefaultsBaseLogSeparateErrorsEnabled  DefaultsBaseLogSeparateErrors = "enabled"
)

// Defines values for DefaultsBaseLogasap.
const (
	DefaultsBaseLogasapDisabled DefaultsBaseLogasap = "disabled"
	DefaultsBaseLogasapEnabled  DefaultsBaseLogasap = "enabled"
)

// Defines values for DefaultsBaseMode.
const (
	DefaultsBaseModeHttp DefaultsBaseMode = "http"
	DefaultsBaseModeLog  DefaultsBaseMode = "log"
	DefaultsBaseModeTcp  DefaultsBaseMode = "tcp"
)

// Defines values for DefaultsBaseNolinger.
const (
	DefaultsBaseNolingerDisabled DefaultsBaseNolinger = "disabled"
	DefaultsBaseNolingerEnabled  DefaultsBaseNolinger = "enabled"
)

// Defines values for DefaultsBasePersist.
const (
	DefaultsBasePersistDisabled DefaultsBasePersist = "disabled"
	DefaultsBasePersistEnabled  DefaultsBasePersist = "enabled"
)

// Defines values for DefaultsBasePreferLastServer.
const (
	DefaultsBasePreferLastServerDisabled DefaultsBasePreferLastServer = "disabled"
	DefaultsBasePreferLastServerEnabled  DefaultsBasePreferLastServer = "enabled"
)

// Defines values for DefaultsBaseSocketStats.
const (
	DefaultsBaseSocketStatsDisabled DefaultsBaseSocketStats = "disabled"
	DefaultsBaseSocketStatsEnabled  DefaultsBaseSocketStats = "enabled"
)

// Defines values for DefaultsBaseSpliceAuto.
const (
	DefaultsBaseSpliceAutoDisabled DefaultsBaseSpliceAuto = "disabled"
	DefaultsBaseSpliceAutoEnabled  DefaultsBaseSpliceAuto = "enabled"
)

// Defines values for DefaultsBaseSpliceRequest.
const (
	DefaultsBaseSpliceRequestDisabled DefaultsBaseSpliceRequest = "disabled"
	DefaultsBaseSpliceRequestEnabled  DefaultsBaseSpliceRequest = "enabled"
)

// Defines values for DefaultsBaseSpliceResponse.
const (
	DefaultsBaseSpliceResponseDisabled DefaultsBaseSpliceResponse = "disabled"
	DefaultsBaseSpliceResponseEnabled  DefaultsBaseSpliceResponse = "enabled"
)

// Defines values for DefaultsBaseSrvtcpka.
const (
	DefaultsBaseSrvtcpkaDisabled DefaultsBaseSrvtcpka = "disabled"
	DefaultsBaseSrvtcpkaEnabled  DefaultsBaseSrvtcpka = "enabled"
)

// Defines values for DefaultsBaseTcpSmartAccept.
const (
	DefaultsBaseTcpSmartAcceptDisabled DefaultsBaseTcpSmartAccept = "disabled"
	DefaultsBaseTcpSmartAcceptEnabled  DefaultsBaseTcpSmartAccept = "enabled"
)

// Defines values for DefaultsBaseTcpSmartConnect.
const (
	DefaultsBaseTcpSmartConnectDisabled DefaultsBaseTcpSmartConnect = "disabled"
	DefaultsBaseTcpSmartConnectEnabled  DefaultsBaseTcpSmartConnect = "enabled"
)

// Defines values for DefaultsBaseTcpka.
const (
	DefaultsBaseTcpkaDisabled DefaultsBaseTcpka = "disabled"
	DefaultsBaseTcpkaEnabled  DefaultsBaseTcpka = "enabled"
)

// Defines values for DefaultsBaseTransparent.
const (
	DefaultsBaseTransparentDisabled DefaultsBaseTransparent = "disabled"
	DefaultsBaseTransparentEnabled  DefaultsBaseTransparent = "enabled"
)

// Defines values for DynamicUpdateRuleAgentCheck.
const (
	DynamicUpdateRuleAgentCheckDisabled DynamicUpdateRuleAgentCheck = "disabled"
	DynamicUpdateRuleAgentCheckEnabled  DynamicUpdateRuleAgentCheck = "enabled"
)

// Defines values for DynamicUpdateRuleBackup.
const (
	DynamicUpdateRuleBackupDisabled DynamicUpdateRuleBackup = "disabled"
	DynamicUpdateRuleBackupEnabled  DynamicUpdateRuleBackup = "enabled"
)

// Defines values for DynamicUpdateRuleCheck.
const (
	DynamicUpdateRuleCheckDisabled DynamicUpdateRuleCheck = "disabled"
	DynamicUpdateRuleCheckEnabled  DynamicUpdateRuleCheck = "enabled"
)

// Defines values for DynamicUpdateRuleCheckSendProxy.
const (
	DynamicUpdateRuleCheckSendProxyDisabled DynamicUpdateRuleCheckSendProxy = "disabled"
	DynamicUpdateRuleCheckSendProxyEnabled  DynamicUpdateRuleCheckSendProxy = "enabled"
)

// Defines values for DynamicUpdateRuleCheckSsl.
const (
	DynamicUpdateRuleCheckSslDisabled DynamicUpdateRuleCheckSsl = "disabled"
	DynamicUpdateRuleCheckSslEnabled  DynamicUpdateRuleCheckSsl = "enabled"
)

// Defines values for DynamicUpdateRuleCheckViaSocks4.
const (
	DynamicUpdateRuleCheckViaSocks4Disabled DynamicUpdateRuleCheckViaSocks4 = "disabled"
	DynamicUpdateRuleCheckViaSocks4Enabled  DynamicUpdateRuleCheckViaSocks4 = "enabled"
)

// Defines values for DynamicUpdateRuleForceSslv3.
const (
	DynamicUpdateRuleForceSslv3Disabled DynamicUpdateRuleForceSslv3 = "disabled"
	DynamicUpdateRuleForceSslv3Enabled  DynamicUpdateRuleForceSslv3 = "enabled"
)

// Defines values for DynamicUpdateRuleForceTlsv10.
const (
	DynamicUpdateRuleForceTlsv10Disabled DynamicUpdateRuleForceTlsv10 = "disabled"
	DynamicUpdateRuleForceTlsv10Enabled  DynamicUpdateRuleForceTlsv10 = "enabled"
)

// Defines values for DynamicUpdateRuleForceTlsv11.
const (
	DynamicUpdateRuleForceTlsv11Disabled DynamicUpdateRuleForceTlsv11 = "disabled"
	DynamicUpdateRuleForceTlsv11Enabled  DynamicUpdateRuleForceTlsv11 = "enabled"
)

// Defines values for DynamicUpdateRuleForceTlsv12.
const (
	DynamicUpdateRuleForceTlsv12Disabled DynamicUpdateRuleForceTlsv12 = "disabled"
	DynamicUpdateRuleForceTlsv12Enabled  DynamicUpdateRuleForceTlsv12 = "enabled"
)

// Defines values for DynamicUpdateRuleForceTlsv13.
const (
	DynamicUpdateRuleForceTlsv13Disabled DynamicUpdateRuleForceTlsv13 = "disabled"
	DynamicUpdateRuleForceTlsv13Enabled  DynamicUpdateRuleForceTlsv13 = "enabled"
)

// Defines values for DynamicUpdateRuleLogProto.
const (
	DynamicUpdateRuleLogProtoLegacy     DynamicUpdateRuleLogProto = "legacy"
	DynamicUpdateRuleLogProtoOctetCount DynamicUpdateRuleLogProto = "octet-count"
)

// Defines values for DynamicUpdateRuleMaintenance.
const (
	DynamicUpdateRuleMaintenanceDisabled DynamicUpdateRuleMaintenance = "disabled"
	DynamicUpdateRuleMaintenanceEnabled  DynamicUpdateRuleMaintenance = "enabled"
)

// Defines values for DynamicUpdateRuleNoSslv3.
const (
	DynamicUpdateRuleNoSslv3Disabled DynamicUpdateRuleNoSslv3 = "disabled"
	DynamicUpdateRuleNoSslv3Enabled  DynamicUpdateRuleNoSslv3 = "enabled"
)

// Defines values for DynamicUpdateRuleNoTlsv10.
const (
	DynamicUpdateRuleNoTlsv10Disabled DynamicUpdateRuleNoTlsv10 = "disabled"
	DynamicUpdateRuleNoTlsv10Enabled  DynamicUpdateRuleNoTlsv10 = "enabled"
)

// Defines values for DynamicUpdateRuleNoTlsv11.
const (
	DynamicUpdateRuleNoTlsv11Disabled DynamicUpdateRuleNoTlsv11 = "disabled"
	DynamicUpdateRuleNoTlsv11Enabled  DynamicUpdateRuleNoTlsv11 = "enabled"
)

// Defines values for DynamicUpdateRuleNoTlsv12.
const (
	DynamicUpdateRuleNoTlsv12Disabled DynamicUpdateRuleNoTlsv12 = "disabled"
	DynamicUpdateRuleNoTlsv12Enabled  DynamicUpdateRuleNoTlsv12 = "enabled"
)

// Defines values for DynamicUpdateRuleNoTlsv13.
const (
	DynamicUpdateRuleNoTlsv13Disabled DynamicUpdateRuleNoTlsv13 = "disabled"
	DynamicUpdateRuleNoTlsv13Enabled  DynamicUpdateRuleNoTlsv13 = "enabled"
)

// Defines values for DynamicUpdateRuleNoVerifyhost.
const (
	DynamicUpdateRuleNoVerifyhostDisabled DynamicUpdateRuleNoVerifyhost = "disabled"
	DynamicUpdateRuleNoVerifyhostEnabled  DynamicUpdateRuleNoVerifyhost = "enabled"
)

// Defines values for DynamicUpdateRuleObserve.
const (
	DynamicUpdateRuleObserveLayer4 DynamicUpdateRuleObserve = "layer4"
	DynamicUpdateRuleObserveLayer7 DynamicUpdateRuleObserve = "layer7"
)

// Defines values for DynamicUpdateRuleOnError.
const (
	DynamicUpdateRuleOnErrorFailCheck   DynamicUpdateRuleOnError = "fail-check"
	DynamicUpdateRuleOnErrorFastinter   DynamicUpdateRuleOnError = "fastinter"
	DynamicUpdateRuleOnErrorMarkDown    DynamicUpdateRuleOnError = "mark-down"
	DynamicUpdateRuleOnErrorSuddenDeath DynamicUpdateRuleOnError = "sudden-death"
)

// Defines values for DynamicUpdateRuleOnMarkedDown.
const (
	DynamicUpdateRuleOnMarkedDownShutdownSessions DynamicUpdateRuleOnMarkedDown = "shutdown-sessions"
)

// Defines values for DynamicUpdateRuleOnMarkedUp.
const (
	DynamicUpdateRuleOnMarkedUpShutdownBackupSessions DynamicUpdateRuleOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for DynamicUpdateRuleProxyV2Options.
const (
	DynamicUpdateRuleProxyV2OptionsAuthority DynamicUpdateRuleProxyV2Options = "authority"
	DynamicUpdateRuleProxyV2OptionsCertCn    DynamicUpdateRuleProxyV2Options = "cert-cn"
	DynamicUpdateRuleProxyV2OptionsCertKey   DynamicUpdateRuleProxyV2Options = "cert-key"
	DynamicUpdateRuleProxyV2OptionsCertSig   DynamicUpdateRuleProxyV2Options = "cert-sig"
	DynamicUpdateRuleProxyV2OptionsCrc32c    DynamicUpdateRuleProxyV2Options = "crc32c"
	DynamicUpdateRuleProxyV2OptionsSsl       DynamicUpdateRuleProxyV2Options = "ssl"
	DynamicUpdateRuleProxyV2OptionsSslCipher DynamicUpdateRuleProxyV2Options = "ssl-cipher"
	DynamicUpdateRuleProxyV2OptionsUniqueId  DynamicUpdateRuleProxyV2Options = "unique-id"
)

// Defines values for DynamicUpdateRuleResolvePrefer.
const (
	DynamicUpdateRuleResolvePreferIpv4 DynamicUpdateRuleResolvePrefer = "ipv4"
	DynamicUpdateRuleResolvePreferIpv6 DynamicUpdateRuleResolvePrefer = "ipv6"
)

// Defines values for DynamicUpdateRuleSendProxy.
const (
	DynamicUpdateRuleSendProxyDisabled DynamicUpdateRuleSendProxy = "disabled"
	DynamicUpdateRuleSendProxyEnabled  DynamicUpdateRuleSendProxy = "enabled"
)

// Defines values for DynamicUpdateRuleSendProxyV2.
const (
	DynamicUpdateRuleSendProxyV2Disabled DynamicUpdateRuleSendProxyV2 = "disabled"
	DynamicUpdateRuleSendProxyV2Enabled  DynamicUpdateRuleSendProxyV2 = "enabled"
)

// Defines values for DynamicUpdateRuleSendProxyV2Ssl.
const (
	DynamicUpdateRuleSendProxyV2SslDisabled DynamicUpdateRuleSendProxyV2Ssl = "disabled"
	DynamicUpdateRuleSendProxyV2SslEnabled  DynamicUpdateRuleSendProxyV2Ssl = "enabled"
)

// Defines values for DynamicUpdateRuleSendProxyV2SslCn.
const (
	DynamicUpdateRuleSendProxyV2SslCnDisabled DynamicUpdateRuleSendProxyV2SslCn = "disabled"
	DynamicUpdateRuleSendProxyV2SslCnEnabled  DynamicUpdateRuleSendProxyV2SslCn = "enabled"
)

// Defines values for DynamicUpdateRuleSsl.
const (
	DynamicUpdateRuleSslDisabled DynamicUpdateRuleSsl = "disabled"
	DynamicUpdateRuleSslEnabled  DynamicUpdateRuleSsl = "enabled"
)

// Defines values for DynamicUpdateRuleSslMaxVer.
const (
	DynamicUpdateRuleSslMaxVerSSLv3  DynamicUpdateRuleSslMaxVer = "SSLv3"
	DynamicUpdateRuleSslMaxVerTLSv10 DynamicUpdateRuleSslMaxVer = "TLSv1.0"
	DynamicUpdateRuleSslMaxVerTLSv11 DynamicUpdateRuleSslMaxVer = "TLSv1.1"
	DynamicUpdateRuleSslMaxVerTLSv12 DynamicUpdateRuleSslMaxVer = "TLSv1.2"
	DynamicUpdateRuleSslMaxVerTLSv13 DynamicUpdateRuleSslMaxVer = "TLSv1.3"
)

// Defines values for DynamicUpdateRuleSslMinVer.
const (
	DynamicUpdateRuleSslMinVerSSLv3  DynamicUpdateRuleSslMinVer = "SSLv3"
	DynamicUpdateRuleSslMinVerTLSv10 DynamicUpdateRuleSslMinVer = "TLSv1.0"
	DynamicUpdateRuleSslMinVerTLSv11 DynamicUpdateRuleSslMinVer = "TLSv1.1"
	DynamicUpdateRuleSslMinVerTLSv12 DynamicUpdateRuleSslMinVer = "TLSv1.2"
	DynamicUpdateRuleSslMinVerTLSv13 DynamicUpdateRuleSslMinVer = "TLSv1.3"
)

// Defines values for DynamicUpdateRuleSslReuse.
const (
	DynamicUpdateRuleSslReuseDisabled DynamicUpdateRuleSslReuse = "disabled"
	DynamicUpdateRuleSslReuseEnabled  DynamicUpdateRuleSslReuse = "enabled"
)

// Defines values for DynamicUpdateRuleStick.
const (
	DynamicUpdateRuleStickDisabled DynamicUpdateRuleStick = "disabled"
	DynamicUpdateRuleStickEnabled  DynamicUpdateRuleStick = "enabled"
)

// Defines values for DynamicUpdateRuleTfo.
const (
	DynamicUpdateRuleTfoDisabled DynamicUpdateRuleTfo = "disabled"
	DynamicUpdateRuleTfoEnabled  DynamicUpdateRuleTfo = "enabled"
)

// Defines values for DynamicUpdateRuleTlsTickets.
const (
	DynamicUpdateRuleTlsTicketsDisabled DynamicUpdateRuleTlsTickets = "disabled"
	DynamicUpdateRuleTlsTicketsEnabled  DynamicUpdateRuleTlsTickets = "enabled"
)

// Defines values for DynamicUpdateRuleVerify.
const (
	DynamicUpdateRuleVerifyNone     DynamicUpdateRuleVerify = "none"
	DynamicUpdateRuleVerifyRequired DynamicUpdateRuleVerify = "required"
)

// Defines values for DynamicUpdateRuleWs.
const (
	DynamicUpdateRuleWsAuto DynamicUpdateRuleWs = "auto"
	DynamicUpdateRuleWsH1   DynamicUpdateRuleWs = "h1"
	DynamicUpdateRuleWsH2   DynamicUpdateRuleWs = "h2"
)

// Defines values for EmailAlertLevel.
const (
	EmailAlertLevelAlert   EmailAlertLevel = "alert"
	EmailAlertLevelCrit    EmailAlertLevel = "crit"
	EmailAlertLevelDebug   EmailAlertLevel = "debug"
	EmailAlertLevelEmerg   EmailAlertLevel = "emerg"
	EmailAlertLevelErr     EmailAlertLevel = "err"
	EmailAlertLevelInfo    EmailAlertLevel = "info"
	EmailAlertLevelNotice  EmailAlertLevel = "notice"
	EmailAlertLevelWarning EmailAlertLevel = "warning"
)

// Defines values for ErrorfileCode.
const (
	ErrorfileCodeN200 ErrorfileCode = 200
	ErrorfileCodeN400 ErrorfileCode = 400
	ErrorfileCodeN401 ErrorfileCode = 401
	ErrorfileCodeN403 ErrorfileCode = 403
	ErrorfileCodeN404 ErrorfileCode = 404
	ErrorfileCodeN405 ErrorfileCode = 405
	ErrorfileCodeN407 ErrorfileCode = 407
	ErrorfileCodeN408 ErrorfileCode = 408
	ErrorfileCodeN410 ErrorfileCode = 410
	ErrorfileCodeN413 ErrorfileCode = 413
	ErrorfileCodeN425 ErrorfileCode = 425
	ErrorfileCodeN429 ErrorfileCode = 429
	ErrorfileCodeN500 ErrorfileCode = 500
	ErrorfileCodeN501 ErrorfileCode = 501
	ErrorfileCodeN502 ErrorfileCode = 502
	ErrorfileCodeN503 ErrorfileCode = 503
	ErrorfileCodeN504 ErrorfileCode = 504
)

// Defines values for ErrorfilesCodes.
const (
	ErrorfilesCodesN200 ErrorfilesCodes = 200
	ErrorfilesCodesN400 ErrorfilesCodes = 400
	ErrorfilesCodesN401 ErrorfilesCodes = 401
	ErrorfilesCodesN403 ErrorfilesCodes = 403
	ErrorfilesCodesN404 ErrorfilesCodes = 404
	ErrorfilesCodesN405 ErrorfilesCodes = 405
	ErrorfilesCodesN407 ErrorfilesCodes = 407
	ErrorfilesCodesN408 ErrorfilesCodes = 408
	ErrorfilesCodesN410 ErrorfilesCodes = 410
	ErrorfilesCodesN413 ErrorfilesCodes = 413
	ErrorfilesCodesN425 ErrorfilesCodes = 425
	ErrorfilesCodesN429 ErrorfilesCodes = 429
	ErrorfilesCodesN500 ErrorfilesCodes = 500
	ErrorfilesCodesN501 ErrorfilesCodes = 501
	ErrorfilesCodesN502 ErrorfilesCodes = 502
	ErrorfilesCodesN503 ErrorfilesCodes = 503
	ErrorfilesCodesN504 ErrorfilesCodes = 504
)

// Defines values for ErrorlocCode.
const (
	ErrorlocCodeN200 ErrorlocCode = 200
	ErrorlocCodeN400 ErrorlocCode = 400
	ErrorlocCodeN401 ErrorlocCode = 401
	ErrorlocCodeN403 ErrorlocCode = 403
	ErrorlocCodeN404 ErrorlocCode = 404
	ErrorlocCodeN405 ErrorlocCode = 405
	ErrorlocCodeN407 ErrorlocCode = 407
	ErrorlocCodeN408 ErrorlocCode = 408
	ErrorlocCodeN410 ErrorlocCode = 410
	ErrorlocCodeN413 ErrorlocCode = 413
	ErrorlocCodeN425 ErrorlocCode = 425
	ErrorlocCodeN429 ErrorlocCode = 429
	ErrorlocCodeN500 ErrorlocCode = 500
	ErrorlocCodeN501 ErrorlocCode = 501
	ErrorlocCodeN502 ErrorlocCode = 502
	ErrorlocCodeN503 ErrorlocCode = 503
	ErrorlocCodeN504 ErrorlocCode = 504
)

// Defines values for FcgiAppGetValues.
const (
	FcgiAppGetValuesDisabled FcgiAppGetValues = "disabled"
	FcgiAppGetValuesEnabled  FcgiAppGetValues = "enabled"
)

// Defines values for FcgiAppKeepConn.
const (
	FcgiAppKeepConnDisabled FcgiAppKeepConn = "disabled"
	FcgiAppKeepConnEnabled  FcgiAppKeepConn = "enabled"
)

// Defines values for FcgiAppMpxsConns.
const (
	FcgiAppMpxsConnsDisabled FcgiAppMpxsConns = "disabled"
	FcgiAppMpxsConnsEnabled  FcgiAppMpxsConns = "enabled"
)

// Defines values for FcgiAppBaseGetValues.
const (
	FcgiAppBaseGetValuesDisabled FcgiAppBaseGetValues = "disabled"
	FcgiAppBaseGetValuesEnabled  FcgiAppBaseGetValues = "enabled"
)

// Defines values for FcgiAppBaseKeepConn.
const (
	FcgiAppBaseKeepConnDisabled FcgiAppBaseKeepConn = "disabled"
	FcgiAppBaseKeepConnEnabled  FcgiAppBaseKeepConn = "enabled"
)

// Defines values for FcgiAppBaseMpxsConns.
const (
	FcgiAppBaseMpxsConnsDisabled FcgiAppBaseMpxsConns = "disabled"
	FcgiAppBaseMpxsConnsEnabled  FcgiAppBaseMpxsConns = "enabled"
)

// Defines values for FcgiPassHeaderCond.
const (
	FcgiPassHeaderCondIf     FcgiPassHeaderCond = "if"
	FcgiPassHeaderCondUnless FcgiPassHeaderCond = "unless"
)

// Defines values for FcgiSetParamCond.
const (
	FcgiSetParamCondIf     FcgiSetParamCond = "if"
	FcgiSetParamCondUnless FcgiSetParamCond = "unless"
)

// Defines values for FilterAnalyze.
const (
	FilterAnalyzeAll  FilterAnalyze = "all"
	FilterAnalyzeSqli FilterAnalyze = "sqli"
	FilterAnalyzeXss  FilterAnalyze = "xss"
)

// Defines values for FilterCond.
const (
	FilterCondIf     FilterCond = "if"
	FilterCondUnless FilterCond = "unless"
)

// Defines values for FilterLogExtensive.
const (
	FilterLogExtensiveExtensive    FilterLogExtensive = "extensive"
	FilterLogExtensiveExtensiveMsg FilterLogExtensive = "extensive+msg"
)

// Defines values for FilterMode.
const (
	FilterModeRelaxed FilterMode = "relaxed"
	FilterModeStrict  FilterMode = "strict"
)

// Defines values for FilterType.
const (
	FilterTypeBotmgmt     FilterType = "botmgmt"
	FilterTypeBwlimIn     FilterType = "bwlim-in"
	FilterTypeBwlimOut    FilterType = "bwlim-out"
	FilterTypeCache       FilterType = "cache"
	FilterTypeCompression FilterType = "compression"
	FilterTypeFcgiApp     FilterType = "fcgi-app"
	FilterTypeHtmldom     FilterType = "htmldom"
	FilterTypeModsecurity FilterType = "modsecurity"
	FilterTypeSpoe        FilterType = "spoe"
	FilterTypeSslcrl      FilterType = "sslcrl"
	FilterTypeTrace       FilterType = "trace"
	FilterTypeWaf         FilterType = "waf"
)

// Defines values for ForwardforEnabled.
const (
	ForwardforEnabledEnabled ForwardforEnabled = "enabled"
)

// Defines values for FrontendAcceptInvalidHttpRequest.
const (
	FrontendAcceptInvalidHttpRequestDisabled FrontendAcceptInvalidHttpRequest = "disabled"
	FrontendAcceptInvalidHttpRequestEnabled  FrontendAcceptInvalidHttpRequest = "enabled"
)

// Defines values for FrontendClitcpka.
const (
	FrontendClitcpkaDisabled FrontendClitcpka = "disabled"
	FrontendClitcpkaEnabled  FrontendClitcpka = "enabled"
)

// Defines values for FrontendContstats.
const (
	FrontendContstatsEnabled FrontendContstats = "enabled"
)

// Defines values for FrontendDisableH2Upgrade.
const (
	FrontendDisableH2UpgradeDisabled FrontendDisableH2Upgrade = "disabled"
	FrontendDisableH2UpgradeEnabled  FrontendDisableH2Upgrade = "enabled"
)

// Defines values for FrontendDontlogNormal.
const (
	FrontendDontlogNormalDisabled FrontendDontlogNormal = "disabled"
	FrontendDontlogNormalEnabled  FrontendDontlogNormal = "enabled"
)

// Defines values for FrontendDontlognull.
const (
	FrontendDontlognullDisabled FrontendDontlognull = "disabled"
	FrontendDontlognullEnabled  FrontendDontlognull = "enabled"
)

// Defines values for FrontendH1CaseAdjustBogusClient.
const (
	FrontendH1CaseAdjustBogusClientDisabled FrontendH1CaseAdjustBogusClient = "disabled"
	FrontendH1CaseAdjustBogusClientEnabled  FrontendH1CaseAdjustBogusClient = "enabled"
)

// Defines values for FrontendHttpBufferRequest.
const (
	FrontendHttpBufferRequestDisabled FrontendHttpBufferRequest = "disabled"
	FrontendHttpBufferRequestEnabled  FrontendHttpBufferRequest = "enabled"
)

// Defines values for FrontendHttpUseHtx.
const (
	FrontendHttpUseHtxDisabled FrontendHttpUseHtx = "disabled"
	FrontendHttpUseHtxEnabled  FrontendHttpUseHtx = "enabled"
)

// Defines values for FrontendHttpConnectionMode.
const (
	FrontendHttpConnectionModeHttpKeepAlive   FrontendHttpConnectionMode = "http-keep-alive"
	FrontendHttpConnectionModeHttpServerClose FrontendHttpConnectionMode = "http-server-close"
	FrontendHttpConnectionModeHttpclose       FrontendHttpConnectionMode = "httpclose"
)

// Defines values for FrontendHttpIgnoreProbes.
const (
	FrontendHttpIgnoreProbesDisabled FrontendHttpIgnoreProbes = "disabled"
	FrontendHttpIgnoreProbesEnabled  FrontendHttpIgnoreProbes = "enabled"
)

// Defines values for FrontendHttpNoDelay.
const (
	FrontendHttpNoDelayDisabled FrontendHttpNoDelay = "disabled"
	FrontendHttpNoDelayEnabled  FrontendHttpNoDelay = "enabled"
)

// Defines values for FrontendHttpRestrictReqHdrNames.
const (
	FrontendHttpRestrictReqHdrNamesDelete   FrontendHttpRestrictReqHdrNames = "delete"
	FrontendHttpRestrictReqHdrNamesPreserve FrontendHttpRestrictReqHdrNames = "preserve"
	FrontendHttpRestrictReqHdrNamesReject   FrontendHttpRestrictReqHdrNames = "reject"
)

// Defines values for FrontendHttpUseProxyHeader.
const (
	FrontendHttpUseProxyHeaderDisabled FrontendHttpUseProxyHeader = "disabled"
	FrontendHttpUseProxyHeaderEnabled  FrontendHttpUseProxyHeader = "enabled"
)

// Defines values for FrontendHttpslog.
const (
	FrontendHttpslogDisabled FrontendHttpslog = "disabled"
	FrontendHttpslogEnabled  FrontendHttpslog = "enabled"
)

// Defines values for FrontendIdleCloseOnResponse.
const (
	FrontendIdleCloseOnResponseDisabled FrontendIdleCloseOnResponse = "disabled"
	FrontendIdleCloseOnResponseEnabled  FrontendIdleCloseOnResponse = "enabled"
)

// Defines values for FrontendIndependentStreams.
const (
	FrontendIndependentStreamsDisabled FrontendIndependentStreams = "disabled"
	FrontendIndependentStreamsEnabled  FrontendIndependentStreams = "enabled"
)

// Defines values for FrontendLogSeparateErrors.
const (
	FrontendLogSeparateErrorsDisabled FrontendLogSeparateErrors = "disabled"
	FrontendLogSeparateErrorsEnabled  FrontendLogSeparateErrors = "enabled"
)

// Defines values for FrontendLogasap.
const (
	FrontendLogasapDisabled FrontendLogasap = "disabled"
	FrontendLogasapEnabled  FrontendLogasap = "enabled"
)

// Defines values for FrontendMode.
const (
	FrontendModeHttp FrontendMode = "http"
	FrontendModeTcp  FrontendMode = "tcp"
)

// Defines values for FrontendNolinger.
const (
	FrontendNolingerDisabled FrontendNolinger = "disabled"
	FrontendNolingerEnabled  FrontendNolinger = "enabled"
)

// Defines values for FrontendSocketStats.
const (
	FrontendSocketStatsDisabled FrontendSocketStats = "disabled"
	FrontendSocketStatsEnabled  FrontendSocketStats = "enabled"
)

// Defines values for FrontendSpliceAuto.
const (
	FrontendSpliceAutoDisabled FrontendSpliceAuto = "disabled"
	FrontendSpliceAutoEnabled  FrontendSpliceAuto = "enabled"
)

// Defines values for FrontendSpliceRequest.
const (
	FrontendSpliceRequestDisabled FrontendSpliceRequest = "disabled"
	FrontendSpliceRequestEnabled  FrontendSpliceRequest = "enabled"
)

// Defines values for FrontendSpliceResponse.
const (
	FrontendSpliceResponseDisabled FrontendSpliceResponse = "disabled"
	FrontendSpliceResponseEnabled  FrontendSpliceResponse = "enabled"
)

// Defines values for FrontendTcpSmartAccept.
const (
	FrontendTcpSmartAcceptDisabled FrontendTcpSmartAccept = "disabled"
	FrontendTcpSmartAcceptEnabled  FrontendTcpSmartAccept = "enabled"
)

// Defines values for FrontendTcpka.
const (
	FrontendTcpkaDisabled FrontendTcpka = "disabled"
	FrontendTcpkaEnabled  FrontendTcpka = "enabled"
)

// Defines values for FrontendBaseAcceptInvalidHttpRequest.
const (
	FrontendBaseAcceptInvalidHttpRequestDisabled FrontendBaseAcceptInvalidHttpRequest = "disabled"
	FrontendBaseAcceptInvalidHttpRequestEnabled  FrontendBaseAcceptInvalidHttpRequest = "enabled"
)

// Defines values for FrontendBaseClitcpka.
const (
	FrontendBaseClitcpkaDisabled FrontendBaseClitcpka = "disabled"
	FrontendBaseClitcpkaEnabled  FrontendBaseClitcpka = "enabled"
)

// Defines values for FrontendBaseContstats.
const (
	FrontendBaseContstatsEnabled FrontendBaseContstats = "enabled"
)

// Defines values for FrontendBaseDisableH2Upgrade.
const (
	FrontendBaseDisableH2UpgradeDisabled FrontendBaseDisableH2Upgrade = "disabled"
	FrontendBaseDisableH2UpgradeEnabled  FrontendBaseDisableH2Upgrade = "enabled"
)

// Defines values for FrontendBaseDontlogNormal.
const (
	FrontendBaseDontlogNormalDisabled FrontendBaseDontlogNormal = "disabled"
	FrontendBaseDontlogNormalEnabled  FrontendBaseDontlogNormal = "enabled"
)

// Defines values for FrontendBaseDontlognull.
const (
	FrontendBaseDontlognullDisabled FrontendBaseDontlognull = "disabled"
	FrontendBaseDontlognullEnabled  FrontendBaseDontlognull = "enabled"
)

// Defines values for FrontendBaseH1CaseAdjustBogusClient.
const (
	FrontendBaseH1CaseAdjustBogusClientDisabled FrontendBaseH1CaseAdjustBogusClient = "disabled"
	FrontendBaseH1CaseAdjustBogusClientEnabled  FrontendBaseH1CaseAdjustBogusClient = "enabled"
)

// Defines values for FrontendBaseHttpBufferRequest.
const (
	FrontendBaseHttpBufferRequestDisabled FrontendBaseHttpBufferRequest = "disabled"
	FrontendBaseHttpBufferRequestEnabled  FrontendBaseHttpBufferRequest = "enabled"
)

// Defines values for FrontendBaseHttpUseHtx.
const (
	FrontendBaseHttpUseHtxDisabled FrontendBaseHttpUseHtx = "disabled"
	FrontendBaseHttpUseHtxEnabled  FrontendBaseHttpUseHtx = "enabled"
)

// Defines values for FrontendBaseHttpConnectionMode.
const (
	FrontendBaseHttpConnectionModeHttpKeepAlive   FrontendBaseHttpConnectionMode = "http-keep-alive"
	FrontendBaseHttpConnectionModeHttpServerClose FrontendBaseHttpConnectionMode = "http-server-close"
	FrontendBaseHttpConnectionModeHttpclose       FrontendBaseHttpConnectionMode = "httpclose"
)

// Defines values for FrontendBaseHttpIgnoreProbes.
const (
	FrontendBaseHttpIgnoreProbesDisabled FrontendBaseHttpIgnoreProbes = "disabled"
	FrontendBaseHttpIgnoreProbesEnabled  FrontendBaseHttpIgnoreProbes = "enabled"
)

// Defines values for FrontendBaseHttpNoDelay.
const (
	FrontendBaseHttpNoDelayDisabled FrontendBaseHttpNoDelay = "disabled"
	FrontendBaseHttpNoDelayEnabled  FrontendBaseHttpNoDelay = "enabled"
)

// Defines values for FrontendBaseHttpRestrictReqHdrNames.
const (
	FrontendBaseHttpRestrictReqHdrNamesDelete   FrontendBaseHttpRestrictReqHdrNames = "delete"
	FrontendBaseHttpRestrictReqHdrNamesPreserve FrontendBaseHttpRestrictReqHdrNames = "preserve"
	FrontendBaseHttpRestrictReqHdrNamesReject   FrontendBaseHttpRestrictReqHdrNames = "reject"
)

// Defines values for FrontendBaseHttpUseProxyHeader.
const (
	FrontendBaseHttpUseProxyHeaderDisabled FrontendBaseHttpUseProxyHeader = "disabled"
	FrontendBaseHttpUseProxyHeaderEnabled  FrontendBaseHttpUseProxyHeader = "enabled"
)

// Defines values for FrontendBaseHttpslog.
const (
	FrontendBaseHttpslogDisabled FrontendBaseHttpslog = "disabled"
	FrontendBaseHttpslogEnabled  FrontendBaseHttpslog = "enabled"
)

// Defines values for FrontendBaseIdleCloseOnResponse.
const (
	FrontendBaseIdleCloseOnResponseDisabled FrontendBaseIdleCloseOnResponse = "disabled"
	FrontendBaseIdleCloseOnResponseEnabled  FrontendBaseIdleCloseOnResponse = "enabled"
)

// Defines values for FrontendBaseIndependentStreams.
const (
	FrontendBaseIndependentStreamsDisabled FrontendBaseIndependentStreams = "disabled"
	FrontendBaseIndependentStreamsEnabled  FrontendBaseIndependentStreams = "enabled"
)

// Defines values for FrontendBaseLogSeparateErrors.
const (
	FrontendBaseLogSeparateErrorsDisabled FrontendBaseLogSeparateErrors = "disabled"
	FrontendBaseLogSeparateErrorsEnabled  FrontendBaseLogSeparateErrors = "enabled"
)

// Defines values for FrontendBaseLogasap.
const (
	FrontendBaseLogasapDisabled FrontendBaseLogasap = "disabled"
	FrontendBaseLogasapEnabled  FrontendBaseLogasap = "enabled"
)

// Defines values for FrontendBaseMode.
const (
	FrontendBaseModeHttp FrontendBaseMode = "http"
	FrontendBaseModeTcp  FrontendBaseMode = "tcp"
)

// Defines values for FrontendBaseNolinger.
const (
	FrontendBaseNolingerDisabled FrontendBaseNolinger = "disabled"
	FrontendBaseNolingerEnabled  FrontendBaseNolinger = "enabled"
)

// Defines values for FrontendBaseSocketStats.
const (
	FrontendBaseSocketStatsDisabled FrontendBaseSocketStats = "disabled"
	FrontendBaseSocketStatsEnabled  FrontendBaseSocketStats = "enabled"
)

// Defines values for FrontendBaseSpliceAuto.
const (
	FrontendBaseSpliceAutoDisabled FrontendBaseSpliceAuto = "disabled"
	FrontendBaseSpliceAutoEnabled  FrontendBaseSpliceAuto = "enabled"
)

// Defines values for FrontendBaseSpliceRequest.
const (
	FrontendBaseSpliceRequestDisabled FrontendBaseSpliceRequest = "disabled"
	FrontendBaseSpliceRequestEnabled  FrontendBaseSpliceRequest = "enabled"
)

// Defines values for FrontendBaseSpliceResponse.
const (
	FrontendBaseSpliceResponseDisabled FrontendBaseSpliceResponse = "disabled"
	FrontendBaseSpliceResponseEnabled  FrontendBaseSpliceResponse = "enabled"
)

// Defines values for FrontendBaseTcpSmartAccept.
const (
	FrontendBaseTcpSmartAcceptDisabled FrontendBaseTcpSmartAccept = "disabled"
	FrontendBaseTcpSmartAcceptEnabled  FrontendBaseTcpSmartAccept = "enabled"
)

// Defines values for FrontendBaseTcpka.
const (
	FrontendBaseTcpkaDisabled FrontendBaseTcpka = "disabled"
	FrontendBaseTcpkaEnabled  FrontendBaseTcpka = "enabled"
)

// Defines values for GitActionAction.
const (
	GitActionActionCheckout GitActionAction = "checkout"
	GitActionActionCommit   GitActionAction = "commit"
	GitActionActionDiff     GitActionAction = "diff"
	GitActionActionPull     GitActionAction = "pull"
	GitActionActionPush     GitActionAction = "push"
	GitActionActionStatus   GitActionAction = "status"
)

// Defines values for GitResponseSuccess.
const (
	GitResponseSuccessFailed     GitResponseSuccess = "failed"
	GitResponseSuccessSuccessful GitResponseSuccess = "successful"
)

// Defines values for GitSettingsAuthMethod.
const (
	GitSettingsAuthMethodAccessToken GitSettingsAuthMethod = "access_token"
	GitSettingsAuthMethodBasic       GitSettingsAuthMethod = "basic"
	GitSettingsAuthMethodNone        GitSettingsAuthMethod = "none"
)

// Defines values for GitSettingsStorageType.
const (
	GitSettingsStorageTypeDir    GitSettingsStorageType = "dir"
	GitSettingsStorageTypeMemory GitSettingsStorageType = "memory"
)

// Defines values for GlobalDefaultPathType.
const (
	GlobalDefaultPathTypeConfig  GlobalDefaultPathType = "config"
	GlobalDefaultPathTypeCurrent GlobalDefaultPathType = "current"
	GlobalDefaultPathTypeOrigin  GlobalDefaultPathType = "origin"
	GlobalDefaultPathTypeParent  GlobalDefaultPathType = "parent"
)

// Defines values for GlobalHardenRejectPrivilegedPortsQuic.
const (
	GlobalHardenRejectPrivilegedPortsQuicDisabled GlobalHardenRejectPrivilegedPortsQuic = "disabled"
	GlobalHardenRejectPrivilegedPortsQuicEnabled  GlobalHardenRejectPrivilegedPortsQuic = "enabled"
)

// Defines values for GlobalHardenRejectPrivilegedPortsTcp.
const (
	GlobalHardenRejectPrivilegedPortsTcpDisabled GlobalHardenRejectPrivilegedPortsTcp = "disabled"
	GlobalHardenRejectPrivilegedPortsTcpEnabled  GlobalHardenRejectPrivilegedPortsTcp = "enabled"
)

// Defines values for GlobalLogSendHostnameEnabled.
const (
	GlobalLogSendHostnameEnabledDisabled GlobalLogSendHostnameEnabled = "disabled"
	GlobalLogSendHostnameEnabledEnabled  GlobalLogSendHostnameEnabled = "enabled"
)

// Defines values for GlobalNumaCpuMapping.
const (
	GlobalNumaCpuMappingDisabled GlobalNumaCpuMapping = "disabled"
	GlobalNumaCpuMappingEnabled  GlobalNumaCpuMapping = "enabled"
)

// Defines values for GlobalRuntimeApisLevel.
const (
	GlobalRuntimeApisLevelAdmin    GlobalRuntimeApisLevel = "admin"
	GlobalRuntimeApisLevelOperator GlobalRuntimeApisLevel = "operator"
	GlobalRuntimeApisLevelUser     GlobalRuntimeApisLevel = "user"
)

// Defines values for GlobalRuntimeApisQuicCcAlgo.
const (
	GlobalRuntimeApisQuicCcAlgoCubic   GlobalRuntimeApisQuicCcAlgo = "cubic"
	GlobalRuntimeApisQuicCcAlgoNewreno GlobalRuntimeApisQuicCcAlgo = "newreno"
)

// Defines values for GlobalRuntimeApisQuicSocket.
const (
	GlobalRuntimeApisQuicSocketConnection GlobalRuntimeApisQuicSocket = "connection"
	GlobalRuntimeApisQuicSocketListener   GlobalRuntimeApisQuicSocket = "listener"
)

// Defines values for GlobalRuntimeApisSeverityOutput.
const (
	GlobalRuntimeApisSeverityOutputNone   GlobalRuntimeApisSeverityOutput = "none"
	GlobalRuntimeApisSeverityOutputNumber GlobalRuntimeApisSeverityOutput = "number"
	GlobalRuntimeApisSeverityOutputString GlobalRuntimeApisSeverityOutput = "string"
)

// Defines values for GlobalRuntimeApisSslMaxVer.
const (
	GlobalRuntimeApisSslMaxVerSSLv3  GlobalRuntimeApisSslMaxVer = "SSLv3"
	GlobalRuntimeApisSslMaxVerTLSv10 GlobalRuntimeApisSslMaxVer = "TLSv1.0"
	GlobalRuntimeApisSslMaxVerTLSv11 GlobalRuntimeApisSslMaxVer = "TLSv1.1"
	GlobalRuntimeApisSslMaxVerTLSv12 GlobalRuntimeApisSslMaxVer = "TLSv1.2"
	GlobalRuntimeApisSslMaxVerTLSv13 GlobalRuntimeApisSslMaxVer = "TLSv1.3"
)

// Defines values for GlobalRuntimeApisSslMinVer.
const (
	GlobalRuntimeApisSslMinVerSSLv3  GlobalRuntimeApisSslMinVer = "SSLv3"
	GlobalRuntimeApisSslMinVerTLSv10 GlobalRuntimeApisSslMinVer = "TLSv1.0"
	GlobalRuntimeApisSslMinVerTLSv11 GlobalRuntimeApisSslMinVer = "TLSv1.1"
	GlobalRuntimeApisSslMinVerTLSv12 GlobalRuntimeApisSslMinVer = "TLSv1.2"
	GlobalRuntimeApisSslMinVerTLSv13 GlobalRuntimeApisSslMinVer = "TLSv1.3"
)

// Defines values for GlobalRuntimeApisVerify.
const (
	GlobalRuntimeApisVerifyNone     GlobalRuntimeApisVerify = "none"
	GlobalRuntimeApisVerifyOptional GlobalRuntimeApisVerify = "optional"
	GlobalRuntimeApisVerifyRequired GlobalRuntimeApisVerify = "required"
)

// Defines values for GlobalBaseDefaultPathType.
const (
	GlobalBaseDefaultPathTypeConfig  GlobalBaseDefaultPathType = "config"
	GlobalBaseDefaultPathTypeCurrent GlobalBaseDefaultPathType = "current"
	GlobalBaseDefaultPathTypeOrigin  GlobalBaseDefaultPathType = "origin"
	GlobalBaseDefaultPathTypeParent  GlobalBaseDefaultPathType = "parent"
)

// Defines values for GlobalBaseHardenRejectPrivilegedPortsQuic.
const (
	GlobalBaseHardenRejectPrivilegedPortsQuicDisabled GlobalBaseHardenRejectPrivilegedPortsQuic = "disabled"
	GlobalBaseHardenRejectPrivilegedPortsQuicEnabled  GlobalBaseHardenRejectPrivilegedPortsQuic = "enabled"
)

// Defines values for GlobalBaseHardenRejectPrivilegedPortsTcp.
const (
	GlobalBaseHardenRejectPrivilegedPortsTcpDisabled GlobalBaseHardenRejectPrivilegedPortsTcp = "disabled"
	GlobalBaseHardenRejectPrivilegedPortsTcpEnabled  GlobalBaseHardenRejectPrivilegedPortsTcp = "enabled"
)

// Defines values for GlobalBaseLogSendHostnameEnabled.
const (
	GlobalBaseLogSendHostnameEnabledDisabled GlobalBaseLogSendHostnameEnabled = "disabled"
	GlobalBaseLogSendHostnameEnabledEnabled  GlobalBaseLogSendHostnameEnabled = "enabled"
)

// Defines values for GlobalBaseNumaCpuMapping.
const (
	GlobalBaseNumaCpuMappingDisabled GlobalBaseNumaCpuMapping = "disabled"
	GlobalBaseNumaCpuMappingEnabled  GlobalBaseNumaCpuMapping = "enabled"
)

// Defines values for GlobalBaseRuntimeApisLevel.
const (
	GlobalBaseRuntimeApisLevelAdmin    GlobalBaseRuntimeApisLevel = "admin"
	GlobalBaseRuntimeApisLevelOperator GlobalBaseRuntimeApisLevel = "operator"
	GlobalBaseRuntimeApisLevelUser     GlobalBaseRuntimeApisLevel = "user"
)

// Defines values for GlobalBaseRuntimeApisQuicCcAlgo.
const (
	GlobalBaseRuntimeApisQuicCcAlgoCubic   GlobalBaseRuntimeApisQuicCcAlgo = "cubic"
	GlobalBaseRuntimeApisQuicCcAlgoNewreno GlobalBaseRuntimeApisQuicCcAlgo = "newreno"
)

// Defines values for GlobalBaseRuntimeApisQuicSocket.
const (
	GlobalBaseRuntimeApisQuicSocketConnection GlobalBaseRuntimeApisQuicSocket = "connection"
	GlobalBaseRuntimeApisQuicSocketListener   GlobalBaseRuntimeApisQuicSocket = "listener"
)

// Defines values for GlobalBaseRuntimeApisSeverityOutput.
const (
	GlobalBaseRuntimeApisSeverityOutputNone   GlobalBaseRuntimeApisSeverityOutput = "none"
	GlobalBaseRuntimeApisSeverityOutputNumber GlobalBaseRuntimeApisSeverityOutput = "number"
	GlobalBaseRuntimeApisSeverityOutputString GlobalBaseRuntimeApisSeverityOutput = "string"
)

// Defines values for GlobalBaseRuntimeApisSslMaxVer.
const (
	GlobalBaseRuntimeApisSslMaxVerSSLv3  GlobalBaseRuntimeApisSslMaxVer = "SSLv3"
	GlobalBaseRuntimeApisSslMaxVerTLSv10 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.0"
	GlobalBaseRuntimeApisSslMaxVerTLSv11 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.1"
	GlobalBaseRuntimeApisSslMaxVerTLSv12 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.2"
	GlobalBaseRuntimeApisSslMaxVerTLSv13 GlobalBaseRuntimeApisSslMaxVer = "TLSv1.3"
)

// Defines values for GlobalBaseRuntimeApisSslMinVer.
const (
	GlobalBaseRuntimeApisSslMinVerSSLv3  GlobalBaseRuntimeApisSslMinVer = "SSLv3"
	GlobalBaseRuntimeApisSslMinVerTLSv10 GlobalBaseRuntimeApisSslMinVer = "TLSv1.0"
	GlobalBaseRuntimeApisSslMinVerTLSv11 GlobalBaseRuntimeApisSslMinVer = "TLSv1.1"
	GlobalBaseRuntimeApisSslMinVerTLSv12 GlobalBaseRuntimeApisSslMinVer = "TLSv1.2"
	GlobalBaseRuntimeApisSslMinVerTLSv13 GlobalBaseRuntimeApisSslMinVer = "TLSv1.3"
)

// Defines values for GlobalBaseRuntimeApisVerify.
const (
	GlobalBaseRuntimeApisVerifyNone     GlobalBaseRuntimeApisVerify = "none"
	GlobalBaseRuntimeApisVerifyOptional GlobalBaseRuntimeApisVerify = "optional"
	GlobalBaseRuntimeApisVerifyRequired GlobalBaseRuntimeApisVerify = "required"
)

// Defines values for HashTypeFunction.
const (
	HashTypeFunctionCrc32 HashTypeFunction = "crc32"
	HashTypeFunctionDjb2  HashTypeFunction = "djb2"
	HashTypeFunctionNone  HashTypeFunction = "none"
	HashTypeFunctionSdbm  HashTypeFunction = "sdbm"
	HashTypeFunctionWt6   HashTypeFunction = "wt6"
)

// Defines values for HashTypeMethod.
const (
	HashTypeMethodConsistent HashTypeMethod = "consistent"
	HashTypeMethodMapBased   HashTypeMethod = "map-based"
)

// Defines values for HashTypeModifier.
const (
	HashTypeModifierAvalanche HashTypeModifier = "avalanche"
)

// Defines values for HealthHaproxy.
const (
	HealthHaproxyDown    HealthHaproxy = "down"
	HealthHaproxyUnknown HealthHaproxy = "unknown"
	HealthHaproxyUp      HealthHaproxy = "up"
)

// Defines values for HealthKeepalived.
const (
	HealthKeepalivedDown    HealthKeepalived = "down"
	HealthKeepalivedUnknown HealthKeepalived = "unknown"
	HealthKeepalivedUp      HealthKeepalived = "up"
)

// Defines values for HttpAfterResponseRuleCond.
const (
	HttpAfterResponseRuleCondIf     HttpAfterResponseRuleCond = "if"
	HttpAfterResponseRuleCondUnless HttpAfterResponseRuleCond = "unless"
)

// Defines values for HttpAfterResponseRuleLogLevel.
const (
	HttpAfterResponseRuleLogLevelAlert   HttpAfterResponseRuleLogLevel = "alert"
	HttpAfterResponseRuleLogLevelCrit    HttpAfterResponseRuleLogLevel = "crit"
	HttpAfterResponseRuleLogLevelDebug   HttpAfterResponseRuleLogLevel = "debug"
	HttpAfterResponseRuleLogLevelEmerg   HttpAfterResponseRuleLogLevel = "emerg"
	HttpAfterResponseRuleLogLevelErr     HttpAfterResponseRuleLogLevel = "err"
	HttpAfterResponseRuleLogLevelInfo    HttpAfterResponseRuleLogLevel = "info"
	HttpAfterResponseRuleLogLevelNotice  HttpAfterResponseRuleLogLevel = "notice"
	HttpAfterResponseRuleLogLevelSilent  HttpAfterResponseRuleLogLevel = "silent"
	HttpAfterResponseRuleLogLevelWarning HttpAfterResponseRuleLogLevel = "warning"
)

// Defines values for HttpAfterResponseRuleStrictMode.
const (
	HttpAfterResponseRuleStrictModeOff HttpAfterResponseRuleStrictMode = "off"
	HttpAfterResponseRuleStrictModeOn  HttpAfterResponseRuleStrictMode = "on"
)

// Defines values for HttpAfterResponseRuleType.
const (
	HttpAfterResponseRuleTypeAddHeader     HttpAfterResponseRuleType = "add-header"
	HttpAfterResponseRuleTypeAllow         HttpAfterResponseRuleType = "allow"
	HttpAfterResponseRuleTypeCapture       HttpAfterResponseRuleType = "capture"
	HttpAfterResponseRuleTypeDelAcl        HttpAfterResponseRuleType = "del-acl"
	HttpAfterResponseRuleTypeDelHeader     HttpAfterResponseRuleType = "del-header"
	HttpAfterResponseRuleTypeDelMap        HttpAfterResponseRuleType = "del-map"
	HttpAfterResponseRuleTypeReplaceHeader HttpAfterResponseRuleType = "replace-header"
	HttpAfterResponseRuleTypeReplaceValue  HttpAfterResponseRuleType = "replace-value"
	HttpAfterResponseRuleTypeScAddGpc      HttpAfterResponseRuleType = "sc-add-gpc"
	HttpAfterResponseRuleTypeScIncGpc      HttpAfterResponseRuleType = "sc-inc-gpc"
	HttpAfterResponseRuleTypeScIncGpc0     HttpAfterResponseRuleType = "sc-inc-gpc0"
	HttpAfterResponseRuleTypeScIncGpc1     HttpAfterResponseRuleType = "sc-inc-gpc1"
	HttpAfterResponseRuleTypeScSetGpt      HttpAfterResponseRuleType = "sc-set-gpt"
	HttpAfterResponseRuleTypeScSetGpt0     HttpAfterResponseRuleType = "sc-set-gpt0"
	HttpAfterResponseRuleTypeScSetGptstr   HttpAfterResponseRuleType = "sc-set-gptstr"
	HttpAfterResponseRuleTypeSetHeader     HttpAfterResponseRuleType = "set-header"
	HttpAfterResponseRuleTypeSetLogLevel   HttpAfterResponseRuleType = "set-log-level"
	HttpAfterResponseRuleTypeSetMap        HttpAfterResponseRuleType = "set-map"
	HttpAfterResponseRuleTypeSetStatus     HttpAfterResponseRuleType = "set-status"
	HttpAfterResponseRuleTypeSetVar        HttpAfterResponseRuleType = "set-var"
	HttpAfterResponseRuleTypeSetVarFmt     HttpAfterResponseRuleType = "set-var-fmt"
	HttpAfterResponseRuleTypeStrictMode    HttpAfterResponseRuleType = "strict-mode"
	HttpAfterResponseRuleTypeUnsetVar      HttpAfterResponseRuleType = "unset-var"
)

// Defines values for HttpCheckErrorStatus.
const (
	HttpCheckErrorStatusL4CON HttpCheckErrorStatus = "L4CON"
	HttpCheckErrorStatusL6RSP HttpCheckErrorStatus = "L6RSP"
	HttpCheckErrorStatusL7OKC HttpCheckErrorStatus = "L7OKC"
	HttpCheckErrorStatusL7RSP HttpCheckErrorStatus = "L7RSP"
	HttpCheckErrorStatusL7STS HttpCheckErrorStatus = "L7STS"
)

// Defines values for HttpCheckMatch.
const (
	HttpCheckMatchFhdr    HttpCheckMatch = "fhdr"
	HttpCheckMatchHdr     HttpCheckMatch = "hdr"
	HttpCheckMatchRstatus HttpCheckMatch = "rstatus"
	HttpCheckMatchRstring HttpCheckMatch = "rstring"
	HttpCheckMatchStatus  HttpCheckMatch = "status"
	HttpCheckMatchString  HttpCheckMatch = "string"
)

// Defines values for HttpCheckMethod.
const (
	HttpCheckMethodCONNECT HttpCheckMethod = "CONNECT"
	HttpCheckMethodDELETE  HttpCheckMethod = "DELETE"
	HttpCheckMethodGET     HttpCheckMethod = "GET"
	HttpCheckMethodHEAD    HttpCheckMethod = "HEAD"
	HttpCheckMethodOPTIONS HttpCheckMethod = "OPTIONS"
	HttpCheckMethodPATCH   HttpCheckMethod = "PATCH"
	HttpCheckMethodPOST    HttpCheckMethod = "POST"
	HttpCheckMethodPUT     HttpCheckMethod = "PUT"
	HttpCheckMethodTRACE   HttpCheckMethod = "TRACE"
)

// Defines values for HttpCheckOkStatus.
const (
	HttpCheckOkStatusL4OK  HttpCheckOkStatus = "L4OK"
	HttpCheckOkStatusL6OK  HttpCheckOkStatus = "L6OK"
	HttpCheckOkStatusL7OK  HttpCheckOkStatus = "L7OK"
	HttpCheckOkStatusL7OKC HttpCheckOkStatus = "L7OKC"
)

// Defines values for HttpCheckToutStatus.
const (
	HttpCheckToutStatusL4TOUT HttpCheckToutStatus = "L4TOUT"
	HttpCheckToutStatusL6TOUT HttpCheckToutStatus = "L6TOUT"
	HttpCheckToutStatusL7TOUT HttpCheckToutStatus = "L7TOUT"
)

// Defines values for HttpCheckType.
const (
	HttpCheckTypeComment      HttpCheckType = "comment"
	HttpCheckTypeConnect      HttpCheckType = "connect"
	HttpCheckTypeDisableOn404 HttpCheckType = "disable-on-404"
	HttpCheckTypeExpect       HttpCheckType = "expect"
	HttpCheckTypeSend         HttpCheckType = "send"
	HttpCheckTypeSendState    HttpCheckType = "send-state"
	HttpCheckTypeSetVar       HttpCheckType = "set-var"
	HttpCheckTypeSetVarFmt    HttpCheckType = "set-var-fmt"
	HttpCheckTypeUnsetVar     HttpCheckType = "unset-var"
)

// Defines values for HttpClientOptionsResolversDisabled.
const (
	HttpClientOptionsResolversDisabledDisabled HttpClientOptionsResolversDisabled = "disabled"
	HttpClientOptionsResolversDisabledEnabled  HttpClientOptionsResolversDisabled = "enabled"
)

// Defines values for HttpClientOptionsResolversPrefer.
const (
	HttpClientOptionsResolversPreferIpv4 HttpClientOptionsResolversPrefer = "ipv4"
	HttpClientOptionsResolversPreferIpv6 HttpClientOptionsResolversPrefer = "ipv6"
)

// Defines values for HttpClientOptionsSslVerify.
const (
	HttpClientOptionsSslVerifyEmpty    HttpClientOptionsSslVerify = ""
	HttpClientOptionsSslVerifyNone     HttpClientOptionsSslVerify = "none"
	HttpClientOptionsSslVerifyRequired HttpClientOptionsSslVerify = "required"
)

// Defines values for HttpErrorRuleReturnContentFormat.
const (
	HttpErrorRuleReturnContentFormatDefaultErrorfiles HttpErrorRuleReturnContentFormat = "default-errorfiles"
	HttpErrorRuleReturnContentFormatErrorfile         HttpErrorRuleReturnContentFormat = "errorfile"
	HttpErrorRuleReturnContentFormatErrorfiles        HttpErrorRuleReturnContentFormat = "errorfiles"
	HttpErrorRuleReturnContentFormatFile              HttpErrorRuleReturnContentFormat = "file"
	HttpErrorRuleReturnContentFormatLfFile            HttpErrorRuleReturnContentFormat = "lf-file"
	HttpErrorRuleReturnContentFormatLfString          HttpErrorRuleReturnContentFormat = "lf-string"
	HttpErrorRuleReturnContentFormatString            HttpErrorRuleReturnContentFormat = "string"
)

// Defines values for HttpErrorRuleStatus.
const (
	HttpErrorRuleStatusN200 HttpErrorRuleStatus = 200
	HttpErrorRuleStatusN400 HttpErrorRuleStatus = 400
	HttpErrorRuleStatusN401 HttpErrorRuleStatus = 401
	HttpErrorRuleStatusN403 HttpErrorRuleStatus = 403
	HttpErrorRuleStatusN404 HttpErrorRuleStatus = 404
	HttpErrorRuleStatusN405 HttpErrorRuleStatus = 405
	HttpErrorRuleStatusN407 HttpErrorRuleStatus = 407
	HttpErrorRuleStatusN408 HttpErrorRuleStatus = 408
	HttpErrorRuleStatusN410 HttpErrorRuleStatus = 410
	HttpErrorRuleStatusN413 HttpErrorRuleStatus = 413
	HttpErrorRuleStatusN425 HttpErrorRuleStatus = 425
	HttpErrorRuleStatusN429 HttpErrorRuleStatus = 429
	HttpErrorRuleStatusN500 HttpErrorRuleStatus = 500
	HttpErrorRuleStatusN501 HttpErrorRuleStatus = 501
	HttpErrorRuleStatusN502 HttpErrorRuleStatus = 502
	HttpErrorRuleStatusN503 HttpErrorRuleStatus = 503
	HttpErrorRuleStatusN504 HttpErrorRuleStatus = 504
)

// Defines values for HttpErrorRuleType.
const (
	HttpErrorRuleTypeStatus HttpErrorRuleType = "status"
)

// Defines values for HttpRequestRuleCond.
const (
	HttpRequestRuleCondIf     HttpRequestRuleCond = "if"
	HttpRequestRuleCondUnless HttpRequestRuleCond = "unless"
)

// Defines values for HttpRequestRuleLogLevel.
const (
	HttpRequestRuleLogLevelAlert   HttpRequestRuleLogLevel = "alert"
	HttpRequestRuleLogLevelCrit    HttpRequestRuleLogLevel = "crit"
	HttpRequestRuleLogLevelDebug   HttpRequestRuleLogLevel = "debug"
	HttpRequestRuleLogLevelEmerg   HttpRequestRuleLogLevel = "emerg"
	HttpRequestRuleLogLevelErr     HttpRequestRuleLogLevel = "err"
	HttpRequestRuleLogLevelInfo    HttpRequestRuleLogLevel = "info"
	HttpRequestRuleLogLevelNotice  HttpRequestRuleLogLevel = "notice"
	HttpRequestRuleLogLevelSilent  HttpRequestRuleLogLevel = "silent"
	HttpRequestRuleLogLevelWarning HttpRequestRuleLogLevel = "warning"
)

// Defines values for HttpRequestRuleNormalizer.
const (
	HttpRequestRuleNormalizerFragmentEncode          HttpRequestRuleNormalizer = "fragment-encode"
	HttpRequestRuleNormalizerFragmentStrip           HttpRequestRuleNormalizer = "fragment-strip"
	HttpRequestRuleNormalizerPathMergeSlashes        HttpRequestRuleNormalizer = "path-merge-slashes"
	HttpRequestRuleNormalizerPathStripDot            HttpRequestRuleNormalizer = "path-strip-dot"
	HttpRequestRuleNormalizerPathStripDotdot         HttpRequestRuleNormalizer = "path-strip-dotdot"
	HttpRequestRuleNormalizerPercentDecodeUnreserved HttpRequestRuleNormalizer = "percent-decode-unreserved"
	HttpRequestRuleNormalizerPercentToUppercase      HttpRequestRuleNormalizer = "percent-to-uppercase"
	HttpRequestRuleNormalizerQuerySortByName         HttpRequestRuleNormalizer = "query-sort-by-name"
)

// Defines values for HttpRequestRuleProtocol.
const (
	HttpRequestRuleProtocolIpv4 HttpRequestRuleProtocol = "ipv4"
	HttpRequestRuleProtocolIpv6 HttpRequestRuleProtocol = "ipv6"
)

// Defines values for HttpRequestRuleRedirCode.
const (
	HttpRequestRuleRedirCodeN301 HttpRequestRuleRedirCode = 301
	HttpRequestRuleRedirCodeN302 HttpRequestRuleRedirCode = 302
	HttpRequestRuleRedirCodeN303 HttpRequestRuleRedirCode = 303
	HttpRequestRuleRedirCodeN307 HttpRequestRuleRedirCode = 307
	HttpRequestRuleRedirCodeN308 HttpRequestRuleRedirCode = 308
)

// Defines values for HttpRequestRuleRedirType.
const (
	HttpRequestRuleRedirTypeLocation HttpRequestRuleRedirType = "location"
	HttpRequestRuleRedirTypePrefix   HttpRequestRuleRedirType = "prefix"
	HttpRequestRuleRedirTypeScheme   HttpRequestRuleRedirType = "scheme"
)

// Defines values for HttpRequestRuleReturnContentFormat.
const (
	HttpRequestRuleReturnContentFormatDefaultErrorfiles HttpRequestRuleReturnContentFormat = "default-errorfiles"
	HttpRequestRuleReturnContentFormatErrorfile         HttpRequestRuleReturnContentFormat = "errorfile"
	HttpRequestRuleReturnContentFormatErrorfiles        HttpRequestRuleReturnContentFormat = "errorfiles"
	HttpRequestRuleReturnContentFormatFile              HttpRequestRuleReturnContentFormat = "file"
	HttpRequestRuleReturnContentFormatLfFile            HttpRequestRuleReturnContentFormat = "lf-file"
	HttpRequestRuleReturnContentFormatLfString          HttpRequestRuleReturnContentFormat = "lf-string"
	HttpRequestRuleReturnContentFormatString            HttpRequestRuleReturnContentFormat = "string"
)

// Defines values for HttpRequestRuleStrictMode.
const (
	HttpRequestRuleStrictModeOff HttpRequestRuleStrictMode = "off"
	HttpRequestRuleStrictModeOn  HttpRequestRuleStrictMode = "on"
)

// Defines values for HttpRequestRuleTimeoutType.
const (
	HttpRequestRuleTimeoutTypeClient HttpRequestRuleTimeoutType = "client"
	HttpRequestRuleTimeoutTypeServer HttpRequestRuleTimeoutType = "server"
	HttpRequestRuleTimeoutTypeTunnel HttpRequestRuleTimeoutType = "tunnel"
)

// Defines values for HttpRequestRuleType.
const (
	HttpRequestRuleTypeAddAcl            HttpRequestRuleType = "add-acl"
	HttpRequestRuleTypeAddHeader         HttpRequestRuleType = "add-header"
	HttpRequestRuleTypeAllow             HttpRequestRuleType = "allow"
	HttpRequestRuleTypeAuth              HttpRequestRuleType = "auth"
	HttpRequestRuleTypeBotmgmtEvaluate   HttpRequestRuleType = "botmgmt-evaluate"
	HttpRequestRuleTypeCacheUse          HttpRequestRuleType = "cache-use"
	HttpRequestRuleTypeCapture           HttpRequestRuleType = "capture"
	HttpRequestRuleTypeDelAcl            HttpRequestRuleType = "del-acl"
	HttpRequestRuleTypeDelHeader         HttpRequestRuleType = "del-header"
	HttpRequestRuleTypeDelMap            HttpRequestRuleType = "del-map"
	HttpRequestRuleTypeDeny              HttpRequestRuleType = "deny"
	HttpRequestRuleTypeDisableL7Retry    HttpRequestRuleType = "disable-l7-retry"
	HttpRequestRuleTypeDoResolve         HttpRequestRuleType = "do-resolve"
	HttpRequestRuleTypeEarlyHint         HttpRequestRuleType = "early-hint"
	HttpRequestRuleTypeLua               HttpRequestRuleType = "lua"
	HttpRequestRuleTypeNormalizeUri      HttpRequestRuleType = "normalize-uri"
	HttpRequestRuleTypeRedirect          HttpRequestRuleType = "redirect"
	HttpRequestRuleTypeReject            HttpRequestRuleType = "reject"
	HttpRequestRuleTypeReplaceHeader     HttpRequestRuleType = "replace-header"
	HttpRequestRuleTypeReplacePath       HttpRequestRuleType = "replace-path"
	HttpRequestRuleTypeReplacePathq      HttpRequestRuleType = "replace-pathq"
	HttpRequestRuleTypeReplaceUri        HttpRequestRuleType = "replace-uri"
	HttpRequestRuleTypeReplaceValue      HttpRequestRuleType = "replace-value"
	HttpRequestRuleTypeReturn            HttpRequestRuleType = "return"
	HttpRequestRuleTypeSamlSso           HttpRequestRuleType = "saml-sso"
	HttpRequestRuleTypeScAddGpc          HttpRequestRuleType = "sc-add-gpc"
	HttpRequestRuleTypeScIncGpc          HttpRequestRuleType = "sc-inc-gpc"
	HttpRequestRuleTypeScIncGpc0         HttpRequestRuleType = "sc-inc-gpc0"
	HttpRequestRuleTypeScIncGpc1         HttpRequestRuleType = "sc-inc-gpc1"
	HttpRequestRuleTypeScSetGpt          HttpRequestRuleType = "sc-set-gpt"
	HttpRequestRuleTypeScSetGpt0         HttpRequestRuleType = "sc-set-gpt0"
	HttpRequestRuleTypeScSetGptstr       HttpRequestRuleType = "sc-set-gptstr"
	HttpRequestRuleTypeSendChallenge     HttpRequestRuleType = "send-challenge"
	HttpRequestRuleTypeSendSpoeGroup     HttpRequestRuleType = "send-spoe-group"
	HttpRequestRuleTypeSetBandwidthLimit HttpRequestRuleType = "set-bandwidth-limit"
	HttpRequestRuleTypeSetBcMark         HttpRequestRuleType = "set-bc-mark"
	HttpRequestRuleTypeSetBcTos          HttpRequestRuleType = "set-bc-tos"
	HttpRequestRuleTypeSetChallenge      HttpRequestRuleType = "set-challenge"
	HttpRequestRuleTypeSetDst            HttpRequestRuleType = "set-dst"
	HttpRequestRuleTypeSetDstPort        HttpRequestRuleType = "set-dst-port"
	HttpRequestRuleTypeSetFcMark         HttpRequestRuleType = "set-fc-mark"
	HttpRequestRuleTypeSetFcTos          HttpRequestRuleType = "set-fc-tos"
	HttpRequestRuleTypeSetHeader         HttpRequestRuleType = "set-header"
	HttpRequestRuleTypeSetLogLevel       HttpRequestRuleType = "set-log-level"
	HttpRequestRuleTypeSetMap            HttpRequestRuleType = "set-map"
	HttpRequestRuleTypeSetMark           HttpRequestRuleType = "set-mark"
	HttpRequestRuleTypeSetMethod         HttpRequestRuleType = "set-method"
	HttpRequestRuleTypeSetNice           HttpRequestRuleType = "set-nice"
	HttpRequestRuleTypeSetPath           HttpRequestRuleType = "set-path"
	HttpRequestRuleTypeSetPathq          HttpRequestRuleType = "set-pathq"
	HttpRequestRuleTypeSetPriorityClass  HttpRequestRuleType = "set-priority-class"
	HttpRequestRuleTypeSetPriorityOffset HttpRequestRuleType = "set-priority-offset"
	HttpRequestRuleTypeSetQuery          HttpRequestRuleType = "set-query"
	HttpRequestRuleTypeSetSrc            HttpRequestRuleType = "set-src"
	HttpRequestRuleTypeSetSrcPort        HttpRequestRuleType = "set-src-port"
	HttpRequestRuleTypeSetTimeout        HttpRequestRuleType = "set-timeout"
	HttpRequestRuleTypeSetTos            HttpRequestRuleType = "set-tos"
	HttpRequestRuleTypeSetUri            HttpRequestRuleType = "set-uri"
	HttpRequestRuleTypeSetVar            HttpRequestRuleType = "set-var"
	HttpRequestRuleTypeSetVarFmt         HttpRequestRuleType = "set-var-fmt"
	HttpRequestRuleTypeSilentDrop        HttpRequestRuleType = "silent-drop"
	HttpRequestRuleTypeStrictMode        HttpRequestRuleType = "strict-mode"
	HttpRequestRuleTypeTarpit            HttpRequestRuleType = "tarpit"
	HttpRequestRuleTypeTrackSc           HttpRequestRuleType = "track-sc"
	HttpRequestRuleTypeUnsetVar          HttpRequestRuleType = "unset-var"
	HttpRequestRuleTypeUseService        HttpRequestRuleType = "use-service"
	HttpRequestRuleTypeWaitForBody       HttpRequestRuleType = "wait-for-body"
	HttpRequestRuleTypeWaitForHandshake  HttpRequestRuleType = "wait-for-handshake"
)

// Defines values for HttpResponseRuleCond.
const (
	HttpResponseRuleCondIf     HttpResponseRuleCond = "if"
	HttpResponseRuleCondUnless HttpResponseRuleCond = "unless"
)

// Defines values for HttpResponseRuleLogLevel.
const (
	HttpResponseRuleLogLevelAlert   HttpResponseRuleLogLevel = "alert"
	HttpResponseRuleLogLevelCrit    HttpResponseRuleLogLevel = "crit"
	HttpResponseRuleLogLevelDebug   HttpResponseRuleLogLevel = "debug"
	HttpResponseRuleLogLevelEmerg   HttpResponseRuleLogLevel = "emerg"
	HttpResponseRuleLogLevelErr     HttpResponseRuleLogLevel = "err"
	HttpResponseRuleLogLevelInfo    HttpResponseRuleLogLevel = "info"
	HttpResponseRuleLogLevelNotice  HttpResponseRuleLogLevel = "notice"
	HttpResponseRuleLogLevelSilent  HttpResponseRuleLogLevel = "silent"
	HttpResponseRuleLogLevelWarning HttpResponseRuleLogLevel = "warning"
)

// Defines values for HttpResponseRuleRedirCode.
const (
	HttpResponseRuleRedirCodeN301 HttpResponseRuleRedirCode = 301
	HttpResponseRuleRedirCodeN302 HttpResponseRuleRedirCode = 302
	HttpResponseRuleRedirCodeN303 HttpResponseRuleRedirCode = 303
	HttpResponseRuleRedirCodeN307 HttpResponseRuleRedirCode = 307
	HttpResponseRuleRedirCodeN308 HttpResponseRuleRedirCode = 308
)

// Defines values for HttpResponseRuleRedirType.
const (
	HttpResponseRuleRedirTypeLocation HttpResponseRuleRedirType = "location"
	HttpResponseRuleRedirTypePrefix   HttpResponseRuleRedirType = "prefix"
	HttpResponseRuleRedirTypeScheme   HttpResponseRuleRedirType = "scheme"
)

// Defines values for HttpResponseRuleReturnContentFormat.
const (
	HttpResponseRuleReturnContentFormatDefaultErrorfiles HttpResponseRuleReturnContentFormat = "default-errorfiles"
	HttpResponseRuleReturnContentFormatErrorfile         HttpResponseRuleReturnContentFormat = "errorfile"
	HttpResponseRuleReturnContentFormatErrorfiles        HttpResponseRuleReturnContentFormat = "errorfiles"
	HttpResponseRuleReturnContentFormatFile              HttpResponseRuleReturnContentFormat = "file"
	HttpResponseRuleReturnContentFormatLfFile            HttpResponseRuleReturnContentFormat = "lf-file"
	HttpResponseRuleReturnContentFormatLfString          HttpResponseRuleReturnContentFormat = "lf-string"
	HttpResponseRuleReturnContentFormatString            HttpResponseRuleReturnContentFormat = "string"
)

// Defines values for HttpResponseRuleStrictMode.
const (
	HttpResponseRuleStrictModeOff HttpResponseRuleStrictMode = "off"
	HttpResponseRuleStrictModeOn  HttpResponseRuleStrictMode = "on"
)

// Defines values for HttpResponseRuleTimeoutType.
const (
	HttpResponseRuleTimeoutTypeClient HttpResponseRuleTimeoutType = "client"
	HttpResponseRuleTimeoutTypeServer HttpResponseRuleTimeoutType = "server"
	HttpResponseRuleTimeoutTypeTunnel HttpResponseRuleTimeoutType = "tunnel"
)

// Defines values for HttpResponseRuleType.
const (
	HttpResponseRuleTypeAddAcl            HttpResponseRuleType = "add-acl"
	HttpResponseRuleTypeAddHeader         HttpResponseRuleType = "add-header"
	HttpResponseRuleTypeAllow             HttpResponseRuleType = "allow"
	HttpResponseRuleTypeCacheStore        HttpResponseRuleType = "cache-store"
	HttpResponseRuleTypeCapture           HttpResponseRuleType = "capture"
	HttpResponseRuleTypeDelAcl            HttpResponseRuleType = "del-acl"
	HttpResponseRuleTypeDelHeader         HttpResponseRuleType = "del-header"
	HttpResponseRuleTypeDelMap            HttpResponseRuleType = "del-map"
	HttpResponseRuleTypeDeny              HttpResponseRuleType = "deny"
	HttpResponseRuleTypeLua               HttpResponseRuleType = "lua"
	HttpResponseRuleTypeRedirect          HttpResponseRuleType = "redirect"
	HttpResponseRuleTypeReplaceHeader     HttpResponseRuleType = "replace-header"
	HttpResponseRuleTypeReplaceValue      HttpResponseRuleType = "replace-value"
	HttpResponseRuleTypeReturn            HttpResponseRuleType = "return"
	HttpResponseRuleTypeSamlSso           HttpResponseRuleType = "saml-sso"
	HttpResponseRuleTypeScAddGpc          HttpResponseRuleType = "sc-add-gpc"
	HttpResponseRuleTypeScIncGpc          HttpResponseRuleType = "sc-inc-gpc"
	HttpResponseRuleTypeScIncGpc0         HttpResponseRuleType = "sc-inc-gpc0"
	HttpResponseRuleTypeScIncGpc1         HttpResponseRuleType = "sc-inc-gpc1"
	HttpResponseRuleTypeScSetGpt          HttpResponseRuleType = "sc-set-gpt"
	HttpResponseRuleTypeScSetGpt0         HttpResponseRuleType = "sc-set-gpt0"
	HttpResponseRuleTypeScSetGptstr       HttpResponseRuleType = "sc-set-gptstr"
	HttpResponseRuleTypeSendSpoeGroup     HttpResponseRuleType = "send-spoe-group"
	HttpResponseRuleTypeSetBandwidthLimit HttpResponseRuleType = "set-bandwidth-limit"
	HttpResponseRuleTypeSetFcMark         HttpResponseRuleType = "set-fc-mark"
	HttpResponseRuleTypeSetFcTos          HttpResponseRuleType = "set-fc-tos"
	HttpResponseRuleTypeSetHeader         HttpResponseRuleType = "set-header"
	HttpResponseRuleTypeSetLogLevel       HttpResponseRuleType = "set-log-level"
	HttpResponseRuleTypeSetMap            HttpResponseRuleType = "set-map"
	HttpResponseRuleTypeSetMark           HttpResponseRuleType = "set-mark"
	HttpResponseRuleTypeSetNice           HttpResponseRuleType = "set-nice"
	HttpResponseRuleTypeSetStatus         HttpResponseRuleType = "set-status"
	HttpResponseRuleTypeSetTimeout        HttpResponseRuleType = "set-timeout"
	HttpResponseRuleTypeSetTos            HttpResponseRuleType = "set-tos"
	HttpResponseRuleTypeSetVar            HttpResponseRuleType = "set-var"
	HttpResponseRuleTypeSetVarFmt         HttpResponseRuleType = "set-var-fmt"
	HttpResponseRuleTypeSilentDrop        HttpResponseRuleType = "silent-drop"
	HttpResponseRuleTypeStrictMode        HttpResponseRuleType = "strict-mode"
	HttpResponseRuleTypeTrackSc           HttpResponseRuleType = "track-sc"
	HttpResponseRuleTypeUnsetVar          HttpResponseRuleType = "unset-var"
	HttpResponseRuleTypeWaitForBody       HttpResponseRuleType = "wait-for-body"
)

// Defines values for HttpchkParamsMethod.
const (
	HttpchkParamsMethodCONNECT HttpchkParamsMethod = "CONNECT"
	HttpchkParamsMethodDELETE  HttpchkParamsMethod = "DELETE"
	HttpchkParamsMethodGET     HttpchkParamsMethod = "GET"
	HttpchkParamsMethodHEAD    HttpchkParamsMethod = "HEAD"
	HttpchkParamsMethodOPTIONS HttpchkParamsMethod = "OPTIONS"
	HttpchkParamsMethodPATCH   HttpchkParamsMethod = "PATCH"
	HttpchkParamsMethodPOST    HttpchkParamsMethod = "POST"
	HttpchkParamsMethodPUT     HttpchkParamsMethod = "PUT"
	HttpchkParamsMethodTRACE   HttpchkParamsMethod = "TRACE"
)

// Defines values for KeepalivedReloadStatus.
const (
	KeepalivedReloadStatusFailed     KeepalivedReloadStatus = "failed"
	KeepalivedReloadStatusInProgress KeepalivedReloadStatus = "in_progress"
	KeepalivedReloadStatusSucceeded  KeepalivedReloadStatus = "succeeded"
)

// Defines values for KeepalivedTransactionStatus.
const (
	KeepalivedTransactionStatusFailed     KeepalivedTransactionStatus = "failed"
	KeepalivedTransactionStatusInProgress KeepalivedTransactionStatus = "in_progress"
	KeepalivedTransactionStatusSuccess    KeepalivedTransactionStatus = "success"
)

// Defines values for LogInputType.
const (
	LogInputTypeSyslog LogInputType = "syslog"
)

// Defines values for LogOutputType.
const (
	LogOutputTypeClickhouse LogOutputType = "clickhouse"
	LogOutputTypeSyslog     LogOutputType = "syslog"
)

// Defines values for LogRuleNumberMatcher.
const (
	LogRuleNumberMatcherEquals LogRuleNumberMatcher = "equals"
	LogRuleNumberMatcherGe     LogRuleNumberMatcher = "ge"
	LogRuleNumberMatcherGt     LogRuleNumberMatcher = "gt"
	LogRuleNumberMatcherLe     LogRuleNumberMatcher = "le"
	LogRuleNumberMatcherLt     LogRuleNumberMatcher = "lt"
)

// Defines values for LogRuleStringMatcher.
const (
	LogRuleStringMatcherContains   LogRuleStringMatcher = "contains"
	LogRuleStringMatcherEndsWith   LogRuleStringMatcher = "ends_with"
	LogRuleStringMatcherEquals     LogRuleStringMatcher = "equals"
	LogRuleStringMatcherRegex      LogRuleStringMatcher = "regex"
	LogRuleStringMatcherStartsWith LogRuleStringMatcher = "starts_with"
)

// Defines values for LogRuleTimestampMatcher.
const (
	LogRuleTimestampMatcherAfter  LogRuleTimestampMatcher = "after"
	LogRuleTimestampMatcherBefore LogRuleTimestampMatcher = "before"
	LogRuleTimestampMatcherEquals LogRuleTimestampMatcher = "equals"
)

// Defines values for LogRuleType.
const (
	LogRuleTypeBool      LogRuleType = "bool"
	LogRuleTypeNumber    LogRuleType = "number"
	LogRuleTypeString    LogRuleType = "string"
	LogRuleTypeTimestamp LogRuleType = "timestamp"
)

// Defines values for LogTargetFacility.
const (
	LogTargetFacilityAlert  LogTargetFacility = "alert"
	LogTargetFacilityAudit  LogTargetFacility = "audit"
	LogTargetFacilityAuth   LogTargetFacility = "auth"
	LogTargetFacilityAuth2  LogTargetFacility = "auth2"
	LogTargetFacilityCron   LogTargetFacility = "cron"
	LogTargetFacilityCron2  LogTargetFacility = "cron2"
	LogTargetFacilityDaemon LogTargetFacility = "daemon"
	LogTargetFacilityFtp    LogTargetFacility = "ftp"
	LogTargetFacilityKern   LogTargetFacility = "kern"
	LogTargetFacilityLocal0 LogTargetFacility = "local0"
	LogTargetFacilityLocal1 LogTargetFacility = "local1"
	LogTargetFacilityLocal2 LogTargetFacility = "local2"
	LogTargetFacilityLocal3 LogTargetFacility = "local3"
	LogTargetFacilityLocal4 LogTargetFacility = "local4"
	LogTargetFacilityLocal5 LogTargetFacility = "local5"
	LogTargetFacilityLocal6 LogTargetFacility = "local6"
	LogTargetFacilityLocal7 LogTargetFacility = "local7"
	LogTargetFacilityLpr    LogTargetFacility = "lpr"
	LogTargetFacilityMail   LogTargetFacility = "mail"
	LogTargetFacilityNews   LogTargetFacility = "news"
	LogTargetFacilityNtp    LogTargetFacility = "ntp"
	LogTargetFacilitySyslog LogTargetFacility = "syslog"
	LogTargetFacilityUser   LogTargetFacility = "user"
	LogTargetFacilityUucp   LogTargetFacility = "uucp"
)

// Defines values for LogTargetFormat.
const (
	LogTargetFormatIso      LogTargetFormat = "iso"
	LogTargetFormatLocal    LogTargetFormat = "local"
	LogTargetFormatPriority LogTargetFormat = "priority"
	LogTargetFormatRaw      LogTargetFormat = "raw"
	LogTargetFormatRfc3164  LogTargetFormat = "rfc3164"
	LogTargetFormatRfc5424  LogTargetFormat = "rfc5424"
	LogTargetFormatShort    LogTargetFormat = "short"
	LogTargetFormatTimed    LogTargetFormat = "timed"
)

// Defines values for LogTargetLevel.
const (
	LogTargetLevelAlert   LogTargetLevel = "alert"
	LogTargetLevelCrit    LogTargetLevel = "crit"
	LogTargetLevelDebug   LogTargetLevel = "debug"
	LogTargetLevelEmerg   LogTargetLevel = "emerg"
	LogTargetLevelErr     LogTargetLevel = "err"
	LogTargetLevelInfo    LogTargetLevel = "info"
	LogTargetLevelNotice  LogTargetLevel = "notice"
	LogTargetLevelWarning LogTargetLevel = "warning"
)

// Defines values for LogTargetMinlevel.
const (
	LogTargetMinlevelAlert   LogTargetMinlevel = "alert"
	LogTargetMinlevelCrit    LogTargetMinlevel = "crit"
	LogTargetMinlevelDebug   LogTargetMinlevel = "debug"
	LogTargetMinlevelEmerg   LogTargetMinlevel = "emerg"
	LogTargetMinlevelErr     LogTargetMinlevel = "err"
	LogTargetMinlevelInfo    LogTargetMinlevel = "info"
	LogTargetMinlevelNotice  LogTargetMinlevel = "notice"
	LogTargetMinlevelWarning LogTargetMinlevel = "warning"
)

// Defines values for LuaOptionsPrependPathType.
const (
	LuaOptionsPrependPathTypeCpath LuaOptionsPrependPathType = "cpath"
	LuaOptionsPrependPathTypePath  LuaOptionsPrependPathType = "path"
)

// Defines values for ModsecurityOptionsMaxCpuAction.
const (
	ModsecurityOptionsMaxCpuActionDeny ModsecurityOptionsMaxCpuAction = "deny"
	ModsecurityOptionsMaxCpuActionPass ModsecurityOptionsMaxCpuAction = "pass"
)

// Defines values for MonitorFailCond.
const (
	MonitorFailCondIf     MonitorFailCond = "if"
	MonitorFailCondUnless MonitorFailCond = "unless"
)

// Defines values for MysqlCheckParamsClientVersion.
const (
	MysqlCheckParamsClientVersionPost41 MysqlCheckParamsClientVersion = "post-41"
	MysqlCheckParamsClientVersionPre41  MysqlCheckParamsClientVersion = "pre-41"
)

// Defines values for NativeStatType.
const (
	NativeStatTypeBackend  NativeStatType = "backend"
	NativeStatTypeFrontend NativeStatType = "frontend"
	NativeStatTypeServer   NativeStatType = "server"
)

// Defines values for NativeStatStatsAgentStatus.
const (
	NativeStatStatsAgentStatusINI     NativeStatStatsAgentStatus = "INI"
	NativeStatStatsAgentStatusL4CON   NativeStatStatsAgentStatus = "L4CON"
	NativeStatStatsAgentStatusL4OK    NativeStatStatsAgentStatus = "L4OK"
	NativeStatStatsAgentStatusL4TOUT  NativeStatStatsAgentStatus = "L4TOUT"
	NativeStatStatsAgentStatusL7OK    NativeStatStatsAgentStatus = "L7OK"
	NativeStatStatsAgentStatusL7STS   NativeStatStatsAgentStatus = "L7STS"
	NativeStatStatsAgentStatusSOCKERR NativeStatStatsAgentStatus = "SOCKERR"
	NativeStatStatsAgentStatusUNK     NativeStatStatsAgentStatus = "UNK"
)

// Defines values for NativeStatStatsCheckStatus.
const (
	NativeStatStatsCheckStatusINI     NativeStatStatsCheckStatus = "INI"
	NativeStatStatsCheckStatusL4CON   NativeStatStatsCheckStatus = "L4CON"
	NativeStatStatsCheckStatusL4OK    NativeStatStatsCheckStatus = "L4OK"
	NativeStatStatsCheckStatusL4TOUT  NativeStatStatsCheckStatus = "L4TOUT"
	NativeStatStatsCheckStatusL6OK    NativeStatStatsCheckStatus = "L6OK"
	NativeStatStatsCheckStatusL6RSP   NativeStatStatsCheckStatus = "L6RSP"
	NativeStatStatsCheckStatusL6TOUT  NativeStatStatsCheckStatus = "L6TOUT"
	NativeStatStatsCheckStatusL7OK    NativeStatStatsCheckStatus = "L7OK"
	NativeStatStatsCheckStatusL7OKC   NativeStatStatsCheckStatus = "L7OKC"
	NativeStatStatsCheckStatusL7RSP   NativeStatStatsCheckStatus = "L7RSP"
	NativeStatStatsCheckStatusL7STS   NativeStatStatsCheckStatus = "L7STS"
	NativeStatStatsCheckStatusL7TOUT  NativeStatStatsCheckStatus = "L7TOUT"
	NativeStatStatsCheckStatusSOCKERR NativeStatStatsCheckStatus = "SOCKERR"
	NativeStatStatsCheckStatusUNK     NativeStatStatsCheckStatus = "UNK"
)

// Defines values for NativeStatStatsMode.
const (
	NativeStatStatsModeHealth  NativeStatStatsMode = "health"
	NativeStatStatsModeHttp    NativeStatStatsMode = "http"
	NativeStatStatsModeTcp     NativeStatStatsMode = "tcp"
	NativeStatStatsModeUnknown NativeStatStatsMode = "unknown"
)

// Defines values for NativeStatStatsStatus.
const (
	NativeStatStatsStatusDOWN    NativeStatStatsStatus = "DOWN"
	NativeStatStatsStatusMAINT   NativeStatStatsStatus = "MAINT"
	NativeStatStatsStatusNOLB    NativeStatStatsStatus = "NOLB"
	NativeStatStatsStatusNoCheck NativeStatStatsStatus = "no check"
	NativeStatStatsStatusUP      NativeStatStatsStatus = "UP"
)

// Defines values for OcspUpdateOptionsMode.
const (
	OcspUpdateOptionsModeDisabled OcspUpdateOptionsMode = "disabled"
	OcspUpdateOptionsModeEnabled  OcspUpdateOptionsMode = "enabled"
)

// Defines values for OriginaltoEnabled.
const (
	OriginaltoEnabledEnabled OriginaltoEnabled = "enabled"
)

// Defines values for PerformanceOptionsProfilingMemory.
const (
	PerformanceOptionsProfilingMemoryDisabled PerformanceOptionsProfilingMemory = "disabled"
	PerformanceOptionsProfilingMemoryEnabled  PerformanceOptionsProfilingMemory = "enabled"
)

// Defines values for PerformanceOptionsProfilingTasks.
const (
	PerformanceOptionsProfilingTasksAuto     PerformanceOptionsProfilingTasks = "auto"
	PerformanceOptionsProfilingTasksDisabled PerformanceOptionsProfilingTasks = "disabled"
	PerformanceOptionsProfilingTasksEnabled  PerformanceOptionsProfilingTasks = "enabled"
)

// Defines values for PersistRuleType.
const (
	PersistRuleTypeRdpCookie PersistRuleType = "rdp-cookie"
)

// Defines values for ProgramStartOnReload.
const (
	ProgramStartOnReloadDisabled ProgramStartOnReload = "disabled"
	ProgramStartOnReloadEnabled  ProgramStartOnReload = "enabled"
)

// Defines values for RedispatchEnabled.
const (
	RedispatchEnabledDisabled RedispatchEnabled = "disabled"
	RedispatchEnabledEnabled  RedispatchEnabled = "enabled"
)

// Defines values for ReloadStatus.
const (
	ReloadStatusFailed     ReloadStatus = "failed"
	ReloadStatusInProgress ReloadStatus = "in_progress"
	ReloadStatusSucceeded  ReloadStatus = "succeeded"
)

// Defines values for RingFormat.
const (
	RingFormatIso      RingFormat = "iso"
	RingFormatLocal    RingFormat = "local"
	RingFormatPriority RingFormat = "priority"
	RingFormatRaw      RingFormat = "raw"
	RingFormatRfc3164  RingFormat = "rfc3164"
	RingFormatRfc5424  RingFormat = "rfc5424"
	RingFormatShort    RingFormat = "short"
	RingFormatTimed    RingFormat = "timed"
)

// Defines values for RingBaseFormat.
const (
	RingBaseFormatIso      RingBaseFormat = "iso"
	RingBaseFormatLocal    RingBaseFormat = "local"
	RingBaseFormatPriority RingBaseFormat = "priority"
	RingBaseFormatRaw      RingBaseFormat = "raw"
	RingBaseFormatRfc3164  RingBaseFormat = "rfc3164"
	RingBaseFormatRfc5424  RingBaseFormat = "rfc5424"
	RingBaseFormatShort    RingBaseFormat = "short"
	RingBaseFormatTimed    RingBaseFormat = "timed"
)

// Defines values for RuntimeAddServerAgentCheck.
const (
	RuntimeAddServerAgentCheckDisabled RuntimeAddServerAgentCheck = "disabled"
	RuntimeAddServerAgentCheckEnabled  RuntimeAddServerAgentCheck = "enabled"
)

// Defines values for RuntimeAddServerBackup.
const (
	RuntimeAddServerBackupDisabled RuntimeAddServerBackup = "disabled"
	RuntimeAddServerBackupEnabled  RuntimeAddServerBackup = "enabled"
)

// Defines values for RuntimeAddServerCheck.
const (
	RuntimeAddServerCheckDisabled RuntimeAddServerCheck = "disabled"
	RuntimeAddServerCheckEnabled  RuntimeAddServerCheck = "enabled"
)

// Defines values for RuntimeAddServerCheckSendProxy.
const (
	RuntimeAddServerCheckSendProxyDisabled RuntimeAddServerCheckSendProxy = "disabled"
	RuntimeAddServerCheckSendProxyEnabled  RuntimeAddServerCheckSendProxy = "enabled"
)

// Defines values for RuntimeAddServerCheckSsl.
const (
	RuntimeAddServerCheckSslDisabled RuntimeAddServerCheckSsl = "disabled"
	RuntimeAddServerCheckSslEnabled  RuntimeAddServerCheckSsl = "enabled"
)

// Defines values for RuntimeAddServerCheckViaSocks4.
const (
	RuntimeAddServerCheckViaSocks4Disabled RuntimeAddServerCheckViaSocks4 = "disabled"
	RuntimeAddServerCheckViaSocks4Enabled  RuntimeAddServerCheckViaSocks4 = "enabled"
)

// Defines values for RuntimeAddServerForceSslv3.
const (
	RuntimeAddServerForceSslv3Disabled RuntimeAddServerForceSslv3 = "disabled"
	RuntimeAddServerForceSslv3Enabled  RuntimeAddServerForceSslv3 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv10.
const (
	RuntimeAddServerForceTlsv10Disabled RuntimeAddServerForceTlsv10 = "disabled"
	RuntimeAddServerForceTlsv10Enabled  RuntimeAddServerForceTlsv10 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv11.
const (
	RuntimeAddServerForceTlsv11Disabled RuntimeAddServerForceTlsv11 = "disabled"
	RuntimeAddServerForceTlsv11Enabled  RuntimeAddServerForceTlsv11 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv12.
const (
	RuntimeAddServerForceTlsv12Disabled RuntimeAddServerForceTlsv12 = "disabled"
	RuntimeAddServerForceTlsv12Enabled  RuntimeAddServerForceTlsv12 = "enabled"
)

// Defines values for RuntimeAddServerForceTlsv13.
const (
	RuntimeAddServerForceTlsv13Disabled RuntimeAddServerForceTlsv13 = "disabled"
	RuntimeAddServerForceTlsv13Enabled  RuntimeAddServerForceTlsv13 = "enabled"
)

// Defines values for RuntimeAddServerMaintenance.
const (
	RuntimeAddServerMaintenanceDisabled RuntimeAddServerMaintenance = "disabled"
	RuntimeAddServerMaintenanceEnabled  RuntimeAddServerMaintenance = "enabled"
)

// Defines values for RuntimeAddServerNoSslv3.
const (
	RuntimeAddServerNoSslv3Disabled RuntimeAddServerNoSslv3 = "disabled"
	RuntimeAddServerNoSslv3Enabled  RuntimeAddServerNoSslv3 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv10.
const (
	RuntimeAddServerNoTlsv10Disabled RuntimeAddServerNoTlsv10 = "disabled"
	RuntimeAddServerNoTlsv10Enabled  RuntimeAddServerNoTlsv10 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv11.
const (
	RuntimeAddServerNoTlsv11Disabled RuntimeAddServerNoTlsv11 = "disabled"
	RuntimeAddServerNoTlsv11Enabled  RuntimeAddServerNoTlsv11 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv12.
const (
	RuntimeAddServerNoTlsv12Disabled RuntimeAddServerNoTlsv12 = "disabled"
	RuntimeAddServerNoTlsv12Enabled  RuntimeAddServerNoTlsv12 = "enabled"
)

// Defines values for RuntimeAddServerNoTlsv13.
const (
	RuntimeAddServerNoTlsv13Disabled RuntimeAddServerNoTlsv13 = "disabled"
	RuntimeAddServerNoTlsv13Enabled  RuntimeAddServerNoTlsv13 = "enabled"
)

// Defines values for RuntimeAddServerObserve.
const (
	RuntimeAddServerObserveLayer4 RuntimeAddServerObserve = "layer4"
	RuntimeAddServerObserveLayer7 RuntimeAddServerObserve = "layer7"
)

// Defines values for RuntimeAddServerOnError.
const (
	RuntimeAddServerOnErrorFailCheck   RuntimeAddServerOnError = "fail-check"
	RuntimeAddServerOnErrorFastinter   RuntimeAddServerOnError = "fastinter"
	RuntimeAddServerOnErrorMarkDown    RuntimeAddServerOnError = "mark-down"
	RuntimeAddServerOnErrorSuddenDeath RuntimeAddServerOnError = "sudden-death"
)

// Defines values for RuntimeAddServerOnMarkedDown.
const (
	RuntimeAddServerOnMarkedDownShutdownSessions RuntimeAddServerOnMarkedDown = "shutdown-sessions"
)

// Defines values for RuntimeAddServerOnMarkedUp.
const (
	RuntimeAddServerOnMarkedUpShutdownBackupSessions RuntimeAddServerOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for RuntimeAddServerProxyV2Options.
const (
	RuntimeAddServerProxyV2OptionsAuthority RuntimeAddServerProxyV2Options = "authority"
	RuntimeAddServerProxyV2OptionsCertCn    RuntimeAddServerProxyV2Options = "cert-cn"
	RuntimeAddServerProxyV2OptionsCertKey   RuntimeAddServerProxyV2Options = "cert-key"
	RuntimeAddServerProxyV2OptionsCertSig   RuntimeAddServerProxyV2Options = "cert-sig"
	RuntimeAddServerProxyV2OptionsCrc32c    RuntimeAddServerProxyV2Options = "crc32c"
	RuntimeAddServerProxyV2OptionsSsl       RuntimeAddServerProxyV2Options = "ssl"
	RuntimeAddServerProxyV2OptionsSslCipher RuntimeAddServerProxyV2Options = "ssl-cipher"
	RuntimeAddServerProxyV2OptionsUniqueId  RuntimeAddServerProxyV2Options = "unique-id"
)

// Defines values for RuntimeAddServerSendProxy.
const (
	RuntimeAddServerSendProxyDisabled RuntimeAddServerSendProxy = "disabled"
	RuntimeAddServerSendProxyEnabled  RuntimeAddServerSendProxy = "enabled"
)

// Defines values for RuntimeAddServerSendProxyV2.
const (
	RuntimeAddServerSendProxyV2Disabled RuntimeAddServerSendProxyV2 = "disabled"
	RuntimeAddServerSendProxyV2Enabled  RuntimeAddServerSendProxyV2 = "enabled"
)

// Defines values for RuntimeAddServerSendProxyV2Ssl.
const (
	RuntimeAddServerSendProxyV2SslDisabled RuntimeAddServerSendProxyV2Ssl = "disabled"
	RuntimeAddServerSendProxyV2SslEnabled  RuntimeAddServerSendProxyV2Ssl = "enabled"
)

// Defines values for RuntimeAddServerSendProxyV2SslCn.
const (
	RuntimeAddServerSendProxyV2SslCnDisabled RuntimeAddServerSendProxyV2SslCn = "disabled"
	RuntimeAddServerSendProxyV2SslCnEnabled  RuntimeAddServerSendProxyV2SslCn = "enabled"
)

// Defines values for RuntimeAddServerSsl.
const (
	RuntimeAddServerSslDisabled RuntimeAddServerSsl = "disabled"
	RuntimeAddServerSslEnabled  RuntimeAddServerSsl = "enabled"
)

// Defines values for RuntimeAddServerSslMaxVer.
const (
	RuntimeAddServerSslMaxVerSSLv3  RuntimeAddServerSslMaxVer = "SSLv3"
	RuntimeAddServerSslMaxVerTLSv10 RuntimeAddServerSslMaxVer = "TLSv1.0"
	RuntimeAddServerSslMaxVerTLSv11 RuntimeAddServerSslMaxVer = "TLSv1.1"
	RuntimeAddServerSslMaxVerTLSv12 RuntimeAddServerSslMaxVer = "TLSv1.2"
	RuntimeAddServerSslMaxVerTLSv13 RuntimeAddServerSslMaxVer = "TLSv1.3"
)

// Defines values for RuntimeAddServerSslMinVer.
const (
	RuntimeAddServerSslMinVerSSLv3  RuntimeAddServerSslMinVer = "SSLv3"
	RuntimeAddServerSslMinVerTLSv10 RuntimeAddServerSslMinVer = "TLSv1.0"
	RuntimeAddServerSslMinVerTLSv11 RuntimeAddServerSslMinVer = "TLSv1.1"
	RuntimeAddServerSslMinVerTLSv12 RuntimeAddServerSslMinVer = "TLSv1.2"
	RuntimeAddServerSslMinVerTLSv13 RuntimeAddServerSslMinVer = "TLSv1.3"
)

// Defines values for RuntimeAddServerSslReuse.
const (
	RuntimeAddServerSslReuseDisabled RuntimeAddServerSslReuse = "disabled"
	RuntimeAddServerSslReuseEnabled  RuntimeAddServerSslReuse = "enabled"
)

// Defines values for RuntimeAddServerTfo.
const (
	RuntimeAddServerTfoDisabled RuntimeAddServerTfo = "disabled"
	RuntimeAddServerTfoEnabled  RuntimeAddServerTfo = "enabled"
)

// Defines values for RuntimeAddServerTlsTickets.
const (
	RuntimeAddServerTlsTicketsDisabled RuntimeAddServerTlsTickets = "disabled"
	RuntimeAddServerTlsTicketsEnabled  RuntimeAddServerTlsTickets = "enabled"
)

// Defines values for RuntimeAddServerVerify.
const (
	RuntimeAddServerVerifyNone     RuntimeAddServerVerify = "none"
	RuntimeAddServerVerifyRequired RuntimeAddServerVerify = "required"
)

// Defines values for RuntimeAddServerWs.
const (
	RuntimeAddServerWsAuto RuntimeAddServerWs = "auto"
	RuntimeAddServerWsH1   RuntimeAddServerWs = "h1"
	RuntimeAddServerWsH2   RuntimeAddServerWs = "h2"
)

// Defines values for RuntimeServerAdminState.
const (
	RuntimeServerAdminStateDrain RuntimeServerAdminState = "drain"
	RuntimeServerAdminStateMaint RuntimeServerAdminState = "maint"
	RuntimeServerAdminStateReady RuntimeServerAdminState = "ready"
)

// Defines values for RuntimeServerOperationalState.
const (
	RuntimeServerOperationalStateDown     RuntimeServerOperationalState = "down"
	RuntimeServerOperationalStateStopping RuntimeServerOperationalState = "stopping"
	RuntimeServerOperationalStateUp       RuntimeServerOperationalState = "up"
)

// Defines values for ServerAgentCheck.
const (
	ServerAgentCheckDisabled ServerAgentCheck = "disabled"
	ServerAgentCheckEnabled  ServerAgentCheck = "enabled"
)

// Defines values for ServerBackup.
const (
	ServerBackupDisabled ServerBackup = "disabled"
	ServerBackupEnabled  ServerBackup = "enabled"
)

// Defines values for ServerCheck.
const (
	ServerCheckDisabled ServerCheck = "disabled"
	ServerCheckEnabled  ServerCheck = "enabled"
)

// Defines values for ServerCheckSendProxy.
const (
	ServerCheckSendProxyDisabled ServerCheckSendProxy = "disabled"
	ServerCheckSendProxyEnabled  ServerCheckSendProxy = "enabled"
)

// Defines values for ServerCheckSsl.
const (
	ServerCheckSslDisabled ServerCheckSsl = "disabled"
	ServerCheckSslEnabled  ServerCheckSsl = "enabled"
)

// Defines values for ServerCheckViaSocks4.
const (
	ServerCheckViaSocks4Disabled ServerCheckViaSocks4 = "disabled"
	ServerCheckViaSocks4Enabled  ServerCheckViaSocks4 = "enabled"
)

// Defines values for ServerForceSslv3.
const (
	ServerForceSslv3Disabled ServerForceSslv3 = "disabled"
	ServerForceSslv3Enabled  ServerForceSslv3 = "enabled"
)

// Defines values for ServerForceTlsv10.
const (
	ServerForceTlsv10Disabled ServerForceTlsv10 = "disabled"
	ServerForceTlsv10Enabled  ServerForceTlsv10 = "enabled"
)

// Defines values for ServerForceTlsv11.
const (
	ServerForceTlsv11Disabled ServerForceTlsv11 = "disabled"
	ServerForceTlsv11Enabled  ServerForceTlsv11 = "enabled"
)

// Defines values for ServerForceTlsv12.
const (
	ServerForceTlsv12Disabled ServerForceTlsv12 = "disabled"
	ServerForceTlsv12Enabled  ServerForceTlsv12 = "enabled"
)

// Defines values for ServerForceTlsv13.
const (
	ServerForceTlsv13Disabled ServerForceTlsv13 = "disabled"
	ServerForceTlsv13Enabled  ServerForceTlsv13 = "enabled"
)

// Defines values for ServerLogProto.
const (
	ServerLogProtoLegacy     ServerLogProto = "legacy"
	ServerLogProtoOctetCount ServerLogProto = "octet-count"
)

// Defines values for ServerMaintenance.
const (
	ServerMaintenanceDisabled ServerMaintenance = "disabled"
	ServerMaintenanceEnabled  ServerMaintenance = "enabled"
)

// Defines values for ServerNoSslv3.
const (
	ServerNoSslv3Disabled ServerNoSslv3 = "disabled"
	ServerNoSslv3Enabled  ServerNoSslv3 = "enabled"
)

// Defines values for ServerNoTlsv10.
const (
	ServerNoTlsv10Disabled ServerNoTlsv10 = "disabled"
	ServerNoTlsv10Enabled  ServerNoTlsv10 = "enabled"
)

// Defines values for ServerNoTlsv11.
const (
	ServerNoTlsv11Disabled ServerNoTlsv11 = "disabled"
	ServerNoTlsv11Enabled  ServerNoTlsv11 = "enabled"
)

// Defines values for ServerNoTlsv12.
const (
	ServerNoTlsv12Disabled ServerNoTlsv12 = "disabled"
	ServerNoTlsv12Enabled  ServerNoTlsv12 = "enabled"
)

// Defines values for ServerNoTlsv13.
const (
	ServerNoTlsv13Disabled ServerNoTlsv13 = "disabled"
	ServerNoTlsv13Enabled  ServerNoTlsv13 = "enabled"
)

// Defines values for ServerNoVerifyhost.
const (
	ServerNoVerifyhostDisabled ServerNoVerifyhost = "disabled"
	ServerNoVerifyhostEnabled  ServerNoVerifyhost = "enabled"
)

// Defines values for ServerObserve.
const (
	ServerObserveLayer4 ServerObserve = "layer4"
	ServerObserveLayer7 ServerObserve = "layer7"
)

// Defines values for ServerOnError.
const (
	ServerOnErrorFailCheck   ServerOnError = "fail-check"
	ServerOnErrorFastinter   ServerOnError = "fastinter"
	ServerOnErrorMarkDown    ServerOnError = "mark-down"
	ServerOnErrorSuddenDeath ServerOnError = "sudden-death"
)

// Defines values for ServerOnMarkedDown.
const (
	ServerOnMarkedDownShutdownSessions ServerOnMarkedDown = "shutdown-sessions"
)

// Defines values for ServerOnMarkedUp.
const (
	ServerOnMarkedUpShutdownBackupSessions ServerOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for ServerProxyV2Options.
const (
	ServerProxyV2OptionsAuthority ServerProxyV2Options = "authority"
	ServerProxyV2OptionsCertCn    ServerProxyV2Options = "cert-cn"
	ServerProxyV2OptionsCertKey   ServerProxyV2Options = "cert-key"
	ServerProxyV2OptionsCertSig   ServerProxyV2Options = "cert-sig"
	ServerProxyV2OptionsCrc32c    ServerProxyV2Options = "crc32c"
	ServerProxyV2OptionsSsl       ServerProxyV2Options = "ssl"
	ServerProxyV2OptionsSslCipher ServerProxyV2Options = "ssl-cipher"
	ServerProxyV2OptionsUniqueId  ServerProxyV2Options = "unique-id"
)

// Defines values for ServerResolvePrefer.
const (
	ServerResolvePreferIpv4 ServerResolvePrefer = "ipv4"
	ServerResolvePreferIpv6 ServerResolvePrefer = "ipv6"
)

// Defines values for ServerSendProxy.
const (
	ServerSendProxyDisabled ServerSendProxy = "disabled"
	ServerSendProxyEnabled  ServerSendProxy = "enabled"
)

// Defines values for ServerSendProxyV2.
const (
	ServerSendProxyV2Disabled ServerSendProxyV2 = "disabled"
	ServerSendProxyV2Enabled  ServerSendProxyV2 = "enabled"
)

// Defines values for ServerSendProxyV2Ssl.
const (
	ServerSendProxyV2SslDisabled ServerSendProxyV2Ssl = "disabled"
	ServerSendProxyV2SslEnabled  ServerSendProxyV2Ssl = "enabled"
)

// Defines values for ServerSendProxyV2SslCn.
const (
	ServerSendProxyV2SslCnDisabled ServerSendProxyV2SslCn = "disabled"
	ServerSendProxyV2SslCnEnabled  ServerSendProxyV2SslCn = "enabled"
)

// Defines values for ServerSsl.
const (
	ServerSslDisabled ServerSsl = "disabled"
	ServerSslEnabled  ServerSsl = "enabled"
)

// Defines values for ServerSslMaxVer.
const (
	ServerSslMaxVerSSLv3  ServerSslMaxVer = "SSLv3"
	ServerSslMaxVerTLSv10 ServerSslMaxVer = "TLSv1.0"
	ServerSslMaxVerTLSv11 ServerSslMaxVer = "TLSv1.1"
	ServerSslMaxVerTLSv12 ServerSslMaxVer = "TLSv1.2"
	ServerSslMaxVerTLSv13 ServerSslMaxVer = "TLSv1.3"
)

// Defines values for ServerSslMinVer.
const (
	ServerSslMinVerSSLv3  ServerSslMinVer = "SSLv3"
	ServerSslMinVerTLSv10 ServerSslMinVer = "TLSv1.0"
	ServerSslMinVerTLSv11 ServerSslMinVer = "TLSv1.1"
	ServerSslMinVerTLSv12 ServerSslMinVer = "TLSv1.2"
	ServerSslMinVerTLSv13 ServerSslMinVer = "TLSv1.3"
)

// Defines values for ServerSslReuse.
const (
	ServerSslReuseDisabled ServerSslReuse = "disabled"
	ServerSslReuseEnabled  ServerSslReuse = "enabled"
)

// Defines values for ServerStick.
const (
	ServerStickDisabled ServerStick = "disabled"
	ServerStickEnabled  ServerStick = "enabled"
)

// Defines values for ServerTfo.
const (
	ServerTfoDisabled ServerTfo = "disabled"
	ServerTfoEnabled  ServerTfo = "enabled"
)

// Defines values for ServerTlsTickets.
const (
	ServerTlsTicketsDisabled ServerTlsTickets = "disabled"
	ServerTlsTicketsEnabled  ServerTlsTickets = "enabled"
)

// Defines values for ServerVerify.
const (
	ServerVerifyNone     ServerVerify = "none"
	ServerVerifyRequired ServerVerify = "required"
)

// Defines values for ServerWs.
const (
	ServerWsAuto ServerWs = "auto"
	ServerWsH1   ServerWs = "h1"
	ServerWsH2   ServerWs = "h2"
)

// Defines values for ServerParamsAgentCheck.
const (
	ServerParamsAgentCheckDisabled ServerParamsAgentCheck = "disabled"
	ServerParamsAgentCheckEnabled  ServerParamsAgentCheck = "enabled"
)

// Defines values for ServerParamsBackup.
const (
	ServerParamsBackupDisabled ServerParamsBackup = "disabled"
	ServerParamsBackupEnabled  ServerParamsBackup = "enabled"
)

// Defines values for ServerParamsCheck.
const (
	ServerParamsCheckDisabled ServerParamsCheck = "disabled"
	ServerParamsCheckEnabled  ServerParamsCheck = "enabled"
)

// Defines values for ServerParamsCheckSendProxy.
const (
	ServerParamsCheckSendProxyDisabled ServerParamsCheckSendProxy = "disabled"
	ServerParamsCheckSendProxyEnabled  ServerParamsCheckSendProxy = "enabled"
)

// Defines values for ServerParamsCheckSsl.
const (
	ServerParamsCheckSslDisabled ServerParamsCheckSsl = "disabled"
	ServerParamsCheckSslEnabled  ServerParamsCheckSsl = "enabled"
)

// Defines values for ServerParamsCheckViaSocks4.
const (
	ServerParamsCheckViaSocks4Disabled ServerParamsCheckViaSocks4 = "disabled"
	ServerParamsCheckViaSocks4Enabled  ServerParamsCheckViaSocks4 = "enabled"
)

// Defines values for ServerParamsForceSslv3.
const (
	ServerParamsForceSslv3Disabled ServerParamsForceSslv3 = "disabled"
	ServerParamsForceSslv3Enabled  ServerParamsForceSslv3 = "enabled"
)

// Defines values for ServerParamsForceTlsv10.
const (
	ServerParamsForceTlsv10Disabled ServerParamsForceTlsv10 = "disabled"
	ServerParamsForceTlsv10Enabled  ServerParamsForceTlsv10 = "enabled"
)

// Defines values for ServerParamsForceTlsv11.
const (
	ServerParamsForceTlsv11Disabled ServerParamsForceTlsv11 = "disabled"
	ServerParamsForceTlsv11Enabled  ServerParamsForceTlsv11 = "enabled"
)

// Defines values for ServerParamsForceTlsv12.
const (
	ServerParamsForceTlsv12Disabled ServerParamsForceTlsv12 = "disabled"
	ServerParamsForceTlsv12Enabled  ServerParamsForceTlsv12 = "enabled"
)

// Defines values for ServerParamsForceTlsv13.
const (
	ServerParamsForceTlsv13Disabled ServerParamsForceTlsv13 = "disabled"
	ServerParamsForceTlsv13Enabled  ServerParamsForceTlsv13 = "enabled"
)

// Defines values for ServerParamsLogProto.
const (
	ServerParamsLogProtoLegacy     ServerParamsLogProto = "legacy"
	ServerParamsLogProtoOctetCount ServerParamsLogProto = "octet-count"
)

// Defines values for ServerParamsMaintenance.
const (
	ServerParamsMaintenanceDisabled ServerParamsMaintenance = "disabled"
	ServerParamsMaintenanceEnabled  ServerParamsMaintenance = "enabled"
)

// Defines values for ServerParamsNoSslv3.
const (
	ServerParamsNoSslv3Disabled ServerParamsNoSslv3 = "disabled"
	ServerParamsNoSslv3Enabled  ServerParamsNoSslv3 = "enabled"
)

// Defines values for ServerParamsNoTlsv10.
const (
	ServerParamsNoTlsv10Disabled ServerParamsNoTlsv10 = "disabled"
	ServerParamsNoTlsv10Enabled  ServerParamsNoTlsv10 = "enabled"
)

// Defines values for ServerParamsNoTlsv11.
const (
	ServerParamsNoTlsv11Disabled ServerParamsNoTlsv11 = "disabled"
	ServerParamsNoTlsv11Enabled  ServerParamsNoTlsv11 = "enabled"
)

// Defines values for ServerParamsNoTlsv12.
const (
	ServerParamsNoTlsv12Disabled ServerParamsNoTlsv12 = "disabled"
	ServerParamsNoTlsv12Enabled  ServerParamsNoTlsv12 = "enabled"
)

// Defines values for ServerParamsNoTlsv13.
const (
	ServerParamsNoTlsv13Disabled ServerParamsNoTlsv13 = "disabled"
	ServerParamsNoTlsv13Enabled  ServerParamsNoTlsv13 = "enabled"
)

// Defines values for ServerParamsNoVerifyhost.
const (
	ServerParamsNoVerifyhostDisabled ServerParamsNoVerifyhost = "disabled"
	ServerParamsNoVerifyhostEnabled  ServerParamsNoVerifyhost = "enabled"
)

// Defines values for ServerParamsObserve.
const (
	ServerParamsObserveLayer4 ServerParamsObserve = "layer4"
	ServerParamsObserveLayer7 ServerParamsObserve = "layer7"
)

// Defines values for ServerParamsOnError.
const (
	ServerParamsOnErrorFailCheck   ServerParamsOnError = "fail-check"
	ServerParamsOnErrorFastinter   ServerParamsOnError = "fastinter"
	ServerParamsOnErrorMarkDown    ServerParamsOnError = "mark-down"
	ServerParamsOnErrorSuddenDeath ServerParamsOnError = "sudden-death"
)

// Defines values for ServerParamsOnMarkedDown.
const (
	ServerParamsOnMarkedDownShutdownSessions ServerParamsOnMarkedDown = "shutdown-sessions"
)

// Defines values for ServerParamsOnMarkedUp.
const (
	ServerParamsOnMarkedUpShutdownBackupSessions ServerParamsOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for ServerParamsProxyV2Options.
const (
	ServerParamsProxyV2OptionsAuthority ServerParamsProxyV2Options = "authority"
	ServerParamsProxyV2OptionsCertCn    ServerParamsProxyV2Options = "cert-cn"
	ServerParamsProxyV2OptionsCertKey   ServerParamsProxyV2Options = "cert-key"
	ServerParamsProxyV2OptionsCertSig   ServerParamsProxyV2Options = "cert-sig"
	ServerParamsProxyV2OptionsCrc32c    ServerParamsProxyV2Options = "crc32c"
	ServerParamsProxyV2OptionsSsl       ServerParamsProxyV2Options = "ssl"
	ServerParamsProxyV2OptionsSslCipher ServerParamsProxyV2Options = "ssl-cipher"
	ServerParamsProxyV2OptionsUniqueId  ServerParamsProxyV2Options = "unique-id"
)

// Defines values for ServerParamsResolvePrefer.
const (
	ServerParamsResolvePreferIpv4 ServerParamsResolvePrefer = "ipv4"
	ServerParamsResolvePreferIpv6 ServerParamsResolvePrefer = "ipv6"
)

// Defines values for ServerParamsSendProxy.
const (
	ServerParamsSendProxyDisabled ServerParamsSendProxy = "disabled"
	ServerParamsSendProxyEnabled  ServerParamsSendProxy = "enabled"
)

// Defines values for ServerParamsSendProxyV2.
const (
	ServerParamsSendProxyV2Disabled ServerParamsSendProxyV2 = "disabled"
	ServerParamsSendProxyV2Enabled  ServerParamsSendProxyV2 = "enabled"
)

// Defines values for ServerParamsSendProxyV2Ssl.
const (
	ServerParamsSendProxyV2SslDisabled ServerParamsSendProxyV2Ssl = "disabled"
	ServerParamsSendProxyV2SslEnabled  ServerParamsSendProxyV2Ssl = "enabled"
)

// Defines values for ServerParamsSendProxyV2SslCn.
const (
	ServerParamsSendProxyV2SslCnDisabled ServerParamsSendProxyV2SslCn = "disabled"
	ServerParamsSendProxyV2SslCnEnabled  ServerParamsSendProxyV2SslCn = "enabled"
)

// Defines values for ServerParamsSsl.
const (
	ServerParamsSslDisabled ServerParamsSsl = "disabled"
	ServerParamsSslEnabled  ServerParamsSsl = "enabled"
)

// Defines values for ServerParamsSslMaxVer.
const (
	ServerParamsSslMaxVerSSLv3  ServerParamsSslMaxVer = "SSLv3"
	ServerParamsSslMaxVerTLSv10 ServerParamsSslMaxVer = "TLSv1.0"
	ServerParamsSslMaxVerTLSv11 ServerParamsSslMaxVer = "TLSv1.1"
	ServerParamsSslMaxVerTLSv12 ServerParamsSslMaxVer = "TLSv1.2"
	ServerParamsSslMaxVerTLSv13 ServerParamsSslMaxVer = "TLSv1.3"
)

// Defines values for ServerParamsSslMinVer.
const (
	ServerParamsSslMinVerSSLv3  ServerParamsSslMinVer = "SSLv3"
	ServerParamsSslMinVerTLSv10 ServerParamsSslMinVer = "TLSv1.0"
	ServerParamsSslMinVerTLSv11 ServerParamsSslMinVer = "TLSv1.1"
	ServerParamsSslMinVerTLSv12 ServerParamsSslMinVer = "TLSv1.2"
	ServerParamsSslMinVerTLSv13 ServerParamsSslMinVer = "TLSv1.3"
)

// Defines values for ServerParamsSslReuse.
const (
	ServerParamsSslReuseDisabled ServerParamsSslReuse = "disabled"
	ServerParamsSslReuseEnabled  ServerParamsSslReuse = "enabled"
)

// Defines values for ServerParamsStick.
const (
	ServerParamsStickDisabled ServerParamsStick = "disabled"
	ServerParamsStickEnabled  ServerParamsStick = "enabled"
)

// Defines values for ServerParamsTfo.
const (
	ServerParamsTfoDisabled ServerParamsTfo = "disabled"
	ServerParamsTfoEnabled  ServerParamsTfo = "enabled"
)

// Defines values for ServerParamsTlsTickets.
const (
	ServerParamsTlsTicketsDisabled ServerParamsTlsTickets = "disabled"
	ServerParamsTlsTicketsEnabled  ServerParamsTlsTickets = "enabled"
)

// Defines values for ServerParamsVerify.
const (
	ServerParamsVerifyNone     ServerParamsVerify = "none"
	ServerParamsVerifyRequired ServerParamsVerify = "required"
)

// Defines values for ServerParamsWs.
const (
	ServerParamsWsAuto ServerParamsWs = "auto"
	ServerParamsWsH1   ServerParamsWs = "h1"
	ServerParamsWsH2   ServerParamsWs = "h2"
)

// Defines values for ServerSwitchingRuleCond.
const (
	ServerSwitchingRuleCondIf     ServerSwitchingRuleCond = "if"
	ServerSwitchingRuleCondUnless ServerSwitchingRuleCond = "unless"
)

// Defines values for ServerTemplateAgentCheck.
const (
	ServerTemplateAgentCheckDisabled ServerTemplateAgentCheck = "disabled"
	ServerTemplateAgentCheckEnabled  ServerTemplateAgentCheck = "enabled"
)

// Defines values for ServerTemplateBackup.
const (
	ServerTemplateBackupDisabled ServerTemplateBackup = "disabled"
	ServerTemplateBackupEnabled  ServerTemplateBackup = "enabled"
)

// Defines values for ServerTemplateCheck.
const (
	ServerTemplateCheckDisabled ServerTemplateCheck = "disabled"
	ServerTemplateCheckEnabled  ServerTemplateCheck = "enabled"
)

// Defines values for ServerTemplateCheckSendProxy.
const (
	ServerTemplateCheckSendProxyDisabled ServerTemplateCheckSendProxy = "disabled"
	ServerTemplateCheckSendProxyEnabled  ServerTemplateCheckSendProxy = "enabled"
)

// Defines values for ServerTemplateCheckSsl.
const (
	ServerTemplateCheckSslDisabled ServerTemplateCheckSsl = "disabled"
	ServerTemplateCheckSslEnabled  ServerTemplateCheckSsl = "enabled"
)

// Defines values for ServerTemplateCheckViaSocks4.
const (
	ServerTemplateCheckViaSocks4Disabled ServerTemplateCheckViaSocks4 = "disabled"
	ServerTemplateCheckViaSocks4Enabled  ServerTemplateCheckViaSocks4 = "enabled"
)

// Defines values for ServerTemplateForceSslv3.
const (
	ServerTemplateForceSslv3Disabled ServerTemplateForceSslv3 = "disabled"
	ServerTemplateForceSslv3Enabled  ServerTemplateForceSslv3 = "enabled"
)

// Defines values for ServerTemplateForceTlsv10.
const (
	ServerTemplateForceTlsv10Disabled ServerTemplateForceTlsv10 = "disabled"
	ServerTemplateForceTlsv10Enabled  ServerTemplateForceTlsv10 = "enabled"
)

// Defines values for ServerTemplateForceTlsv11.
const (
	ServerTemplateForceTlsv11Disabled ServerTemplateForceTlsv11 = "disabled"
	ServerTemplateForceTlsv11Enabled  ServerTemplateForceTlsv11 = "enabled"
)

// Defines values for ServerTemplateForceTlsv12.
const (
	ServerTemplateForceTlsv12Disabled ServerTemplateForceTlsv12 = "disabled"
	ServerTemplateForceTlsv12Enabled  ServerTemplateForceTlsv12 = "enabled"
)

// Defines values for ServerTemplateForceTlsv13.
const (
	ServerTemplateForceTlsv13Disabled ServerTemplateForceTlsv13 = "disabled"
	ServerTemplateForceTlsv13Enabled  ServerTemplateForceTlsv13 = "enabled"
)

// Defines values for ServerTemplateLogProto.
const (
	ServerTemplateLogProtoLegacy     ServerTemplateLogProto = "legacy"
	ServerTemplateLogProtoOctetCount ServerTemplateLogProto = "octet-count"
)

// Defines values for ServerTemplateMaintenance.
const (
	ServerTemplateMaintenanceDisabled ServerTemplateMaintenance = "disabled"
	ServerTemplateMaintenanceEnabled  ServerTemplateMaintenance = "enabled"
)

// Defines values for ServerTemplateNoSslv3.
const (
	ServerTemplateNoSslv3Disabled ServerTemplateNoSslv3 = "disabled"
	ServerTemplateNoSslv3Enabled  ServerTemplateNoSslv3 = "enabled"
)

// Defines values for ServerTemplateNoTlsv10.
const (
	ServerTemplateNoTlsv10Disabled ServerTemplateNoTlsv10 = "disabled"
	ServerTemplateNoTlsv10Enabled  ServerTemplateNoTlsv10 = "enabled"
)

// Defines values for ServerTemplateNoTlsv11.
const (
	ServerTemplateNoTlsv11Disabled ServerTemplateNoTlsv11 = "disabled"
	ServerTemplateNoTlsv11Enabled  ServerTemplateNoTlsv11 = "enabled"
)

// Defines values for ServerTemplateNoTlsv12.
const (
	ServerTemplateNoTlsv12Disabled ServerTemplateNoTlsv12 = "disabled"
	ServerTemplateNoTlsv12Enabled  ServerTemplateNoTlsv12 = "enabled"
)

// Defines values for ServerTemplateNoTlsv13.
const (
	ServerTemplateNoTlsv13Disabled ServerTemplateNoTlsv13 = "disabled"
	ServerTemplateNoTlsv13Enabled  ServerTemplateNoTlsv13 = "enabled"
)

// Defines values for ServerTemplateNoVerifyhost.
const (
	ServerTemplateNoVerifyhostDisabled ServerTemplateNoVerifyhost = "disabled"
	ServerTemplateNoVerifyhostEnabled  ServerTemplateNoVerifyhost = "enabled"
)

// Defines values for ServerTemplateObserve.
const (
	ServerTemplateObserveLayer4 ServerTemplateObserve = "layer4"
	ServerTemplateObserveLayer7 ServerTemplateObserve = "layer7"
)

// Defines values for ServerTemplateOnError.
const (
	ServerTemplateOnErrorFailCheck   ServerTemplateOnError = "fail-check"
	ServerTemplateOnErrorFastinter   ServerTemplateOnError = "fastinter"
	ServerTemplateOnErrorMarkDown    ServerTemplateOnError = "mark-down"
	ServerTemplateOnErrorSuddenDeath ServerTemplateOnError = "sudden-death"
)

// Defines values for ServerTemplateOnMarkedDown.
const (
	ServerTemplateOnMarkedDownShutdownSessions ServerTemplateOnMarkedDown = "shutdown-sessions"
)

// Defines values for ServerTemplateOnMarkedUp.
const (
	ServerTemplateOnMarkedUpShutdownBackupSessions ServerTemplateOnMarkedUp = "shutdown-backup-sessions"
)

// Defines values for ServerTemplateProxyV2Options.
const (
	ServerTemplateProxyV2OptionsAuthority ServerTemplateProxyV2Options = "authority"
	ServerTemplateProxyV2OptionsCertCn    ServerTemplateProxyV2Options = "cert-cn"
	ServerTemplateProxyV2OptionsCertKey   ServerTemplateProxyV2Options = "cert-key"
	ServerTemplateProxyV2OptionsCertSig   ServerTemplateProxyV2Options = "cert-sig"
	ServerTemplateProxyV2OptionsCrc32c    ServerTemplateProxyV2Options = "crc32c"
	ServerTemplateProxyV2OptionsSsl       ServerTemplateProxyV2Options = "ssl"
	ServerTemplateProxyV2OptionsSslCipher ServerTemplateProxyV2Options = "ssl-cipher"
	ServerTemplateProxyV2OptionsUniqueId  ServerTemplateProxyV2Options = "unique-id"
)

// Defines values for ServerTemplateResolvePrefer.
const (
	ServerTemplateResolvePreferIpv4 ServerTemplateResolvePrefer = "ipv4"
	ServerTemplateResolvePreferIpv6 ServerTemplateResolvePrefer = "ipv6"
)

// Defines values for ServerTemplateSendProxy.
const (
	ServerTemplateSendProxyDisabled ServerTemplateSendProxy = "disabled"
	ServerTemplateSendProxyEnabled  ServerTemplateSendProxy = "enabled"
)

// Defines values for ServerTemplateSendProxyV2.
const (
	ServerTemplateSendProxyV2Disabled ServerTemplateSendProxyV2 = "disabled"
	ServerTemplateSendProxyV2Enabled  ServerTemplateSendProxyV2 = "enabled"
)

// Defines values for ServerTemplateSendProxyV2Ssl.
const (
	ServerTemplateSendProxyV2SslDisabled ServerTemplateSendProxyV2Ssl = "disabled"
	ServerTemplateSendProxyV2SslEnabled  ServerTemplateSendProxyV2Ssl = "enabled"
)

// Defines values for ServerTemplateSendProxyV2SslCn.
const (
	ServerTemplateSendProxyV2SslCnDisabled ServerTemplateSendProxyV2SslCn = "disabled"
	ServerTemplateSendProxyV2SslCnEnabled  ServerTemplateSendProxyV2SslCn = "enabled"
)

// Defines values for ServerTemplateSsl.
const (
	ServerTemplateSslDisabled ServerTemplateSsl = "disabled"
	ServerTemplateSslEnabled  ServerTemplateSsl = "enabled"
)

// Defines values for ServerTemplateSslMaxVer.
const (
	ServerTemplateSslMaxVerSSLv3  ServerTemplateSslMaxVer = "SSLv3"
	ServerTemplateSslMaxVerTLSv10 ServerTemplateSslMaxVer = "TLSv1.0"
	ServerTemplateSslMaxVerTLSv11 ServerTemplateSslMaxVer = "TLSv1.1"
	ServerTemplateSslMaxVerTLSv12 ServerTemplateSslMaxVer = "TLSv1.2"
	ServerTemplateSslMaxVerTLSv13 ServerTemplateSslMaxVer = "TLSv1.3"
)

// Defines values for ServerTemplateSslMinVer.
const (
	ServerTemplateSslMinVerSSLv3  ServerTemplateSslMinVer = "SSLv3"
	ServerTemplateSslMinVerTLSv10 ServerTemplateSslMinVer = "TLSv1.0"
	ServerTemplateSslMinVerTLSv11 ServerTemplateSslMinVer = "TLSv1.1"
	ServerTemplateSslMinVerTLSv12 ServerTemplateSslMinVer = "TLSv1.2"
	ServerTemplateSslMinVerTLSv13 ServerTemplateSslMinVer = "TLSv1.3"
)

// Defines values for ServerTemplateSslReuse.
const (
	ServerTemplateSslReuseDisabled ServerTemplateSslReuse = "disabled"
	ServerTemplateSslReuseEnabled  ServerTemplateSslReuse = "enabled"
)

// Defines values for ServerTemplateStick.
const (
	ServerTemplateStickDisabled ServerTemplateStick = "disabled"
	ServerTemplateStickEnabled  ServerTemplateStick = "enabled"
)

// Defines values for ServerTemplateTfo.
const (
	ServerTemplateTfoDisabled ServerTemplateTfo = "disabled"
	ServerTemplateTfoEnabled  ServerTemplateTfo = "enabled"
)

// Defines values for ServerTemplateTlsTickets.
const (
	ServerTemplateTlsTicketsDisabled ServerTemplateTlsTickets = "disabled"
	ServerTemplateTlsTicketsEnabled  ServerTemplateTlsTickets = "enabled"
)

// Defines values for ServerTemplateVerify.
const (
	ServerTemplateVerifyNone     ServerTemplateVerify = "none"
	ServerTemplateVerifyRequired ServerTemplateVerify = "required"
)

// Defines values for ServerTemplateWs.
const (
	ServerTemplateWsAuto ServerTemplateWs = "auto"
	ServerTemplateWsH1   ServerTemplateWs = "h1"
	ServerTemplateWsH2   ServerTemplateWs = "h2"
)

// Defines values for SiteFarmsCond.
const (
	SiteFarmsCondIf     SiteFarmsCond = "if"
	SiteFarmsCondUnless SiteFarmsCond = "unless"
)

// Defines values for SiteFarmsMode.
const (
	SiteFarmsModeHttp SiteFarmsMode = "http"
	SiteFarmsModeTcp  SiteFarmsMode = "tcp"
)

// Defines values for SiteFarmsUseAs.
const (
	SiteFarmsUseAsConditional SiteFarmsUseAs = "conditional"
	SiteFarmsUseAsDefault     SiteFarmsUseAs = "default"
)

// Defines values for SiteServiceHttpConnectionMode.
const (
	SiteServiceHttpConnectionModeForcedClose     SiteServiceHttpConnectionMode = "forced-close"
	SiteServiceHttpConnectionModeHttpKeepAlive   SiteServiceHttpConnectionMode = "http-keep-alive"
	SiteServiceHttpConnectionModeHttpServerClose SiteServiceHttpConnectionMode = "http-server-close"
	SiteServiceHttpConnectionModeHttpTunnel      SiteServiceHttpConnectionMode = "http-tunnel"
	SiteServiceHttpConnectionModeHttpclose       SiteServiceHttpConnectionMode = "httpclose"
)

// Defines values for SiteServiceMode.
const (
	SiteServiceModeHttp SiteServiceMode = "http"
	SiteServiceModeTcp  SiteServiceMode = "tcp"
)

// Defines values for SourceUsesrc.
const (
	SourceUsesrcAddress  SourceUsesrc = "address"
	SourceUsesrcClient   SourceUsesrc = "client"
	SourceUsesrcClientip SourceUsesrc = "clientip"
	SourceUsesrcHdrIp    SourceUsesrc = "hdr_ip"
)

// Defines values for SpoeAgentAsync.
const (
	SpoeAgentAsyncDisabled SpoeAgentAsync = "disabled"
	SpoeAgentAsyncEnabled  SpoeAgentAsync = "enabled"
)

// Defines values for SpoeAgentContinueOnError.
const (
	SpoeAgentContinueOnErrorEnabled SpoeAgentContinueOnError = "enabled"
)

// Defines values for SpoeAgentDontlogNormal.
const (
	SpoeAgentDontlogNormalDisabled SpoeAgentDontlogNormal = "disabled"
	SpoeAgentDontlogNormalEnabled  SpoeAgentDontlogNormal = "enabled"
)

// Defines values for SpoeAgentForceSetVar.
const (
	SpoeAgentForceSetVarEnabled SpoeAgentForceSetVar = "enabled"
)

// Defines values for SpoeAgentPipelining.
const (
	SpoeAgentPipeliningDisabled SpoeAgentPipelining = "disabled"
	SpoeAgentPipeliningEnabled  SpoeAgentPipelining = "enabled"
)

// Defines values for SpoeAgentSendFragPayload.
const (
	SpoeAgentSendFragPayloadDisabled SpoeAgentSendFragPayload = "disabled"
	SpoeAgentSendFragPayloadEnabled  SpoeAgentSendFragPayload = "enabled"
)

// Defines values for SpoeMessageEventCond.
const (
	SpoeMessageEventCondIf     SpoeMessageEventCond = "if"
	SpoeMessageEventCondUnless SpoeMessageEventCond = "unless"
)

// Defines values for SpoeMessageEventName.
const (
	SpoeMessageEventNameOnBackendHttpRequest  SpoeMessageEventName = "on-backend-http-request"
	SpoeMessageEventNameOnBackendTcpRequest   SpoeMessageEventName = "on-backend-tcp-request"
	SpoeMessageEventNameOnClientSession       SpoeMessageEventName = "on-client-session"
	SpoeMessageEventNameOnFrontendHttpRequest SpoeMessageEventName = "on-frontend-http-request"
	SpoeMessageEventNameOnFrontendTcpRequest  SpoeMessageEventName = "on-frontend-tcp-request"
	SpoeMessageEventNameOnHttpResponse        SpoeMessageEventName = "on-http-response"
	SpoeMessageEventNameOnServerSession       SpoeMessageEventName = "on-server-session"
	SpoeMessageEventNameOnTcpResponse         SpoeMessageEventName = "on-tcp-response"
)

// Defines values for SpoeTransactionStatus.
const (
	SpoeTransactionStatusFailed     SpoeTransactionStatus = "failed"
	SpoeTransactionStatusInProgress SpoeTransactionStatus = "in_progress"
	SpoeTransactionStatusSuccess    SpoeTransactionStatus = "success"
)

// Defines values for SslOptionsModeAsync.
const (
	SslOptionsModeAsyncDisabled SslOptionsModeAsync = "disabled"
	SslOptionsModeAsyncEnabled  SslOptionsModeAsync = "enabled"
)

// Defines values for SslOptionsServerVerify.
const (
	SslOptionsServerVerifyNone     SslOptionsServerVerify = "none"
	SslOptionsServerVerifyRequired SslOptionsServerVerify = "required"
)

// Defines values for StatsHttpRequestType.
const (
	StatsHttpRequestTypeAllow StatsHttpRequestType = "allow"
	StatsHttpRequestTypeAuth  StatsHttpRequestType = "auth"
	StatsHttpRequestTypeDeny  StatsHttpRequestType = "deny"
)

// Defines values for StatsOptionsStatsAdminCond.
const (
	StatsOptionsStatsAdminCondIf     StatsOptionsStatsAdminCond = "if"
	StatsOptionsStatsAdminCondUnless StatsOptionsStatsAdminCond = "unless"
)

// Defines values for StickRuleCond.
const (
	StickRuleCondIf     StickRuleCond = "if"
	StickRuleCondUnless StickRuleCond = "unless"
)

// Defines values for StickRuleType.
const (
	StickRuleTypeMatch         StickRuleType = "match"
	StickRuleTypeOn            StickRuleType = "on"
	StickRuleTypeStoreRequest  StickRuleType = "store-request"
	StickRuleTypeStoreResponse StickRuleType = "store-response"
)

// Defines values for StickTableFieldsField.
const (
	StickTableFieldsFieldBytesInCnt   StickTableFieldsField = "bytes_in_cnt"
	StickTableFieldsFieldBytesInRate  StickTableFieldsField = "bytes_in_rate"
	StickTableFieldsFieldBytesOutCnt  StickTableFieldsField = "bytes_out_cnt"
	StickTableFieldsFieldBytesOutRate StickTableFieldsField = "bytes_out_rate"
	StickTableFieldsFieldConnCnt      StickTableFieldsField = "conn_cnt"
	StickTableFieldsFieldConnCur      StickTableFieldsField = "conn_cur"
	StickTableFieldsFieldConnRate     StickTableFieldsField = "conn_rate"
	StickTableFieldsFieldGlitchCnt    StickTableFieldsField = "glitch_cnt"
	StickTableFieldsFieldGlitchRate   StickTableFieldsField = "glitch_rate"
	StickTableFieldsFieldGpc          StickTableFieldsField = "gpc"
	StickTableFieldsFieldGpc0         StickTableFieldsField = "gpc0"
	StickTableFieldsFieldGpc0Rate     StickTableFieldsField = "gpc0_rate"
	StickTableFieldsFieldGpc1         StickTableFieldsField = "gpc1"
	StickTableFieldsFieldGpc1Rate     StickTableFieldsField = "gpc1_rate"
	StickTableFieldsFieldGpcRate      StickTableFieldsField = "gpc_rate"
	StickTableFieldsFieldGpt          StickTableFieldsField = "gpt"
	StickTableFieldsFieldGpt0         StickTableFieldsField = "gpt0"
	StickTableFieldsFieldHttpErrCnt   StickTableFieldsField = "http_err_cnt"
	StickTableFieldsFieldHttpErrRate  StickTableFieldsField = "http_err_rate"
	StickTableFieldsFieldHttpFailCnt  StickTableFieldsField = "http_fail_cnt"
	StickTableFieldsFieldHttpFailRate StickTableFieldsField = "http_fail_rate"
	StickTableFieldsFieldHttpReqCnt   StickTableFieldsField = "http_req_cnt"
	StickTableFieldsFieldHttpReqRate  StickTableFieldsField = "http_req_rate"
	StickTableFieldsFieldServerId     StickTableFieldsField = "server_id"
	StickTableFieldsFieldSessCnt      StickTableFieldsField = "sess_cnt"
	StickTableFieldsFieldSessRate     StickTableFieldsField = "sess_rate"
)

// Defines values for StickTableFieldsType.
const (
	StickTableFieldsTypeCounter StickTableFieldsType = "counter"
	StickTableFieldsTypeRate    StickTableFieldsType = "rate"
)

// Defines values for StickTableType.
const (
	StickTableTypeBinary  StickTableType = "binary"
	StickTableTypeInteger StickTableType = "integer"
	StickTableTypeIp      StickTableType = "ip"
	StickTableTypeIpv6    StickTableType = "ipv6"
	StickTableTypeString  StickTableType = "string"
)

// Defines values for SyslogOutputLogFormat.
const (
	SyslogOutputLogFormatHttp           SyslogOutputLogFormat = "http"
	SyslogOutputLogFormatHttpCLF        SyslogOutputLogFormat = "httpCLF"
	SyslogOutputLogFormatHttps          SyslogOutputLogFormat = "https"
	SyslogOutputLogFormatTcp            SyslogOutputLogFormat = "tcp"
	SyslogOutputLogFormatTcpExtended    SyslogOutputLogFormat = "tcp-extended"
	SyslogOutputLogFormatTcpExtendedSsl SyslogOutputLogFormat = "tcp-extended-ssl"
)

// Defines values for SyslogOutputProtocol.
const (
	SyslogOutputProtocolTcp SyslogOutputProtocol = "tcp"
	SyslogOutputProtocolUdp SyslogOutputProtocol = "udp"
)

// Defines values for TableType.
const (
	TableTypeBinary  TableType = "binary"
	TableTypeInteger TableType = "integer"
	TableTypeIp      TableType = "ip"
	TableTypeString  TableType = "string"
)

// Defines values for TcpCheckAction.
const (
	TcpCheckActionComment      TcpCheckAction = "comment"
	TcpCheckActionConnect      TcpCheckAction = "connect"
	TcpCheckActionExpect       TcpCheckAction = "expect"
	TcpCheckActionSend         TcpCheckAction = "send"
	TcpCheckActionSendBinary   TcpCheckAction = "send-binary"
	TcpCheckActionSendBinaryLf TcpCheckAction = "send-binary-lf"
	TcpCheckActionSendLf       TcpCheckAction = "send-lf"
	TcpCheckActionSetVar       TcpCheckAction = "set-var"
	TcpCheckActionSetVarFmt    TcpCheckAction = "set-var-fmt"
	TcpCheckActionUnsetVar     TcpCheckAction = "unset-var"
)

// Defines values for TcpCheckErrorStatus.
const (
	TcpCheckErrorStatusL4CON TcpCheckErrorStatus = "L4CON"
	TcpCheckErrorStatusL6RSP TcpCheckErrorStatus = "L6RSP"
	TcpCheckErrorStatusL7OKC TcpCheckErrorStatus = "L7OKC"
	TcpCheckErrorStatusL7RSP TcpCheckErrorStatus = "L7RSP"
	TcpCheckErrorStatusL7STS TcpCheckErrorStatus = "L7STS"
)

// Defines values for TcpCheckMatch.
const (
	TcpCheckMatchBinary   TcpCheckMatch = "binary"
	TcpCheckMatchBinaryLf TcpCheckMatch = "binary-lf"
	TcpCheckMatchRbinary  TcpCheckMatch = "rbinary"
	TcpCheckMatchRstring  TcpCheckMatch = "rstring"
	TcpCheckMatchString   TcpCheckMatch = "string"
	TcpCheckMatchStringLf TcpCheckMatch = "string-lf"
)

// Defines values for TcpCheckOkStatus.
const (
	TcpCheckOkStatusL4OK  TcpCheckOkStatus = "L4OK"
	TcpCheckOkStatusL6OK  TcpCheckOkStatus = "L6OK"
	TcpCheckOkStatusL7OK  TcpCheckOkStatus = "L7OK"
	TcpCheckOkStatusL7OKC TcpCheckOkStatus = "L7OKC"
)

// Defines values for TcpCheckToutStatus.
const (
	TcpCheckToutStatusL4TOUT TcpCheckToutStatus = "L4TOUT"
	TcpCheckToutStatusL6TOUT TcpCheckToutStatus = "L6TOUT"
	TcpCheckToutStatusL7TOUT TcpCheckToutStatus = "L7TOUT"
)

// Defines values for TcpRequestRuleAction.
const (
	TcpRequestRuleActionAccept             TcpRequestRuleAction = "accept"
	TcpRequestRuleActionAttachSrv          TcpRequestRuleAction = "attach-srv"
	TcpRequestRuleActionCapture            TcpRequestRuleAction = "capture"
	TcpRequestRuleActionDoResolve          TcpRequestRuleAction = "do-resolve"
	TcpRequestRuleActionExpectNetscalerCip TcpRequestRuleAction = "expect-netscaler-cip"
	TcpRequestRuleActionExpectProxy        TcpRequestRuleAction = "expect-proxy"
	TcpRequestRuleActionLua                TcpRequestRuleAction = "lua"
	TcpRequestRuleActionReject             TcpRequestRuleAction = "reject"
	TcpRequestRuleActionScAddGpc           TcpRequestRuleAction = "sc-add-gpc"
	TcpRequestRuleActionScIncGpc           TcpRequestRuleAction = "sc-inc-gpc"
	TcpRequestRuleActionScIncGpc0          TcpRequestRuleAction = "sc-inc-gpc0"
	TcpRequestRuleActionScIncGpc1          TcpRequestRuleAction = "sc-inc-gpc1"
	TcpRequestRuleActionScSetGpt           TcpRequestRuleAction = "sc-set-gpt"
	TcpRequestRuleActionScSetGpt0          TcpRequestRuleAction = "sc-set-gpt0"
	TcpRequestRuleActionScSetGptstr        TcpRequestRuleAction = "sc-set-gptstr"
	TcpRequestRuleActionSendSpoeGroup      TcpRequestRuleAction = "send-spoe-group"
	TcpRequestRuleActionSetBandwidthLimit  TcpRequestRuleAction = "set-bandwidth-limit"
	TcpRequestRuleActionSetBcMark          TcpRequestRuleAction = "set-bc-mark"
	TcpRequestRuleActionSetBcTos           TcpRequestRuleAction = "set-bc-tos"
	TcpRequestRuleActionSetDst             TcpRequestRuleAction = "set-dst"
	TcpRequestRuleActionSetDstPort         TcpRequestRuleAction = "set-dst-port"
	TcpRequestRuleActionSetFcMark          TcpRequestRuleAction = "set-fc-mark"
	TcpRequestRuleActionSetFcTos           TcpRequestRuleAction = "set-fc-tos"
	TcpRequestRuleActionSetLogLevel        TcpRequestRuleAction = "set-log-level"
	TcpRequestRuleActionSetMark            TcpRequestRuleAction = "set-mark"
	TcpRequestRuleActionSetNice            TcpRequestRuleAction = "set-nice"
	TcpRequestRuleActionSetPriorityClass   TcpRequestRuleAction = "set-priority-class"
	TcpRequestRuleActionSetPriorityOffset  TcpRequestRuleAction = "set-priority-offset"
	TcpRequestRuleActionSetSrc             TcpRequestRuleAction = "set-src"
	TcpRequestRuleActionSetSrcPort         TcpRequestRuleAction = "set-src-port"
	TcpRequestRuleActionSetTos             TcpRequestRuleAction = "set-tos"
	TcpRequestRuleActionSetVar             TcpRequestRuleAction = "set-var"
	TcpRequestRuleActionSetVarFmt          TcpRequestRuleAction = "set-var-fmt"
	TcpRequestRuleActionSilentDrop         TcpRequestRuleAction = "silent-drop"
	TcpRequestRuleActionSwitchMode         TcpRequestRuleAction = "switch-mode"
	TcpRequestRuleActionTrackSc            TcpRequestRuleAction = "track-sc"
	TcpRequestRuleActionUnsetVar           TcpRequestRuleAction = "unset-var"
	TcpRequestRuleActionUseService         TcpRequestRuleAction = "use-service"
)

// Defines values for TcpRequestRuleCond.
const (
	TcpRequestRuleCondIf     TcpRequestRuleCond = "if"
	TcpRequestRuleCondUnless TcpRequestRuleCond = "unless"
)

// Defines values for TcpRequestRuleLogLevel.
const (
	TcpRequestRuleLogLevelAlert   TcpRequestRuleLogLevel = "alert"
	TcpRequestRuleLogLevelCrit    TcpRequestRuleLogLevel = "crit"
	TcpRequestRuleLogLevelDebug   TcpRequestRuleLogLevel = "debug"
	TcpRequestRuleLogLevelEmerg   TcpRequestRuleLogLevel = "emerg"
	TcpRequestRuleLogLevelErr     TcpRequestRuleLogLevel = "err"
	TcpRequestRuleLogLevelInfo    TcpRequestRuleLogLevel = "info"
	TcpRequestRuleLogLevelNotice  TcpRequestRuleLogLevel = "notice"
	TcpRequestRuleLogLevelSilent  TcpRequestRuleLogLevel = "silent"
	TcpRequestRuleLogLevelWarning TcpRequestRuleLogLevel = "warning"
)

// Defines values for TcpRequestRuleResolveProtocol.
const (
	TcpRequestRuleResolveProtocolIpv4 TcpRequestRuleResolveProtocol = "ipv4"
	TcpRequestRuleResolveProtocolIpv6 TcpRequestRuleResolveProtocol = "ipv6"
)

// Defines values for TcpRequestRuleType.
const (
	TcpRequestRuleTypeConnection   TcpRequestRuleType = "connection"
	TcpRequestRuleTypeContent      TcpRequestRuleType = "content"
	TcpRequestRuleTypeInspectDelay TcpRequestRuleType = "inspect-delay"
	TcpRequestRuleTypeSession      TcpRequestRuleType = "session"
)

// Defines values for TcpResponseRuleAction.
const (
	TcpResponseRuleActionAccept            TcpResponseRuleAction = "accept"
	TcpResponseRuleActionClose             TcpResponseRuleAction = "close"
	TcpResponseRuleActionLua               TcpResponseRuleAction = "lua"
	TcpResponseRuleActionReject            TcpResponseRuleAction = "reject"
	TcpResponseRuleActionScAddGpc          TcpResponseRuleAction = "sc-add-gpc"
	TcpResponseRuleActionScIncGpc          TcpResponseRuleAction = "sc-inc-gpc"
	TcpResponseRuleActionScIncGpc0         TcpResponseRuleAction = "sc-inc-gpc0"
	TcpResponseRuleActionScIncGpc1         TcpResponseRuleAction = "sc-inc-gpc1"
	TcpResponseRuleActionScSetGpt          TcpResponseRuleAction = "sc-set-gpt"
	TcpResponseRuleActionScSetGpt0         TcpResponseRuleAction = "sc-set-gpt0"
	TcpResponseRuleActionScSetGptstr       TcpResponseRuleAction = "sc-set-gptstr"
	TcpResponseRuleActionSendSpoeGroup     TcpResponseRuleAction = "send-spoe-group"
	TcpResponseRuleActionSetBandwidthLimit TcpResponseRuleAction = "set-bandwidth-limit"
	TcpResponseRuleActionSetFcMark         TcpResponseRuleAction = "set-fc-mark"
	TcpResponseRuleActionSetFcTos          TcpResponseRuleAction = "set-fc-tos"
	TcpResponseRuleActionSetLogLevel       TcpResponseRuleAction = "set-log-level"
	TcpResponseRuleActionSetMark           TcpResponseRuleAction = "set-mark"
	TcpResponseRuleActionSetNice           TcpResponseRuleAction = "set-nice"
	TcpResponseRuleActionSetTos            TcpResponseRuleAction = "set-tos"
	TcpResponseRuleActionSetVar            TcpResponseRuleAction = "set-var"
	TcpResponseRuleActionSetVarFmt         TcpResponseRuleAction = "set-var-fmt"
	TcpResponseRuleActionSilentDrop        TcpResponseRuleAction = "silent-drop"
	TcpResponseRuleActionUnsetVar          TcpResponseRuleAction = "unset-var"
)

// Defines values for TcpResponseRuleCond.
const (
	TcpResponseRuleCondIf     TcpResponseRuleCond = "if"
	TcpResponseRuleCondUnless TcpResponseRuleCond = "unless"
)

// Defines values for TcpResponseRuleLogLevel.
const (
	TcpResponseRuleLogLevelAlert   TcpResponseRuleLogLevel = "alert"
	TcpResponseRuleLogLevelCrit    TcpResponseRuleLogLevel = "crit"
	TcpResponseRuleLogLevelDebug   TcpResponseRuleLogLevel = "debug"
	TcpResponseRuleLogLevelEmerg   TcpResponseRuleLogLevel = "emerg"
	TcpResponseRuleLogLevelErr     TcpResponseRuleLogLevel = "err"
	TcpResponseRuleLogLevelInfo    TcpResponseRuleLogLevel = "info"
	TcpResponseRuleLogLevelNotice  TcpResponseRuleLogLevel = "notice"
	TcpResponseRuleLogLevelSilent  TcpResponseRuleLogLevel = "silent"
	TcpResponseRuleLogLevelWarning TcpResponseRuleLogLevel = "warning"
)

// Defines values for TcpResponseRuleType.
const (
	TcpResponseRuleTypeContent      TcpResponseRuleType = "content"
	TcpResponseRuleTypeInspectDelay TcpResponseRuleType = "inspect-delay"
)

// Defines values for TransactionStatus.
const (
	TransactionStatusFailed     TransactionStatus = "failed"
	TransactionStatusInProgress TransactionStatus = "in_progress"
	TransactionStatusOutdated   TransactionStatus = "outdated"
	TransactionStatusSuccess    TransactionStatus = "success"
)

// Defines values for TuneLuaOptionsLogLoggers.
const (
	TuneLuaOptionsLogLoggersDisabled TuneLuaOptionsLogLoggers = "disabled"
	TuneLuaOptionsLogLoggersEnabled  TuneLuaOptionsLogLoggers = "enabled"
)

// Defines values for TuneLuaOptionsLogStderr.
const (
	TuneLuaOptionsLogStderrAuto     TuneLuaOptionsLogStderr = "auto"
	TuneLuaOptionsLogStderrDisabled TuneLuaOptionsLogStderr = "disabled"
	TuneLuaOptionsLogStderrEnabled  TuneLuaOptionsLogStderr = "enabled"
)

// Defines values for TuneOptionsAppletZeroCopyForwarding.
const (
	TuneOptionsAppletZeroCopyForwardingDisabled TuneOptionsAppletZeroCopyForwarding = "disabled"
	TuneOptionsAppletZeroCopyForwardingEnabled  TuneOptionsAppletZeroCopyForwarding = "enabled"
)

// Defines values for TuneOptionsFdEdgeTriggered.
const (
	TuneOptionsFdEdgeTriggeredDisabled TuneOptionsFdEdgeTriggered = "disabled"
	TuneOptionsFdEdgeTriggeredEnabled  TuneOptionsFdEdgeTriggered = "enabled"
)

// Defines values for TuneOptionsH1ZeroCopyFwdRecv.
const (
	TuneOptionsH1ZeroCopyFwdRecvDisabled TuneOptionsH1ZeroCopyFwdRecv = "disabled"
	TuneOptionsH1ZeroCopyFwdRecvEnabled  TuneOptionsH1ZeroCopyFwdRecv = "enabled"
)

// Defines values for TuneOptionsH1ZeroCopyFwdSend.
const (
	TuneOptionsH1ZeroCopyFwdSendDisabled TuneOptionsH1ZeroCopyFwdSend = "disabled"
	TuneOptionsH1ZeroCopyFwdSendEnabled  TuneOptionsH1ZeroCopyFwdSend = "enabled"
)

// Defines values for TuneOptionsH2ZeroCopyFwdSend.
const (
	TuneOptionsH2ZeroCopyFwdSendDisabled TuneOptionsH2ZeroCopyFwdSend = "disabled"
	TuneOptionsH2ZeroCopyFwdSendEnabled  TuneOptionsH2ZeroCopyFwdSend = "enabled"
)

// Defines values for TuneOptionsIdlePoolShared.
const (
	TuneOptionsIdlePoolSharedDisabled TuneOptionsIdlePoolShared = "disabled"
	TuneOptionsIdlePoolSharedEnabled  TuneOptionsIdlePoolShared = "enabled"
)

// Defines values for TuneOptionsListenerDefaultShards.
const (
	TuneOptionsListenerDefaultShardsByGroup   TuneOptionsListenerDefaultShards = "by-group"
	TuneOptionsListenerDefaultShardsByProcess TuneOptionsListenerDefaultShards = "by-process"
	TuneOptionsListenerDefaultShardsByThread  TuneOptionsListenerDefaultShards = "by-thread"
)

// Defines values for TuneOptionsListenerMultiQueue.
const (
	TuneOptionsListenerMultiQueueDisabled TuneOptionsListenerMultiQueue = "disabled"
	TuneOptionsListenerMultiQueueEnabled  TuneOptionsListenerMultiQueue = "enabled"
)

// Defines values for TuneOptionsPtZeroCopyForwarding.
const (
	TuneOptionsPtZeroCopyForwardingDisabled TuneOptionsPtZeroCopyForwarding = "disabled"
	TuneOptionsPtZeroCopyForwardingEnabled  TuneOptionsPtZeroCopyForwarding = "enabled"
)

// Defines values for TuneOptionsSchedLowLatency.
const (
	TuneOptionsSchedLowLatencyDisabled TuneOptionsSchedLowLatency = "disabled"
	TuneOptionsSchedLowLatencyEnabled  TuneOptionsSchedLowLatency = "enabled"
)

// Defines values for TuneQuicOptionsSocketOwner.
const (
	TuneQuicOptionsSocketOwnerConnection TuneQuicOptionsSocketOwner = "connection"
	TuneQuicOptionsSocketOwnerListener   TuneQuicOptionsSocketOwner = "listener"
)

// Defines values for TuneQuicOptionsZeroCopyFwdSend.
const (
	TuneQuicOptionsZeroCopyFwdSendDisabled TuneQuicOptionsZeroCopyFwdSend = "disabled"
	TuneQuicOptionsZeroCopyFwdSendEnabled  TuneQuicOptionsZeroCopyFwdSend = "enabled"
)

// Defines values for TuneSslOptionsKeylog.
const (
	TuneSslOptionsKeylogDisabled TuneSslOptionsKeylog = "disabled"
	TuneSslOptionsKeylogEnabled  TuneSslOptionsKeylog = "enabled"
)

// Defines values for UdpLbAdvCheck.
const (
	UdpLbAdvCheckTcp UdpLbAdvCheck = "tcp"
	UdpLbAdvCheckUdp UdpLbAdvCheck = "udp"
)

// Defines values for UdpLbBaseAdvCheck.
const (
	UdpLbBaseAdvCheckTcp UdpLbBaseAdvCheck = "tcp"
	UdpLbBaseAdvCheckUdp UdpLbBaseAdvCheck = "udp"
)

// Defines values for VrrpAuthenticationType.
const (
	VrrpAuthenticationTypeIPSecAuthenticationHeader VrrpAuthenticationType = "IPSecAuthenticationHeader"
	VrrpAuthenticationTypePass                      VrrpAuthenticationType = "pass"
)

// Defines values for VrrpInstanceState.
const (
	VrrpInstanceStateBackup VrrpInstanceState = "backup"
	VrrpInstanceStateMaster VrrpInstanceState = "master"
)

// Defines values for WafBodyRuleCond.
const (
	WafBodyRuleCondIf     WafBodyRuleCond = "if"
	WafBodyRuleCondUnless WafBodyRuleCond = "unless"
)

// Defines values for WafBodyRuleType.
const (
	WafBodyRuleTypeAllow    WafBodyRuleType = "allow"
	WafBodyRuleTypeDeny     WafBodyRuleType = "deny"
	WafBodyRuleTypeSetVar   WafBodyRuleType = "set-var"
	WafBodyRuleTypeUnsetVar WafBodyRuleType = "unset-var"
)

// Defines values for DeleteClusterParamsConfiguration.
const (
	DeleteClusterParamsConfigurationKeep DeleteClusterParamsConfiguration = "keep"
)

// Defines values for PostClusterParamsConfiguration.
const (
	PostClusterParamsConfigurationKeep PostClusterParamsConfiguration = "keep"
)

// Defines values for GetAllSpoeTransactionParamsStatus.
const (
	GetAllSpoeTransactionParamsStatusFailed     GetAllSpoeTransactionParamsStatus = "failed"
	GetAllSpoeTransactionParamsStatusInProgress GetAllSpoeTransactionParamsStatus = "in_progress"
)

// Defines values for GetStatsParamsType.
const (
	GetStatsParamsTypeBackend  GetStatsParamsType = "backend"
	GetStatsParamsTypeFrontend GetStatsParamsType = "frontend"
	GetStatsParamsTypeServer   GetStatsParamsType = "server"
)

// Defines values for GetTransactionsParamsStatus.
const (
	GetTransactionsParamsStatusFailed     GetTransactionsParamsStatus = "failed"
	GetTransactionsParamsStatusInProgress GetTransactionsParamsStatus = "in_progress"
)

// Defines values for GetAllKeepalivedTransactionParamsStatus.
const (
	GetAllKeepalivedTransactionParamsStatusFailed     GetAllKeepalivedTransactionParamsStatus = "failed"
	GetAllKeepalivedTransactionParamsStatusInProgress GetAllKeepalivedTransactionParamsStatus = "in_progress"
)

// Acl The use of Access Control Lists (ACL) provides a flexible solution to perform
// content switching and generally to take decisions based on content extracted
// from the request, the response or any environmental status.
type Acl struct {
	AclName   string  `json:"acl_name"`
	Criterion string  `json:"criterion"`
	Value     *string `json:"value,omitempty"`
}

// AclFile ACL File
type AclFile struct {
	Description *string `json:"description,omitempty"`
	Id          *string `json:"id,omitempty"`
	StorageName *string `json:"storage_name,omitempty"`
}

// AclFileEntry One ACL File Entry
type AclFileEntry struct {
	Id    *string `json:"id,omitempty"`
	Value *string `json:"value,omitempty"`
}

// AclFiles Array of runtime acl files
type AclFiles = []AclFile

// AclFilesEntries Array of entries of one runtime acl file
type AclFilesEntries = []AclFileEntry

// Acls HAProxy ACL lines array (corresponds to acl directives)
type Acls = []Acl

// Action An Action to start, stop, reload, restart or check a service.
type Action struct {
	Error *string `json:"error,omitempty"`
	Id    *string `json:"id,omitempty"`

	// Logs Logs emitted by the service. Optional.
	Logs      *string          `json:"logs,omitempty"`
	Operation *ActionOperation `json:"operation,omitempty"`
	Service   *ActionService   `json:"service,omitempty"`
	Success   *bool            `json:"success,omitempty"`
}

// ActionOperation defines model for Action.Operation.
type ActionOperation string

// ActionService defines model for Action.Service.
type ActionService string

// Actions List of actions
type Actions = []Action

// AlohaAction defines model for aloha_action.
type AlohaAction struct {
	ApiVersion string              `json:"api_version"`
	BaseUrl    string              `json:"base_url"`
	ConfigHash *string             `json:"config_hash,omitempty"`
	Id         *string             `json:"id,omitempty"`
	Password   string              `json:"password"`
	Response   *string             `json:"response,omitempty"`
	Success    *AlohaActionSuccess `json:"success,omitempty"`
	Type       AlohaActionType     `json:"type"`
	Username   string              `json:"username"`
}

// AlohaActionSuccess defines model for AlohaAction.Success.
type AlohaActionSuccess string

// AlohaActionType defines model for AlohaAction.Type.
type AlohaActionType string

// AlohaActions List of ALOHA Actions executed
type AlohaActions = []AlohaAction

// AwsFilters defines model for awsFilters.
type AwsFilters struct {
	// Key Key to use as filter, using the format specified at https://docs.aws.amazon.com/cli/latest/reference/ec2/describe-instances.html#options
	Key string `json:"key"`

	// Value Value of the filter to use
	Value string `json:"value"`
}

// AwsRegion AWS region configuration
type AwsRegion struct {
	// AccessKeyId AWS Access Key ID.
	AccessKeyId *string `json:"access_key_id,omitempty"`

	// Allowlist Specify the AWS filters used to filter the EC2 instances to add
	Allowlist *[]AwsFilters `json:"allowlist,omitempty"`

	// Denylist Specify the AWS filters used to filter the EC2 instances to ignore
	Denylist    *[]AwsFilters `json:"denylist,omitempty"`
	Description *string       `json:"description,omitempty"`
	Enabled     bool          `json:"enabled"`

	// Id Auto generated ID.
	Id *string `json:"id"`

	// Ipv4Address Select which IPv4 address the Service Discovery has to use for the backend server entry
	Ipv4Address AwsRegionIpv4Address `json:"ipv4_address"`
	Name        string               `json:"name"`
	Region      string               `json:"region"`

	// RetryTimeout Duration in seconds in-between data pulling requests to the AWS region
	RetryTimeout int `json:"retry_timeout"`

	// SecretAccessKey AWS Secret Access Key.
	SecretAccessKey            *string                         `json:"secret_access_key,omitempty"`
	ServerParams               *ServerParams                   `json:"server_params,omitempty"`
	ServerSlotsBase            *int                            `json:"server_slots_base,omitempty"`
	ServerSlotsGrowthIncrement *int                            `json:"server_slots_growth_increment,omitempty"`
	ServerSlotsGrowthType      *AwsRegionServerSlotsGrowthType `json:"server_slots_growth_type,omitempty"`
	ServerSlotsUseRuntime      *bool                           `json:"server_slots_use_runtime,omitempty"`
}

// AwsRegionIpv4Address Select which IPv4 address the Service Discovery has to use for the backend server entry
type AwsRegionIpv4Address string

// AwsRegionServerSlotsGrowthType defines model for AwsRegion.ServerSlotsGrowthType.
type AwsRegionServerSlotsGrowthType string

// AwsRegions AWS regions array
type AwsRegions = []AwsRegion

// Backend defines model for backend.
type Backend struct {
	Abortonclose              *BackendAbortonclose              `json:"abortonclose,omitempty"`
	AcceptInvalidHttpResponse *BackendAcceptInvalidHttpResponse `json:"accept_invalid_http_response,omitempty"`

	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList          *Acls              `json:"acl_list,omitempty"`
	AdvCheck         *BackendAdvCheck   `json:"adv_check,omitempty"`
	Allbackups       *BackendAllbackups `json:"allbackups,omitempty"`
	Balance          *Balance           `json:"balance,omitempty"`
	CheckTimeout     *int               `json:"check_timeout"`
	Checkcache       *BackendCheckcache `json:"checkcache,omitempty"`
	Compression      *Compression       `json:"compression,omitempty"`
	ConnectTimeout   *int               `json:"connect_timeout"`
	Cookie           *Cookie            `json:"cookie,omitempty"`
	DefaultServer    *DefaultServer     `json:"default_server,omitempty"`
	Description      *string            `json:"description,omitempty"`
	Disabled         *bool              `json:"disabled,omitempty"`
	DynamicCookieKey *string            `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert           `json:"email_alert,omitempty"`
	Enabled                  *bool                 `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile          `json:"error_files,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles         `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc             `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc             `json:"errorloc303,omitempty"`
	ExternalCheck            *BackendExternalCheck `json:"external_check,omitempty"`
	ExternalCheckCommand     *string               `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string               `json:"external_check_path,omitempty"`

	// FilterList HAProxy filters array (corresponds to filter directive)
	FilterList *Filters `json:"filter_list,omitempty"`

	// BackendForcePersist This field is deprecated in favor of force_persist_list, and will be removed in a future release
	BackendForcePersist *struct {
		Cond     BackendForcePersistCond `json:"cond"`
		CondTest string                  `json:"cond_test"`
	} `json:"force_persist,omitempty"`
	ForcePersistList *[]struct {
		Cond     BackendForcePersistListCond `json:"cond"`
		CondTest string                      `json:"cond_test"`
	} `json:"force_persist_list,omitempty"`
	Forwardfor              *Forwardfor                     `json:"forwardfor,omitempty"`
	From                    *string                         `json:"from,omitempty"`
	Fullconn                *int                            `json:"fullconn"`
	Guid                    *string                         `json:"guid,omitempty"`
	H1CaseAdjustBogusServer *BackendH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor       *int                            `json:"hash_balance_factor"`
	HashType                *HashType                       `json:"hash_type,omitempty"`
	HttpBufferRequest       *BackendHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpNoDelay             *BackendHttpNoDelay             `json:"http-no-delay,omitempty"`
	HttpUseHtx              *BackendHttpUseHtx              `json:"http-use-htx,omitempty"`

	// HttpAfterResponseRuleList HAProxy HTTP after response rules array (corresponds to http-after-response directives)
	HttpAfterResponseRuleList *HttpAfterResponseRules    `json:"http_after_response_rule_list,omitempty"`
	HttpCheckList             *HttpChecks                `json:"http_check_list,omitempty"`
	HttpConnectionMode        *BackendHttpConnectionMode `json:"http_connection_mode,omitempty"`

	// HttpErrorRuleList HAProxy HTTP error rules array (corresponds to http-error directives)
	HttpErrorRuleList    *HttpErrorRules              `json:"http_error_rule_list,omitempty"`
	HttpKeepAliveTimeout *int                         `json:"http_keep_alive_timeout"`
	HttpPretendKeepalive *BackendHttpPretendKeepalive `json:"http_pretend_keepalive,omitempty"`
	HttpProxy            *BackendHttpProxy            `json:"http_proxy,omitempty"`

	// HttpRequestRuleList HAProxy HTTP request rules array (corresponds to http-request directives)
	HttpRequestRuleList *HttpRequestRules `json:"http_request_rule_list,omitempty"`
	HttpRequestTimeout  *int              `json:"http_request_timeout"`

	// HttpResponseRuleList HAProxy HTTP response rules array (corresponds to http-response directives)
	HttpResponseRuleList    *HttpResponseRules              `json:"http_response_rule_list,omitempty"`
	HttpRestrictReqHdrNames *BackendHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse               *BackendHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader      *string                         `json:"http_send_name_header"`
	HttpchkParams           *HttpchkParams                  `json:"httpchk_params,omitempty"`
	Id                      *int                            `json:"id"`

	// BackendIgnorePersist This field is deprecated in favor of ignore_persist_list, and will be removed in a future release
	BackendIgnorePersist *struct {
		Cond     BackendIgnorePersistCond `json:"cond"`
		CondTest string                   `json:"cond_test"`
	} `json:"ignore_persist,omitempty"`
	IgnorePersistList *[]struct {
		Cond     BackendIgnorePersistListCond `json:"cond"`
		CondTest string                       `json:"cond_test"`
	} `json:"ignore_persist_list,omitempty"`
	IndependentStreams      *BackendIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile *BackendLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogHealthChecks         *BackendLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogTag                  *string                         `json:"log_tag,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList       *LogTargets              `json:"log_target_list,omitempty"`
	MaxKeepAliveQueue   *int                     `json:"max_keep_alive_queue"`
	Mode                *BackendMode             `json:"mode,omitempty"`
	MysqlCheckParams    *MysqlCheckParams        `json:"mysql_check_params,omitempty"`
	Name                string                   `json:"name"`
	Nolinger            *BackendNolinger         `json:"nolinger,omitempty"`
	Originalto          *Originalto              `json:"originalto,omitempty"`
	Persist             *BackendPersist          `json:"persist,omitempty"`
	PersistRule         *PersistRule             `json:"persist_rule,omitempty"`
	PgsqlCheckParams    *PgsqlCheckParams        `json:"pgsql_check_params,omitempty"`
	PreferLastServer    *BackendPreferLastServer `json:"prefer_last_server,omitempty"`
	QueueTimeout        *int                     `json:"queue_timeout"`
	Redispatch          *Redispatch              `json:"redispatch,omitempty"`
	Retries             *int                     `json:"retries"`
	RetryOn             *string                  `json:"retry_on,omitempty"`
	ServerFinTimeout    *int                     `json:"server_fin_timeout"`
	ServerStateFileName *string                  `json:"server_state_file_name,omitempty"`

	// ServerSwitchingRuleList HAProxy backend server switching rules array (corresponds to use-server directives)
	ServerSwitchingRuleList *ServerSwitchingRules      `json:"server_switching_rule_list,omitempty"`
	ServerTemplates         *map[string]ServerTemplate `json:"server_templates,omitempty"`
	ServerTimeout           *int                       `json:"server_timeout"`
	Servers                 *map[string]Server         `json:"servers,omitempty"`
	SmtpchkParams           *SmtpchkParams             `json:"smtpchk_params,omitempty"`
	Source                  *Source                    `json:"source,omitempty"`
	SpliceAuto              *BackendSpliceAuto         `json:"splice_auto,omitempty"`
	SpliceRequest           *BackendSpliceRequest      `json:"splice_request,omitempty"`
	SpliceResponse          *BackendSpliceResponse     `json:"splice_response,omitempty"`
	SpopCheck               *BackendSpopCheck          `json:"spop_check,omitempty"`
	Srvtcpka                *BackendSrvtcpka           `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt             *int                       `json:"srvtcpka_cnt"`
	SrvtcpkaIdle            *int                       `json:"srvtcpka_idle"`
	SrvtcpkaIntvl           *int                       `json:"srvtcpka_intvl"`
	StatsOptions            *StatsOptions              `json:"stats_options,omitempty"`

	// StickRuleList HAProxy backend stick rules array (corresponds to stick store-request, stick match, stick on, stick store-response)
	StickRuleList    *StickRules       `json:"stick_rule_list,omitempty"`
	StickTable       *ConfigStickTable `json:"stick_table,omitempty"`
	TarpitTimeout    *int              `json:"tarpit_timeout"`
	TcpCheckRuleList *TcpChecks        `json:"tcp_check_rule_list,omitempty"`

	// TcpRequestRuleList HAProxy TCP request rules array (corresponds to tcp-request directive)
	TcpRequestRuleList *TcpRequestRules `json:"tcp_request_rule_list,omitempty"`

	// TcpResponseRuleList HAProxy TCP response rules array (corresponds to tcp-response directive)
	TcpResponseRuleList *TcpResponseRules       `json:"tcp_response_rule_list,omitempty"`
	TcpSmartConnect     *BackendTcpSmartConnect `json:"tcp_smart_connect,omitempty"`
	Tcpka               *BackendTcpka           `json:"tcpka,omitempty"`
	Transparent         *BackendTransparent     `json:"transparent,omitempty"`
	TunnelTimeout       *int                    `json:"tunnel_timeout"`
	UseFcgiApp          *string                 `json:"use_fcgi_app,omitempty"`
	WafBodyRuleList     *WafBodyRules           `json:"waf_body_rule_list,omitempty"`
}

// BackendAbortonclose defines model for Backend.Abortonclose.
type BackendAbortonclose string

// BackendAcceptInvalidHttpResponse defines model for Backend.AcceptInvalidHttpResponse.
type BackendAcceptInvalidHttpResponse string

// BackendAdvCheck defines model for Backend.AdvCheck.
type BackendAdvCheck string

// BackendAllbackups defines model for Backend.Allbackups.
type BackendAllbackups string

// BackendCheckcache defines model for Backend.Checkcache.
type BackendCheckcache string

// BackendExternalCheck defines model for Backend.ExternalCheck.
type BackendExternalCheck string

// BackendForcePersistCond defines model for Backend.ForcePersist.Cond.
type BackendForcePersistCond string

// BackendForcePersistListCond defines model for Backend.ForcePersistList.Cond.
type BackendForcePersistListCond string

// BackendH1CaseAdjustBogusServer defines model for Backend.H1CaseAdjustBogusServer.
type BackendH1CaseAdjustBogusServer string

// BackendHttpBufferRequest defines model for Backend.HttpBufferRequest.
type BackendHttpBufferRequest string

// BackendHttpNoDelay defines model for Backend.HttpNoDelay.
type BackendHttpNoDelay string

// BackendHttpUseHtx defines model for Backend.HttpUseHtx.
type BackendHttpUseHtx string

// BackendHttpConnectionMode defines model for Backend.HttpConnectionMode.
type BackendHttpConnectionMode string

// BackendHttpPretendKeepalive defines model for Backend.HttpPretendKeepalive.
type BackendHttpPretendKeepalive string

// BackendHttpProxy defines model for Backend.HttpProxy.
type BackendHttpProxy string

// BackendHttpRestrictReqHdrNames defines model for Backend.HttpRestrictReqHdrNames.
type BackendHttpRestrictReqHdrNames string

// BackendHttpReuse defines model for Backend.HttpReuse.
type BackendHttpReuse string

// BackendIgnorePersistCond defines model for Backend.IgnorePersist.Cond.
type BackendIgnorePersistCond string

// BackendIgnorePersistListCond defines model for Backend.IgnorePersistList.Cond.
type BackendIgnorePersistListCond string

// BackendIndependentStreams defines model for Backend.IndependentStreams.
type BackendIndependentStreams string

// BackendLoadServerStateFromFile defines model for Backend.LoadServerStateFromFile.
type BackendLoadServerStateFromFile string

// BackendLogHealthChecks defines model for Backend.LogHealthChecks.
type BackendLogHealthChecks string

// BackendMode defines model for Backend.Mode.
type BackendMode string

// BackendNolinger defines model for Backend.Nolinger.
type BackendNolinger string

// BackendPersist defines model for Backend.Persist.
type BackendPersist string

// BackendPreferLastServer defines model for Backend.PreferLastServer.
type BackendPreferLastServer string

// BackendSpliceAuto defines model for Backend.SpliceAuto.
type BackendSpliceAuto string

// BackendSpliceRequest defines model for Backend.SpliceRequest.
type BackendSpliceRequest string

// BackendSpliceResponse defines model for Backend.SpliceResponse.
type BackendSpliceResponse string

// BackendSpopCheck defines model for Backend.SpopCheck.
type BackendSpopCheck string

// BackendSrvtcpka defines model for Backend.Srvtcpka.
type BackendSrvtcpka string

// BackendTcpSmartConnect defines model for Backend.TcpSmartConnect.
type BackendTcpSmartConnect string

// BackendTcpka defines model for Backend.Tcpka.
type BackendTcpka string

// BackendTransparent defines model for Backend.Transparent.
type BackendTransparent string

// BackendBase HAProxy backend configuration
type BackendBase struct {
	Abortonclose              *BackendBaseAbortonclose              `json:"abortonclose,omitempty"`
	AcceptInvalidHttpResponse *BackendBaseAcceptInvalidHttpResponse `json:"accept_invalid_http_response,omitempty"`
	AdvCheck                  *BackendBaseAdvCheck                  `json:"adv_check,omitempty"`
	Allbackups                *BackendBaseAllbackups                `json:"allbackups,omitempty"`
	Balance                   *Balance                              `json:"balance,omitempty"`
	CheckTimeout              *int                                  `json:"check_timeout"`
	Checkcache                *BackendBaseCheckcache                `json:"checkcache,omitempty"`
	Compression               *Compression                          `json:"compression,omitempty"`
	ConnectTimeout            *int                                  `json:"connect_timeout"`
	Cookie                    *Cookie                               `json:"cookie,omitempty"`
	DefaultServer             *DefaultServer                        `json:"default_server,omitempty"`
	Description               *string                               `json:"description,omitempty"`
	Disabled                  *bool                                 `json:"disabled,omitempty"`
	DynamicCookieKey          *string                               `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert               `json:"email_alert,omitempty"`
	Enabled                  *bool                     `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile              `json:"error_files,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles             `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                 `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                 `json:"errorloc303,omitempty"`
	ExternalCheck            *BackendBaseExternalCheck `json:"external_check,omitempty"`
	ExternalCheckCommand     *string                   `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string                   `json:"external_check_path,omitempty"`

	// BackendForcePersist This field is deprecated in favor of force_persist_list, and will be removed in a future release
	BackendForcePersist *struct {
		Cond     BackendBaseForcePersistCond `json:"cond"`
		CondTest string                      `json:"cond_test"`
	} `json:"force_persist,omitempty"`
	ForcePersistList *[]struct {
		Cond     BackendBaseForcePersistListCond `json:"cond"`
		CondTest string                          `json:"cond_test"`
	} `json:"force_persist_list,omitempty"`
	Forwardfor              *Forwardfor                         `json:"forwardfor,omitempty"`
	From                    *string                             `json:"from,omitempty"`
	Fullconn                *int                                `json:"fullconn"`
	Guid                    *string                             `json:"guid,omitempty"`
	H1CaseAdjustBogusServer *BackendBaseH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor       *int                                `json:"hash_balance_factor"`
	HashType                *HashType                           `json:"hash_type,omitempty"`
	HttpBufferRequest       *BackendBaseHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpNoDelay             *BackendBaseHttpNoDelay             `json:"http-no-delay,omitempty"`
	HttpUseHtx              *BackendBaseHttpUseHtx              `json:"http-use-htx,omitempty"`
	HttpConnectionMode      *BackendBaseHttpConnectionMode      `json:"http_connection_mode,omitempty"`
	HttpKeepAliveTimeout    *int                                `json:"http_keep_alive_timeout"`
	HttpPretendKeepalive    *BackendBaseHttpPretendKeepalive    `json:"http_pretend_keepalive,omitempty"`
	HttpProxy               *BackendBaseHttpProxy               `json:"http_proxy,omitempty"`
	HttpRequestTimeout      *int                                `json:"http_request_timeout"`
	HttpRestrictReqHdrNames *BackendBaseHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse               *BackendBaseHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader      *string                             `json:"http_send_name_header"`
	HttpchkParams           *HttpchkParams                      `json:"httpchk_params,omitempty"`
	Id                      *int                                `json:"id"`

	// BackendIgnorePersist This field is deprecated in favor of ignore_persist_list, and will be removed in a future release
	BackendIgnorePersist *struct {
		Cond     BackendBaseIgnorePersistCond `json:"cond"`
		CondTest string                       `json:"cond_test"`
	} `json:"ignore_persist,omitempty"`
	IgnorePersistList *[]struct {
		Cond     BackendBaseIgnorePersistListCond `json:"cond"`
		CondTest string                           `json:"cond_test"`
	} `json:"ignore_persist_list,omitempty"`
	IndependentStreams      *BackendBaseIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile *BackendBaseLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogHealthChecks         *BackendBaseLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogTag                  *string                             `json:"log_tag,omitempty"`
	MaxKeepAliveQueue       *int                                `json:"max_keep_alive_queue"`
	Mode                    *BackendBaseMode                    `json:"mode,omitempty"`
	MysqlCheckParams        *MysqlCheckParams                   `json:"mysql_check_params,omitempty"`
	Name                    string                              `json:"name"`
	Nolinger                *BackendBaseNolinger                `json:"nolinger,omitempty"`
	Originalto              *Originalto                         `json:"originalto,omitempty"`
	Persist                 *BackendBasePersist                 `json:"persist,omitempty"`
	PersistRule             *PersistRule                        `json:"persist_rule,omitempty"`
	PgsqlCheckParams        *PgsqlCheckParams                   `json:"pgsql_check_params,omitempty"`
	PreferLastServer        *BackendBasePreferLastServer        `json:"prefer_last_server,omitempty"`
	QueueTimeout            *int                                `json:"queue_timeout"`
	Redispatch              *Redispatch                         `json:"redispatch,omitempty"`
	Retries                 *int                                `json:"retries"`
	RetryOn                 *string                             `json:"retry_on,omitempty"`
	ServerFinTimeout        *int                                `json:"server_fin_timeout"`
	ServerStateFileName     *string                             `json:"server_state_file_name,omitempty"`
	ServerTimeout           *int                                `json:"server_timeout"`
	SmtpchkParams           *SmtpchkParams                      `json:"smtpchk_params,omitempty"`
	Source                  *Source                             `json:"source,omitempty"`
	SpliceAuto              *BackendBaseSpliceAuto              `json:"splice_auto,omitempty"`
	SpliceRequest           *BackendBaseSpliceRequest           `json:"splice_request,omitempty"`
	SpliceResponse          *BackendBaseSpliceResponse          `json:"splice_response,omitempty"`
	SpopCheck               *BackendBaseSpopCheck               `json:"spop_check,omitempty"`
	Srvtcpka                *BackendBaseSrvtcpka                `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt             *int                                `json:"srvtcpka_cnt"`
	SrvtcpkaIdle            *int                                `json:"srvtcpka_idle"`
	SrvtcpkaIntvl           *int                                `json:"srvtcpka_intvl"`
	StatsOptions            *StatsOptions                       `json:"stats_options,omitempty"`
	StickTable              *ConfigStickTable                   `json:"stick_table,omitempty"`
	TarpitTimeout           *int                                `json:"tarpit_timeout"`
	TcpSmartConnect         *BackendBaseTcpSmartConnect         `json:"tcp_smart_connect,omitempty"`
	Tcpka                   *BackendBaseTcpka                   `json:"tcpka,omitempty"`
	Transparent             *BackendBaseTransparent             `json:"transparent,omitempty"`
	TunnelTimeout           *int                                `json:"tunnel_timeout"`
	UseFcgiApp              *string                             `json:"use_fcgi_app,omitempty"`
}

// BackendBaseAbortonclose defines model for BackendBase.Abortonclose.
type BackendBaseAbortonclose string

// BackendBaseAcceptInvalidHttpResponse defines model for BackendBase.AcceptInvalidHttpResponse.
type BackendBaseAcceptInvalidHttpResponse string

// BackendBaseAdvCheck defines model for BackendBase.AdvCheck.
type BackendBaseAdvCheck string

// BackendBaseAllbackups defines model for BackendBase.Allbackups.
type BackendBaseAllbackups string

// BackendBaseCheckcache defines model for BackendBase.Checkcache.
type BackendBaseCheckcache string

// BackendBaseExternalCheck defines model for BackendBase.ExternalCheck.
type BackendBaseExternalCheck string

// BackendBaseForcePersistCond defines model for BackendBase.ForcePersist.Cond.
type BackendBaseForcePersistCond string

// BackendBaseForcePersistListCond defines model for BackendBase.ForcePersistList.Cond.
type BackendBaseForcePersistListCond string

// BackendBaseH1CaseAdjustBogusServer defines model for BackendBase.H1CaseAdjustBogusServer.
type BackendBaseH1CaseAdjustBogusServer string

// BackendBaseHttpBufferRequest defines model for BackendBase.HttpBufferRequest.
type BackendBaseHttpBufferRequest string

// BackendBaseHttpNoDelay defines model for BackendBase.HttpNoDelay.
type BackendBaseHttpNoDelay string

// BackendBaseHttpUseHtx defines model for BackendBase.HttpUseHtx.
type BackendBaseHttpUseHtx string

// BackendBaseHttpConnectionMode defines model for BackendBase.HttpConnectionMode.
type BackendBaseHttpConnectionMode string

// BackendBaseHttpPretendKeepalive defines model for BackendBase.HttpPretendKeepalive.
type BackendBaseHttpPretendKeepalive string

// BackendBaseHttpProxy defines model for BackendBase.HttpProxy.
type BackendBaseHttpProxy string

// BackendBaseHttpRestrictReqHdrNames defines model for BackendBase.HttpRestrictReqHdrNames.
type BackendBaseHttpRestrictReqHdrNames string

// BackendBaseHttpReuse defines model for BackendBase.HttpReuse.
type BackendBaseHttpReuse string

// BackendBaseIgnorePersistCond defines model for BackendBase.IgnorePersist.Cond.
type BackendBaseIgnorePersistCond string

// BackendBaseIgnorePersistListCond defines model for BackendBase.IgnorePersistList.Cond.
type BackendBaseIgnorePersistListCond string

// BackendBaseIndependentStreams defines model for BackendBase.IndependentStreams.
type BackendBaseIndependentStreams string

// BackendBaseLoadServerStateFromFile defines model for BackendBase.LoadServerStateFromFile.
type BackendBaseLoadServerStateFromFile string

// BackendBaseLogHealthChecks defines model for BackendBase.LogHealthChecks.
type BackendBaseLogHealthChecks string

// BackendBaseMode defines model for BackendBase.Mode.
type BackendBaseMode string

// BackendBaseNolinger defines model for BackendBase.Nolinger.
type BackendBaseNolinger string

// BackendBasePersist defines model for BackendBase.Persist.
type BackendBasePersist string

// BackendBasePreferLastServer defines model for BackendBase.PreferLastServer.
type BackendBasePreferLastServer string

// BackendBaseSpliceAuto defines model for BackendBase.SpliceAuto.
type BackendBaseSpliceAuto string

// BackendBaseSpliceRequest defines model for BackendBase.SpliceRequest.
type BackendBaseSpliceRequest string

// BackendBaseSpliceResponse defines model for BackendBase.SpliceResponse.
type BackendBaseSpliceResponse string

// BackendBaseSpopCheck defines model for BackendBase.SpopCheck.
type BackendBaseSpopCheck string

// BackendBaseSrvtcpka defines model for BackendBase.Srvtcpka.
type BackendBaseSrvtcpka string

// BackendBaseTcpSmartConnect defines model for BackendBase.TcpSmartConnect.
type BackendBaseTcpSmartConnect string

// BackendBaseTcpka defines model for BackendBase.Tcpka.
type BackendBaseTcpka string

// BackendBaseTransparent defines model for BackendBase.Transparent.
type BackendBaseTransparent string

// BackendSwitchingRule HAProxy backend switching rule configuration (corresponds to use_backend directive)
type BackendSwitchingRule struct {
	Cond     *BackendSwitchingRuleCond `json:"cond,omitempty"`
	CondTest *string                   `json:"cond_test,omitempty"`
	Name     string                    `json:"name"`
}

// BackendSwitchingRuleCond defines model for BackendSwitchingRule.Cond.
type BackendSwitchingRuleCond string

// BackendSwitchingRules HAProxy backend switching rules array (corresponds to use_backend directives)
type BackendSwitchingRules = []BackendSwitchingRule

// Backends HAProxy backends array
type Backends = []Backend

// Balance defines model for balance.
type Balance struct {
	Algorithm         BalanceAlgorithm `json:"algorithm"`
	HashExpression    *string          `json:"hash_expression,omitempty"`
	HdrName           *string          `json:"hdr_name,omitempty"`
	HdrUseDomainOnly  *bool            `json:"hdr_use_domain_only,omitempty"`
	RandomDraws       *int             `json:"random_draws,omitempty"`
	RdpCookieName     *string          `json:"rdp_cookie_name,omitempty"`
	UriDepth          *int             `json:"uri_depth,omitempty"`
	UriLen            *int             `json:"uri_len,omitempty"`
	UriPathOnly       *bool            `json:"uri_path_only,omitempty"`
	UriWhole          *bool            `json:"uri_whole,omitempty"`
	UrlParam          *string          `json:"url_param,omitempty"`
	UrlParamCheckPost *int             `json:"url_param_check_post,omitempty"`
	UrlParamMaxWait   *int             `json:"url_param_max_wait,omitempty"`
}

// BalanceAlgorithm defines model for Balance.Algorithm.
type BalanceAlgorithm string

// Bind defines model for bind.
type Bind struct {
	AcceptNetscalerCip   *int                `json:"accept_netscaler_cip,omitempty"`
	AcceptProxy          *bool               `json:"accept_proxy,omitempty"`
	Address              *string             `json:"address,omitempty"`
	Allow0rtt            *bool               `json:"allow_0rtt,omitempty"`
	Alpn                 *string             `json:"alpn,omitempty"`
	Backlog              *string             `json:"backlog,omitempty"`
	CaIgnoreErr          *string             `json:"ca_ignore_err,omitempty"`
	CaSignFile           *string             `json:"ca_sign_file,omitempty"`
	CaSignPass           *string             `json:"ca_sign_pass,omitempty"`
	CaVerifyFile         *string             `json:"ca_verify_file,omitempty"`
	Ciphers              *string             `json:"ciphers,omitempty"`
	Ciphersuites         *string             `json:"ciphersuites,omitempty"`
	ClientSigalgs        *string             `json:"client_sigalgs,omitempty"`
	CrlFile              *string             `json:"crl_file,omitempty"`
	CrtIgnoreErr         *string             `json:"crt_ignore_err,omitempty"`
	CrtList              *string             `json:"crt_list,omitempty"`
	Curves               *string             `json:"curves,omitempty"`
	DefaultCrtList       *[]string           `json:"default_crt_list,omitempty"`
	DeferAccept          *bool               `json:"defer_accept,omitempty"`
	Ecdhe                *string             `json:"ecdhe,omitempty"`
	ExposeFdListeners    *bool               `json:"expose_fd_listeners,omitempty"`
	ForceSslv3           *bool               `json:"force_sslv3,omitempty"`
	ForceTlsv10          *bool               `json:"force_tlsv10,omitempty"`
	ForceTlsv11          *bool               `json:"force_tlsv11,omitempty"`
	ForceTlsv12          *bool               `json:"force_tlsv12,omitempty"`
	ForceTlsv13          *bool               `json:"force_tlsv13,omitempty"`
	GenerateCertificates *bool               `json:"generate_certificates,omitempty"`
	Gid                  *int                `json:"gid,omitempty"`
	Group                *string             `json:"group,omitempty"`
	GuidPrefix           *string             `json:"guid_prefix,omitempty"`
	Id                   *string             `json:"id,omitempty"`
	Interface            *string             `json:"interface,omitempty"`
	Level                *BindLevel          `json:"level,omitempty"`
	Maxconn              *int                `json:"maxconn,omitempty"`
	Mode                 *string             `json:"mode,omitempty"`
	Mss                  *string             `json:"mss,omitempty"`
	Name                 *string             `json:"name,omitempty"`
	Namespace            *string             `json:"namespace,omitempty"`
	Nbconn               *int                `json:"nbconn,omitempty"`
	Nice                 *int                `json:"nice,omitempty"`
	NoAlpn               *bool               `json:"no_alpn,omitempty"`
	NoCaNames            *bool               `json:"no_ca_names,omitempty"`
	NoSslv3              *bool               `json:"no_sslv3,omitempty"`
	NoTlsTickets         *bool               `json:"no_tls_tickets,omitempty"`
	NoTlsv10             *bool               `json:"no_tlsv10,omitempty"`
	NoTlsv11             *bool               `json:"no_tlsv11,omitempty"`
	NoTlsv12             *bool               `json:"no_tlsv12,omitempty"`
	NoTlsv13             *bool               `json:"no_tlsv13,omitempty"`
	Npn                  *string             `json:"npn,omitempty"`
	Port                 *int                `json:"port"`
	PortRangeEnd         *int                `json:"port-range-end"`
	PreferClientCiphers  *bool               `json:"prefer_client_ciphers,omitempty"`
	Proto                *string             `json:"proto,omitempty"`
	QuicCcAlgo           *BindQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
	QuicForceRetry       *bool               `json:"quic-force-retry,omitempty"`
	QuicSocket           *BindQuicSocket     `json:"quic-socket,omitempty"`
	SeverityOutput       *BindSeverityOutput `json:"severity_output,omitempty"`
	Sigalgs              *string             `json:"sigalgs,omitempty"`
	Ssl                  *bool               `json:"ssl,omitempty"`
	SslCafile            *string             `json:"ssl_cafile,omitempty"`
	SslCertificate       *string             `json:"ssl_certificate,omitempty"`
	SslMaxVer            *BindSslMaxVer      `json:"ssl_max_ver,omitempty"`
	SslMinVer            *BindSslMinVer      `json:"ssl_min_ver,omitempty"`
	StrictSni            *bool               `json:"strict_sni,omitempty"`
	TcpUserTimeout       *int                `json:"tcp_user_timeout"`
	Tfo                  *bool               `json:"tfo,omitempty"`
	Thread               *string             `json:"thread,omitempty"`
	TlsTicketKeys        *string             `json:"tls_ticket_keys,omitempty"`
	Transparent          *bool               `json:"transparent,omitempty"`
	Uid                  *string             `json:"uid,omitempty"`
	User                 *string             `json:"user,omitempty"`
	V4v6                 *bool               `json:"v4v6,omitempty"`
	V6only               *bool               `json:"v6only,omitempty"`
	Verify               *BindVerify         `json:"verify,omitempty"`
}

// BindLevel defines model for Bind.Level.
type BindLevel string

// BindQuicCcAlgo defines model for Bind.QuicCcAlgo.
type BindQuicCcAlgo string

// BindQuicSocket defines model for Bind.QuicSocket.
type BindQuicSocket string

// BindSeverityOutput defines model for Bind.SeverityOutput.
type BindSeverityOutput string

// BindSslMaxVer defines model for Bind.SslMaxVer.
type BindSslMaxVer string

// BindSslMinVer defines model for Bind.SslMinVer.
type BindSslMinVer string

// BindVerify defines model for Bind.Verify.
type BindVerify string

// BindParams defines model for bind_params.
type BindParams struct {
	AcceptNetscalerCip   *int                      `json:"accept_netscaler_cip,omitempty"`
	AcceptProxy          *bool                     `json:"accept_proxy,omitempty"`
	Allow0rtt            *bool                     `json:"allow_0rtt,omitempty"`
	Alpn                 *string                   `json:"alpn,omitempty"`
	Backlog              *string                   `json:"backlog,omitempty"`
	CaIgnoreErr          *string                   `json:"ca_ignore_err,omitempty"`
	CaSignFile           *string                   `json:"ca_sign_file,omitempty"`
	CaSignPass           *string                   `json:"ca_sign_pass,omitempty"`
	CaVerifyFile         *string                   `json:"ca_verify_file,omitempty"`
	Ciphers              *string                   `json:"ciphers,omitempty"`
	Ciphersuites         *string                   `json:"ciphersuites,omitempty"`
	ClientSigalgs        *string                   `json:"client_sigalgs,omitempty"`
	CrlFile              *string                   `json:"crl_file,omitempty"`
	CrtIgnoreErr         *string                   `json:"crt_ignore_err,omitempty"`
	CrtList              *string                   `json:"crt_list,omitempty"`
	Curves               *string                   `json:"curves,omitempty"`
	DefaultCrtList       *[]string                 `json:"default_crt_list,omitempty"`
	DeferAccept          *bool                     `json:"defer_accept,omitempty"`
	Ecdhe                *string                   `json:"ecdhe,omitempty"`
	ExposeFdListeners    *bool                     `json:"expose_fd_listeners,omitempty"`
	ForceSslv3           *bool                     `json:"force_sslv3,omitempty"`
	ForceTlsv10          *bool                     `json:"force_tlsv10,omitempty"`
	ForceTlsv11          *bool                     `json:"force_tlsv11,omitempty"`
	ForceTlsv12          *bool                     `json:"force_tlsv12,omitempty"`
	ForceTlsv13          *bool                     `json:"force_tlsv13,omitempty"`
	GenerateCertificates *bool                     `json:"generate_certificates,omitempty"`
	Gid                  *int                      `json:"gid,omitempty"`
	Group                *string                   `json:"group,omitempty"`
	GuidPrefix           *string                   `json:"guid_prefix,omitempty"`
	Id                   *string                   `json:"id,omitempty"`
	Interface            *string                   `json:"interface,omitempty"`
	Level                *BindParamsLevel          `json:"level,omitempty"`
	Maxconn              *int                      `json:"maxconn,omitempty"`
	Mode                 *string                   `json:"mode,omitempty"`
	Mss                  *string                   `json:"mss,omitempty"`
	Name                 *string                   `json:"name,omitempty"`
	Namespace            *string                   `json:"namespace,omitempty"`
	Nbconn               *int                      `json:"nbconn,omitempty"`
	Nice                 *int                      `json:"nice,omitempty"`
	NoAlpn               *bool                     `json:"no_alpn,omitempty"`
	NoCaNames            *bool                     `json:"no_ca_names,omitempty"`
	NoSslv3              *bool                     `json:"no_sslv3,omitempty"`
	NoTlsTickets         *bool                     `json:"no_tls_tickets,omitempty"`
	NoTlsv10             *bool                     `json:"no_tlsv10,omitempty"`
	NoTlsv11             *bool                     `json:"no_tlsv11,omitempty"`
	NoTlsv12             *bool                     `json:"no_tlsv12,omitempty"`
	NoTlsv13             *bool                     `json:"no_tlsv13,omitempty"`
	Npn                  *string                   `json:"npn,omitempty"`
	PreferClientCiphers  *bool                     `json:"prefer_client_ciphers,omitempty"`
	Proto                *string                   `json:"proto,omitempty"`
	QuicCcAlgo           *BindParamsQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
	QuicForceRetry       *bool                     `json:"quic-force-retry,omitempty"`
	QuicSocket           *BindParamsQuicSocket     `json:"quic-socket,omitempty"`
	SeverityOutput       *BindParamsSeverityOutput `json:"severity_output,omitempty"`
	Sigalgs              *string                   `json:"sigalgs,omitempty"`
	Ssl                  *bool                     `json:"ssl,omitempty"`
	SslCafile            *string                   `json:"ssl_cafile,omitempty"`
	SslCertificate       *string                   `json:"ssl_certificate,omitempty"`
	SslMaxVer            *BindParamsSslMaxVer      `json:"ssl_max_ver,omitempty"`
	SslMinVer            *BindParamsSslMinVer      `json:"ssl_min_ver,omitempty"`
	StrictSni            *bool                     `json:"strict_sni,omitempty"`
	TcpUserTimeout       *int                      `json:"tcp_user_timeout"`
	Tfo                  *bool                     `json:"tfo,omitempty"`
	Thread               *string                   `json:"thread,omitempty"`
	TlsTicketKeys        *string                   `json:"tls_ticket_keys,omitempty"`
	Transparent          *bool                     `json:"transparent,omitempty"`
	Uid                  *string                   `json:"uid,omitempty"`
	User                 *string                   `json:"user,omitempty"`
	V4v6                 *bool                     `json:"v4v6,omitempty"`
	V6only               *bool                     `json:"v6only,omitempty"`
	Verify               *BindParamsVerify         `json:"verify,omitempty"`
}

// BindParamsLevel defines model for BindParams.Level.
type BindParamsLevel string

// BindParamsQuicCcAlgo defines model for BindParams.QuicCcAlgo.
type BindParamsQuicCcAlgo string

// BindParamsQuicSocket defines model for BindParams.QuicSocket.
type BindParamsQuicSocket string

// BindParamsSeverityOutput defines model for BindParams.SeverityOutput.
type BindParamsSeverityOutput string

// BindParamsSslMaxVer defines model for BindParams.SslMaxVer.
type BindParamsSslMaxVer string

// BindParamsSslMinVer defines model for BindParams.SslMinVer.
type BindParamsSslMinVer string

// BindParamsVerify defines model for BindParams.Verify.
type BindParamsVerify string

// Binds HAProxy frontend binds array (corresponds to bind directives)
type Binds = []Bind

// BotmanagementOptions BOTMGMT module configuration.
type BotmanagementOptions struct {
	// AutoEnable Automatically enable the BOTMGMT filter on all available proxies (frontends/listeners configured in HTTP mode with SSL enabled).
	AutoEnable *bool `json:"auto_enable,omitempty"`

	// DataFile Path of the data file to be loaded.
	DataFile *string `json:"data_file,omitempty"`

	// Update Enables the automatic update.
	Update *struct {
		// Delay Download period. Defaults to 5 minutes.
		Delay *int `json:"delay"`

		// DontlogNormal Deactivates logging of successful updates.
		DontlogNormal *bool `json:"dontlog_normal,omitempty"`

		// Log Enables logging using the configured "log" targets.
		Log *bool `json:"log,omitempty"`

		// Modified Enables the use of the time from the "Last-Modified" response HTTP header.
		// i.e. checking whether or not to update the data by setting the "If-Modified-Since" request HTTP header.
		Modified *bool `json:"modified,omitempty"`

		// Retries number of retries to establish a connection to the server. If unspecified, the global "retries" value is used.
		Retries      *int          `json:"retries"`
		ServerParams *ServerParams `json:"server_params,omitempty"`

		// Timeout HTTP connect timeout for attempts to download a new file version. Default is 5 seconds.
		Timeout *int `json:"timeout"`

		// Url The location from where the data file can be downloaded.
		Url string `json:"url"`

		// Xmodified It is the same as the 'modified' parameter, with the difference that the file modification time is set immediately after reading this information from the file status (i.e. immediately after starting HAProxy).
		// This means that the first data download may also be rejected if the file to be downloaded is not more recent than the data originally loaded from the local file system.
		Xmodified *bool `json:"xmodified,omitempty"`
	} `json:"update,omitempty"`
}

// BotmgmtProfile Botmgmt profiles that can be used across multiple filter instances and/or actions.
type BotmgmtProfile struct {
	Name string `json:"name"`

	// ScoreVersion The score algorithm version to use.
	ScoreVersion *int `json:"score_version"`

	// Track Enable or disable the tracking feature.
	Track *BotmgmtProfileTrack `json:"track,omitempty"`

	// TrackDefaults The defaults used when creating the tracking stick-tables.
	TrackDefaults *BotmgmtTrackDefaults `json:"track_defaults,omitempty"`

	// TrackPeers The name of the peers section to use for replication.
	TrackPeers *string `json:"track_peers,omitempty"`
}

// BotmgmtProfileTrack Enable or disable the tracking feature.
type BotmgmtProfileTrack string

// BotmgmtProfiles List of botmgmt-profile sections
type BotmgmtProfiles = []BotmgmtProfile

// BotmgmtTrackDefaults The defaults used when creating the tracking stick-tables.
type BotmgmtTrackDefaults struct {
	Expire *int `json:"expire"`
	Period *int `json:"period"`
	Size   *int `json:"size"`
}

// Cache HAPRoxy Cache section
type Cache struct {
	MaxAge              *int   `json:"max_age,omitempty"`
	MaxObjectSize       *int   `json:"max_object_size,omitempty"`
	MaxSecondaryEntries *int   `json:"max_secondary_entries,omitempty"`
	Name                string `json:"name"`
	ProcessVary         *bool  `json:"process_vary"`
	TotalMaxSize        *int   `json:"total_max_size,omitempty"`
}

// Caches HAProxy caches array
type Caches = []Cache

// Captcha Configuration for the captcha module.
type Captcha struct {
	// ApiKey Api key for assessments in Google Recaptcha Enterprise.
	ApiKey *string `json:"api_key,omitempty"`

	// CustFormat Format of the POST request to the verifying server.
	CustFormat *CaptchaCustFormat `json:"cust_format,omitempty"`

	// CustHtmlFile HTML file that will be sent when requesting a captcha.
	CustHtmlFile *string `json:"cust_html_file,omitempty"`

	// CustRespField Name of the response field.
	CustRespField *string `json:"cust_resp_field,omitempty"`

	// CustRespParam Name of the response parameter that will be sent to the verifying server.
	CustRespParam *string `json:"cust_resp_param,omitempty"`

	// CustScoreBased Enable or disable score-based verification.
	CustScoreBased *CaptchaCustScoreBased `json:"cust_score_based,omitempty"`

	// CustSecretParam Name of the secret parameter that will be sent to the verifying server.
	CustSecretParam *string `json:"cust_secret_param,omitempty"`

	// CustSuccess String indicating success in the response from verifying server.
	CustSuccess *string `json:"cust_success,omitempty"`

	// CustUrl URL of the captcha verification service.
	CustUrl *string `json:"cust_url,omitempty"`

	// HmacSecret Secret used to sign the cookie. Limited to 42 bytes.
	HmacSecret *string `json:"hmac_secret,omitempty"`

	// IpCookie Adds the client's IP address into the HMAC.
	IpCookie *CaptchaIpCookie `json:"ip_cookie,omitempty"`

	// Mode Captcha provider, for instance: recaptcha, recaptcha_v3, recaptcha_enterprise,
	// hcaptcha, frcaptcha (friendly captcha), turnstile or custom.
	Mode *string `json:"mode,omitempty"`
	Name string  `json:"name"`

	// Path Path for the POST request sent to verify the captcha token.
	Path *string `json:"path,omitempty"`

	// ProjectId Project id for Google Recaptcha Enterprise.
	ProjectId *string `json:"project_id,omitempty"`

	// ScoreOnlyOnce Request score only on first-page access.
	ScoreOnlyOnce *CaptchaScoreOnlyOnce `json:"score_only_once,omitempty"`

	// SecretKey Private key obtained from the captcha provider.
	SecretKey *string `json:"secret_key,omitempty"`

	// SiteKey Public key obtained from the captcha provider.
	SiteKey *string `json:"site_key,omitempty"`

	// ValidTime Cookie lifetime in seconds.
	ValidTime *int `json:"valid_time"`
}

// CaptchaCustFormat Format of the POST request to the verifying server.
type CaptchaCustFormat string

// CaptchaCustScoreBased Enable or disable score-based verification.
type CaptchaCustScoreBased string

// CaptchaIpCookie Adds the client's IP address into the HMAC.
type CaptchaIpCookie string

// CaptchaScoreOnlyOnce Request score only on first-page access.
type CaptchaScoreOnlyOnce string

// Captchas List of captcha sections
type Captchas = []Captcha

// Capture defines model for capture.
type Capture struct {
	Length int         `json:"length"`
	Type   CaptureType `json:"type"`
}

// CaptureType defines model for Capture.Type.
type CaptureType string

// Captures defines model for captures.
type Captures = []Capture

// ClickhouseOutput Send logs to ClickHouse database.
type ClickhouseOutput struct {
	// BatchSize Logs are inserted in batch in DB. This defined the size of the batch.
	BatchSize *int `json:"batch_size,omitempty"`

	// ClusterName Name of the ClickHouse cluster.
	ClusterName *string `json:"cluster_name,omitempty"`

	// DbConnDelay DB connection delay in seconds.
	DbConnDelay *int `json:"db_conn_delay,omitempty"`

	// DbConnRetries Number of DB connection retries.
	DbConnRetries *int `json:"db_conn_retries,omitempty"`

	// DbName Name of the database.
	DbName string `json:"db_name"`

	// FlushInterval Maximum duration for which the logs can be batched before they are sent to ClickHouse.
	// If batch_size is reached before the flushInterval, the logs are sent immediately to ClickHouse. However, if batch_size is not reached by the time flushInterval expires, the current batch of logs is sent to ClickHouse.
	// flush_interval is a sequence of decimal numbers, each with optional fraction and a unit suffix, such as `300ms`, `-1.5h` or `2h45m`. Valid time units are `ns`, `us` (or `s`), `ms`, `s`, `m`, `h`
	FlushInterval *string `json:"flush_interval,omitempty"`

	// HostPortList This is a list of `HostPort` objects. Each object contains the `host` and `port` details for a database instance in a cluster. This list would contain multiple entries in a distributed database setup, such as a ClickHouse sharded cluster.
	HostPortList HostPortList `json:"host_port_list"`

	// Password Password for DB connection.
	Password string `json:"password"`

	// ReplicaCount Number of replicas.
	ReplicaCount *int `json:"replica_count,omitempty"`

	// ShardCount Number of shards.
	ShardCount *int `json:"shard_count,omitempty"`

	// UseTls Set to use TLS connection to the database
	UseTls *bool `json:"use_tls,omitempty"`

	// User Username for DB connection.
	User string `json:"user"`
}

// ClusterSettings Settings related to a cluster.
type ClusterSettings struct {
	BootstrapKey *string `json:"bootstrap_key,omitempty"`
	Cluster      *struct {
		Address           *string `json:"address,omitempty"`
		ApiBasePath       *string `json:"api_base_path,omitempty"`
		ClusterId         *string `json:"cluster_id,omitempty"`
		Description       *string `json:"description,omitempty"`
		ClusterLogTargets *[]struct {
			Address   string                                   `json:"address"`
			LogFormat *string                                  `json:"log_format,omitempty"`
			Port      int                                      `json:"port"`
			Protocol  ClusterSettingsClusterLogTargetsProtocol `json:"protocol"`
		} `json:"log_targets,omitempty"`
		Name           *string `json:"name,omitempty"`
		Port           *int    `json:"port"`
		UseHashStorage *bool   `json:"use_hash_storage,omitempty"`
	} `json:"cluster,omitempty"`
	Mode   *ClusterSettingsMode   `json:"mode,omitempty"`
	Status *ClusterSettingsStatus `json:"status,omitempty"`
}

// ClusterSettingsClusterLogTargetsProtocol defines model for ClusterSettings.Cluster.LogTargets.Protocol.
type ClusterSettingsClusterLogTargetsProtocol string

// ClusterSettingsMode defines model for ClusterSettings.Mode.
type ClusterSettingsMode string

// ClusterSettingsStatus defines model for ClusterSettings.Status.
type ClusterSettingsStatus string

// ClusterVersion defines model for cluster_version.
type ClusterVersion struct {
	Checksum       *string `json:"checksum,omitempty"`
	ClusterVersion *int    `json:"cluster_version,omitempty"`
}

// Compression defines model for compression.
type Compression struct {
	AlgoReq    *CompressionAlgoReq      `json:"algo-req,omitempty"`
	Algorithms *[]CompressionAlgorithms `json:"algorithms,omitempty"`
	AlgosRes   *[]CompressionAlgosRes   `json:"algos-res,omitempty"`
	Direction  *CompressionDirection    `json:"direction,omitempty"`
	Offload    *bool                    `json:"offload,omitempty"`
	Types      *[]string                `json:"types,omitempty"`
	TypesReq   *[]string                `json:"types-req,omitempty"`
	TypesRes   *[]string                `json:"types-res,omitempty"`
}

// CompressionAlgoReq defines model for Compression.AlgoReq.
type CompressionAlgoReq string

// CompressionAlgorithms defines model for Compression.Algorithms.
type CompressionAlgorithms string

// CompressionAlgosRes defines model for Compression.AlgosRes.
type CompressionAlgosRes string

// CompressionDirection defines model for Compression.Direction.
type CompressionDirection string

// ConfigStickTable defines model for config_stick_table.
type ConfigStickTable struct {
	Expire  *int                    `json:"expire"`
	Keylen  *int                    `json:"keylen"`
	Nopurge *bool                   `json:"nopurge,omitempty"`
	Peers   *string                 `json:"peers,omitempty"`
	Size    *int                    `json:"size"`
	Srvkey  *ConfigStickTableSrvkey `json:"srvkey"`
	Store   *string                 `json:"store,omitempty"`
	Type    *ConfigStickTableType   `json:"type,omitempty"`
	WriteTo *string                 `json:"write_to"`
}

// ConfigStickTableSrvkey defines model for ConfigStickTable.Srvkey.
type ConfigStickTableSrvkey string

// ConfigStickTableType defines model for ConfigStickTable.Type.
type ConfigStickTableType string

// Consul Consul server configuration
type Consul struct {
	Address string `json:"address"`

	// Defaults Name of the defaults section to be used in backends created by this service
	Defaults    *string `json:"defaults,omitempty"`
	Description *string `json:"description,omitempty"`
	Enabled     bool    `json:"enabled"`

	// HealthCheckPolicy Defines the health check conditions required for each node to be considered valid for the service.
	//   none: all nodes are considered valid
	//   any: a node is considered valid if any one health check is 'passing'
	//   all: a node is considered valid if all health checks are 'passing'
	//   min: a node is considered valid if the number of 'passing' checks is greater or equal to the 'health_check_policy_min' value.
	//     If the node has less health checks configured then 'health_check_policy_min' it is considered invalid.
	HealthCheckPolicy    *ConsulHealthCheckPolicy `json:"health_check_policy,omitempty"`
	HealthCheckPolicyMin *int                     `json:"health_check_policy_min,omitempty"`

	// Id Auto generated ID.
	Id        *string     `json:"id"`
	Mode      *ConsulMode `json:"mode,omitempty"`
	Name      *string     `json:"name,omitempty"`
	Namespace *string     `json:"namespace,omitempty"`
	Port      int         `json:"port"`

	// RetryTimeout Duration in seconds in-between data pulling requests to the consul server
	RetryTimeout               int                          `json:"retry_timeout"`
	ServerParams               *ServerParams                `json:"server_params,omitempty"`
	ServerSlotsBase            *int                         `json:"server_slots_base,omitempty"`
	ServerSlotsGrowthIncrement *int                         `json:"server_slots_growth_increment,omitempty"`
	ServerSlotsGrowthType      *ConsulServerSlotsGrowthType `json:"server_slots_growth_type,omitempty"`
	ServerSlotsUseRuntime      *bool                        `json:"server_slots_use_runtime,omitempty"`
	ServiceAllowlist           *[]string                    `json:"service_allowlist,omitempty"`
	ServiceDenylist            *[]string                    `json:"service_denylist,omitempty"`

	// ServiceNameRegexp Regular expression used to filter services by name.
	ServiceNameRegexp *string `json:"service_name_regexp,omitempty"`
	Token             *string `json:"token,omitempty"`
}

// ConsulHealthCheckPolicy Defines the health check conditions required for each node to be considered valid for the service.
//
//	none: all nodes are considered valid
//	any: a node is considered valid if any one health check is 'passing'
//	all: a node is considered valid if all health checks are 'passing'
//	min: a node is considered valid if the number of 'passing' checks is greater or equal to the 'health_check_policy_min' value.
//	  If the node has less health checks configured then 'health_check_policy_min' it is considered invalid.
type ConsulHealthCheckPolicy string

// ConsulMode defines model for Consul.Mode.
type ConsulMode string

// ConsulServerSlotsGrowthType defines model for Consul.ServerSlotsGrowthType.
type ConsulServerSlotsGrowthType string

// Consuls Consuls array
type Consuls = []Consul

// Cookie defines model for cookie.
type Cookie struct {
	Attrs *[]struct {
		Value *string `json:"value,omitempty"`
	} `json:"attr,omitempty"`
	Domains *[]struct {
		Value *string `json:"value,omitempty"`
	} `json:"domain,omitempty"`
	Dynamic  *bool       `json:"dynamic,omitempty"`
	Httponly *bool       `json:"httponly,omitempty"`
	Indirect *bool       `json:"indirect,omitempty"`
	Maxidle  *int        `json:"maxidle,omitempty"`
	Maxlife  *int        `json:"maxlife,omitempty"`
	Name     string      `json:"name"`
	Nocache  *bool       `json:"nocache,omitempty"`
	Postonly *bool       `json:"postonly,omitempty"`
	Preserve *bool       `json:"preserve,omitempty"`
	Secure   *bool       `json:"secure,omitempty"`
	Type     *CookieType `json:"type,omitempty"`
}

// CookieType defines model for Cookie.Type.
type CookieType string

// CrtLoad Loads a certificate from a store with options
type CrtLoad struct {
	// Alias Certificate alias
	Alias *string `json:"alias,omitempty"`

	// Certificate Certificate filename
	Certificate string `json:"certificate"`

	// Issuer OCSP issuer filename
	Issuer *string `json:"issuer,omitempty"`

	// Key Private key filename
	Key *string `json:"key,omitempty"`

	// Ocsp OCSP response filename
	Ocsp *string `json:"ocsp,omitempty"`

	// OcspUpdate Automatic OCSP response update
	OcspUpdate *CrtLoadOcspUpdate `json:"ocsp_update,omitempty"`

	// Sctl Signed Certificate Timestamp List filename
	Sctl *string `json:"sctl,omitempty"`
}

// CrtLoadOcspUpdate Automatic OCSP response update
type CrtLoadOcspUpdate string

// CrtLoads List of certificates to load from a Certificate Store
type CrtLoads = []CrtLoad

// CrtStore Storage mechanism to load and store certificates used in the configuration
type CrtStore struct {
	// CrtBase Default directory to fetch SSL certificates from
	CrtBase *string `json:"crt_base,omitempty"`

	// KeyBase Default directory to fetch SSL private keys from
	KeyBase *string `json:"key_base,omitempty"`

	// Loads List of certificates to load from a Certificate Store
	Loads *CrtLoads `json:"loads,omitempty"`
	Name  string    `json:"name"`
}

// CrtStores List of Certificate Stores
type CrtStores = []CrtStore

// DebugOptions defines model for debug_options.
type DebugOptions struct {
	Anonkey     *int  `json:"anonkey"`
	Quiet       *bool `json:"quiet,omitempty"`
	ZeroWarning *bool `json:"zero_warning,omitempty"`
}

// DefaultBind defines model for default_bind.
type DefaultBind = BindParams

// DefaultServer defines model for default_server.
type DefaultServer = ServerParams

// Defaults defines model for defaults.
type Defaults struct {
	Abortonclose              *DefaultsAbortonclose              `json:"abortonclose,omitempty"`
	AcceptInvalidHttpRequest  *DefaultsAcceptInvalidHttpRequest  `json:"accept_invalid_http_request,omitempty"`
	AcceptInvalidHttpResponse *DefaultsAcceptInvalidHttpResponse `json:"accept_invalid_http_response,omitempty"`
	AdvCheck                  *DefaultsAdvCheck                  `json:"adv_check,omitempty"`
	Allbackups                *DefaultsAllbackups                `json:"allbackups,omitempty"`
	Backlog                   *int                               `json:"backlog"`
	Balance                   *Balance                           `json:"balance,omitempty"`
	CheckTimeout              *int                               `json:"check_timeout"`
	Checkcache                *DefaultsCheckcache                `json:"checkcache,omitempty"`
	Clflog                    *bool                              `json:"clflog,omitempty"`
	ClientFinTimeout          *int                               `json:"client_fin_timeout"`
	ClientTimeout             *int                               `json:"client_timeout"`
	Clitcpka                  *DefaultsClitcpka                  `json:"clitcpka,omitempty"`
	ClitcpkaCnt               *int                               `json:"clitcpka_cnt"`
	ClitcpkaIdle              *int                               `json:"clitcpka_idle"`
	ClitcpkaIntvl             *int                               `json:"clitcpka_intvl"`
	Compression               *Compression                       `json:"compression,omitempty"`
	ConnectTimeout            *int                               `json:"connect_timeout"`
	Contstats                 *DefaultsContstats                 `json:"contstats,omitempty"`
	Cookie                    *Cookie                            `json:"cookie,omitempty"`
	DefaultBackend            *string                            `json:"default_backend,omitempty"`
	DefaultServer             *DefaultServer                     `json:"default_server,omitempty"`
	DisableH2Upgrade          *DefaultsDisableH2Upgrade          `json:"disable_h2_upgrade,omitempty"`
	Disabled                  *bool                              `json:"disabled,omitempty"`
	DontlogNormal             *DefaultsDontlogNormal             `json:"dontlog_normal,omitempty"`
	Dontlognull               *DefaultsDontlognull               `json:"dontlognull,omitempty"`
	DynamicCookieKey          *string                            `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert                      `json:"email_alert,omitempty"`
	Enabled                  *bool                            `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile                     `json:"error_files,omitempty"`
	ErrorLogFormat           *string                          `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles                    `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                        `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                        `json:"errorloc303,omitempty"`
	ExternalCheck            *DefaultsExternalCheck           `json:"external_check,omitempty"`
	ExternalCheckCommand     *string                          `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string                          `json:"external_check_path,omitempty"`
	Forwardfor               *Forwardfor                      `json:"forwardfor,omitempty"`
	From                     *string                          `json:"from,omitempty"`
	Fullconn                 *int                             `json:"fullconn"`
	H1CaseAdjustBogusClient  *DefaultsH1CaseAdjustBogusClient `json:"h1_case_adjust_bogus_client,omitempty"`
	H1CaseAdjustBogusServer  *DefaultsH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor        *int                             `json:"hash_balance_factor"`
	HashType                 *HashType                        `json:"hash_type,omitempty"`
	HttpBufferRequest        *DefaultsHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpUseHtx               *DefaultsHttpUseHtx              `json:"http-use-htx,omitempty"`
	HttpCheckList            *HttpChecks                      `json:"http_check_list,omitempty"`
	HttpConnectionMode       *DefaultsHttpConnectionMode      `json:"http_connection_mode,omitempty"`

	// HttpErrorRuleList HAProxy HTTP error rules array (corresponds to http-error directives)
	HttpErrorRuleList       *HttpErrorRules                  `json:"http_error_rule_list,omitempty"`
	HttpIgnoreProbes        *DefaultsHttpIgnoreProbes        `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout    *int                             `json:"http_keep_alive_timeout"`
	HttpNoDelay             *DefaultsHttpNoDelay             `json:"http_no_delay,omitempty"`
	HttpPretendKeepalive    *DefaultsHttpPretendKeepalive    `json:"http_pretend_keepalive,omitempty"`
	HttpRequestTimeout      *int                             `json:"http_request_timeout"`
	HttpRestrictReqHdrNames *DefaultsHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse               *DefaultsHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader      *string                          `json:"http_send_name_header"`
	HttpUseProxyHeader      *DefaultsHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	HttpchkParams           *HttpchkParams                   `json:"httpchk_params,omitempty"`
	Httplog                 *bool                            `json:"httplog,omitempty"`
	Httpslog                *DefaultsHttpslog                `json:"httpslog,omitempty"`
	IdleCloseOnResponse     *DefaultsIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams      *DefaultsIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile *DefaultsLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogFormat               *string                          `json:"log_format,omitempty"`
	LogFormatSd             *string                          `json:"log_format_sd,omitempty"`
	LogHealthChecks         *DefaultsLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogSeparateErrors       *DefaultsLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogTag                  *string                          `json:"log_tag,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList     *LogTargets               `json:"log_target_list,omitempty"`
	Logasap           *DefaultsLogasap          `json:"logasap,omitempty"`
	MaxKeepAliveQueue *int                      `json:"max_keep_alive_queue"`
	Maxconn           *int                      `json:"maxconn"`
	Mode              *DefaultsMode             `json:"mode,omitempty"`
	MonitorUri        *MonitorUri               `json:"monitor_uri,omitempty"`
	MysqlCheckParams  *MysqlCheckParams         `json:"mysql_check_params,omitempty"`
	Name              *string                   `json:"name,omitempty"`
	Nolinger          *DefaultsNolinger         `json:"nolinger,omitempty"`
	Originalto        *Originalto               `json:"originalto,omitempty"`
	Persist           *DefaultsPersist          `json:"persist,omitempty"`
	PersistRule       *PersistRule              `json:"persist_rule,omitempty"`
	PgsqlCheckParams  *PgsqlCheckParams         `json:"pgsql_check_params,omitempty"`
	PreferLastServer  *DefaultsPreferLastServer `json:"prefer_last_server,omitempty"`
	QueueTimeout      *int                      `json:"queue_timeout"`
	Redispatch        *Redispatch               `json:"redispatch,omitempty"`
	Retries           *int                      `json:"retries"`
	RetryOn           *string                   `json:"retry_on,omitempty"`
	ServerFinTimeout  *int                      `json:"server_fin_timeout"`
	ServerTimeout     *int                      `json:"server_timeout"`
	SmtpchkParams     *SmtpchkParams            `json:"smtpchk_params,omitempty"`
	SocketStats       *DefaultsSocketStats      `json:"socket_stats,omitempty"`
	Source            *Source                   `json:"source,omitempty"`
	SpliceAuto        *DefaultsSpliceAuto       `json:"splice_auto,omitempty"`
	SpliceRequest     *DefaultsSpliceRequest    `json:"splice_request,omitempty"`
	SpliceResponse    *DefaultsSpliceResponse   `json:"splice_response,omitempty"`
	Srvtcpka          *DefaultsSrvtcpka         `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt       *int                      `json:"srvtcpka_cnt"`
	SrvtcpkaIdle      *int                      `json:"srvtcpka_idle"`
	SrvtcpkaIntvl     *int                      `json:"srvtcpka_intvl"`
	StatsOptions      *StatsOptions             `json:"stats_options,omitempty"`
	TarpitTimeout     *int                      `json:"tarpit_timeout"`
	TcpCheckRuleList  *TcpChecks                `json:"tcp_check_rule_list,omitempty"`
	TcpSmartAccept    *DefaultsTcpSmartAccept   `json:"tcp_smart_accept,omitempty"`
	TcpSmartConnect   *DefaultsTcpSmartConnect  `json:"tcp_smart_connect,omitempty"`
	Tcpka             *DefaultsTcpka            `json:"tcpka,omitempty"`
	Tcplog            *bool                     `json:"tcplog,omitempty"`
	Transparent       *DefaultsTransparent      `json:"transparent,omitempty"`
	TunnelTimeout     *int                      `json:"tunnel_timeout"`
	UniqueIdFormat    *string                   `json:"unique_id_format,omitempty"`
	UniqueIdHeader    *string                   `json:"unique_id_header,omitempty"`
}

// DefaultsAbortonclose defines model for Defaults.Abortonclose.
type DefaultsAbortonclose string

// DefaultsAcceptInvalidHttpRequest defines model for Defaults.AcceptInvalidHttpRequest.
type DefaultsAcceptInvalidHttpRequest string

// DefaultsAcceptInvalidHttpResponse defines model for Defaults.AcceptInvalidHttpResponse.
type DefaultsAcceptInvalidHttpResponse string

// DefaultsAdvCheck defines model for Defaults.AdvCheck.
type DefaultsAdvCheck string

// DefaultsAllbackups defines model for Defaults.Allbackups.
type DefaultsAllbackups string

// DefaultsCheckcache defines model for Defaults.Checkcache.
type DefaultsCheckcache string

// DefaultsClitcpka defines model for Defaults.Clitcpka.
type DefaultsClitcpka string

// DefaultsContstats defines model for Defaults.Contstats.
type DefaultsContstats string

// DefaultsDisableH2Upgrade defines model for Defaults.DisableH2Upgrade.
type DefaultsDisableH2Upgrade string

// DefaultsDontlogNormal defines model for Defaults.DontlogNormal.
type DefaultsDontlogNormal string

// DefaultsDontlognull defines model for Defaults.Dontlognull.
type DefaultsDontlognull string

// DefaultsExternalCheck defines model for Defaults.ExternalCheck.
type DefaultsExternalCheck string

// DefaultsH1CaseAdjustBogusClient defines model for Defaults.H1CaseAdjustBogusClient.
type DefaultsH1CaseAdjustBogusClient string

// DefaultsH1CaseAdjustBogusServer defines model for Defaults.H1CaseAdjustBogusServer.
type DefaultsH1CaseAdjustBogusServer string

// DefaultsHttpBufferRequest defines model for Defaults.HttpBufferRequest.
type DefaultsHttpBufferRequest string

// DefaultsHttpUseHtx defines model for Defaults.HttpUseHtx.
type DefaultsHttpUseHtx string

// DefaultsHttpConnectionMode defines model for Defaults.HttpConnectionMode.
type DefaultsHttpConnectionMode string

// DefaultsHttpIgnoreProbes defines model for Defaults.HttpIgnoreProbes.
type DefaultsHttpIgnoreProbes string

// DefaultsHttpNoDelay defines model for Defaults.HttpNoDelay.
type DefaultsHttpNoDelay string

// DefaultsHttpPretendKeepalive defines model for Defaults.HttpPretendKeepalive.
type DefaultsHttpPretendKeepalive string

// DefaultsHttpRestrictReqHdrNames defines model for Defaults.HttpRestrictReqHdrNames.
type DefaultsHttpRestrictReqHdrNames string

// DefaultsHttpReuse defines model for Defaults.HttpReuse.
type DefaultsHttpReuse string

// DefaultsHttpUseProxyHeader defines model for Defaults.HttpUseProxyHeader.
type DefaultsHttpUseProxyHeader string

// DefaultsHttpslog defines model for Defaults.Httpslog.
type DefaultsHttpslog string

// DefaultsIdleCloseOnResponse defines model for Defaults.IdleCloseOnResponse.
type DefaultsIdleCloseOnResponse string

// DefaultsIndependentStreams defines model for Defaults.IndependentStreams.
type DefaultsIndependentStreams string

// DefaultsLoadServerStateFromFile defines model for Defaults.LoadServerStateFromFile.
type DefaultsLoadServerStateFromFile string

// DefaultsLogHealthChecks defines model for Defaults.LogHealthChecks.
type DefaultsLogHealthChecks string

// DefaultsLogSeparateErrors defines model for Defaults.LogSeparateErrors.
type DefaultsLogSeparateErrors string

// DefaultsLogasap defines model for Defaults.Logasap.
type DefaultsLogasap string

// DefaultsMode defines model for Defaults.Mode.
type DefaultsMode string

// DefaultsNolinger defines model for Defaults.Nolinger.
type DefaultsNolinger string

// DefaultsPersist defines model for Defaults.Persist.
type DefaultsPersist string

// DefaultsPreferLastServer defines model for Defaults.PreferLastServer.
type DefaultsPreferLastServer string

// DefaultsSocketStats defines model for Defaults.SocketStats.
type DefaultsSocketStats string

// DefaultsSpliceAuto defines model for Defaults.SpliceAuto.
type DefaultsSpliceAuto string

// DefaultsSpliceRequest defines model for Defaults.SpliceRequest.
type DefaultsSpliceRequest string

// DefaultsSpliceResponse defines model for Defaults.SpliceResponse.
type DefaultsSpliceResponse string

// DefaultsSrvtcpka defines model for Defaults.Srvtcpka.
type DefaultsSrvtcpka string

// DefaultsTcpSmartAccept defines model for Defaults.TcpSmartAccept.
type DefaultsTcpSmartAccept string

// DefaultsTcpSmartConnect defines model for Defaults.TcpSmartConnect.
type DefaultsTcpSmartConnect string

// DefaultsTcpka defines model for Defaults.Tcpka.
type DefaultsTcpka string

// DefaultsTransparent defines model for Defaults.Transparent.
type DefaultsTransparent string

// DefaultsBase HAProxy defaults configuration
type DefaultsBase struct {
	Abortonclose              *DefaultsBaseAbortonclose              `json:"abortonclose,omitempty"`
	AcceptInvalidHttpRequest  *DefaultsBaseAcceptInvalidHttpRequest  `json:"accept_invalid_http_request,omitempty"`
	AcceptInvalidHttpResponse *DefaultsBaseAcceptInvalidHttpResponse `json:"accept_invalid_http_response,omitempty"`
	AdvCheck                  *DefaultsBaseAdvCheck                  `json:"adv_check,omitempty"`
	Allbackups                *DefaultsBaseAllbackups                `json:"allbackups,omitempty"`
	Backlog                   *int                                   `json:"backlog"`
	Balance                   *Balance                               `json:"balance,omitempty"`
	CheckTimeout              *int                                   `json:"check_timeout"`
	Checkcache                *DefaultsBaseCheckcache                `json:"checkcache,omitempty"`
	Clflog                    *bool                                  `json:"clflog,omitempty"`
	ClientFinTimeout          *int                                   `json:"client_fin_timeout"`
	ClientTimeout             *int                                   `json:"client_timeout"`
	Clitcpka                  *DefaultsBaseClitcpka                  `json:"clitcpka,omitempty"`
	ClitcpkaCnt               *int                                   `json:"clitcpka_cnt"`
	ClitcpkaIdle              *int                                   `json:"clitcpka_idle"`
	ClitcpkaIntvl             *int                                   `json:"clitcpka_intvl"`
	Compression               *Compression                           `json:"compression,omitempty"`
	ConnectTimeout            *int                                   `json:"connect_timeout"`
	Contstats                 *DefaultsBaseContstats                 `json:"contstats,omitempty"`
	Cookie                    *Cookie                                `json:"cookie,omitempty"`
	DefaultBackend            *string                                `json:"default_backend,omitempty"`
	DefaultServer             *DefaultServer                         `json:"default_server,omitempty"`
	DisableH2Upgrade          *DefaultsBaseDisableH2Upgrade          `json:"disable_h2_upgrade,omitempty"`
	Disabled                  *bool                                  `json:"disabled,omitempty"`
	DontlogNormal             *DefaultsBaseDontlogNormal             `json:"dontlog_normal,omitempty"`
	Dontlognull               *DefaultsBaseDontlognull               `json:"dontlognull,omitempty"`
	DynamicCookieKey          *string                                `json:"dynamic_cookie_key,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert                          `json:"email_alert,omitempty"`
	Enabled                  *bool                                `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile                         `json:"error_files,omitempty"`
	ErrorLogFormat           *string                              `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles                        `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                            `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                            `json:"errorloc303,omitempty"`
	ExternalCheck            *DefaultsBaseExternalCheck           `json:"external_check,omitempty"`
	ExternalCheckCommand     *string                              `json:"external_check_command,omitempty"`
	ExternalCheckPath        *string                              `json:"external_check_path,omitempty"`
	Forwardfor               *Forwardfor                          `json:"forwardfor,omitempty"`
	From                     *string                              `json:"from,omitempty"`
	Fullconn                 *int                                 `json:"fullconn"`
	H1CaseAdjustBogusClient  *DefaultsBaseH1CaseAdjustBogusClient `json:"h1_case_adjust_bogus_client,omitempty"`
	H1CaseAdjustBogusServer  *DefaultsBaseH1CaseAdjustBogusServer `json:"h1_case_adjust_bogus_server,omitempty"`
	HashBalanceFactor        *int                                 `json:"hash_balance_factor"`
	HashType                 *HashType                            `json:"hash_type,omitempty"`
	HttpBufferRequest        *DefaultsBaseHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpUseHtx               *DefaultsBaseHttpUseHtx              `json:"http-use-htx,omitempty"`
	HttpConnectionMode       *DefaultsBaseHttpConnectionMode      `json:"http_connection_mode,omitempty"`
	HttpIgnoreProbes         *DefaultsBaseHttpIgnoreProbes        `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout     *int                                 `json:"http_keep_alive_timeout"`
	HttpNoDelay              *DefaultsBaseHttpNoDelay             `json:"http_no_delay,omitempty"`
	HttpPretendKeepalive     *DefaultsBaseHttpPretendKeepalive    `json:"http_pretend_keepalive,omitempty"`
	HttpRequestTimeout       *int                                 `json:"http_request_timeout"`
	HttpRestrictReqHdrNames  *DefaultsBaseHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpReuse                *DefaultsBaseHttpReuse               `json:"http_reuse,omitempty"`
	HttpSendNameHeader       *string                              `json:"http_send_name_header"`
	HttpUseProxyHeader       *DefaultsBaseHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	HttpchkParams            *HttpchkParams                       `json:"httpchk_params,omitempty"`
	Httplog                  *bool                                `json:"httplog,omitempty"`
	Httpslog                 *DefaultsBaseHttpslog                `json:"httpslog,omitempty"`
	IdleCloseOnResponse      *DefaultsBaseIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams       *DefaultsBaseIndependentStreams      `json:"independent_streams,omitempty"`
	LoadServerStateFromFile  *DefaultsBaseLoadServerStateFromFile `json:"load_server_state_from_file,omitempty"`
	LogFormat                *string                              `json:"log_format,omitempty"`
	LogFormatSd              *string                              `json:"log_format_sd,omitempty"`
	LogHealthChecks          *DefaultsBaseLogHealthChecks         `json:"log_health_checks,omitempty"`
	LogSeparateErrors        *DefaultsBaseLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogTag                   *string                              `json:"log_tag,omitempty"`
	Logasap                  *DefaultsBaseLogasap                 `json:"logasap,omitempty"`
	MaxKeepAliveQueue        *int                                 `json:"max_keep_alive_queue"`
	Maxconn                  *int                                 `json:"maxconn"`
	Mode                     *DefaultsBaseMode                    `json:"mode,omitempty"`
	MonitorUri               *MonitorUri                          `json:"monitor_uri,omitempty"`
	MysqlCheckParams         *MysqlCheckParams                    `json:"mysql_check_params,omitempty"`
	Name                     *string                              `json:"name,omitempty"`
	Nolinger                 *DefaultsBaseNolinger                `json:"nolinger,omitempty"`
	Originalto               *Originalto                          `json:"originalto,omitempty"`
	Persist                  *DefaultsBasePersist                 `json:"persist,omitempty"`
	PersistRule              *PersistRule                         `json:"persist_rule,omitempty"`
	PgsqlCheckParams         *PgsqlCheckParams                    `json:"pgsql_check_params,omitempty"`
	PreferLastServer         *DefaultsBasePreferLastServer        `json:"prefer_last_server,omitempty"`
	QueueTimeout             *int                                 `json:"queue_timeout"`
	Redispatch               *Redispatch                          `json:"redispatch,omitempty"`
	Retries                  *int                                 `json:"retries"`
	RetryOn                  *string                              `json:"retry_on,omitempty"`
	ServerFinTimeout         *int                                 `json:"server_fin_timeout"`
	ServerTimeout            *int                                 `json:"server_timeout"`
	SmtpchkParams            *SmtpchkParams                       `json:"smtpchk_params,omitempty"`
	SocketStats              *DefaultsBaseSocketStats             `json:"socket_stats,omitempty"`
	Source                   *Source                              `json:"source,omitempty"`
	SpliceAuto               *DefaultsBaseSpliceAuto              `json:"splice_auto,omitempty"`
	SpliceRequest            *DefaultsBaseSpliceRequest           `json:"splice_request,omitempty"`
	SpliceResponse           *DefaultsBaseSpliceResponse          `json:"splice_response,omitempty"`
	Srvtcpka                 *DefaultsBaseSrvtcpka                `json:"srvtcpka,omitempty"`
	SrvtcpkaCnt              *int                                 `json:"srvtcpka_cnt"`
	SrvtcpkaIdle             *int                                 `json:"srvtcpka_idle"`
	SrvtcpkaIntvl            *int                                 `json:"srvtcpka_intvl"`
	StatsOptions             *StatsOptions                        `json:"stats_options,omitempty"`
	TarpitTimeout            *int                                 `json:"tarpit_timeout"`
	TcpSmartAccept           *DefaultsBaseTcpSmartAccept          `json:"tcp_smart_accept,omitempty"`
	TcpSmartConnect          *DefaultsBaseTcpSmartConnect         `json:"tcp_smart_connect,omitempty"`
	Tcpka                    *DefaultsBaseTcpka                   `json:"tcpka,omitempty"`
	Tcplog                   *bool                                `json:"tcplog,omitempty"`
	Transparent              *DefaultsBaseTransparent             `json:"transparent,omitempty"`
	TunnelTimeout            *int                                 `json:"tunnel_timeout"`
	UniqueIdFormat           *string                              `json:"unique_id_format,omitempty"`
	UniqueIdHeader           *string                              `json:"unique_id_header,omitempty"`
}

// DefaultsBaseAbortonclose defines model for DefaultsBase.Abortonclose.
type DefaultsBaseAbortonclose string

// DefaultsBaseAcceptInvalidHttpRequest defines model for DefaultsBase.AcceptInvalidHttpRequest.
type DefaultsBaseAcceptInvalidHttpRequest string

// DefaultsBaseAcceptInvalidHttpResponse defines model for DefaultsBase.AcceptInvalidHttpResponse.
type DefaultsBaseAcceptInvalidHttpResponse string

// DefaultsBaseAdvCheck defines model for DefaultsBase.AdvCheck.
type DefaultsBaseAdvCheck string

// DefaultsBaseAllbackups defines model for DefaultsBase.Allbackups.
type DefaultsBaseAllbackups string

// DefaultsBaseCheckcache defines model for DefaultsBase.Checkcache.
type DefaultsBaseCheckcache string

// DefaultsBaseClitcpka defines model for DefaultsBase.Clitcpka.
type DefaultsBaseClitcpka string

// DefaultsBaseContstats defines model for DefaultsBase.Contstats.
type DefaultsBaseContstats string

// DefaultsBaseDisableH2Upgrade defines model for DefaultsBase.DisableH2Upgrade.
type DefaultsBaseDisableH2Upgrade string

// DefaultsBaseDontlogNormal defines model for DefaultsBase.DontlogNormal.
type DefaultsBaseDontlogNormal string

// DefaultsBaseDontlognull defines model for DefaultsBase.Dontlognull.
type DefaultsBaseDontlognull string

// DefaultsBaseExternalCheck defines model for DefaultsBase.ExternalCheck.
type DefaultsBaseExternalCheck string

// DefaultsBaseH1CaseAdjustBogusClient defines model for DefaultsBase.H1CaseAdjustBogusClient.
type DefaultsBaseH1CaseAdjustBogusClient string

// DefaultsBaseH1CaseAdjustBogusServer defines model for DefaultsBase.H1CaseAdjustBogusServer.
type DefaultsBaseH1CaseAdjustBogusServer string

// DefaultsBaseHttpBufferRequest defines model for DefaultsBase.HttpBufferRequest.
type DefaultsBaseHttpBufferRequest string

// DefaultsBaseHttpUseHtx defines model for DefaultsBase.HttpUseHtx.
type DefaultsBaseHttpUseHtx string

// DefaultsBaseHttpConnectionMode defines model for DefaultsBase.HttpConnectionMode.
type DefaultsBaseHttpConnectionMode string

// DefaultsBaseHttpIgnoreProbes defines model for DefaultsBase.HttpIgnoreProbes.
type DefaultsBaseHttpIgnoreProbes string

// DefaultsBaseHttpNoDelay defines model for DefaultsBase.HttpNoDelay.
type DefaultsBaseHttpNoDelay string

// DefaultsBaseHttpPretendKeepalive defines model for DefaultsBase.HttpPretendKeepalive.
type DefaultsBaseHttpPretendKeepalive string

// DefaultsBaseHttpRestrictReqHdrNames defines model for DefaultsBase.HttpRestrictReqHdrNames.
type DefaultsBaseHttpRestrictReqHdrNames string

// DefaultsBaseHttpReuse defines model for DefaultsBase.HttpReuse.
type DefaultsBaseHttpReuse string

// DefaultsBaseHttpUseProxyHeader defines model for DefaultsBase.HttpUseProxyHeader.
type DefaultsBaseHttpUseProxyHeader string

// DefaultsBaseHttpslog defines model for DefaultsBase.Httpslog.
type DefaultsBaseHttpslog string

// DefaultsBaseIdleCloseOnResponse defines model for DefaultsBase.IdleCloseOnResponse.
type DefaultsBaseIdleCloseOnResponse string

// DefaultsBaseIndependentStreams defines model for DefaultsBase.IndependentStreams.
type DefaultsBaseIndependentStreams string

// DefaultsBaseLoadServerStateFromFile defines model for DefaultsBase.LoadServerStateFromFile.
type DefaultsBaseLoadServerStateFromFile string

// DefaultsBaseLogHealthChecks defines model for DefaultsBase.LogHealthChecks.
type DefaultsBaseLogHealthChecks string

// DefaultsBaseLogSeparateErrors defines model for DefaultsBase.LogSeparateErrors.
type DefaultsBaseLogSeparateErrors string

// DefaultsBaseLogasap defines model for DefaultsBase.Logasap.
type DefaultsBaseLogasap string

// DefaultsBaseMode defines model for DefaultsBase.Mode.
type DefaultsBaseMode string

// DefaultsBaseNolinger defines model for DefaultsBase.Nolinger.
type DefaultsBaseNolinger string

// DefaultsBasePersist defines model for DefaultsBase.Persist.
type DefaultsBasePersist string

// DefaultsBasePreferLastServer defines model for DefaultsBase.PreferLastServer.
type DefaultsBasePreferLastServer string

// DefaultsBaseSocketStats defines model for DefaultsBase.SocketStats.
type DefaultsBaseSocketStats string

// DefaultsBaseSpliceAuto defines model for DefaultsBase.SpliceAuto.
type DefaultsBaseSpliceAuto string

// DefaultsBaseSpliceRequest defines model for DefaultsBase.SpliceRequest.
type DefaultsBaseSpliceRequest string

// DefaultsBaseSpliceResponse defines model for DefaultsBase.SpliceResponse.
type DefaultsBaseSpliceResponse string

// DefaultsBaseSrvtcpka defines model for DefaultsBase.Srvtcpka.
type DefaultsBaseSrvtcpka string

// DefaultsBaseTcpSmartAccept defines model for DefaultsBase.TcpSmartAccept.
type DefaultsBaseTcpSmartAccept string

// DefaultsBaseTcpSmartConnect defines model for DefaultsBase.TcpSmartConnect.
type DefaultsBaseTcpSmartConnect string

// DefaultsBaseTcpka defines model for DefaultsBase.Tcpka.
type DefaultsBaseTcpka string

// DefaultsBaseTransparent defines model for DefaultsBase.Transparent.
type DefaultsBaseTransparent string

// DefaultsSections HAProxy defaults sections array
type DefaultsSections = []Defaults

// DeviceAtlasOptions defines model for device_atlas_options.
type DeviceAtlasOptions struct {
	CacheSize        *int    `json:"cache_size"`
	JsonFile         *string `json:"json_file,omitempty"`
	LogLevel         *string `json:"log_level,omitempty"`
	PropertiesCookie *string `json:"properties_cookie,omitempty"`
	Separator        *string `json:"separator,omitempty"`
}

// DgramBind HAProxy log forward dgram bind configuration
type DgramBind struct {
	Address      *string `json:"address,omitempty"`
	Interface    *string `json:"interface,omitempty"`
	Name         *string `json:"name,omitempty"`
	Namespace    *string `json:"namespace,omitempty"`
	Nice         *int    `json:"nice,omitempty"`
	Port         *int    `json:"port"`
	PortRangeEnd *int    `json:"port-range-end"`
	Shards       *int    `json:"shards,omitempty"`
	Thread       *string `json:"thread,omitempty"`
	Transparent  *bool   `json:"transparent,omitempty"`
}

// DgramBinds HAProxy dgram bind array
type DgramBinds = []DgramBind

// DynamicUpdateRule defines model for dynamic_update_rule.
type DynamicUpdateRule struct {
	AgentAddr          *string                            `json:"agent-addr,omitempty"`
	AgentCheck         *DynamicUpdateRuleAgentCheck       `json:"agent-check,omitempty"`
	AgentInter         *int                               `json:"agent-inter"`
	AgentPort          *int                               `json:"agent-port"`
	AgentSend          *string                            `json:"agent-send,omitempty"`
	Allow0rtt          *bool                              `json:"allow_0rtt,omitempty"`
	Alpn               *string                            `json:"alpn,omitempty"`
	Backup             *DynamicUpdateRuleBackup           `json:"backup,omitempty"`
	Check              *DynamicUpdateRuleCheck            `json:"check,omitempty"`
	CheckSendProxy     *DynamicUpdateRuleCheckSendProxy   `json:"check-send-proxy,omitempty"`
	CheckSni           *string                            `json:"check-sni,omitempty"`
	CheckSsl           *DynamicUpdateRuleCheckSsl         `json:"check-ssl,omitempty"`
	CheckAlpn          *string                            `json:"check_alpn,omitempty"`
	CheckProto         *string                            `json:"check_proto,omitempty"`
	CheckViaSocks4     *DynamicUpdateRuleCheckViaSocks4   `json:"check_via_socks4,omitempty"`
	Ciphers            *string                            `json:"ciphers,omitempty"`
	Ciphersuites       *string                            `json:"ciphersuites,omitempty"`
	ClientSigalgs      *string                            `json:"client_sigalgs,omitempty"`
	Cookie             *string                            `json:"cookie,omitempty"`
	CrlFile            *string                            `json:"crl_file,omitempty"`
	Curves             *string                            `json:"curves,omitempty"`
	Delay              *int                               `json:"delay"`
	DontlogNormal      *bool                              `json:"dontlog-normal,omitempty"`
	Downinter          *int                               `json:"downinter"`
	ErrorLimit         *int                               `json:"error_limit,omitempty"`
	Fall               *int                               `json:"fall"`
	Fastinter          *int                               `json:"fastinter"`
	ForceSslv3         *DynamicUpdateRuleForceSslv3       `json:"force_sslv3,omitempty"`
	ForceTlsv10        *DynamicUpdateRuleForceTlsv10      `json:"force_tlsv10,omitempty"`
	ForceTlsv11        *DynamicUpdateRuleForceTlsv11      `json:"force_tlsv11,omitempty"`
	ForceTlsv12        *DynamicUpdateRuleForceTlsv12      `json:"force_tlsv12,omitempty"`
	ForceTlsv13        *DynamicUpdateRuleForceTlsv13      `json:"force_tlsv13,omitempty"`
	Guid               *string                            `json:"guid,omitempty"`
	HashKey            *string                            `json:"hash_key,omitempty"`
	HealthCheckAddress *string                            `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                               `json:"health_check_port"`
	Id                 string                             `json:"id"`
	InitAddr           *string                            `json:"init-addr"`
	Inter              *int                               `json:"inter"`
	Log                *bool                              `json:"log,omitempty"`
	LogBufsize         *int                               `json:"log-bufsize"`
	LogProto           *DynamicUpdateRuleLogProto         `json:"log_proto,omitempty"`
	Maintenance        *DynamicUpdateRuleMaintenance      `json:"maintenance,omitempty"`
	Map                *bool                              `json:"map,omitempty"`
	MaxReuse           *int                               `json:"max_reuse"`
	Maxconn            *int                               `json:"maxconn"`
	Maxqueue           *int                               `json:"maxqueue"`
	Minconn            *int                               `json:"minconn"`
	Modified           *bool                              `json:"modified,omitempty"`
	Namespace          *string                            `json:"namespace,omitempty"`
	NoSslv3            *DynamicUpdateRuleNoSslv3          `json:"no_sslv3,omitempty"`
	NoTlsv10           *DynamicUpdateRuleNoTlsv10         `json:"no_tlsv10,omitempty"`
	NoTlsv11           *DynamicUpdateRuleNoTlsv11         `json:"no_tlsv11,omitempty"`
	NoTlsv12           *DynamicUpdateRuleNoTlsv12         `json:"no_tlsv12,omitempty"`
	NoTlsv13           *DynamicUpdateRuleNoTlsv13         `json:"no_tlsv13,omitempty"`
	NoVerifyhost       *DynamicUpdateRuleNoVerifyhost     `json:"no_verifyhost,omitempty"`
	Npn                *string                            `json:"npn,omitempty"`
	Observe            *DynamicUpdateRuleObserve          `json:"observe,omitempty"`
	OnError            *DynamicUpdateRuleOnError          `json:"on-error,omitempty"`
	OnMarkedDown       *DynamicUpdateRuleOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp         *DynamicUpdateRuleOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolConnName       *string                            `json:"pool_conn_name,omitempty"`
	PoolLowConn        *int                               `json:"pool_low_conn"`
	PoolMaxConn        *int                               `json:"pool_max_conn"`
	PoolPurgeDelay     *int                               `json:"pool_purge_delay"`
	Proto              *string                            `json:"proto,omitempty"`
	ProxyV2Options     *[]DynamicUpdateRuleProxyV2Options `json:"proxy-v2-options,omitempty"`
	PurgeCount         *int                               `json:"purge_count"`
	PurgeId            *string                            `json:"purge_id"`
	PurgeInterval      *int                               `json:"purge_interval"`
	Redir              *string                            `json:"redir,omitempty"`
	ResolveNet         *string                            `json:"resolve-net,omitempty"`
	ResolvePrefer      *DynamicUpdateRuleResolvePrefer    `json:"resolve-prefer,omitempty"`
	ResolveOpts        *string                            `json:"resolve_opts,omitempty"`
	Resolvers          *string                            `json:"resolvers,omitempty"`
	Retries            *int                               `json:"retries"`
	Rise               *int                               `json:"rise"`
	SendProxy          *DynamicUpdateRuleSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2        *DynamicUpdateRuleSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl     *DynamicUpdateRuleSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn   *DynamicUpdateRuleSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt   *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int                         `json:"shard,omitempty"`
	Sigalgs        *string                      `json:"sigalgs,omitempty"`
	Slowstart      *int                         `json:"slowstart"`
	Sni            *string                      `json:"sni,omitempty"`
	Socks4         *string                      `json:"socks4,omitempty"`
	Source         *string                      `json:"source,omitempty"`
	SourceAddress  *string                      `json:"source_address,omitempty"`
	SourcePort     *int                         `json:"source_port,omitempty"`
	Ssl            *DynamicUpdateRuleSsl        `json:"ssl,omitempty"`
	SslCafile      *string                      `json:"ssl_cafile,omitempty"`
	SslCertificate *string                      `json:"ssl_certificate,omitempty"`
	SslMaxVer      *DynamicUpdateRuleSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *DynamicUpdateRuleSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *DynamicUpdateRuleSslReuse   `json:"ssl_reuse,omitempty"`
	Stick          *DynamicUpdateRuleStick      `json:"stick,omitempty"`
	TcpUt          *int                         `json:"tcp_ut"`
	Tfo            *DynamicUpdateRuleTfo        `json:"tfo,omitempty"`
	Timeout        *int                         `json:"timeout"`
	TlsTickets     *DynamicUpdateRuleTlsTickets `json:"tls_tickets,omitempty"`
	Track          *string                      `json:"track,omitempty"`
	Url            string                       `json:"url"`
	Verify         *DynamicUpdateRuleVerify     `json:"verify,omitempty"`
	Verifyhost     *string                      `json:"verifyhost,omitempty"`
	Weight         *int                         `json:"weight"`
	Ws             *DynamicUpdateRuleWs         `json:"ws,omitempty"`
	Xdelay         *int                         `json:"xdelay"`
	Xmodified      *bool                        `json:"xmodified,omitempty"`
	Xnext          *int                         `json:"xnext"`
	Xretry         *int                         `json:"xretry"`
	Xstart         *int                         `json:"xstart"`
}

// DynamicUpdateRuleAgentCheck defines model for DynamicUpdateRule.AgentCheck.
type DynamicUpdateRuleAgentCheck string

// DynamicUpdateRuleBackup defines model for DynamicUpdateRule.Backup.
type DynamicUpdateRuleBackup string

// DynamicUpdateRuleCheck defines model for DynamicUpdateRule.Check.
type DynamicUpdateRuleCheck string

// DynamicUpdateRuleCheckSendProxy defines model for DynamicUpdateRule.CheckSendProxy.
type DynamicUpdateRuleCheckSendProxy string

// DynamicUpdateRuleCheckSsl defines model for DynamicUpdateRule.CheckSsl.
type DynamicUpdateRuleCheckSsl string

// DynamicUpdateRuleCheckViaSocks4 defines model for DynamicUpdateRule.CheckViaSocks4.
type DynamicUpdateRuleCheckViaSocks4 string

// DynamicUpdateRuleForceSslv3 defines model for DynamicUpdateRule.ForceSslv3.
type DynamicUpdateRuleForceSslv3 string

// DynamicUpdateRuleForceTlsv10 defines model for DynamicUpdateRule.ForceTlsv10.
type DynamicUpdateRuleForceTlsv10 string

// DynamicUpdateRuleForceTlsv11 defines model for DynamicUpdateRule.ForceTlsv11.
type DynamicUpdateRuleForceTlsv11 string

// DynamicUpdateRuleForceTlsv12 defines model for DynamicUpdateRule.ForceTlsv12.
type DynamicUpdateRuleForceTlsv12 string

// DynamicUpdateRuleForceTlsv13 defines model for DynamicUpdateRule.ForceTlsv13.
type DynamicUpdateRuleForceTlsv13 string

// DynamicUpdateRuleLogProto defines model for DynamicUpdateRule.LogProto.
type DynamicUpdateRuleLogProto string

// DynamicUpdateRuleMaintenance defines model for DynamicUpdateRule.Maintenance.
type DynamicUpdateRuleMaintenance string

// DynamicUpdateRuleNoSslv3 defines model for DynamicUpdateRule.NoSslv3.
type DynamicUpdateRuleNoSslv3 string

// DynamicUpdateRuleNoTlsv10 defines model for DynamicUpdateRule.NoTlsv10.
type DynamicUpdateRuleNoTlsv10 string

// DynamicUpdateRuleNoTlsv11 defines model for DynamicUpdateRule.NoTlsv11.
type DynamicUpdateRuleNoTlsv11 string

// DynamicUpdateRuleNoTlsv12 defines model for DynamicUpdateRule.NoTlsv12.
type DynamicUpdateRuleNoTlsv12 string

// DynamicUpdateRuleNoTlsv13 defines model for DynamicUpdateRule.NoTlsv13.
type DynamicUpdateRuleNoTlsv13 string

// DynamicUpdateRuleNoVerifyhost defines model for DynamicUpdateRule.NoVerifyhost.
type DynamicUpdateRuleNoVerifyhost string

// DynamicUpdateRuleObserve defines model for DynamicUpdateRule.Observe.
type DynamicUpdateRuleObserve string

// DynamicUpdateRuleOnError defines model for DynamicUpdateRule.OnError.
type DynamicUpdateRuleOnError string

// DynamicUpdateRuleOnMarkedDown defines model for DynamicUpdateRule.OnMarkedDown.
type DynamicUpdateRuleOnMarkedDown string

// DynamicUpdateRuleOnMarkedUp defines model for DynamicUpdateRule.OnMarkedUp.
type DynamicUpdateRuleOnMarkedUp string

// DynamicUpdateRuleProxyV2Options defines model for DynamicUpdateRule.ProxyV2Options.
type DynamicUpdateRuleProxyV2Options string

// DynamicUpdateRuleResolvePrefer defines model for DynamicUpdateRule.ResolvePrefer.
type DynamicUpdateRuleResolvePrefer string

// DynamicUpdateRuleSendProxy defines model for DynamicUpdateRule.SendProxy.
type DynamicUpdateRuleSendProxy string

// DynamicUpdateRuleSendProxyV2 defines model for DynamicUpdateRule.SendProxyV2.
type DynamicUpdateRuleSendProxyV2 string

// DynamicUpdateRuleSendProxyV2Ssl defines model for DynamicUpdateRule.SendProxyV2Ssl.
type DynamicUpdateRuleSendProxyV2Ssl string

// DynamicUpdateRuleSendProxyV2SslCn defines model for DynamicUpdateRule.SendProxyV2SslCn.
type DynamicUpdateRuleSendProxyV2SslCn string

// DynamicUpdateRuleSsl defines model for DynamicUpdateRule.Ssl.
type DynamicUpdateRuleSsl string

// DynamicUpdateRuleSslMaxVer defines model for DynamicUpdateRule.SslMaxVer.
type DynamicUpdateRuleSslMaxVer string

// DynamicUpdateRuleSslMinVer defines model for DynamicUpdateRule.SslMinVer.
type DynamicUpdateRuleSslMinVer string

// DynamicUpdateRuleSslReuse defines model for DynamicUpdateRule.SslReuse.
type DynamicUpdateRuleSslReuse string

// DynamicUpdateRuleStick defines model for DynamicUpdateRule.Stick.
type DynamicUpdateRuleStick string

// DynamicUpdateRuleTfo defines model for DynamicUpdateRule.Tfo.
type DynamicUpdateRuleTfo string

// DynamicUpdateRuleTlsTickets defines model for DynamicUpdateRule.TlsTickets.
type DynamicUpdateRuleTlsTickets string

// DynamicUpdateRuleVerify defines model for DynamicUpdateRule.Verify.
type DynamicUpdateRuleVerify string

// DynamicUpdateRuleWs defines model for DynamicUpdateRule.Ws.
type DynamicUpdateRuleWs string

// DynamicUpdateRules defines model for dynamic_update_rules.
type DynamicUpdateRules = []DynamicUpdateRule

// EmailAlert Send emails for important log messages.
type EmailAlert struct {
	From       string           `json:"from"`
	Level      *EmailAlertLevel `json:"level,omitempty"`
	Mailers    string           `json:"mailers"`
	Myhostname *string          `json:"myhostname,omitempty"`
	To         string           `json:"to"`
}

// EmailAlertLevel defines model for EmailAlert.Level.
type EmailAlertLevel string

// Endpoint Endpoint definition
type Endpoint struct {
	// Description Endpoint description
	Description *string `json:"description,omitempty"`

	// Title Endpoint title
	Title *string `json:"title,omitempty"`

	// Url Path to the endpoint
	Url *string `json:"url,omitempty"`
}

// Endpoints Collection of endpoints
type Endpoints = []Endpoint

// EnvironmentOptions defines model for environment_options.
type EnvironmentOptions struct {
	PresetEnvs *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"presetenv,omitempty"`
	Resetenv *string `json:"resetenv,omitempty"`
	SetEnvs  *[]struct {
		Name  string `json:"name"`
		Value string `json:"value"`
	} `json:"setenv,omitempty"`
	Unsetenv *string `json:"unsetenv,omitempty"`
}

// Error API Error
type Error struct {
	Code                 *int              `json:"code"`
	Message              *string           `json:"message"`
	Sha                  *string           `json:"sha"`
	Uid                  *string           `json:"uid"`
	AdditionalProperties map[string]string `json:"-"`
}

// Errorfile defines model for errorfile.
type Errorfile struct {
	Code *ErrorfileCode `json:"code,omitempty"`
	File *string        `json:"file,omitempty"`
}

// ErrorfileCode defines model for Errorfile.Code.
type ErrorfileCode int

// Errorfiles defines model for errorfiles.
type Errorfiles struct {
	Codes *[]ErrorfilesCodes `json:"codes,omitempty"`
	Name  *string            `json:"name,omitempty"`
}

// ErrorfilesCodes defines model for Errorfiles.Codes.
type ErrorfilesCodes int

// Errorloc defines model for errorloc.
type Errorloc struct {
	Code ErrorlocCode `json:"code"`
	Url  string       `json:"url"`
}

// ErrorlocCode defines model for Errorloc.Code.
type ErrorlocCode int

// Facts Facts stats map
type Facts map[string]string

// FCGIApp defines model for fcgiApp.
type FCGIApp struct {
	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList *Acls `json:"acl_list,omitempty"`

	// Docroot Defines the document root on the remote host. The parameter serves to build the default value of FastCGI parameters SCRIPT_FILENAME and PATH_TRANSLATED. It is a mandatory setting.
	Docroot string `json:"docroot"`

	// GetValues Enables or disables the retrieval of variables related to connection management.
	GetValues *FcgiAppGetValues `json:"get_values,omitempty"`

	// Index Defines the script name to append after a URI that ends with a slash ("/") to set the default value for the FastCGI parameter SCRIPT_NAME. It is an optional setting.
	Index *string `json:"index,omitempty"`

	// KeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
	KeepConn   *FcgiAppKeepConn `json:"keep_conn,omitempty"`
	LogStderrs *[]FcgiLogStderr `json:"log_stderrs,omitempty"`

	// MaxReqs Defines the maximum number of concurrent requests this application can accept. If the FastCGI application retrieves the variable FCGI_MAX_REQS during connection establishment, it can override this option. Furthermore, if the application does not do multiplexing, it will ignore this option.
	MaxReqs *int `json:"max_reqs,omitempty"`

	// MpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
	MpxsConns *FcgiAppMpxsConns `json:"mpxs_conns,omitempty"`

	// Name Declares a FastCGI application
	Name        string            `json:"name"`
	PassHeaders *[]FcgiPassHeader `json:"pass_headers,omitempty"`

	// PathInfo Defines a regular expression to extract the script-name and the path-info from the URI.
	// Thus, <regex> must have two captures: the first to capture the script name, and the second to capture the path- info.
	// If not defined, it does not perform matching on the URI, and does not fill the FastCGI parameters PATH_INFO and PATH_TRANSLATED.
	PathInfo  *string         `json:"path_info,omitempty"`
	SetParams *[]FcgiSetParam `json:"set_params,omitempty"`
}

// FcgiAppGetValues Enables or disables the retrieval of variables related to connection management.
type FcgiAppGetValues string

// FcgiAppKeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
type FcgiAppKeepConn string

// FcgiAppMpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
type FcgiAppMpxsConns string

// FcgiAppBase HAProxy FastCGI application configuration
type FcgiAppBase struct {
	// Docroot Defines the document root on the remote host. The parameter serves to build the default value of FastCGI parameters SCRIPT_FILENAME and PATH_TRANSLATED. It is a mandatory setting.
	Docroot string `json:"docroot"`

	// GetValues Enables or disables the retrieval of variables related to connection management.
	GetValues *FcgiAppBaseGetValues `json:"get_values,omitempty"`

	// Index Defines the script name to append after a URI that ends with a slash ("/") to set the default value for the FastCGI parameter SCRIPT_NAME. It is an optional setting.
	Index *string `json:"index,omitempty"`

	// KeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
	KeepConn   *FcgiAppBaseKeepConn `json:"keep_conn,omitempty"`
	LogStderrs *[]FcgiLogStderr     `json:"log_stderrs,omitempty"`

	// MaxReqs Defines the maximum number of concurrent requests this application can accept. If the FastCGI application retrieves the variable FCGI_MAX_REQS during connection establishment, it can override this option. Furthermore, if the application does not do multiplexing, it will ignore this option.
	MaxReqs *int `json:"max_reqs,omitempty"`

	// MpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
	MpxsConns *FcgiAppBaseMpxsConns `json:"mpxs_conns,omitempty"`

	// Name Declares a FastCGI application
	Name        string            `json:"name"`
	PassHeaders *[]FcgiPassHeader `json:"pass_headers,omitempty"`

	// PathInfo Defines a regular expression to extract the script-name and the path-info from the URI.
	// Thus, <regex> must have two captures: the first to capture the script name, and the second to capture the path- info.
	// If not defined, it does not perform matching on the URI, and does not fill the FastCGI parameters PATH_INFO and PATH_TRANSLATED.
	PathInfo  *string         `json:"path_info,omitempty"`
	SetParams *[]FcgiSetParam `json:"set_params,omitempty"`
}

// FcgiAppBaseGetValues Enables or disables the retrieval of variables related to connection management.
type FcgiAppBaseGetValues string

// FcgiAppBaseKeepConn Tells the FastCGI application whether or not to keep the connection open after it sends a response. If disabled, the FastCGI application closes the connection after responding to this request.
type FcgiAppBaseKeepConn string

// FcgiAppBaseMpxsConns Enables or disables the support of connection multiplexing. If the FastCGI application retrieves the variable FCGI_MPXS_CONNS during connection establishment, it can override this option.
type FcgiAppBaseMpxsConns string

// FcgiApps defines model for fcgiApps.
type FcgiApps = []FCGIApp

// FcgiLogStderr Enables logging of STDERR messages that the FastCGI application reports.
// It is an optional setting. By default, HAProxy Enterprise ignores STDERR messages.
type FcgiLogStderr struct {
	Address  *string `json:"address,omitempty"`
	Facility *string `json:"facility,omitempty"`
	Format   *string `json:"format,omitempty"`
	Global   *bool   `json:"global,omitempty"`
	Len      *int    `json:"len,omitempty"`
	Level    *string `json:"level,omitempty"`
	Minlevel *string `json:"minlevel,omitempty"`
	Sample   *struct {
		Ranges string `json:"ranges"`
		Size   int    `json:"size"`
	} `json:"sample,omitempty"`
}

// FcgiPassHeader Specifies the name of a request header to pass to the FastCGI application.
// Optionally, you can follow it with an ACL-based condition, in which case the FastCGI application evaluates it only if the condition is true.
// Most request headers are already available to the FastCGI application with the prefix "HTTP".
// Thus, you only need this directive to pass headers that are purposefully omitted.
// Currently, the headers "Authorization", "Proxy-Authorization", and hop-by-hop headers are omitted.
// Note that the headers "Content-type" and "Content-length" never pass to the FastCGI application because they are already converted into parameters.
type FcgiPassHeader struct {
	Cond     *FcgiPassHeaderCond `json:"cond,omitempty"`
	CondTest *string             `json:"cond_test,omitempty"`
	Name     *string             `json:"name,omitempty"`
}

// FcgiPassHeaderCond defines model for FcgiPassHeader.Cond.
type FcgiPassHeaderCond string

// FcgiSetParam Sets a FastCGI parameter to pass to this application.
// Its value, defined by <format> can take a formatted string, the same as the log directive.
// Optionally, you can follow it with an ACL-based condition, in which case the FastCGI application evaluates it only if the condition is true.
type FcgiSetParam struct {
	Cond     *FcgiSetParamCond `json:"cond,omitempty"`
	CondTest *string           `json:"cond_test,omitempty"`
	Format   *string           `json:"format,omitempty"`
	Name     *string           `json:"name,omitempty"`
}

// FcgiSetParamCond defines model for FcgiSetParam.Cond.
type FcgiSetParamCond string

// FiftyOneDegreesOptions defines model for fifty_one_degrees_options.
type FiftyOneDegreesOptions struct {
	CacheSize         *int    `json:"cache_size,omitempty"`
	DataFile          *string `json:"data_file,omitempty"`
	PropertyNameList  *string `json:"property_name_list,omitempty"`
	PropertySeparator *string `json:"property_separator,omitempty"`
}

// Filter HAProxy filters
type Filter struct {
	Action       *string        `json:"action,omitempty"`
	Analyze      *FilterAnalyze `json:"analyze"`
	AnalyzeAcl   *string        `json:"analyze_acl"`
	AnalyzeFlags *string        `json:"analyze_flags"`

	// AppName Name of the fcgi-app section this filter will use.
	AppName           *string `json:"app_name,omitempty"`
	ArgsLimit         *int    `json:"args_limit"`
	AuditToSyslog     *bool   `json:"audit_to_syslog"`
	AuditUpdateStatus *bool   `json:"audit_update_status"`

	// BandwidthLimitName Filter name that will be used by 'set-bandwidth-limit' actions to reference a specific bandwidth limitation filter
	BandwidthLimitName *string     `json:"bandwidth_limit_name,omitempty"`
	BodyLimit          *int        `json:"body_limit"`
	CacheName          *string     `json:"cache_name,omitempty"`
	Cond               *FilterCond `json:"cond,omitempty"`
	CondTest           *string     `json:"cond_test,omitempty"`
	Content            *string     `json:"content,omitempty"`

	// DefaultLimit The max number of bytes that can be forwarded over the period.
	// The value must be specified for per-stream and shared bandwidth limitation filters.
	// It follows the HAProxy size format and is expressed in bytes.
	DefaultLimit *int `json:"default_limit,omitempty"`

	// DefaultPeriod The default time period used to evaluate the bandwidth limitation rate.
	// It can be specified for per-stream bandwidth limitation filters only.
	// It follows the HAProxy time format and is expressed in milliseconds.
	DefaultPeriod *int    `json:"default_period,omitempty"`
	Identifier    *string `json:"identifier,omitempty"`
	JsonArgsLimit *int    `json:"json_args_limit"`

	// Key A sample expression rule.
	// It describes what elements will be analyzed, extracted, combined, and used to select which table entry to update the counters.
	// It must be specified for shared bandwidth limitation filters only.
	Key      *string `json:"key,omitempty"`
	Learning *bool   `json:"learning"`

	// Limit The max number of bytes that can be forwarded over the period.
	// The value must be specified for per-stream and shared bandwidth limitation filters.
	// It follows the HAProxy size format and is expressed in bytes.
	Limit            *int                `json:"limit,omitempty"`
	Log              *bool               `json:"log"`
	LogExtNonzero    *bool               `json:"log_ext_nonzero"`
	LogExtScore      *bool               `json:"log_ext_score"`
	LogExtensive     *FilterLogExtensive `json:"log_extensive"`
	LogHostHeader    *bool               `json:"log_host_header"`
	LogHostHeaderLen *int                `json:"log_host_header_len"`
	LogLevel         *string             `json:"log_level"`
	LogNonzero       *bool               `json:"log_nonzero"`
	LogWl            *bool               `json:"log_wl"`

	// MinSize The optional minimum number of bytes forwarded at a time by a stream excluding the last packet that may be smaller.
	// This value can be specified for per-stream and shared bandwidth limitation filters.
	// It follows the HAProxy size format and is expressed in bytes.
	MinSize                *int        `json:"min_size,omitempty"`
	Mode                   *FilterMode `json:"mode,omitempty"`
	PreserveAcceptEncoding *bool       `json:"preserve_accept_encoding,omitempty"`
	Profile                *string     `json:"profile"`
	RuleFiles              *[]string   `json:"rule-files,omitempty"`
	RuleProfile            *int        `json:"rule_profile"`
	SpoeConfig             *string     `json:"spoe_config,omitempty"`
	SpoeEngine             *string     `json:"spoe_engine,omitempty"`
	SslcrlConfig           *string     `json:"sslcrl_config,omitempty"`
	SslcrlId               *string     `json:"sslcrl_id,omitempty"`

	// Table An optional table to be used instead of the default one, which is the stick-table declared in the current proxy.
	// It can be specified for shared bandwidth limitation filters only.
	Table              *string    `json:"table,omitempty"`
	TableCategorized   *bool      `json:"table_categorized"`
	TableNonzero       *bool      `json:"table_nonzero"`
	Timeout            *int       `json:"timeout"`
	TimeoutDenyStatus  *int       `json:"timeout_deny_status"`
	TimeoutDisruptive  *bool      `json:"timeout_disruptive"`
	TimeoutRule        *int       `json:"timeout_rule"`
	TraceHexdump       *bool      `json:"trace_hexdump,omitempty"`
	TraceName          *string    `json:"trace_name,omitempty"`
	TraceRndForwarding *bool      `json:"trace_rnd_forwarding,omitempty"`
	TraceRndParsing    *bool      `json:"trace_rnd_parsing,omitempty"`
	Type               FilterType `json:"type"`
	UseCustomcore      *bool      `json:"use_customcore"`
	UseUniqueIdFormat  *bool      `json:"use_unique_id_format"`
	UseVars            *bool      `json:"use_vars"`
	WaitForHeaders     *bool      `json:"wait_for_headers"`
}

// FilterAnalyze defines model for Filter.Analyze.
type FilterAnalyze string

// FilterCond defines model for Filter.Cond.
type FilterCond string

// FilterLogExtensive defines model for Filter.LogExtensive.
type FilterLogExtensive string

// FilterMode defines model for Filter.Mode.
type FilterMode string

// FilterType defines model for Filter.Type.
type FilterType string

// Filters HAProxy filters array (corresponds to filter directive)
type Filters = []Filter

// FingerprintOptions defines model for fingerprint_options.
type FingerprintOptions struct {
	SslBufsize *int `json:"ssl_bufsize,omitempty"`
}

// Forwardfor defines model for forwardfor.
type Forwardfor struct {
	Enabled ForwardforEnabled `json:"enabled"`
	Except  *string           `json:"except,omitempty"`
	Header  *string           `json:"header,omitempty"`
	Ifnone  *bool             `json:"ifnone,omitempty"`
}

// ForwardforEnabled defines model for Forwardfor.Enabled.
type ForwardforEnabled string

// Frontend defines model for frontend.
type Frontend struct {
	AcceptInvalidHttpRequest *FrontendAcceptInvalidHttpRequest `json:"accept_invalid_http_request,omitempty"`

	// AclList HAProxy ACL lines array (corresponds to acl directives)
	AclList *Acls `json:"acl_list,omitempty"`

	// BackendSwitchingRuleList HAProxy backend switching rules array (corresponds to use_backend directives)
	BackendSwitchingRuleList *BackendSwitchingRules    `json:"backend_switching_rule_list,omitempty"`
	Backlog                  *int                      `json:"backlog"`
	Binds                    *map[string]Bind          `json:"binds,omitempty"`
	CaptureList              *Captures                 `json:"capture_list,omitempty"`
	Clflog                   *bool                     `json:"clflog,omitempty"`
	ClientFinTimeout         *int                      `json:"client_fin_timeout"`
	ClientTimeout            *int                      `json:"client_timeout"`
	Clitcpka                 *FrontendClitcpka         `json:"clitcpka,omitempty"`
	ClitcpkaCnt              *int                      `json:"clitcpka_cnt"`
	ClitcpkaIdle             *int                      `json:"clitcpka_idle"`
	ClitcpkaIntvl            *int                      `json:"clitcpka_intvl"`
	Compression              *Compression              `json:"compression,omitempty"`
	Contstats                *FrontendContstats        `json:"contstats,omitempty"`
	DefaultBackend           *string                   `json:"default_backend,omitempty"`
	Description              *string                   `json:"description,omitempty"`
	DisableH2Upgrade         *FrontendDisableH2Upgrade `json:"disable_h2_upgrade,omitempty"`
	Disabled                 *bool                     `json:"disabled,omitempty"`
	DontlogNormal            *FrontendDontlogNormal    `json:"dontlog_normal,omitempty"`
	Dontlognull              *FrontendDontlognull      `json:"dontlognull,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert   `json:"email_alert,omitempty"`
	Enabled                  *bool         `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile  `json:"error_files,omitempty"`
	ErrorLogFormat           *string       `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc     `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc     `json:"errorloc303,omitempty"`

	// FilterList HAProxy filters array (corresponds to filter directive)
	FilterList              *Filters                         `json:"filter_list,omitempty"`
	Fingerprint             *bool                            `json:"fingerprint,omitempty"`
	FingerprintSsl          *bool                            `json:"fingerprint_ssl,omitempty"`
	Forwardfor              *Forwardfor                      `json:"forwardfor,omitempty"`
	From                    *string                          `json:"from,omitempty"`
	Guid                    *string                          `json:"guid,omitempty"`
	H1CaseAdjustBogusClient *FrontendH1CaseAdjustBogusClient `json:"h1_case_adjust_bogus_client,omitempty"`
	HttpBufferRequest       *FrontendHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpUseHtx              *FrontendHttpUseHtx              `json:"http-use-htx,omitempty"`

	// HttpAfterResponseRuleList HAProxy HTTP after response rules array (corresponds to http-after-response directives)
	HttpAfterResponseRuleList *HttpAfterResponseRules     `json:"http_after_response_rule_list,omitempty"`
	HttpConnectionMode        *FrontendHttpConnectionMode `json:"http_connection_mode,omitempty"`

	// HttpErrorRuleList HAProxy HTTP error rules array (corresponds to http-error directives)
	HttpErrorRuleList    *HttpErrorRules           `json:"http_error_rule_list,omitempty"`
	HttpIgnoreProbes     *FrontendHttpIgnoreProbes `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout *int                      `json:"http_keep_alive_timeout"`
	HttpNoDelay          *FrontendHttpNoDelay      `json:"http_no_delay,omitempty"`

	// HttpRequestRuleList HAProxy HTTP request rules array (corresponds to http-request directives)
	HttpRequestRuleList *HttpRequestRules `json:"http_request_rule_list,omitempty"`
	HttpRequestTimeout  *int              `json:"http_request_timeout"`

	// HttpResponseRuleList HAProxy HTTP response rules array (corresponds to http-response directives)
	HttpResponseRuleList    *HttpResponseRules               `json:"http_response_rule_list,omitempty"`
	HttpRestrictReqHdrNames *FrontendHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpUseProxyHeader      *FrontendHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	Httplog                 *bool                            `json:"httplog,omitempty"`
	Httpslog                *FrontendHttpslog                `json:"httpslog,omitempty"`
	Id                      *int                             `json:"id"`
	IdleCloseOnResponse     *FrontendIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams      *FrontendIndependentStreams      `json:"independent_streams,omitempty"`
	LogFormat               *string                          `json:"log_format,omitempty"`
	LogFormatSd             *string                          `json:"log_format_sd,omitempty"`
	LogSeparateErrors       *FrontendLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogTag                  *string                          `json:"log_tag,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList  *LogTargets             `json:"log_target_list,omitempty"`
	Logasap        *FrontendLogasap        `json:"logasap,omitempty"`
	Maxconn        *int                    `json:"maxconn"`
	Mode           *FrontendMode           `json:"mode,omitempty"`
	MonitorFail    *MonitorFail            `json:"monitor_fail,omitempty"`
	MonitorUri     *MonitorUri             `json:"monitor_uri,omitempty"`
	Name           string                  `json:"name"`
	Nolinger       *FrontendNolinger       `json:"nolinger,omitempty"`
	Originalto     *Originalto             `json:"originalto,omitempty"`
	SocketStats    *FrontendSocketStats    `json:"socket_stats,omitempty"`
	SpliceAuto     *FrontendSpliceAuto     `json:"splice_auto,omitempty"`
	SpliceRequest  *FrontendSpliceRequest  `json:"splice_request,omitempty"`
	SpliceResponse *FrontendSpliceResponse `json:"splice_response,omitempty"`
	StatsOptions   *StatsOptions           `json:"stats_options,omitempty"`
	StickTable     *ConfigStickTable       `json:"stick_table,omitempty"`
	TarpitTimeout  *int                    `json:"tarpit_timeout"`

	// TcpRequestRuleList HAProxy TCP request rules array (corresponds to tcp-request directive)
	TcpRequestRuleList *TcpRequestRules        `json:"tcp_request_rule_list,omitempty"`
	TcpSmartAccept     *FrontendTcpSmartAccept `json:"tcp_smart_accept,omitempty"`
	Tcpka              *FrontendTcpka          `json:"tcpka,omitempty"`
	Tcplog             *bool                   `json:"tcplog,omitempty"`
	UniqueIdFormat     *string                 `json:"unique_id_format,omitempty"`
	UniqueIdHeader     *string                 `json:"unique_id_header,omitempty"`
	WafBodyRuleList    *WafBodyRules           `json:"waf_body_rule_list,omitempty"`
}

// FrontendAcceptInvalidHttpRequest defines model for Frontend.AcceptInvalidHttpRequest.
type FrontendAcceptInvalidHttpRequest string

// FrontendClitcpka defines model for Frontend.Clitcpka.
type FrontendClitcpka string

// FrontendContstats defines model for Frontend.Contstats.
type FrontendContstats string

// FrontendDisableH2Upgrade defines model for Frontend.DisableH2Upgrade.
type FrontendDisableH2Upgrade string

// FrontendDontlogNormal defines model for Frontend.DontlogNormal.
type FrontendDontlogNormal string

// FrontendDontlognull defines model for Frontend.Dontlognull.
type FrontendDontlognull string

// FrontendH1CaseAdjustBogusClient defines model for Frontend.H1CaseAdjustBogusClient.
type FrontendH1CaseAdjustBogusClient string

// FrontendHttpBufferRequest defines model for Frontend.HttpBufferRequest.
type FrontendHttpBufferRequest string

// FrontendHttpUseHtx defines model for Frontend.HttpUseHtx.
type FrontendHttpUseHtx string

// FrontendHttpConnectionMode defines model for Frontend.HttpConnectionMode.
type FrontendHttpConnectionMode string

// FrontendHttpIgnoreProbes defines model for Frontend.HttpIgnoreProbes.
type FrontendHttpIgnoreProbes string

// FrontendHttpNoDelay defines model for Frontend.HttpNoDelay.
type FrontendHttpNoDelay string

// FrontendHttpRestrictReqHdrNames defines model for Frontend.HttpRestrictReqHdrNames.
type FrontendHttpRestrictReqHdrNames string

// FrontendHttpUseProxyHeader defines model for Frontend.HttpUseProxyHeader.
type FrontendHttpUseProxyHeader string

// FrontendHttpslog defines model for Frontend.Httpslog.
type FrontendHttpslog string

// FrontendIdleCloseOnResponse defines model for Frontend.IdleCloseOnResponse.
type FrontendIdleCloseOnResponse string

// FrontendIndependentStreams defines model for Frontend.IndependentStreams.
type FrontendIndependentStreams string

// FrontendLogSeparateErrors defines model for Frontend.LogSeparateErrors.
type FrontendLogSeparateErrors string

// FrontendLogasap defines model for Frontend.Logasap.
type FrontendLogasap string

// FrontendMode defines model for Frontend.Mode.
type FrontendMode string

// FrontendNolinger defines model for Frontend.Nolinger.
type FrontendNolinger string

// FrontendSocketStats defines model for Frontend.SocketStats.
type FrontendSocketStats string

// FrontendSpliceAuto defines model for Frontend.SpliceAuto.
type FrontendSpliceAuto string

// FrontendSpliceRequest defines model for Frontend.SpliceRequest.
type FrontendSpliceRequest string

// FrontendSpliceResponse defines model for Frontend.SpliceResponse.
type FrontendSpliceResponse string

// FrontendTcpSmartAccept defines model for Frontend.TcpSmartAccept.
type FrontendTcpSmartAccept string

// FrontendTcpka defines model for Frontend.Tcpka.
type FrontendTcpka string

// FrontendBase HAProxy frontend configuration
type FrontendBase struct {
	AcceptInvalidHttpRequest *FrontendBaseAcceptInvalidHttpRequest `json:"accept_invalid_http_request,omitempty"`
	Backlog                  *int                                  `json:"backlog"`
	Clflog                   *bool                                 `json:"clflog,omitempty"`
	ClientFinTimeout         *int                                  `json:"client_fin_timeout"`
	ClientTimeout            *int                                  `json:"client_timeout"`
	Clitcpka                 *FrontendBaseClitcpka                 `json:"clitcpka,omitempty"`
	ClitcpkaCnt              *int                                  `json:"clitcpka_cnt"`
	ClitcpkaIdle             *int                                  `json:"clitcpka_idle"`
	ClitcpkaIntvl            *int                                  `json:"clitcpka_intvl"`
	Compression              *Compression                          `json:"compression,omitempty"`
	Contstats                *FrontendBaseContstats                `json:"contstats,omitempty"`
	DefaultBackend           *string                               `json:"default_backend,omitempty"`
	Description              *string                               `json:"description,omitempty"`
	DisableH2Upgrade         *FrontendBaseDisableH2Upgrade         `json:"disable_h2_upgrade,omitempty"`
	Disabled                 *bool                                 `json:"disabled,omitempty"`
	DontlogNormal            *FrontendBaseDontlogNormal            `json:"dontlog_normal,omitempty"`
	Dontlognull              *FrontendBaseDontlognull              `json:"dontlognull,omitempty"`

	// EmailAlert Send emails for important log messages.
	EmailAlert               *EmailAlert                          `json:"email_alert,omitempty"`
	Enabled                  *bool                                `json:"enabled,omitempty"`
	ErrorFiles               *[]Errorfile                         `json:"error_files,omitempty"`
	ErrorLogFormat           *string                              `json:"error_log_format,omitempty"`
	ErrorFilesFromHTTPErrors *[]Errorfiles                        `json:"errorfiles_from_http_errors,omitempty"`
	Errorloc302              *Errorloc                            `json:"errorloc302,omitempty"`
	Errorloc303              *Errorloc                            `json:"errorloc303,omitempty"`
	Fingerprint              *bool                                `json:"fingerprint,omitempty"`
	FingerprintSsl           *bool                                `json:"fingerprint_ssl,omitempty"`
	Forwardfor               *Forwardfor                          `json:"forwardfor,omitempty"`
	From                     *string                              `json:"from,omitempty"`
	Guid                     *string                              `json:"guid,omitempty"`
	H1CaseAdjustBogusClient  *FrontendBaseH1CaseAdjustBogusClient `json:"h1_case_adjust_bogus_client,omitempty"`
	HttpBufferRequest        *FrontendBaseHttpBufferRequest       `json:"http-buffer-request,omitempty"`
	HttpUseHtx               *FrontendBaseHttpUseHtx              `json:"http-use-htx,omitempty"`
	HttpConnectionMode       *FrontendBaseHttpConnectionMode      `json:"http_connection_mode,omitempty"`
	HttpIgnoreProbes         *FrontendBaseHttpIgnoreProbes        `json:"http_ignore_probes,omitempty"`
	HttpKeepAliveTimeout     *int                                 `json:"http_keep_alive_timeout"`
	HttpNoDelay              *FrontendBaseHttpNoDelay             `json:"http_no_delay,omitempty"`
	HttpRequestTimeout       *int                                 `json:"http_request_timeout"`
	HttpRestrictReqHdrNames  *FrontendBaseHttpRestrictReqHdrNames `json:"http_restrict_req_hdr_names,omitempty"`
	HttpUseProxyHeader       *FrontendBaseHttpUseProxyHeader      `json:"http_use_proxy_header,omitempty"`
	Httplog                  *bool                                `json:"httplog,omitempty"`
	Httpslog                 *FrontendBaseHttpslog                `json:"httpslog,omitempty"`
	Id                       *int                                 `json:"id"`
	IdleCloseOnResponse      *FrontendBaseIdleCloseOnResponse     `json:"idle_close_on_response,omitempty"`
	IndependentStreams       *FrontendBaseIndependentStreams      `json:"independent_streams,omitempty"`
	LogFormat                *string                              `json:"log_format,omitempty"`
	LogFormatSd              *string                              `json:"log_format_sd,omitempty"`
	LogSeparateErrors        *FrontendBaseLogSeparateErrors       `json:"log_separate_errors,omitempty"`
	LogTag                   *string                              `json:"log_tag,omitempty"`
	Logasap                  *FrontendBaseLogasap                 `json:"logasap,omitempty"`
	Maxconn                  *int                                 `json:"maxconn"`
	Mode                     *FrontendBaseMode                    `json:"mode,omitempty"`
	MonitorFail              *MonitorFail                         `json:"monitor_fail,omitempty"`
	MonitorUri               *MonitorUri                          `json:"monitor_uri,omitempty"`
	Name                     string                               `json:"name"`
	Nolinger                 *FrontendBaseNolinger                `json:"nolinger,omitempty"`
	Originalto               *Originalto                          `json:"originalto,omitempty"`
	SocketStats              *FrontendBaseSocketStats             `json:"socket_stats,omitempty"`
	SpliceAuto               *FrontendBaseSpliceAuto              `json:"splice_auto,omitempty"`
	SpliceRequest            *FrontendBaseSpliceRequest           `json:"splice_request,omitempty"`
	SpliceResponse           *FrontendBaseSpliceResponse          `json:"splice_response,omitempty"`
	StatsOptions             *StatsOptions                        `json:"stats_options,omitempty"`
	StickTable               *ConfigStickTable                    `json:"stick_table,omitempty"`
	TarpitTimeout            *int                                 `json:"tarpit_timeout"`
	TcpSmartAccept           *FrontendBaseTcpSmartAccept          `json:"tcp_smart_accept,omitempty"`
	Tcpka                    *FrontendBaseTcpka                   `json:"tcpka,omitempty"`
	Tcplog                   *bool                                `json:"tcplog,omitempty"`
	UniqueIdFormat           *string                              `json:"unique_id_format,omitempty"`
	UniqueIdHeader           *string                              `json:"unique_id_header,omitempty"`
}

// FrontendBaseAcceptInvalidHttpRequest defines model for FrontendBase.AcceptInvalidHttpRequest.
type FrontendBaseAcceptInvalidHttpRequest string

// FrontendBaseClitcpka defines model for FrontendBase.Clitcpka.
type FrontendBaseClitcpka string

// FrontendBaseContstats defines model for FrontendBase.Contstats.
type FrontendBaseContstats string

// FrontendBaseDisableH2Upgrade defines model for FrontendBase.DisableH2Upgrade.
type FrontendBaseDisableH2Upgrade string

// FrontendBaseDontlogNormal defines model for FrontendBase.DontlogNormal.
type FrontendBaseDontlogNormal string

// FrontendBaseDontlognull defines model for FrontendBase.Dontlognull.
type FrontendBaseDontlognull string

// FrontendBaseH1CaseAdjustBogusClient defines model for FrontendBase.H1CaseAdjustBogusClient.
type FrontendBaseH1CaseAdjustBogusClient string

// FrontendBaseHttpBufferRequest defines model for FrontendBase.HttpBufferRequest.
type FrontendBaseHttpBufferRequest string

// FrontendBaseHttpUseHtx defines model for FrontendBase.HttpUseHtx.
type FrontendBaseHttpUseHtx string

// FrontendBaseHttpConnectionMode defines model for FrontendBase.HttpConnectionMode.
type FrontendBaseHttpConnectionMode string

// FrontendBaseHttpIgnoreProbes defines model for FrontendBase.HttpIgnoreProbes.
type FrontendBaseHttpIgnoreProbes string

// FrontendBaseHttpNoDelay defines model for FrontendBase.HttpNoDelay.
type FrontendBaseHttpNoDelay string

// FrontendBaseHttpRestrictReqHdrNames defines model for FrontendBase.HttpRestrictReqHdrNames.
type FrontendBaseHttpRestrictReqHdrNames string

// FrontendBaseHttpUseProxyHeader defines model for FrontendBase.HttpUseProxyHeader.
type FrontendBaseHttpUseProxyHeader string

// FrontendBaseHttpslog defines model for FrontendBase.Httpslog.
type FrontendBaseHttpslog string

// FrontendBaseIdleCloseOnResponse defines model for FrontendBase.IdleCloseOnResponse.
type FrontendBaseIdleCloseOnResponse string

// FrontendBaseIndependentStreams defines model for FrontendBase.IndependentStreams.
type FrontendBaseIndependentStreams string

// FrontendBaseLogSeparateErrors defines model for FrontendBase.LogSeparateErrors.
type FrontendBaseLogSeparateErrors string

// FrontendBaseLogasap defines model for FrontendBase.Logasap.
type FrontendBaseLogasap string

// FrontendBaseMode defines model for FrontendBase.Mode.
type FrontendBaseMode string

// FrontendBaseNolinger defines model for FrontendBase.Nolinger.
type FrontendBaseNolinger string

// FrontendBaseSocketStats defines model for FrontendBase.SocketStats.
type FrontendBaseSocketStats string

// FrontendBaseSpliceAuto defines model for FrontendBase.SpliceAuto.
type FrontendBaseSpliceAuto string

// FrontendBaseSpliceRequest defines model for FrontendBase.SpliceRequest.
type FrontendBaseSpliceRequest string

// FrontendBaseSpliceResponse defines model for FrontendBase.SpliceResponse.
type FrontendBaseSpliceResponse string

// FrontendBaseTcpSmartAccept defines model for FrontendBase.TcpSmartAccept.
type FrontendBaseTcpSmartAccept string

// FrontendBaseTcpka defines model for FrontendBase.Tcpka.
type FrontendBaseTcpka string

// Frontends HAProxy frontends array
type Frontends = []Frontend

// GeneralFile General use file
type GeneralFile struct {
	Description *string `json:"description,omitempty"`
	File        *string `json:"file,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Size File size in bytes.
	Size        *int    `json:"size"`
	StorageName *string `json:"storage_name,omitempty"`
}

// GeneralFiles Array of general use files
type GeneralFiles = []GeneralFile

// GitAction Action we execute on the git repository that was setup.
type GitAction struct {
	Action         GitActionAction `json:"action"`
	CheckoutBranch *string         `json:"checkout_branch,omitempty"`
	CommitMessage  *string         `json:"commit_message,omitempty"`
	Id             *string         `json:"id,omitempty"`

	// Response Response of an executed git action.
	Response    *GitResponse `json:"response,omitempty"`
	Transaction *string      `json:"transaction,omitempty"`
}

// GitActionAction defines model for GitAction.Action.
type GitActionAction string

// GitActions List of Git Actions executed
type GitActions = []GitAction

// GitResponse Response of an executed git action.
type GitResponse struct {
	Response *string             `json:"response,omitempty"`
	Success  *GitResponseSuccess `json:"success,omitempty"`
}

// GitResponseSuccess defines model for GitResponse.Success.
type GitResponseSuccess string

// GitSettings Settings for git repo where we want the config file to be pushed.
type GitSettings struct {
	UnderscoreVersion *int                    `json:"_version,omitempty"`
	AuthAccessToken   *string                 `json:"auth_access_token,omitempty"`
	AuthMethod        GitSettingsAuthMethod   `json:"auth_method"`
	AuthPassword      *string                 `json:"auth_password,omitempty"`
	AuthUsername      *string                 `json:"auth_username,omitempty"`
	ConfigFile        *string                 `json:"config_file,omitempty"`
	StorageDir        *string                 `json:"storage_dir,omitempty"`
	StorageType       *GitSettingsStorageType `json:"storage_type,omitempty"`
	Url               string                  `json:"url"`
}

// GitSettingsAuthMethod defines model for GitSettings.AuthMethod.
type GitSettingsAuthMethod string

// GitSettingsStorageType defines model for GitSettings.StorageType.
type GitSettingsStorageType string

// Global defines model for global.
type Global struct {
	// BotmanagementOptions BOTMGMT module configuration.
	BotmanagementOptions        *BotmanagementOptions `json:"botmanagement_options,omitempty"`
	Chroot                      *string               `json:"chroot,omitempty"`
	CloseSpreadTime             *int                  `json:"close_spread_time"`
	ClusterSecret               *string               `json:"cluster_secret,omitempty"`
	CookChalSetCookieAttributes *string               `json:"cook_chal.set_cookie_attributes"`
	CPUMaps                     *[]struct {
		CpuSet  string `json:"cpu_set"`
		Process string `json:"process"`
	} `json:"cpu_maps,omitempty"`
	Daemon            *bool         `json:"daemon,omitempty"`
	DebugOptions      *DebugOptions `json:"debug_options,omitempty"`
	GlobalDefaultPath *struct {
		Path *string               `json:"path,omitempty"`
		Type GlobalDefaultPathType `json:"type"`
	} `json:"default_path,omitempty"`
	Description                  *string                 `json:"description,omitempty"`
	DeviceAtlasOptions           *DeviceAtlasOptions     `json:"device_atlas_options,omitempty"`
	EnvironmentOptions           *EnvironmentOptions     `json:"environment_options,omitempty"`
	ExposeExperimentalDirectives *bool                   `json:"expose_experimental_directives,omitempty"`
	ExternalCheck                *bool                   `json:"external_check,omitempty"`
	FiftyOneDegreesOptions       *FiftyOneDegreesOptions `json:"fifty_one_degrees_options,omitempty"`
	FingerprintOptions           *FingerprintOptions     `json:"fingerprint_options,omitempty"`
	Gid                          *int                    `json:"gid,omitempty"`
	Grace                        *int                    `json:"grace"`
	Group                        *string                 `json:"group,omitempty"`
	H1AcceptPayloadWithAnyMethod *bool                   `json:"h1_accept_payload_with_any_method,omitempty"`
	H1CaseAdjusts                *[]struct {
		From string `json:"from"`
		To   string `json:"to"`
	} `json:"h1_case_adjust,omitempty"`
	H1CaseAdjustFile                       *string `json:"h1_case_adjust_file,omitempty"`
	H1DoNotCloseOnInsecureTransferEncoding *bool   `json:"h1_do_not_close_on_insecure_transfer_encoding,omitempty"`
	H2WorkaroundBogusWebsocketClients      *bool   `json:"h2_workaround_bogus_websocket_clients,omitempty"`
	HardStopAfter                          *int    `json:"hard_stop_after"`
	GlobalHarden                           *struct {
		GlobalHardenRejectPrivilegedPorts *struct {
			Quic *GlobalHardenRejectPrivilegedPortsQuic `json:"quic,omitempty"`
			Tcp  *GlobalHardenRejectPrivilegedPortsTcp  `json:"tcp,omitempty"`
		} `json:"reject_privileged_ports,omitempty"`
	} `json:"harden,omitempty"`
	HttpClientOptions     *HttpClientOptions `json:"http_client_options,omitempty"`
	HttpErrCodes          *[]HTTPCodes       `json:"http_err_codes,omitempty"`
	HttpFailCodes         *[]HTTPCodes       `json:"http_fail_codes,omitempty"`
	InsecureForkWanted    *bool              `json:"insecure_fork_wanted,omitempty"`
	InsecureSetuidWanted  *bool              `json:"insecure_setuid_wanted,omitempty"`
	LimitedQuic           *bool              `json:"limited_quic,omitempty"`
	Localpeer             *string            `json:"localpeer,omitempty"`
	GlobalLogSendHostname *struct {
		Enabled GlobalLogSendHostnameEnabled `json:"enabled"`
		Param   *string                      `json:"param,omitempty"`
	} `json:"log_send_hostname,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList      *LogTargets         `json:"log_target_list,omitempty"`
	LuaOptions         *LuaOptions         `json:"lua_options,omitempty"`
	MasterWorker       *bool               `json:"master-worker,omitempty"`
	MaxmindOptions     *MaxmindOptions     `json:"maxmind_options,omitempty"`
	ModsecurityOptions *ModsecurityOptions `json:"modsecurity_options,omitempty"`
	ModuleLoads        *[]struct {
		Value *string `json:"value,omitempty"`
	} `json:"module-loads,omitempty"`
	ModulePath         *string               `json:"module-path,omitempty"`
	MworkerMaxReloads  *int                  `json:"mworker_max_reloads"`
	Nbthread           *int                  `json:"nbthread,omitempty"`
	NoQuic             *bool                 `json:"no_quic,omitempty"`
	Node               *string               `json:"node,omitempty"`
	NumaCpuMapping     *GlobalNumaCpuMapping `json:"numa_cpu_mapping,omitempty"`
	OcspUpdateOptions  *OcspUpdateOptions    `json:"ocsp_update_options,omitempty"`
	PerformanceOptions *PerformanceOptions   `json:"performance_options,omitempty"`
	Pidfile            *string               `json:"pidfile,omitempty"`
	Pp2NeverSendLocal  *bool                 `json:"pp2_never_send_local,omitempty"`
	PreallocFd         *bool                 `json:"prealloc_fd,omitempty"`
	RuntimeAPIs        *[]struct {
		AcceptNetscalerCip   *int                             `json:"accept_netscaler_cip,omitempty"`
		AcceptProxy          *bool                            `json:"accept_proxy,omitempty"`
		Address              string                           `json:"address"`
		Allow0rtt            *bool                            `json:"allow_0rtt,omitempty"`
		Alpn                 *string                          `json:"alpn,omitempty"`
		Backlog              *string                          `json:"backlog,omitempty"`
		CaIgnoreErr          *string                          `json:"ca_ignore_err,omitempty"`
		CaSignFile           *string                          `json:"ca_sign_file,omitempty"`
		CaSignPass           *string                          `json:"ca_sign_pass,omitempty"`
		CaVerifyFile         *string                          `json:"ca_verify_file,omitempty"`
		Ciphers              *string                          `json:"ciphers,omitempty"`
		Ciphersuites         *string                          `json:"ciphersuites,omitempty"`
		ClientSigalgs        *string                          `json:"client_sigalgs,omitempty"`
		CrlFile              *string                          `json:"crl_file,omitempty"`
		CrtIgnoreErr         *string                          `json:"crt_ignore_err,omitempty"`
		CrtList              *string                          `json:"crt_list,omitempty"`
		Curves               *string                          `json:"curves,omitempty"`
		DefaultCrtList       *[]string                        `json:"default_crt_list,omitempty"`
		DeferAccept          *bool                            `json:"defer_accept,omitempty"`
		Ecdhe                *string                          `json:"ecdhe,omitempty"`
		ExposeFdListeners    *bool                            `json:"expose_fd_listeners,omitempty"`
		ForceSslv3           *bool                            `json:"force_sslv3,omitempty"`
		ForceTlsv10          *bool                            `json:"force_tlsv10,omitempty"`
		ForceTlsv11          *bool                            `json:"force_tlsv11,omitempty"`
		ForceTlsv12          *bool                            `json:"force_tlsv12,omitempty"`
		ForceTlsv13          *bool                            `json:"force_tlsv13,omitempty"`
		GenerateCertificates *bool                            `json:"generate_certificates,omitempty"`
		Gid                  *int                             `json:"gid,omitempty"`
		Group                *string                          `json:"group,omitempty"`
		GuidPrefix           *string                          `json:"guid_prefix,omitempty"`
		Id                   *string                          `json:"id,omitempty"`
		Interface            *string                          `json:"interface,omitempty"`
		Level                *GlobalRuntimeApisLevel          `json:"level,omitempty"`
		Maxconn              *int                             `json:"maxconn,omitempty"`
		Mode                 *string                          `json:"mode,omitempty"`
		Mss                  *string                          `json:"mss,omitempty"`
		Name                 *string                          `json:"name,omitempty"`
		Namespace            *string                          `json:"namespace,omitempty"`
		Nbconn               *int                             `json:"nbconn,omitempty"`
		Nice                 *int                             `json:"nice,omitempty"`
		NoAlpn               *bool                            `json:"no_alpn,omitempty"`
		NoCaNames            *bool                            `json:"no_ca_names,omitempty"`
		NoSslv3              *bool                            `json:"no_sslv3,omitempty"`
		NoTlsTickets         *bool                            `json:"no_tls_tickets,omitempty"`
		NoTlsv10             *bool                            `json:"no_tlsv10,omitempty"`
		NoTlsv11             *bool                            `json:"no_tlsv11,omitempty"`
		NoTlsv12             *bool                            `json:"no_tlsv12,omitempty"`
		NoTlsv13             *bool                            `json:"no_tlsv13,omitempty"`
		Npn                  *string                          `json:"npn,omitempty"`
		PreferClientCiphers  *bool                            `json:"prefer_client_ciphers,omitempty"`
		Proto                *string                          `json:"proto,omitempty"`
		QuicCcAlgo           *GlobalRuntimeApisQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
		QuicForceRetry       *bool                            `json:"quic-force-retry,omitempty"`
		QuicSocket           *GlobalRuntimeApisQuicSocket     `json:"quic-socket,omitempty"`
		SeverityOutput       *GlobalRuntimeApisSeverityOutput `json:"severity_output,omitempty"`
		Sigalgs              *string                          `json:"sigalgs,omitempty"`
		Ssl                  *bool                            `json:"ssl,omitempty"`
		SslCafile            *string                          `json:"ssl_cafile,omitempty"`
		SslCertificate       *string                          `json:"ssl_certificate,omitempty"`
		SslMaxVer            *GlobalRuntimeApisSslMaxVer      `json:"ssl_max_ver,omitempty"`
		SslMinVer            *GlobalRuntimeApisSslMinVer      `json:"ssl_min_ver,omitempty"`
		StrictSni            *bool                            `json:"strict_sni,omitempty"`
		TcpUserTimeout       *int                             `json:"tcp_user_timeout"`
		Tfo                  *bool                            `json:"tfo,omitempty"`
		Thread               *string                          `json:"thread,omitempty"`
		TlsTicketKeys        *string                          `json:"tls_ticket_keys,omitempty"`
		Transparent          *bool                            `json:"transparent,omitempty"`
		Uid                  *string                          `json:"uid,omitempty"`
		User                 *string                          `json:"user,omitempty"`
		V4v6                 *bool                            `json:"v4v6,omitempty"`
		V6only               *bool                            `json:"v6only,omitempty"`
		Verify               *GlobalRuntimeApisVerify         `json:"verify,omitempty"`
	} `json:"runtime_apis,omitempty"`

	// SamlOptions SAMP (Security Assertion Markup Language) module configuration.
	SamlOptions *SamlOptions `json:"saml_options,omitempty"`
	SetDumpable *bool        `json:"set_dumpable,omitempty"`
	SetVars     *[]struct {
		Expr string `json:"expr"`
		Name string `json:"name"`
	} `json:"set_var,omitempty"`
	SetVarFmts *[]struct {
		Format string `json:"format"`
		Name   string `json:"name"`
	} `json:"set_var_fmt,omitempty"`
	Setcap *string `json:"setcap,omitempty"`

	// SslCrlOptions lb-sslcrl filter module for HAProxy configuration
	SslCrlOptions    *SslCrlOptions `json:"ssl_crl_options,omitempty"`
	SslOptions       *SslOptions    `json:"ssl_options,omitempty"`
	StatsFile        *string        `json:"stats_file,omitempty"`
	StatsMaxconn     *int           `json:"stats_maxconn"`
	StatsTimeout     *int           `json:"stats_timeout"`
	StrictLimits     *bool          `json:"strict_limits,omitempty"`
	ThreadGroupLines *[]struct {
		Group      string `json:"group"`
		NumOrRange string `json:"num_or_range"`
	} `json:"thread_group_lines,omitempty"`
	ThreadGroups      *int               `json:"thread_groups,omitempty"`
	TuneBufferOptions *TuneBufferOptions `json:"tune_buffer_options,omitempty"`
	TuneLuaOptions    *TuneLuaOptions    `json:"tune_lua_options,omitempty"`
	TuneOptions       *TuneOptions       `json:"tune_options,omitempty"`
	TuneQuicOptions   *TuneQuicOptions   `json:"tune_quic_options,omitempty"`
	TuneSslOptions    *TuneSslOptions    `json:"tune_ssl_options,omitempty"`
	TuneVarsOptions   *TuneVarsOptions   `json:"tune_vars_options,omitempty"`
	TuneZlibOptions   *TuneZlibOptions   `json:"tune_zlib_options,omitempty"`
	Uid               *int               `json:"uid,omitempty"`
	UlimitN           *int               `json:"ulimit_n,omitempty"`
	User              *string            `json:"user,omitempty"`
	WafOptions        *WafOptions        `json:"waf_options,omitempty"`
	WurflOptions      *WurflOptions      `json:"wurfl_options,omitempty"`
}

// GlobalDefaultPathType defines model for Global.DefaultPath.Type.
type GlobalDefaultPathType string

// GlobalHardenRejectPrivilegedPortsQuic defines model for Global.Harden.RejectPrivilegedPorts.Quic.
type GlobalHardenRejectPrivilegedPortsQuic string

// GlobalHardenRejectPrivilegedPortsTcp defines model for Global.Harden.RejectPrivilegedPorts.Tcp.
type GlobalHardenRejectPrivilegedPortsTcp string

// GlobalLogSendHostnameEnabled defines model for Global.LogSendHostname.Enabled.
type GlobalLogSendHostnameEnabled string

// GlobalNumaCpuMapping defines model for Global.NumaCpuMapping.
type GlobalNumaCpuMapping string

// GlobalRuntimeApisLevel defines model for Global.RuntimeApis.Level.
type GlobalRuntimeApisLevel string

// GlobalRuntimeApisQuicCcAlgo defines model for Global.RuntimeApis.QuicCcAlgo.
type GlobalRuntimeApisQuicCcAlgo string

// GlobalRuntimeApisQuicSocket defines model for Global.RuntimeApis.QuicSocket.
type GlobalRuntimeApisQuicSocket string

// GlobalRuntimeApisSeverityOutput defines model for Global.RuntimeApis.SeverityOutput.
type GlobalRuntimeApisSeverityOutput string

// GlobalRuntimeApisSslMaxVer defines model for Global.RuntimeApis.SslMaxVer.
type GlobalRuntimeApisSslMaxVer string

// GlobalRuntimeApisSslMinVer defines model for Global.RuntimeApis.SslMinVer.
type GlobalRuntimeApisSslMinVer string

// GlobalRuntimeApisVerify defines model for Global.RuntimeApis.Verify.
type GlobalRuntimeApisVerify string

// GlobalBase HAProxy global configuration
type GlobalBase struct {
	// BotmanagementOptions BOTMGMT module configuration.
	BotmanagementOptions        *BotmanagementOptions `json:"botmanagement_options,omitempty"`
	Chroot                      *string               `json:"chroot,omitempty"`
	CloseSpreadTime             *int                  `json:"close_spread_time"`
	ClusterSecret               *string               `json:"cluster_secret,omitempty"`
	CookChalSetCookieAttributes *string               `json:"cook_chal.set_cookie_attributes"`
	CPUMaps                     *[]struct {
		CpuSet  string `json:"cpu_set"`
		Process string `json:"process"`
	} `json:"cpu_maps,omitempty"`
	Daemon            *bool         `json:"daemon,omitempty"`
	DebugOptions      *DebugOptions `json:"debug_options,omitempty"`
	GlobalDefaultPath *struct {
		Path *string                   `json:"path,omitempty"`
		Type GlobalBaseDefaultPathType `json:"type"`
	} `json:"default_path,omitempty"`
	Description                  *string                 `json:"description,omitempty"`
	DeviceAtlasOptions           *DeviceAtlasOptions     `json:"device_atlas_options,omitempty"`
	EnvironmentOptions           *EnvironmentOptions     `json:"environment_options,omitempty"`
	ExposeExperimentalDirectives *bool                   `json:"expose_experimental_directives,omitempty"`
	ExternalCheck                *bool                   `json:"external_check,omitempty"`
	FiftyOneDegreesOptions       *FiftyOneDegreesOptions `json:"fifty_one_degrees_options,omitempty"`
	FingerprintOptions           *FingerprintOptions     `json:"fingerprint_options,omitempty"`
	Gid                          *int                    `json:"gid,omitempty"`
	Grace                        *int                    `json:"grace"`
	Group                        *string                 `json:"group,omitempty"`
	H1AcceptPayloadWithAnyMethod *bool                   `json:"h1_accept_payload_with_any_method,omitempty"`
	H1CaseAdjusts                *[]struct {
		From string `json:"from"`
		To   string `json:"to"`
	} `json:"h1_case_adjust,omitempty"`
	H1CaseAdjustFile                       *string `json:"h1_case_adjust_file,omitempty"`
	H1DoNotCloseOnInsecureTransferEncoding *bool   `json:"h1_do_not_close_on_insecure_transfer_encoding,omitempty"`
	H2WorkaroundBogusWebsocketClients      *bool   `json:"h2_workaround_bogus_websocket_clients,omitempty"`
	HardStopAfter                          *int    `json:"hard_stop_after"`
	GlobalHarden                           *struct {
		GlobalHardenRejectPrivilegedPorts *struct {
			Quic *GlobalBaseHardenRejectPrivilegedPortsQuic `json:"quic,omitempty"`
			Tcp  *GlobalBaseHardenRejectPrivilegedPortsTcp  `json:"tcp,omitempty"`
		} `json:"reject_privileged_ports,omitempty"`
	} `json:"harden,omitempty"`
	HttpClientOptions     *HttpClientOptions `json:"http_client_options,omitempty"`
	HttpErrCodes          *[]HTTPCodes       `json:"http_err_codes,omitempty"`
	HttpFailCodes         *[]HTTPCodes       `json:"http_fail_codes,omitempty"`
	InsecureForkWanted    *bool              `json:"insecure_fork_wanted,omitempty"`
	InsecureSetuidWanted  *bool              `json:"insecure_setuid_wanted,omitempty"`
	LimitedQuic           *bool              `json:"limited_quic,omitempty"`
	Localpeer             *string            `json:"localpeer,omitempty"`
	GlobalLogSendHostname *struct {
		Enabled GlobalBaseLogSendHostnameEnabled `json:"enabled"`
		Param   *string                          `json:"param,omitempty"`
	} `json:"log_send_hostname,omitempty"`
	LuaOptions         *LuaOptions         `json:"lua_options,omitempty"`
	MasterWorker       *bool               `json:"master-worker,omitempty"`
	MaxmindOptions     *MaxmindOptions     `json:"maxmind_options,omitempty"`
	ModsecurityOptions *ModsecurityOptions `json:"modsecurity_options,omitempty"`
	ModuleLoads        *[]struct {
		Value *string `json:"value,omitempty"`
	} `json:"module-loads,omitempty"`
	ModulePath         *string                   `json:"module-path,omitempty"`
	MworkerMaxReloads  *int                      `json:"mworker_max_reloads"`
	Nbthread           *int                      `json:"nbthread,omitempty"`
	NoQuic             *bool                     `json:"no_quic,omitempty"`
	Node               *string                   `json:"node,omitempty"`
	NumaCpuMapping     *GlobalBaseNumaCpuMapping `json:"numa_cpu_mapping,omitempty"`
	OcspUpdateOptions  *OcspUpdateOptions        `json:"ocsp_update_options,omitempty"`
	PerformanceOptions *PerformanceOptions       `json:"performance_options,omitempty"`
	Pidfile            *string                   `json:"pidfile,omitempty"`
	Pp2NeverSendLocal  *bool                     `json:"pp2_never_send_local,omitempty"`
	PreallocFd         *bool                     `json:"prealloc_fd,omitempty"`
	RuntimeAPIs        *[]struct {
		AcceptNetscalerCip   *int                                 `json:"accept_netscaler_cip,omitempty"`
		AcceptProxy          *bool                                `json:"accept_proxy,omitempty"`
		Address              string                               `json:"address"`
		Allow0rtt            *bool                                `json:"allow_0rtt,omitempty"`
		Alpn                 *string                              `json:"alpn,omitempty"`
		Backlog              *string                              `json:"backlog,omitempty"`
		CaIgnoreErr          *string                              `json:"ca_ignore_err,omitempty"`
		CaSignFile           *string                              `json:"ca_sign_file,omitempty"`
		CaSignPass           *string                              `json:"ca_sign_pass,omitempty"`
		CaVerifyFile         *string                              `json:"ca_verify_file,omitempty"`
		Ciphers              *string                              `json:"ciphers,omitempty"`
		Ciphersuites         *string                              `json:"ciphersuites,omitempty"`
		ClientSigalgs        *string                              `json:"client_sigalgs,omitempty"`
		CrlFile              *string                              `json:"crl_file,omitempty"`
		CrtIgnoreErr         *string                              `json:"crt_ignore_err,omitempty"`
		CrtList              *string                              `json:"crt_list,omitempty"`
		Curves               *string                              `json:"curves,omitempty"`
		DefaultCrtList       *[]string                            `json:"default_crt_list,omitempty"`
		DeferAccept          *bool                                `json:"defer_accept,omitempty"`
		Ecdhe                *string                              `json:"ecdhe,omitempty"`
		ExposeFdListeners    *bool                                `json:"expose_fd_listeners,omitempty"`
		ForceSslv3           *bool                                `json:"force_sslv3,omitempty"`
		ForceTlsv10          *bool                                `json:"force_tlsv10,omitempty"`
		ForceTlsv11          *bool                                `json:"force_tlsv11,omitempty"`
		ForceTlsv12          *bool                                `json:"force_tlsv12,omitempty"`
		ForceTlsv13          *bool                                `json:"force_tlsv13,omitempty"`
		GenerateCertificates *bool                                `json:"generate_certificates,omitempty"`
		Gid                  *int                                 `json:"gid,omitempty"`
		Group                *string                              `json:"group,omitempty"`
		GuidPrefix           *string                              `json:"guid_prefix,omitempty"`
		Id                   *string                              `json:"id,omitempty"`
		Interface            *string                              `json:"interface,omitempty"`
		Level                *GlobalBaseRuntimeApisLevel          `json:"level,omitempty"`
		Maxconn              *int                                 `json:"maxconn,omitempty"`
		Mode                 *string                              `json:"mode,omitempty"`
		Mss                  *string                              `json:"mss,omitempty"`
		Name                 *string                              `json:"name,omitempty"`
		Namespace            *string                              `json:"namespace,omitempty"`
		Nbconn               *int                                 `json:"nbconn,omitempty"`
		Nice                 *int                                 `json:"nice,omitempty"`
		NoAlpn               *bool                                `json:"no_alpn,omitempty"`
		NoCaNames            *bool                                `json:"no_ca_names,omitempty"`
		NoSslv3              *bool                                `json:"no_sslv3,omitempty"`
		NoTlsTickets         *bool                                `json:"no_tls_tickets,omitempty"`
		NoTlsv10             *bool                                `json:"no_tlsv10,omitempty"`
		NoTlsv11             *bool                                `json:"no_tlsv11,omitempty"`
		NoTlsv12             *bool                                `json:"no_tlsv12,omitempty"`
		NoTlsv13             *bool                                `json:"no_tlsv13,omitempty"`
		Npn                  *string                              `json:"npn,omitempty"`
		PreferClientCiphers  *bool                                `json:"prefer_client_ciphers,omitempty"`
		Proto                *string                              `json:"proto,omitempty"`
		QuicCcAlgo           *GlobalBaseRuntimeApisQuicCcAlgo     `json:"quic-cc-algo,omitempty"`
		QuicForceRetry       *bool                                `json:"quic-force-retry,omitempty"`
		QuicSocket           *GlobalBaseRuntimeApisQuicSocket     `json:"quic-socket,omitempty"`
		SeverityOutput       *GlobalBaseRuntimeApisSeverityOutput `json:"severity_output,omitempty"`
		Sigalgs              *string                              `json:"sigalgs,omitempty"`
		Ssl                  *bool                                `json:"ssl,omitempty"`
		SslCafile            *string                              `json:"ssl_cafile,omitempty"`
		SslCertificate       *string                              `json:"ssl_certificate,omitempty"`
		SslMaxVer            *GlobalBaseRuntimeApisSslMaxVer      `json:"ssl_max_ver,omitempty"`
		SslMinVer            *GlobalBaseRuntimeApisSslMinVer      `json:"ssl_min_ver,omitempty"`
		StrictSni            *bool                                `json:"strict_sni,omitempty"`
		TcpUserTimeout       *int                                 `json:"tcp_user_timeout"`
		Tfo                  *bool                                `json:"tfo,omitempty"`
		Thread               *string                              `json:"thread,omitempty"`
		TlsTicketKeys        *string                              `json:"tls_ticket_keys,omitempty"`
		Transparent          *bool                                `json:"transparent,omitempty"`
		Uid                  *string                              `json:"uid,omitempty"`
		User                 *string                              `json:"user,omitempty"`
		V4v6                 *bool                                `json:"v4v6,omitempty"`
		V6only               *bool                                `json:"v6only,omitempty"`
		Verify               *GlobalBaseRuntimeApisVerify         `json:"verify,omitempty"`
	} `json:"runtime_apis,omitempty"`

	// SamlOptions SAMP (Security Assertion Markup Language) module configuration.
	SamlOptions *SamlOptions `json:"saml_options,omitempty"`
	SetDumpable *bool        `json:"set_dumpable,omitempty"`
	SetVars     *[]struct {
		Expr string `json:"expr"`
		Name string `json:"name"`
	} `json:"set_var,omitempty"`
	SetVarFmts *[]struct {
		Format string `json:"format"`
		Name   string `json:"name"`
	} `json:"set_var_fmt,omitempty"`
	Setcap *string `json:"setcap,omitempty"`

	// SslCrlOptions lb-sslcrl filter module for HAProxy configuration
	SslCrlOptions    *SslCrlOptions `json:"ssl_crl_options,omitempty"`
	SslOptions       *SslOptions    `json:"ssl_options,omitempty"`
	StatsFile        *string        `json:"stats_file,omitempty"`
	StatsMaxconn     *int           `json:"stats_maxconn"`
	StatsTimeout     *int           `json:"stats_timeout"`
	StrictLimits     *bool          `json:"strict_limits,omitempty"`
	ThreadGroupLines *[]struct {
		Group      string `json:"group"`
		NumOrRange string `json:"num_or_range"`
	} `json:"thread_group_lines,omitempty"`
	ThreadGroups      *int               `json:"thread_groups,omitempty"`
	TuneBufferOptions *TuneBufferOptions `json:"tune_buffer_options,omitempty"`
	TuneLuaOptions    *TuneLuaOptions    `json:"tune_lua_options,omitempty"`
	TuneOptions       *TuneOptions       `json:"tune_options,omitempty"`
	TuneQuicOptions   *TuneQuicOptions   `json:"tune_quic_options,omitempty"`
	TuneSslOptions    *TuneSslOptions    `json:"tune_ssl_options,omitempty"`
	TuneVarsOptions   *TuneVarsOptions   `json:"tune_vars_options,omitempty"`
	TuneZlibOptions   *TuneZlibOptions   `json:"tune_zlib_options,omitempty"`
	Uid               *int               `json:"uid,omitempty"`
	UlimitN           *int               `json:"ulimit_n,omitempty"`
	User              *string            `json:"user,omitempty"`
	WafOptions        *WafOptions        `json:"waf_options,omitempty"`
	WurflOptions      *WurflOptions      `json:"wurfl_options,omitempty"`
}

// GlobalBaseDefaultPathType defines model for GlobalBase.DefaultPath.Type.
type GlobalBaseDefaultPathType string

// GlobalBaseHardenRejectPrivilegedPortsQuic defines model for GlobalBase.Harden.RejectPrivilegedPorts.Quic.
type GlobalBaseHardenRejectPrivilegedPortsQuic string

// GlobalBaseHardenRejectPrivilegedPortsTcp defines model for GlobalBase.Harden.RejectPrivilegedPorts.Tcp.
type GlobalBaseHardenRejectPrivilegedPortsTcp string

// GlobalBaseLogSendHostnameEnabled defines model for GlobalBase.LogSendHostname.Enabled.
type GlobalBaseLogSendHostnameEnabled string

// GlobalBaseNumaCpuMapping defines model for GlobalBase.NumaCpuMapping.
type GlobalBaseNumaCpuMapping string

// GlobalBaseRuntimeApisLevel defines model for GlobalBase.RuntimeApis.Level.
type GlobalBaseRuntimeApisLevel string

// GlobalBaseRuntimeApisQuicCcAlgo defines model for GlobalBase.RuntimeApis.QuicCcAlgo.
type GlobalBaseRuntimeApisQuicCcAlgo string

// GlobalBaseRuntimeApisQuicSocket defines model for GlobalBase.RuntimeApis.QuicSocket.
type GlobalBaseRuntimeApisQuicSocket string

// GlobalBaseRuntimeApisSeverityOutput defines model for GlobalBase.RuntimeApis.SeverityOutput.
type GlobalBaseRuntimeApisSeverityOutput string

// GlobalBaseRuntimeApisSslMaxVer defines model for GlobalBase.RuntimeApis.SslMaxVer.
type GlobalBaseRuntimeApisSslMaxVer string

// GlobalBaseRuntimeApisSslMinVer defines model for GlobalBase.RuntimeApis.SslMinVer.
type GlobalBaseRuntimeApisSslMinVer string

// GlobalBaseRuntimeApisVerify defines model for GlobalBase.RuntimeApis.Verify.
type GlobalBaseRuntimeApisVerify string

// Group HAProxy userlist group
type Group struct {
	Name  string  `json:"name"`
	Users *string `json:"users,omitempty"`
}

// Groups HAProxy userlist groups array
type Groups = []Group

// HashType defines model for hash_type.
type HashType struct {
	Function *HashTypeFunction `json:"function,omitempty"`
	Method   *HashTypeMethod   `json:"method,omitempty"`
	Modifier *HashTypeModifier `json:"modifier,omitempty"`
}

// HashTypeFunction defines model for HashType.Function.
type HashTypeFunction string

// HashTypeMethod defines model for HashType.Method.
type HashTypeMethod string

// HashTypeModifier defines model for HashType.Modifier.
type HashTypeModifier string

// Health defines model for health.
type Health struct {
	Haproxy    *HealthHaproxy    `json:"haproxy,omitempty"`
	Keepalived *HealthKeepalived `json:"keepalived,omitempty"`
}

// HealthHaproxy defines model for Health.Haproxy.
type HealthHaproxy string

// HealthKeepalived defines model for Health.Keepalived.
type HealthKeepalived string

// HostPort defines model for host_port.
type HostPort struct {
	// Host The hostname or IP address of the machine where the database is running.
	Host string `json:"host"`

	// Port The port number on which the database is listening for connections.
	Port int `json:"port"`
}

// HostPortList This is a list of `HostPort` objects. Each object contains the `host` and `port` details for a database instance in a cluster. This list would contain multiple entries in a distributed database setup, such as a ClickHouse sharded cluster.
type HostPortList = []HostPort

// HttpAfterResponseRule HAProxy HTTP after response rule configuration (corresponds to http-after-response directives)
type HttpAfterResponseRule struct {
	AclFile       *string                          `json:"acl_file,omitempty"`
	AclKeyfmt     *string                          `json:"acl_keyfmt,omitempty"`
	CaptureId     *int                             `json:"capture_id"`
	CaptureLen    *int                             `json:"capture_len,omitempty"`
	CaptureSample *string                          `json:"capture_sample,omitempty"`
	Cond          *HttpAfterResponseRuleCond       `json:"cond,omitempty"`
	CondTest      *string                          `json:"cond_test,omitempty"`
	HdrFormat     *string                          `json:"hdr_format,omitempty"`
	HdrMatch      *string                          `json:"hdr_match,omitempty"`
	HdrMethod     *string                          `json:"hdr_method,omitempty"`
	HdrName       *string                          `json:"hdr_name,omitempty"`
	LogLevel      *HttpAfterResponseRuleLogLevel   `json:"log_level,omitempty"`
	MapFile       *string                          `json:"map_file,omitempty"`
	MapKeyfmt     *string                          `json:"map_keyfmt,omitempty"`
	MapValuefmt   *string                          `json:"map_valuefmt,omitempty"`
	ScCnt         *int                             `json:"sc_cnt,omitempty"`
	ScExpr        *string                          `json:"sc_expr,omitempty"`
	ScId          *int                             `json:"sc_id,omitempty"`
	ScIdx         *int                             `json:"sc_idx,omitempty"`
	ScInt         *int                             `json:"sc_int"`
	ScMessage     *string                          `json:"sc_message,omitempty"`
	Status        *int                             `json:"status,omitempty"`
	StatusReason  *string                          `json:"status_reason,omitempty"`
	StrictMode    *HttpAfterResponseRuleStrictMode `json:"strict_mode,omitempty"`
	Type          HttpAfterResponseRuleType        `json:"type"`
	VarExpr       *string                          `json:"var_expr,omitempty"`
	VarFormat     *string                          `json:"var_format,omitempty"`
	VarName       *string                          `json:"var_name,omitempty"`
	VarScope      *string                          `json:"var_scope,omitempty"`
}

// HttpAfterResponseRuleCond defines model for HttpAfterResponseRule.Cond.
type HttpAfterResponseRuleCond string

// HttpAfterResponseRuleLogLevel defines model for HttpAfterResponseRule.LogLevel.
type HttpAfterResponseRuleLogLevel string

// HttpAfterResponseRuleStrictMode defines model for HttpAfterResponseRule.StrictMode.
type HttpAfterResponseRuleStrictMode string

// HttpAfterResponseRuleType defines model for HttpAfterResponseRule.Type.
type HttpAfterResponseRuleType string

// HttpAfterResponseRules HAProxy HTTP after response rules array (corresponds to http-after-response directives)
type HttpAfterResponseRules = []HttpAfterResponseRule

// HttpCheck defines model for http_check.
type HttpCheck struct {
	Addr            *string               `json:"addr,omitempty"`
	Alpn            *string               `json:"alpn,omitempty"`
	Body            *string               `json:"body,omitempty"`
	BodyLogFormat   *string               `json:"body_log_format,omitempty"`
	CheckComment    *string               `json:"check_comment,omitempty"`
	Default         *bool                 `json:"default,omitempty"`
	ErrorStatus     *HttpCheckErrorStatus `json:"error_status,omitempty"`
	ExclamationMark *bool                 `json:"exclamation_mark,omitempty"`
	CheckHeaders    *[]ReturnHeader       `json:"headers,omitempty"`
	Linger          *bool                 `json:"linger,omitempty"`
	Match           *HttpCheckMatch       `json:"match,omitempty"`
	Method          *HttpCheckMethod      `json:"method,omitempty"`
	MinRecv         *int                  `json:"min_recv"`
	OkStatus        *HttpCheckOkStatus    `json:"ok_status,omitempty"`
	OnError         *string               `json:"on_error,omitempty"`
	OnSuccess       *string               `json:"on_success,omitempty"`
	Pattern         *string               `json:"pattern,omitempty"`
	Port            *int                  `json:"port"`
	PortString      *string               `json:"port_string,omitempty"`
	Proto           *string               `json:"proto,omitempty"`
	SendProxy       *bool                 `json:"send_proxy,omitempty"`
	Sni             *string               `json:"sni,omitempty"`
	Ssl             *bool                 `json:"ssl,omitempty"`
	StatusCode      *string               `json:"status-code,omitempty"`
	ToutStatus      *HttpCheckToutStatus  `json:"tout_status,omitempty"`
	Type            HttpCheckType         `json:"type"`
	Uri             *string               `json:"uri,omitempty"`
	UriLogFormat    *string               `json:"uri_log_format,omitempty"`
	VarExpr         *string               `json:"var_expr,omitempty"`
	VarFormat       *string               `json:"var_format,omitempty"`
	VarName         *string               `json:"var_name,omitempty"`
	VarScope        *string               `json:"var_scope,omitempty"`
	Version         *string               `json:"version,omitempty"`
	ViaSocks4       *bool                 `json:"via_socks4,omitempty"`
}

// HttpCheckErrorStatus defines model for HttpCheck.ErrorStatus.
type HttpCheckErrorStatus string

// HttpCheckMatch defines model for HttpCheck.Match.
type HttpCheckMatch string

// HttpCheckMethod defines model for HttpCheck.Method.
type HttpCheckMethod string

// HttpCheckOkStatus defines model for HttpCheck.OkStatus.
type HttpCheckOkStatus string

// HttpCheckToutStatus defines model for HttpCheck.ToutStatus.
type HttpCheckToutStatus string

// HttpCheckType defines model for HttpCheck.Type.
type HttpCheckType string

// HttpChecks defines model for http_checks.
type HttpChecks = []HttpCheck

// HttpClientOptions defines model for http_client_options.
type HttpClientOptions struct {
	ResolversDisabled *HttpClientOptionsResolversDisabled `json:"resolvers_disabled,omitempty"`
	ResolversId       *string                             `json:"resolvers_id,omitempty"`
	ResolversPrefer   *HttpClientOptionsResolversPrefer   `json:"resolvers_prefer,omitempty"`
	Retries           *int                                `json:"retries,omitempty"`
	SslCaFile         *string                             `json:"ssl_ca_file,omitempty"`
	SslVerify         *HttpClientOptionsSslVerify         `json:"ssl_verify"`
	TimeoutConnect    *int                                `json:"timeout_connect"`
}

// HttpClientOptionsResolversDisabled defines model for HttpClientOptions.ResolversDisabled.
type HttpClientOptionsResolversDisabled string

// HttpClientOptionsResolversPrefer defines model for HttpClientOptions.ResolversPrefer.
type HttpClientOptionsResolversPrefer string

// HttpClientOptionsSslVerify defines model for HttpClientOptions.SslVerify.
type HttpClientOptionsSslVerify string

// HTTPCodes defines model for http_codes.
type HTTPCodes struct {
	Value string `json:"value"`
}

// HttpErrorRule HAProxy HTTP error rule configuration (corresponds to http-error directives)
type HttpErrorRule struct {
	ReturnContent       *string                           `json:"return_content,omitempty"`
	ReturnContentFormat *HttpErrorRuleReturnContentFormat `json:"return_content_format,omitempty"`
	ReturnContentType   *string                           `json:"return_content_type"`
	ReturnHeaders       *[]ReturnHeader                   `json:"return_hdrs,omitempty"`
	Status              HttpErrorRuleStatus               `json:"status"`
	Type                HttpErrorRuleType                 `json:"type"`
}

// HttpErrorRuleReturnContentFormat defines model for HttpErrorRule.ReturnContentFormat.
type HttpErrorRuleReturnContentFormat string

// HttpErrorRuleStatus defines model for HttpErrorRule.Status.
type HttpErrorRuleStatus int

// HttpErrorRuleType defines model for HttpErrorRule.Type.
type HttpErrorRuleType string

// HttpErrorRules HAProxy HTTP error rules array (corresponds to http-error directives)
type HttpErrorRules = []HttpErrorRule

// HttpErrorsSection A globally declared group of HTTP errors
type HttpErrorsSection struct {
	ErrorFiles []Errorfile `json:"error_files"`
	Name       string      `json:"name"`
}

// HttpErrorsSections An array of HAProxy http-error sections
type HttpErrorsSections = []HttpErrorsSection

// HttpRequestRule HAProxy HTTP request rule configuration (corresponds to http-request directives)
type HttpRequestRule struct {
	AclFile              *string                             `json:"acl_file,omitempty"`
	AclKeyfmt            *string                             `json:"acl_keyfmt,omitempty"`
	AppSectionNameList   *[]string                           `json:"app_section_name_list,omitempty"`
	AuthRealm            *string                             `json:"auth_realm,omitempty"`
	BandwidthLimitLimit  *string                             `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                             `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                             `json:"bandwidth_limit_period,omitempty"`
	CacheName            *string                             `json:"cache_name,omitempty"`
	CaptureId            *int                                `json:"capture_id"`
	CaptureLen           *int                                `json:"capture_len,omitempty"`
	CaptureSample        *string                             `json:"capture_sample,omitempty"`
	ChallengeFile        *string                             `json:"challenge_file,omitempty"`
	ChallengeLevel       *int                                `json:"challenge_level,omitempty"`
	ChallengeName        *string                             `json:"challenge_name,omitempty"`
	ChallengeSecretA     *string                             `json:"challenge_secret_a,omitempty"`
	ChallengeSecretB     *string                             `json:"challenge_secret_b,omitempty"`
	ChallengeTimeout     *string                             `json:"challenge_timeout,omitempty"`
	Cond                 *HttpRequestRuleCond                `json:"cond,omitempty"`
	CondTest             *string                             `json:"cond_test,omitempty"`
	DenyStatus           *int                                `json:"deny_status"`
	Expr                 *string                             `json:"expr,omitempty"`
	HdrFormat            *string                             `json:"hdr_format,omitempty"`
	HdrMatch             *string                             `json:"hdr_match,omitempty"`
	HdrMethod            *string                             `json:"hdr_method,omitempty"`
	HdrName              *string                             `json:"hdr_name,omitempty"`
	HintFormat           *string                             `json:"hint_format,omitempty"`
	HintName             *string                             `json:"hint_name,omitempty"`
	LogLevel             *HttpRequestRuleLogLevel            `json:"log_level,omitempty"`
	LuaAction            *string                             `json:"lua_action,omitempty"`
	LuaParams            *string                             `json:"lua_params,omitempty"`
	MapFile              *string                             `json:"map_file,omitempty"`
	MapKeyfmt            *string                             `json:"map_keyfmt,omitempty"`
	MapValuefmt          *string                             `json:"map_valuefmt,omitempty"`
	MarkValue            *string                             `json:"mark_value,omitempty"`
	MethodFmt            *string                             `json:"method_fmt,omitempty"`
	NiceValue            *int                                `json:"nice_value,omitempty"`
	Normalizer           *HttpRequestRuleNormalizer          `json:"normalizer,omitempty"`
	NormalizerFull       *bool                               `json:"normalizer_full,omitempty"`
	NormalizerStrict     *bool                               `json:"normalizer_strict,omitempty"`
	PathFmt              *string                             `json:"path_fmt,omitempty"`
	PathMatch            *string                             `json:"path_match,omitempty"`
	Profile              *string                             `json:"profile"`
	Protocol             *HttpRequestRuleProtocol            `json:"protocol,omitempty"`
	QueryFmt             *string                             `json:"query-fmt,omitempty"`
	RedirCode            *HttpRequestRuleRedirCode           `json:"redir_code"`
	RedirOption          *string                             `json:"redir_option,omitempty"`
	RedirType            *HttpRequestRuleRedirType           `json:"redir_type,omitempty"`
	RedirValue           *string                             `json:"redir_value,omitempty"`
	Resolvers            *string                             `json:"resolvers,omitempty"`
	ReturnContent        *string                             `json:"return_content,omitempty"`
	ReturnContentFormat  *HttpRequestRuleReturnContentFormat `json:"return_content_format,omitempty"`
	ReturnContentType    *string                             `json:"return_content_type"`
	ReturnHeaders        *[]ReturnHeader                     `json:"return_hdrs,omitempty"`
	ReturnStatusCode     *int                                `json:"return_status_code"`
	RstTtl               *int                                `json:"rst_ttl,omitempty"`
	ScCnt                *int                                `json:"sc_cnt,omitempty"`
	ScExpr               *string                             `json:"sc_expr,omitempty"`
	ScId                 *int                                `json:"sc_id,omitempty"`
	ScIdx                *int                                `json:"sc_idx,omitempty"`
	ScInt                *int                                `json:"sc_int"`
	ScMessage            *string                             `json:"sc_message,omitempty"`
	ServiceName          *string                             `json:"service_name,omitempty"`
	SpoeEngine           *string                             `json:"spoe_engine,omitempty"`
	SpoeGroup            *string                             `json:"spoe_group,omitempty"`
	StrictMode           *HttpRequestRuleStrictMode          `json:"strict_mode,omitempty"`
	Timeout              *string                             `json:"timeout,omitempty"`
	TimeoutType          *HttpRequestRuleTimeoutType         `json:"timeout_type,omitempty"`
	TosValue             *string                             `json:"tos_value,omitempty"`
	TrackScKey           *string                             `json:"track_sc_key,omitempty"`
	TrackScStickCounter  *int                                `json:"track_sc_stick_counter"`
	TrackScTable         *string                             `json:"track_sc_table,omitempty"`
	Type                 HttpRequestRuleType                 `json:"type"`
	UriFmt               *string                             `json:"uri-fmt,omitempty"`
	UriMatch             *string                             `json:"uri-match,omitempty"`
	VarExpr              *string                             `json:"var_expr,omitempty"`
	VarFormat            *string                             `json:"var_format,omitempty"`
	VarName              *string                             `json:"var_name,omitempty"`
	VarScope             *string                             `json:"var_scope,omitempty"`
	WaitAtLeast          *int                                `json:"wait_at_least"`
	WaitTime             *int                                `json:"wait_time"`
}

// HttpRequestRuleCond defines model for HttpRequestRule.Cond.
type HttpRequestRuleCond string

// HttpRequestRuleLogLevel defines model for HttpRequestRule.LogLevel.
type HttpRequestRuleLogLevel string

// HttpRequestRuleNormalizer defines model for HttpRequestRule.Normalizer.
type HttpRequestRuleNormalizer string

// HttpRequestRuleProtocol defines model for HttpRequestRule.Protocol.
type HttpRequestRuleProtocol string

// HttpRequestRuleRedirCode defines model for HttpRequestRule.RedirCode.
type HttpRequestRuleRedirCode int

// HttpRequestRuleRedirType defines model for HttpRequestRule.RedirType.
type HttpRequestRuleRedirType string

// HttpRequestRuleReturnContentFormat defines model for HttpRequestRule.ReturnContentFormat.
type HttpRequestRuleReturnContentFormat string

// HttpRequestRuleStrictMode defines model for HttpRequestRule.StrictMode.
type HttpRequestRuleStrictMode string

// HttpRequestRuleTimeoutType defines model for HttpRequestRule.TimeoutType.
type HttpRequestRuleTimeoutType string

// HttpRequestRuleType defines model for HttpRequestRule.Type.
type HttpRequestRuleType string

// HttpRequestRules HAProxy HTTP request rules array (corresponds to http-request directives)
type HttpRequestRules = []HttpRequestRule

// HttpResponseRule HAProxy HTTP response rule configuration (corresponds to http-response directives)
type HttpResponseRule struct {
	AclFile              *string                              `json:"acl_file,omitempty"`
	AclKeyfmt            *string                              `json:"acl_keyfmt,omitempty"`
	AppSectionNameList   *[]string                            `json:"app_section_name_list,omitempty"`
	BandwidthLimitLimit  *string                              `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                              `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                              `json:"bandwidth_limit_period,omitempty"`
	CacheName            *string                              `json:"cache_name,omitempty"`
	CaptureId            *int                                 `json:"capture_id"`
	CaptureSample        *string                              `json:"capture_sample,omitempty"`
	Cond                 *HttpResponseRuleCond                `json:"cond,omitempty"`
	CondTest             *string                              `json:"cond_test,omitempty"`
	DenyStatus           *int                                 `json:"deny_status"`
	Expr                 *string                              `json:"expr,omitempty"`
	HdrFormat            *string                              `json:"hdr_format,omitempty"`
	HdrMatch             *string                              `json:"hdr_match,omitempty"`
	HdrMethod            *string                              `json:"hdr_method,omitempty"`
	HdrName              *string                              `json:"hdr_name,omitempty"`
	LogLevel             *HttpResponseRuleLogLevel            `json:"log_level,omitempty"`
	LuaAction            *string                              `json:"lua_action,omitempty"`
	LuaParams            *string                              `json:"lua_params,omitempty"`
	MapFile              *string                              `json:"map_file,omitempty"`
	MapKeyfmt            *string                              `json:"map_keyfmt,omitempty"`
	MapValuefmt          *string                              `json:"map_valuefmt,omitempty"`
	MarkValue            *string                              `json:"mark_value,omitempty"`
	NiceValue            *int                                 `json:"nice_value,omitempty"`
	RedirCode            *HttpResponseRuleRedirCode           `json:"redir_code"`
	RedirOption          *string                              `json:"redir_option,omitempty"`
	RedirType            *HttpResponseRuleRedirType           `json:"redir_type,omitempty"`
	RedirValue           *string                              `json:"redir_value,omitempty"`
	ReturnContent        *string                              `json:"return_content,omitempty"`
	ReturnContentFormat  *HttpResponseRuleReturnContentFormat `json:"return_content_format,omitempty"`
	ReturnContentType    *string                              `json:"return_content_type"`
	ReturnHeaders        *[]ReturnHeader                      `json:"return_hdrs,omitempty"`
	ReturnStatusCode     *int                                 `json:"return_status_code"`
	RstTtl               *int                                 `json:"rst_ttl,omitempty"`
	ScCnt                *int                                 `json:"sc_cnt,omitempty"`
	ScExpr               *string                              `json:"sc_expr,omitempty"`
	ScId                 *int                                 `json:"sc_id,omitempty"`
	ScIdx                *int                                 `json:"sc_idx,omitempty"`
	ScInt                *int                                 `json:"sc_int"`
	ScMessage            *string                              `json:"sc_message,omitempty"`
	SpoeEngine           *string                              `json:"spoe_engine,omitempty"`
	SpoeGroup            *string                              `json:"spoe_group,omitempty"`
	Status               *int                                 `json:"status,omitempty"`
	StatusReason         *string                              `json:"status_reason,omitempty"`
	StrictMode           *HttpResponseRuleStrictMode          `json:"strict_mode,omitempty"`
	Timeout              *string                              `json:"timeout,omitempty"`
	TimeoutType          *HttpResponseRuleTimeoutType         `json:"timeout_type,omitempty"`
	TosValue             *string                              `json:"tos_value,omitempty"`
	TrackScKey           *string                              `json:"track_sc_key,omitempty"`
	TrackScStickCounter  *int                                 `json:"track_sc_stick_counter"`
	TrackScTable         *string                              `json:"track_sc_table,omitempty"`
	Type                 HttpResponseRuleType                 `json:"type"`
	VarExpr              *string                              `json:"var_expr,omitempty"`
	VarFormat            *string                              `json:"var_format,omitempty"`
	VarName              *string                              `json:"var_name,omitempty"`
	VarScope             *string                              `json:"var_scope,omitempty"`
	WaitAtLeast          *int                                 `json:"wait_at_least"`
	WaitTime             *int                                 `json:"wait_time"`
}

// HttpResponseRuleCond defines model for HttpResponseRule.Cond.
type HttpResponseRuleCond string

// HttpResponseRuleLogLevel defines model for HttpResponseRule.LogLevel.
type HttpResponseRuleLogLevel string

// HttpResponseRuleRedirCode defines model for HttpResponseRule.RedirCode.
type HttpResponseRuleRedirCode int

// HttpResponseRuleRedirType defines model for HttpResponseRule.RedirType.
type HttpResponseRuleRedirType string

// HttpResponseRuleReturnContentFormat defines model for HttpResponseRule.ReturnContentFormat.
type HttpResponseRuleReturnContentFormat string

// HttpResponseRuleStrictMode defines model for HttpResponseRule.StrictMode.
type HttpResponseRuleStrictMode string

// HttpResponseRuleTimeoutType defines model for HttpResponseRule.TimeoutType.
type HttpResponseRuleTimeoutType string

// HttpResponseRuleType defines model for HttpResponseRule.Type.
type HttpResponseRuleType string

// HttpResponseRules HAProxy HTTP response rules array (corresponds to http-response directives)
type HttpResponseRules = []HttpResponseRule

// HttpchkParams defines model for httpchk_params.
type HttpchkParams struct {
	Method  *HttpchkParamsMethod `json:"method,omitempty"`
	Uri     *string              `json:"uri,omitempty"`
	Version *string              `json:"version,omitempty"`
}

// HttpchkParamsMethod defines model for HttpchkParams.Method.
type HttpchkParamsMethod string

// Info General API, OS and hardware information
type Info struct {
	Api *struct {
		// BuildDate HAProxy Dataplane API build date
		BuildDate *time.Time `json:"build_date,omitempty"`

		// Version HAProxy Dataplane API version string
		Version *string `json:"version,omitempty"`
	} `json:"api,omitempty"`
	System *struct {
		CpuInfo *struct {
			Model *string `json:"model,omitempty"`

			// NumCpus Number of logical CPUs
			NumCpus *int `json:"num_cpus,omitempty"`
		} `json:"cpu_info,omitempty"`

		// Hostname Hostname where the HAProxy is running
		Hostname *string `json:"hostname,omitempty"`
		MemInfo  *struct {
			DataplaneapiMemory *int `json:"dataplaneapi_memory,omitempty"`
			FreeMemory         *int `json:"free_memory,omitempty"`
			TotalMemory        *int `json:"total_memory,omitempty"`
		} `json:"mem_info,omitempty"`

		// OsString OS string
		OsString *string `json:"os_string,omitempty"`

		// Time Current time in milliseconds since Epoch.
		Time *int `json:"time,omitempty"`

		// Uptime System uptime
		Uptime *int `json:"uptime"`
	} `json:"system,omitempty"`
}

// KeepalivedNotifyScript defines model for keepalived_notify_script.
type KeepalivedNotifyScript struct {
	// Args Option list of arguments must be passed to the script
	Args *[]string `json:"args,omitempty"`

	// Script Path to the script
	Script string `json:"script"`
}

// KeepalivedReload Keepalived reload
type KeepalivedReload struct {
	Id              *string                 `json:"id,omitempty"`
	ReloadTimestamp *int                    `json:"reload_timestamp,omitempty"`
	Response        *string                 `json:"response,omitempty"`
	Status          *KeepalivedReloadStatus `json:"status,omitempty"`
}

// KeepalivedReloadStatus defines model for KeepalivedReload.Status.
type KeepalivedReloadStatus string

// KeepalivedReloads Keepalived reloads array
type KeepalivedReloads = []KeepalivedReload

// KeepalivedTransaction Keepalived configuration transaction
type KeepalivedTransaction struct {
	UnderscoreVersion *int                         `json:"_version,omitempty"`
	Id                *string                      `json:"id,omitempty"`
	Status            *KeepalivedTransactionStatus `json:"status,omitempty"`
}

// KeepalivedTransactionStatus defines model for KeepalivedTransaction.Status.
type KeepalivedTransactionStatus string

// KeepalivedTransactions Keepalived Configuration transactions array
type KeepalivedTransactions = []KeepalivedTransaction

// LogConfiguration Configuration for Log Inputs and Outputs
type LogConfiguration struct {
	LogInputs  *map[string]LogInput  `json:"log_inputs,omitempty"`
	LogOutputs *map[string]LogOutput `json:"log_outputs,omitempty"`
	Settings   *LogSettings          `json:"settings,omitempty"`
}

// LogFilter defines model for log_filter.
type LogFilter struct {
	// AllOf List of Log Rules
	AllOf *LogRules `json:"all_of,omitempty"`

	// AnyOf List of Log Rules
	AnyOf *LogRules `json:"any_of,omitempty"`
}

// LogForward defines model for log_forward.
type LogForward struct {
	Backlog    *int                  `json:"backlog"`
	Binds      *map[string]Bind      `json:"binds,omitempty"`
	DgramBinds *map[string]DgramBind `json:"dgram_binds,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList *LogTargets `json:"log_target_list,omitempty"`
	Maxconn       *int        `json:"maxconn"`
	Name          string      `json:"name"`
	TimeoutClient *int        `json:"timeout_client"`
}

// LogForwardBase HAProxy log forward configuration
type LogForwardBase struct {
	Backlog       *int   `json:"backlog"`
	Maxconn       *int   `json:"maxconn"`
	Name          string `json:"name"`
	TimeoutClient *int   `json:"timeout_client"`
}

// LogForwards HAProxy log forwards array
type LogForwards = []LogForward

// LogInput defines model for log_input.
type LogInput struct {
	// Description More detailed information about the log input source.
	Description *string `json:"description,omitempty"`

	// Enabled Indicates if this log input source is active.
	Enabled *bool `json:"enabled"`

	// Id Uniquely identifies the log input source. Must have at least one char and not contain spaces.
	Id *string `json:"id,omitempty"`

	// Name Friendly name of the log input source.
	Name            *string  `json:"name,omitempty"`
	SamplingPercent *float64 `json:"sampling_percent,omitempty"`

	// SyslogOptions Collect Syslog messages with rfc5424 format through the network using UDP.
	SyslogOptions *SyslogInput `json:"syslog_options,omitempty"`

	// Type Type of the log input source.
	Type LogInputType `json:"type"`
}

// LogInputType Type of the log input source.
type LogInputType string

// LogInputs List of Log Inputs
type LogInputs = []LogInput

// LogOutput defines model for log_output.
type LogOutput struct {
	// BufferSize Size of the buffer (number of access logs) in front of this output to store new logs while the current one is being processed.
	BufferSize *int `json:"buffer_size,omitempty"`

	// ClickhouseOptions Send logs to ClickHouse database.
	ClickhouseOptions *ClickhouseOutput `json:"clickhouse_options,omitempty"`

	// Enabled Indicates if this log output destination is active.
	Enabled *bool      `json:"enabled"`
	Filter  *LogFilter `json:"filter,omitempty"`

	// Id Uniquely identifies the log output destination. Must have at least one char and not contain spaces.
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`

	// SyslogOptions Send collected logs to a Syslog server rfc5424 format.
	SyslogOptions *SyslogOutput `json:"syslog_options,omitempty"`

	// Type Type of the log output destination.
	Type LogOutputType `json:"type"`
}

// LogOutputType Type of the log output destination.
type LogOutputType string

// LogOutputs List of Log Outputs
type LogOutputs = []LogOutput

// LogRule A rule to determine whether a log is a match.
type LogRule struct {
	// Field The name of the field in the log that will be compared.
	// You can access structured data map with the special syntax `<sd-id> <key>`.
	// For example,if the structured data are `[exampleSDID@haptech-id eventSource="Application" eventID="1011"][exampleSDID2@haptech-id test="tast"]`, you can access by setting field to `exampleSDID@haptech-id eventSource`.
	// Structured data syntax is applicable when type is string.
	Field string `json:"field"`

	// NumberMatcher Method of comparison for a number field (greater than, greater than or equals). This only applies when type is number.
	NumberMatcher *LogRuleNumberMatcher `json:"number_matcher,omitempty"`

	// StringMatcher Method of comparison for a string field. This only applies when type is string.
	StringMatcher *LogRuleStringMatcher `json:"string_matcher,omitempty"`

	// TimestampMatcher Method of comparison for a timestamp field (equals, before, after). This only applies when type is timestamp.
	TimestampMatcher *LogRuleTimestampMatcher `json:"timestamp_matcher,omitempty"`

	// Type Specifies the field's data type in the log and the matcher to use.
	Type LogRuleType `json:"type"`

	// Value The value to match in the selected field.
	Value string `json:"value"`
}

// LogRuleNumberMatcher Method of comparison for a number field (greater than, greater than or equals). This only applies when type is number.
type LogRuleNumberMatcher string

// LogRuleStringMatcher Method of comparison for a string field. This only applies when type is string.
type LogRuleStringMatcher string

// LogRuleTimestampMatcher Method of comparison for a timestamp field (equals, before, after). This only applies when type is timestamp.
type LogRuleTimestampMatcher string

// LogRuleType Specifies the field's data type in the log and the matcher to use.
type LogRuleType string

// LogRules List of Log Rules
type LogRules = []LogRule

// LogSettings defines model for log_settings.
type LogSettings struct {
	// MessageBufferSize size of the buffer (in number of messages) that connects log inputs to log outputs.
	MessageBufferSize *int `json:"message_buffer_size"`
}

// LogTarget Per-instance logging of events and traffic.
type LogTarget struct {
	Address     *string            `json:"address,omitempty"`
	Facility    *LogTargetFacility `json:"facility,omitempty"`
	Format      *LogTargetFormat   `json:"format,omitempty"`
	Global      *bool              `json:"global,omitempty"`
	Length      *int               `json:"length,omitempty"`
	Level       *LogTargetLevel    `json:"level,omitempty"`
	Minlevel    *LogTargetMinlevel `json:"minlevel,omitempty"`
	Nolog       *bool              `json:"nolog,omitempty"`
	SampleRange *string            `json:"sample_range,omitempty"`
	SampleSize  *int               `json:"sample_size,omitempty"`
}

// LogTargetFacility defines model for LogTarget.Facility.
type LogTargetFacility string

// LogTargetFormat defines model for LogTarget.Format.
type LogTargetFormat string

// LogTargetLevel defines model for LogTarget.Level.
type LogTargetLevel string

// LogTargetMinlevel defines model for LogTarget.Minlevel.
type LogTargetMinlevel string

// LogTargets HAProxy log target array (corresponds to log directives)
type LogTargets = []LogTarget

// LuaOptions defines model for lua_options.
type LuaOptions struct {
	LoadPerThread *string `json:"load_per_thread,omitempty"`
	Loads         *[]struct {
		File string `json:"file"`
	} `json:"loads,omitempty"`
	PrependPath *[]struct {
		Path string                     `json:"path"`
		Type *LuaOptionsPrependPathType `json:"type,omitempty"`
	} `json:"prepend_path,omitempty"`
}

// LuaOptionsPrependPathType defines model for LuaOptions.PrependPath.Type.
type LuaOptionsPrependPathType string

// MailerEntries HAProxy mailer entries
type MailerEntries = []MailerEntry

// MailerEntry Mailer entry of a Mailers section
type MailerEntry struct {
	Address string `json:"address"`
	Name    string `json:"name"`
	Port    int    `json:"port"`
}

// MailersSection defines model for mailers_section.
type MailersSection struct {
	MailerEntries *map[string]MailerEntry `json:"mailer_entries,omitempty"`
	Name          string                  `json:"name"`
	Timeout       *int                    `json:"timeout"`
}

// MailersSectionBase A list of SMTP servers used by HAProxy to send emails.
type MailersSectionBase struct {
	Name    string `json:"name"`
	Timeout *int   `json:"timeout"`
}

// MailersSections HAProxy mailers_section array
type MailersSections = []MailersSection

// Map Map File
type Map struct {
	Description *string `json:"description,omitempty"`
	File        *string `json:"file,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Size File size in bytes.
	Size        *int    `json:"size"`
	StorageName *string `json:"storage_name,omitempty"`
}

// MapEntries Entries of one runtime map
type MapEntries = []MapEntry

// MapEntry One Map Entry
type MapEntry struct {
	Id    *string `json:"id,omitempty"`
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// Maps Array of runtime map files
type Maps = []Map

// MaxmindOptions defines model for maxmind_options.
type MaxmindOptions struct {
	CacheSize   *int  `json:"cache_size,omitempty"`
	Debug       *bool `json:"debug,omitempty"`
	MaxmindLoad *struct {
		MaxmindDBs *[]struct {
			Key  *string `json:"key,omitempty"`
			Path *string `json:"path,omitempty"`
		} `json:"maxmind_dbs,omitempty"`
		MlockMax *int `json:"mlock_max"`
	} `json:"load,omitempty"`
	MaxmindUpdate *struct {
		Checksum      *bool `json:"checksum,omitempty"`
		Delay         *int  `json:"delay"`
		DontlogNormal *bool `json:"dontlog_normal,omitempty"`
		Hash          *bool `json:"hash,omitempty"`
		Log           *bool `json:"log,omitempty"`
		MaxmindURLs   *[]struct {
			Key *string `json:"key,omitempty"`
			Url *string `json:"url,omitempty"`
		} `json:"maxmind_urls,omitempty"`
		Retries *int `json:"retries"`
		Timeout *int `json:"timeout"`
	} `json:"update,omitempty"`
}

// ModsecurityOptions defines model for modsecurity_options.
type ModsecurityOptions struct {
	DenyBlockingIo       *bool                           `json:"deny_blocking_io"`
	MaxCpuAction         *ModsecurityOptionsMaxCpuAction `json:"max_cpu_action"`
	MaxCpuBackoffDelay   *string                         `json:"max_cpu_backoff_delay"`
	MaxCpuBackoffRetries *int                            `json:"max_cpu_backoff_retries"`
	MaxCpuPeriod         *string                         `json:"max_cpu_period"`
	MaxCpuUsage          *int                            `json:"max_cpu_usage"`
}

// ModsecurityOptionsMaxCpuAction defines model for ModsecurityOptions.MaxCpuAction.
type ModsecurityOptionsMaxCpuAction string

// MonitorFail defines model for monitor_fail.
type MonitorFail struct {
	Cond     MonitorFailCond `json:"cond"`
	CondTest string          `json:"cond_test"`
}

// MonitorFailCond defines model for MonitorFail.Cond.
type MonitorFailCond string

// MonitorUri defines model for monitor_uri.
type MonitorUri = string

// MysqlCheckParams defines model for mysql_check_params.
type MysqlCheckParams struct {
	ClientVersion *MysqlCheckParamsClientVersion `json:"client_version,omitempty"`
	Username      *string                        `json:"username,omitempty"`
}

// MysqlCheckParamsClientVersion defines model for MysqlCheckParams.ClientVersion.
type MysqlCheckParamsClientVersion string

// Nameserver Nameserver used in Runtime DNS configuration
type Nameserver struct {
	Address   string  `json:"address"`
	Interface *string `json:"interface,omitempty"`
	Name      string  `json:"name"`
	Port      *int    `json:"port"`
	Source    *string `json:"source,omitempty"`
}

// Nameservers Nameservers array
type Nameservers = []Nameserver

// NativeStat Current stats for one object.
type NativeStat struct {
	BackendName *string          `json:"backend_name,omitempty"`
	Name        *string          `json:"name,omitempty"`
	Stats       *NativeStatStats `json:"stats,omitempty"`
	Type        *NativeStatType  `json:"type,omitempty"`
}

// NativeStatType defines model for NativeStat.Type.
type NativeStatType string

// NativeStatStats defines model for native_stat_stats.
type NativeStatStats struct {
	Act           *int                        `json:"act"`
	Addr          *string                     `json:"addr,omitempty"`
	AgentCode     *int                        `json:"agent_code"`
	AgentDesc     *string                     `json:"agent_desc,omitempty"`
	AgentDuration *int                        `json:"agent_duration"`
	AgentFall     *int                        `json:"agent_fall"`
	AgentHealth   *int                        `json:"agent_health"`
	AgentRise     *int                        `json:"agent_rise"`
	AgentStatus   *NativeStatStatsAgentStatus `json:"agent_status,omitempty"`
	Algo          *string                     `json:"algo,omitempty"`
	Bck           *int                        `json:"bck"`
	Bin           *int                        `json:"bin"`
	Bout          *int                        `json:"bout"`
	CheckCode     *int                        `json:"check_code"`
	CheckDesc     *string                     `json:"check_desc,omitempty"`
	CheckDuration *int                        `json:"check_duration"`
	CheckFall     *int                        `json:"check_fall"`
	CheckHealth   *int                        `json:"check_health"`
	CheckRise     *int                        `json:"check_rise"`
	CheckStatus   *NativeStatStatsCheckStatus `json:"check_status,omitempty"`
	Chkdown       *int                        `json:"chkdown"`
	Chkfail       *int                        `json:"chkfail"`
	CliAbrt       *int                        `json:"cli_abrt"`
	CompByp       *int                        `json:"comp_byp"`
	CompIn        *int                        `json:"comp_in"`
	CompOut       *int                        `json:"comp_out"`
	CompRsp       *int                        `json:"comp_rsp"`
	ConnRate      *int                        `json:"conn_rate"`
	ConnRateMax   *int                        `json:"conn_rate_max"`
	ConnTot       *int                        `json:"conn_tot"`
	Cookie        *string                     `json:"cookie,omitempty"`
	Ctime         *int                        `json:"ctime"`
	Dcon          *int                        `json:"dcon"`
	Downtime      *int                        `json:"downtime"`
	Dreq          *int                        `json:"dreq"`
	Dresp         *int                        `json:"dresp"`
	Dses          *int                        `json:"dses"`
	Econ          *int                        `json:"econ"`
	Ereq          *int                        `json:"ereq"`
	Eresp         *int                        `json:"eresp"`
	Hanafail      *string                     `json:"hanafail,omitempty"`
	Hrsp1xx       *int                        `json:"hrsp_1xx"`
	Hrsp2xx       *int                        `json:"hrsp_2xx"`
	Hrsp3xx       *int                        `json:"hrsp_3xx"`
	Hrsp4xx       *int                        `json:"hrsp_4xx"`
	Hrsp5xx       *int                        `json:"hrsp_5xx"`
	HrspOther     *int                        `json:"hrsp_other"`
	Iid           *int                        `json:"iid"`
	Intercepted   *int                        `json:"intercepted"`
	LastAgt       *string                     `json:"last_agt"`
	LastChk       *string                     `json:"last_chk"`
	Lastchg       *int                        `json:"lastchg"`
	Lastsess      *int                        `json:"lastsess"`
	Lbtot         *int                        `json:"lbtot"`
	Mode          *NativeStatStatsMode        `json:"mode,omitempty"`
	Pid           *int                        `json:"pid"`
	Qcur          *int                        `json:"qcur"`
	Qlimit        *int                        `json:"qlimit"`
	Qmax          *int                        `json:"qmax"`
	Qtime         *int                        `json:"qtime"`
	Rate          *int                        `json:"rate"`
	RateLim       *int                        `json:"rate_lim"`
	RateMax       *int                        `json:"rate_max"`
	ReqRate       *int                        `json:"req_rate"`
	ReqRateMax    *int                        `json:"req_rate_max"`
	ReqTot        *int                        `json:"req_tot"`
	Rtime         *int                        `json:"rtime"`
	Scur          *int                        `json:"scur"`
	Sid           *int                        `json:"sid"`
	Slim          *int                        `json:"slim"`
	Smax          *int                        `json:"smax"`
	SrvAbrt       *int                        `json:"srv_abrt"`
	Status        *NativeStatStatsStatus      `json:"status,omitempty"`
	Stot          *int                        `json:"stot"`
	Throttle      *int                        `json:"throttle"`
	Tracked       *string                     `json:"tracked,omitempty"`
	Ttime         *int                        `json:"ttime"`
	Weight        *int                        `json:"weight"`
	Wredis        *int                        `json:"wredis"`
	Wretr         *int                        `json:"wretr"`
}

// NativeStatStatsAgentStatus defines model for NativeStatStats.AgentStatus.
type NativeStatStatsAgentStatus string

// NativeStatStatsCheckStatus defines model for NativeStatStats.CheckStatus.
type NativeStatStatsCheckStatus string

// NativeStatStatsMode defines model for NativeStatStats.Mode.
type NativeStatStatsMode string

// NativeStatStatsStatus defines model for NativeStatStats.Status.
type NativeStatStatsStatus string

// NativeStats HAProxy stats array
type NativeStats struct {
	Error      *string       `json:"error,omitempty"`
	RuntimeAPI *string       `json:"runtimeAPI,omitempty"`
	Stats      *[]NativeStat `json:"stats,omitempty"`
}

// OcspUpdateOptions defines model for ocsp_update_options.
type OcspUpdateOptions struct {
	Disable   *bool `json:"disable"`
	Httpproxy *struct {
		Address *string `json:"address,omitempty"`
		Port    *int    `json:"port"`
	} `json:"httpproxy,omitempty"`

	// Maxdelay Sets the maximum interval between two automatic updates of the same OCSP response.This time is expressed in seconds
	Maxdelay *int `json:"maxdelay"`

	// Mindelay Sets the minimum interval between two automatic updates of the same OCSP response. This time is expressed in seconds
	Mindelay *int                   `json:"mindelay"`
	Mode     *OcspUpdateOptionsMode `json:"mode,omitempty"`
}

// OcspUpdateOptionsMode defines model for OcspUpdateOptions.Mode.
type OcspUpdateOptionsMode string

// Originalto defines model for originalto.
type Originalto struct {
	Enabled OriginaltoEnabled `json:"enabled"`
	Except  *string           `json:"except,omitempty"`
	Header  *string           `json:"header,omitempty"`
}

// OriginaltoEnabled defines model for Originalto.Enabled.
type OriginaltoEnabled string

// PeerEntries HAProxy peer entries array
type PeerEntries = []PeerEntry

// PeerEntry Peer Entry from peers table
type PeerEntry struct {
	Address string `json:"address"`
	Name    string `json:"name"`
	Port    *int   `json:"port"`
	Shard   *int   `json:"shard,omitempty"`
}

// PeerSection defines model for peer_section.
type PeerSection struct {
	Binds *map[string]Bind `json:"binds,omitempty"`

	// DefaultBind HAProxy default bind configuration
	DefaultBind   *DefaultBind   `json:"default_bind,omitempty"`
	DefaultServer *DefaultServer `json:"default_server,omitempty"`
	Disabled      *bool          `json:"disabled,omitempty"`
	Enabled       *bool          `json:"enabled,omitempty"`

	// LogTargetList HAProxy log target array (corresponds to log directives)
	LogTargetList *LogTargets           `json:"log_target_list,omitempty"`
	Name          string                `json:"name"`
	PeerEntries   *map[string]PeerEntry `json:"peer_entries,omitempty"`
	Servers       *map[string]Server    `json:"servers,omitempty"`

	// Shards In some configurations, one would like to distribute the stick-table contents
	// to some peers in place of sending all the stick-table contents to each peer
	// declared in the "peers" section. In such cases, "shards" specifies the
	// number of peer involved in this stick-table contents distribution.
	Shards *int              `json:"shards,omitempty"`
	Tables *map[string]Table `json:"tables,omitempty"`
}

// PeerSectionBase HAProxy peer_section configuration
type PeerSectionBase struct {
	// DefaultBind HAProxy default bind configuration
	DefaultBind   *DefaultBind   `json:"default_bind,omitempty"`
	DefaultServer *DefaultServer `json:"default_server,omitempty"`
	Disabled      *bool          `json:"disabled,omitempty"`
	Enabled       *bool          `json:"enabled,omitempty"`
	Name          string         `json:"name"`

	// Shards In some configurations, one would like to distribute the stick-table contents
	// to some peers in place of sending all the stick-table contents to each peer
	// declared in the "peers" section. In such cases, "shards" specifies the
	// number of peer involved in this stick-table contents distribution.
	Shards *int `json:"shards,omitempty"`
}

// PeerSections HAProxy peer_section array
type PeerSections = []PeerSection

// PerformanceOptions defines model for performance_options.
type PerformanceOptions struct {
	BusyPolling     *bool                              `json:"busy_polling,omitempty"`
	MaxSpreadChecks *int                               `json:"max_spread_checks"`
	Maxcompcpuusage *int                               `json:"maxcompcpuusage,omitempty"`
	Maxcomprate     *int                               `json:"maxcomprate,omitempty"`
	Maxconn         *int                               `json:"maxconn,omitempty"`
	Maxconnrate     *int                               `json:"maxconnrate,omitempty"`
	Maxpipes        *int                               `json:"maxpipes,omitempty"`
	Maxsessrate     *int                               `json:"maxsessrate,omitempty"`
	Maxzlibmem      *int                               `json:"maxzlibmem,omitempty"`
	Noepoll         *bool                              `json:"noepoll,omitempty"`
	Noevports       *bool                              `json:"noevports,omitempty"`
	Nogetaddrinfo   *bool                              `json:"nogetaddrinfo,omitempty"`
	Nokqueue        *bool                              `json:"nokqueue,omitempty"`
	Nopoll          *bool                              `json:"nopoll,omitempty"`
	Noreuseport     *bool                              `json:"noreuseport,omitempty"`
	Nosplice        *bool                              `json:"nosplice,omitempty"`
	ProfilingMemory *PerformanceOptionsProfilingMemory `json:"profiling_memory,omitempty"`
	ProfilingTasks  *PerformanceOptionsProfilingTasks  `json:"profiling_tasks,omitempty"`
	ServerStateBase *string                            `json:"server_state_base,omitempty"`
	ServerStateFile *string                            `json:"server_state_file,omitempty"`
	SpreadChecks    *int                               `json:"spread_checks,omitempty"`
	ThreadHardLimit *int                               `json:"thread_hard_limit"`
}

// PerformanceOptionsProfilingMemory defines model for PerformanceOptions.ProfilingMemory.
type PerformanceOptionsProfilingMemory string

// PerformanceOptionsProfilingTasks defines model for PerformanceOptions.ProfilingTasks.
type PerformanceOptionsProfilingTasks string

// PersistRule defines model for persist_rule.
type PersistRule struct {
	RdpCookieName *string         `json:"rdp_cookie_name,omitempty"`
	Type          PersistRuleType `json:"type"`
}

// PersistRuleType defines model for PersistRule.Type.
type PersistRuleType string

// PgsqlCheckParams defines model for pgsql_check_params.
type PgsqlCheckParams struct {
	Username *string `json:"username,omitempty"`
}

// ProcessInfo General HAProxy process information
type ProcessInfo struct {
	Error      *string          `json:"error,omitempty"`
	Info       *ProcessInfoItem `json:"info,omitempty"`
	RuntimeAPI *string          `json:"runtimeAPI,omitempty"`
}

// ProcessInfoItem defines model for process_info_item.
type ProcessInfoItem struct {
	ActivePeers        *int `json:"active_peers"`
	BusyPolling        *int `json:"busy_polling"`
	BytesOutRate       *int `json:"bytes_out_rate"`
	CompressBpsIn      *int `json:"compress_bps_in"`
	CompressBpsOut     *int `json:"compress_bps_out"`
	CompressBpsRateLim *int `json:"compress_bps_rate_lim"`
	ConnRate           *int `json:"conn_rate"`
	ConnRateLimit      *int `json:"conn_rate_limit"`
	ConnectedPeers     *int `json:"connected_peers"`
	CumConns           *int `json:"cum_conns"`
	CumReq             *int `json:"cum_req"`
	CumSslConns        *int `json:"cum_ssl_conns"`
	CurrConns          *int `json:"curr_conns"`
	CurrSslConns       *int `json:"curr_ssl_conns"`
	DroppedLogs        *int `json:"dropped_logs"`
	FailedResolutions  *int `json:"failed_resolutions"`
	HardMaxConn        *int `json:"hard_max_conn"`
	IdlePct            *int `json:"idle_pct"`
	Jobs               *int `json:"jobs"`
	Listeners          *int `json:"listeners"`
	MaxConn            *int `json:"max_conn"`
	MaxConnRate        *int `json:"max_conn_rate"`
	MaxPipes           *int `json:"max_pipes"`
	MaxSessRate        *int `json:"max_sess_rate"`
	MaxSock            *int `json:"max_sock"`
	MaxSslConns        *int `json:"max_ssl_conns"`
	MaxSslRate         *int `json:"max_ssl_rate"`
	MaxZlibMemUsage    *int `json:"max_zlib_mem_usage"`
	MemMaxMb           *int `json:"mem_max_mb"`

	// Nbthread Number of threads
	Nbthread *int    `json:"nbthread"`
	Node     *string `json:"node,omitempty"`

	// Pid Process id of the replying worker process
	Pid         *int `json:"pid"`
	PipesFree   *int `json:"pipes_free"`
	PipesUsed   *int `json:"pipes_used"`
	PoolAllocMb *int `json:"pool_alloc_mb"`
	PoolFailed  *int `json:"pool_failed"`
	PoolUsedMb  *int `json:"pool_used_mb"`

	// ProcessNum Process number
	ProcessNum *int `json:"process_num"`

	// Processes Number of spawned processes
	Processes *int `json:"processes"`

	// ReleaseDate HAProxy version release date
	ReleaseDate             *openapi_types.Date `json:"release_date,omitempty"`
	RunQueue                *int                `json:"run_queue"`
	SessRate                *int                `json:"sess_rate"`
	SessRateLimit           *int                `json:"sess_rate_limit"`
	SslBackendKeyRate       *int                `json:"ssl_backend_key_rate"`
	SslBackendMaxKeyRate    *int                `json:"ssl_backend_max_key_rate"`
	SslCacheLookups         *int                `json:"ssl_cache_lookups"`
	SslCacheMisses          *int                `json:"ssl_cache_misses"`
	SslFrontendKeyRate      *int                `json:"ssl_frontend_key_rate"`
	SslFrontendMaxKeyRate   *int                `json:"ssl_frontend_max_key_rate"`
	SslFrontendSessionReuse *int                `json:"ssl_frontend_session_reuse"`
	SslRate                 *int                `json:"ssl_rate"`
	SslRateLimit            *int                `json:"ssl_rate_limit"`
	Stopping                *int                `json:"stopping"`
	Tasks                   *int                `json:"tasks"`
	TotalBytesOut           *int                `json:"total_bytes_out"`
	UlimitN                 *int                `json:"ulimit_n"`
	Unstoppable             *int                `json:"unstoppable"`

	// Uptime HAProxy uptime in s
	Uptime *int `json:"uptime"`

	// Version HAProxy version string
	Version      *string `json:"version,omitempty"`
	ZlibMemUsage *int    `json:"zlib_mem_usage"`
}

// Program HAProxy program configuration
type Program struct {
	// Command The command to be run, with flags and options.
	Command string `json:"command"`

	// Group The group to run the command as, if different than the HAProxy group.
	Group *string `json:"group,omitempty"`
	Name  string  `json:"name"`

	// StartOnReload HAProxy stops and recreates child programs at reload.
	StartOnReload *ProgramStartOnReload `json:"start-on-reload,omitempty"`

	// User The user to run the command as, if different than the HAProxy user.
	User *string `json:"user,omitempty"`
}

// ProgramStartOnReload HAProxy stops and recreates child programs at reload.
type ProgramStartOnReload string

// Programs defines model for programs.
type Programs = []Program

// Redispatch defines model for redispatch.
type Redispatch struct {
	Enabled  RedispatchEnabled `json:"enabled"`
	Interval *int              `json:"interval"`
}

// RedispatchEnabled defines model for Redispatch.Enabled.
type RedispatchEnabled string

// Reload HAProxy reload
type Reload struct {
	Id              *string       `json:"id,omitempty"`
	ReloadTimestamp *int          `json:"reload_timestamp,omitempty"`
	Response        *string       `json:"response,omitempty"`
	Status          *ReloadStatus `json:"status,omitempty"`
}

// ReloadStatus defines model for Reload.Status.
type ReloadStatus string

// Reloads HAProxy reloads array
type Reloads = []Reload

// Resolver defines model for resolver.
type Resolver struct {
	AcceptedPayloadSize *int                   `json:"accepted_payload_size,omitempty"`
	HoldNx              *int                   `json:"hold_nx"`
	HoldObsolete        *int                   `json:"hold_obsolete"`
	HoldOther           *int                   `json:"hold_other"`
	HoldRefused         *int                   `json:"hold_refused"`
	HoldTimeout         *int                   `json:"hold_timeout"`
	HoldValid           *int                   `json:"hold_valid"`
	Name                string                 `json:"name"`
	Nameservers         *map[string]Nameserver `json:"nameservers,omitempty"`
	ParseResolvConf     *bool                  `json:"parse-resolv-conf,omitempty"`
	ResolveRetries      *int                   `json:"resolve_retries,omitempty"`
	TimeoutResolve      *int                   `json:"timeout_resolve,omitempty"`
	TimeoutRetry        *int                   `json:"timeout_retry,omitempty"`
}

// ResolverBase Runtime DNS configuration
type ResolverBase struct {
	AcceptedPayloadSize *int   `json:"accepted_payload_size,omitempty"`
	HoldNx              *int   `json:"hold_nx"`
	HoldObsolete        *int   `json:"hold_obsolete"`
	HoldOther           *int   `json:"hold_other"`
	HoldRefused         *int   `json:"hold_refused"`
	HoldTimeout         *int   `json:"hold_timeout"`
	HoldValid           *int   `json:"hold_valid"`
	Name                string `json:"name"`
	ParseResolvConf     *bool  `json:"parse-resolv-conf,omitempty"`
	ResolveRetries      *int   `json:"resolve_retries,omitempty"`
	TimeoutResolve      *int   `json:"timeout_resolve,omitempty"`
	TimeoutRetry        *int   `json:"timeout_retry,omitempty"`
}

// Resolvers HAProxy resolvers array
type Resolvers = []Resolver

// ReturnHeader defines model for return_header.
type ReturnHeader struct {
	Fmt  string `json:"fmt"`
	Name string `json:"name"`
}

// Ring defines model for ring.
type Ring struct {
	Description    *string            `json:"description,omitempty"`
	Format         *RingFormat        `json:"format,omitempty"`
	Maxlen         *int               `json:"maxlen"`
	Name           string             `json:"name"`
	Servers        *map[string]Server `json:"servers,omitempty"`
	Size           *int               `json:"size"`
	TimeoutConnect *int               `json:"timeout_connect"`
	TimeoutServer  *int               `json:"timeout_server"`
}

// RingFormat defines model for Ring.Format.
type RingFormat string

// RingBase HAProxy ring configuration
type RingBase struct {
	Description    *string         `json:"description,omitempty"`
	Format         *RingBaseFormat `json:"format,omitempty"`
	Maxlen         *int            `json:"maxlen"`
	Name           string          `json:"name"`
	Size           *int            `json:"size"`
	TimeoutConnect *int            `json:"timeout_connect"`
	TimeoutServer  *int            `json:"timeout_server"`
}

// RingBaseFormat defines model for RingBase.Format.
type RingBaseFormat string

// Rings HAProxy rings array
type Rings = []Ring

// RuntimeAddServer Settable properties when adding a new server using HAProxy's runtime.
type RuntimeAddServer struct {
	Address            *string                           `json:"address,omitempty"`
	AgentAddr          *string                           `json:"agent-addr,omitempty"`
	AgentCheck         *RuntimeAddServerAgentCheck       `json:"agent-check,omitempty"`
	AgentInter         *int                              `json:"agent-inter"`
	AgentPort          *int                              `json:"agent-port"`
	AgentSend          *string                           `json:"agent-send,omitempty"`
	Allow0rtt          *bool                             `json:"allow_0rtt,omitempty"`
	Alpn               *string                           `json:"alpn,omitempty"`
	Backup             *RuntimeAddServerBackup           `json:"backup,omitempty"`
	Check              *RuntimeAddServerCheck            `json:"check,omitempty"`
	CheckSendProxy     *RuntimeAddServerCheckSendProxy   `json:"check-send-proxy,omitempty"`
	CheckSni           *string                           `json:"check-sni,omitempty"`
	CheckSsl           *RuntimeAddServerCheckSsl         `json:"check-ssl,omitempty"`
	CheckAlpn          *string                           `json:"check_alpn,omitempty"`
	CheckProto         *string                           `json:"check_proto,omitempty"`
	CheckViaSocks4     *RuntimeAddServerCheckViaSocks4   `json:"check_via_socks4,omitempty"`
	Ciphers            *string                           `json:"ciphers,omitempty"`
	Ciphersuites       *string                           `json:"ciphersuites,omitempty"`
	CrlFile            *string                           `json:"crl_file,omitempty"`
	Downinter          *int                              `json:"downinter"`
	ErrorLimit         *int                              `json:"error_limit"`
	Fall               *int                              `json:"fall"`
	Fastinter          *int                              `json:"fastinter"`
	ForceSslv3         *RuntimeAddServerForceSslv3       `json:"force_sslv3,omitempty"`
	ForceTlsv10        *RuntimeAddServerForceTlsv10      `json:"force_tlsv10,omitempty"`
	ForceTlsv11        *RuntimeAddServerForceTlsv11      `json:"force_tlsv11,omitempty"`
	ForceTlsv12        *RuntimeAddServerForceTlsv12      `json:"force_tlsv12,omitempty"`
	ForceTlsv13        *RuntimeAddServerForceTlsv13      `json:"force_tlsv13,omitempty"`
	HealthCheckAddress *string                           `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                              `json:"health_check_port"`
	Id                 *string                           `json:"id,omitempty"`
	Inter              *int                              `json:"inter"`
	Maintenance        *RuntimeAddServerMaintenance      `json:"maintenance,omitempty"`
	Maxconn            *int                              `json:"maxconn"`
	Maxqueue           *int                              `json:"maxqueue"`
	Minconn            *int                              `json:"minconn"`
	Name               *string                           `json:"name,omitempty"`
	NoSslv3            *RuntimeAddServerNoSslv3          `json:"no_sslv3,omitempty"`
	NoTlsv10           *RuntimeAddServerNoTlsv10         `json:"no_tlsv10,omitempty"`
	NoTlsv11           *RuntimeAddServerNoTlsv11         `json:"no_tlsv11,omitempty"`
	NoTlsv12           *RuntimeAddServerNoTlsv12         `json:"no_tlsv12,omitempty"`
	NoTlsv13           *RuntimeAddServerNoTlsv13         `json:"no_tlsv13,omitempty"`
	Npn                *string                           `json:"npn,omitempty"`
	Observe            *RuntimeAddServerObserve          `json:"observe,omitempty"`
	OnError            *RuntimeAddServerOnError          `json:"on-error,omitempty"`
	OnMarkedDown       *RuntimeAddServerOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp         *RuntimeAddServerOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolLowConn        *int                              `json:"pool_low_conn"`
	PoolMaxConn        *int                              `json:"pool_max_conn"`
	PoolPurgeDelay     *int                              `json:"pool_purge_delay"`
	Port               *int                              `json:"port"`
	Proto              *string                           `json:"proto,omitempty"`
	ProxyV2Options     *[]RuntimeAddServerProxyV2Options `json:"proxy-v2-options,omitempty"`
	Rise               *int                              `json:"rise"`
	SendProxy          *RuntimeAddServerSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2        *RuntimeAddServerSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl     *RuntimeAddServerSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn   *RuntimeAddServerSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	Slowstart          *int                              `json:"slowstart"`
	Sni                *string                           `json:"sni,omitempty"`
	Source             *string                           `json:"source,omitempty"`
	Ssl                *RuntimeAddServerSsl              `json:"ssl,omitempty"`
	SslCafile          *string                           `json:"ssl_cafile,omitempty"`
	SslCertificate     *string                           `json:"ssl_certificate,omitempty"`
	SslMaxVer          *RuntimeAddServerSslMaxVer        `json:"ssl_max_ver,omitempty"`
	SslMinVer          *RuntimeAddServerSslMinVer        `json:"ssl_min_ver,omitempty"`
	SslReuse           *RuntimeAddServerSslReuse         `json:"ssl_reuse,omitempty"`
	Tfo                *RuntimeAddServerTfo              `json:"tfo,omitempty"`
	TlsTickets         *RuntimeAddServerTlsTickets       `json:"tls_tickets,omitempty"`
	Track              *string                           `json:"track,omitempty"`
	Verify             *RuntimeAddServerVerify           `json:"verify,omitempty"`
	Verifyhost         *string                           `json:"verifyhost,omitempty"`
	Weight             *int                              `json:"weight"`
	Ws                 *RuntimeAddServerWs               `json:"ws,omitempty"`
}

// RuntimeAddServerAgentCheck defines model for RuntimeAddServer.AgentCheck.
type RuntimeAddServerAgentCheck string

// RuntimeAddServerBackup defines model for RuntimeAddServer.Backup.
type RuntimeAddServerBackup string

// RuntimeAddServerCheck defines model for RuntimeAddServer.Check.
type RuntimeAddServerCheck string

// RuntimeAddServerCheckSendProxy defines model for RuntimeAddServer.CheckSendProxy.
type RuntimeAddServerCheckSendProxy string

// RuntimeAddServerCheckSsl defines model for RuntimeAddServer.CheckSsl.
type RuntimeAddServerCheckSsl string

// RuntimeAddServerCheckViaSocks4 defines model for RuntimeAddServer.CheckViaSocks4.
type RuntimeAddServerCheckViaSocks4 string

// RuntimeAddServerForceSslv3 defines model for RuntimeAddServer.ForceSslv3.
type RuntimeAddServerForceSslv3 string

// RuntimeAddServerForceTlsv10 defines model for RuntimeAddServer.ForceTlsv10.
type RuntimeAddServerForceTlsv10 string

// RuntimeAddServerForceTlsv11 defines model for RuntimeAddServer.ForceTlsv11.
type RuntimeAddServerForceTlsv11 string

// RuntimeAddServerForceTlsv12 defines model for RuntimeAddServer.ForceTlsv12.
type RuntimeAddServerForceTlsv12 string

// RuntimeAddServerForceTlsv13 defines model for RuntimeAddServer.ForceTlsv13.
type RuntimeAddServerForceTlsv13 string

// RuntimeAddServerMaintenance defines model for RuntimeAddServer.Maintenance.
type RuntimeAddServerMaintenance string

// RuntimeAddServerNoSslv3 defines model for RuntimeAddServer.NoSslv3.
type RuntimeAddServerNoSslv3 string

// RuntimeAddServerNoTlsv10 defines model for RuntimeAddServer.NoTlsv10.
type RuntimeAddServerNoTlsv10 string

// RuntimeAddServerNoTlsv11 defines model for RuntimeAddServer.NoTlsv11.
type RuntimeAddServerNoTlsv11 string

// RuntimeAddServerNoTlsv12 defines model for RuntimeAddServer.NoTlsv12.
type RuntimeAddServerNoTlsv12 string

// RuntimeAddServerNoTlsv13 defines model for RuntimeAddServer.NoTlsv13.
type RuntimeAddServerNoTlsv13 string

// RuntimeAddServerObserve defines model for RuntimeAddServer.Observe.
type RuntimeAddServerObserve string

// RuntimeAddServerOnError defines model for RuntimeAddServer.OnError.
type RuntimeAddServerOnError string

// RuntimeAddServerOnMarkedDown defines model for RuntimeAddServer.OnMarkedDown.
type RuntimeAddServerOnMarkedDown string

// RuntimeAddServerOnMarkedUp defines model for RuntimeAddServer.OnMarkedUp.
type RuntimeAddServerOnMarkedUp string

// RuntimeAddServerProxyV2Options defines model for RuntimeAddServer.ProxyV2Options.
type RuntimeAddServerProxyV2Options string

// RuntimeAddServerSendProxy defines model for RuntimeAddServer.SendProxy.
type RuntimeAddServerSendProxy string

// RuntimeAddServerSendProxyV2 defines model for RuntimeAddServer.SendProxyV2.
type RuntimeAddServerSendProxyV2 string

// RuntimeAddServerSendProxyV2Ssl defines model for RuntimeAddServer.SendProxyV2Ssl.
type RuntimeAddServerSendProxyV2Ssl string

// RuntimeAddServerSendProxyV2SslCn defines model for RuntimeAddServer.SendProxyV2SslCn.
type RuntimeAddServerSendProxyV2SslCn string

// RuntimeAddServerSsl defines model for RuntimeAddServer.Ssl.
type RuntimeAddServerSsl string

// RuntimeAddServerSslMaxVer defines model for RuntimeAddServer.SslMaxVer.
type RuntimeAddServerSslMaxVer string

// RuntimeAddServerSslMinVer defines model for RuntimeAddServer.SslMinVer.
type RuntimeAddServerSslMinVer string

// RuntimeAddServerSslReuse defines model for RuntimeAddServer.SslReuse.
type RuntimeAddServerSslReuse string

// RuntimeAddServerTfo defines model for RuntimeAddServer.Tfo.
type RuntimeAddServerTfo string

// RuntimeAddServerTlsTickets defines model for RuntimeAddServer.TlsTickets.
type RuntimeAddServerTlsTickets string

// RuntimeAddServerVerify defines model for RuntimeAddServer.Verify.
type RuntimeAddServerVerify string

// RuntimeAddServerWs defines model for RuntimeAddServer.Ws.
type RuntimeAddServerWs string

// RuntimeServer Runtime transient server properties
type RuntimeServer struct {
	Address          *string                        `json:"address,omitempty"`
	AdminState       *RuntimeServerAdminState       `json:"admin_state,omitempty"`
	Id               *string                        `json:"id,omitempty"`
	Name             *string                        `json:"name,omitempty"`
	OperationalState *RuntimeServerOperationalState `json:"operational_state,omitempty"`
	Port             *int                           `json:"port"`
}

// RuntimeServerAdminState defines model for RuntimeServer.AdminState.
type RuntimeServerAdminState string

// RuntimeServerOperationalState defines model for RuntimeServer.OperationalState.
type RuntimeServerOperationalState string

// RuntimeServers HAProxy runtime servers array
type RuntimeServers = []RuntimeServer

// SamlOptions SAMP (Security Assertion Markup Language) module configuration.
type SamlOptions struct {
	SamlSsoLoad *struct {
		// ConfigurationDirectory Configuration directory from which the module will load the configuration files into its memory.
		ConfigurationDirectory *string `json:"configuration_directory,omitempty"`

		// IniFile Path to the saml.ini file
		IniFile *string `json:"ini_file,omitempty"`
	} `json:"saml_sso_load,omitempty"`
}

// Server defines model for server.
type Server struct {
	Address            string                             `json:"address"`
	AgentAddr          *string                            `json:"agent-addr,omitempty"`
	AgentCheck         *ServerAgentCheck                  `json:"agent-check,omitempty"`
	AgentInter         *int                               `json:"agent-inter"`
	AgentPort          *int                               `json:"agent-port"`
	AgentSend          *string                            `json:"agent-send,omitempty"`
	Allow0rtt          *bool                              `json:"allow_0rtt,omitempty"`
	Alpn               *string                            `json:"alpn,omitempty"`
	Backup             *ServerBackup                      `json:"backup,omitempty"`
	Check              *ServerCheck                       `json:"check,omitempty"`
	CheckSendProxy     *ServerCheckSendProxy              `json:"check-send-proxy,omitempty"`
	CheckSni           *string                            `json:"check-sni,omitempty"`
	CheckSsl           *ServerCheckSsl                    `json:"check-ssl,omitempty"`
	CheckAlpn          *string                            `json:"check_alpn,omitempty"`
	CheckProto         *string                            `json:"check_proto,omitempty"`
	CheckViaSocks4     *ServerCheckViaSocks4              `json:"check_via_socks4,omitempty"`
	Ciphers            *string                            `json:"ciphers,omitempty"`
	Ciphersuites       *string                            `json:"ciphersuites,omitempty"`
	ClientSigalgs      *string                            `json:"client_sigalgs,omitempty"`
	Cookie             *string                            `json:"cookie,omitempty"`
	CrlFile            *string                            `json:"crl_file,omitempty"`
	Curves             *string                            `json:"curves,omitempty"`
	Downinter          *int                               `json:"downinter"`
	ErrorLimit         *int                               `json:"error_limit,omitempty"`
	Fall               *int                               `json:"fall"`
	Fastinter          *int                               `json:"fastinter"`
	ForceSslv3         *ServerForceSslv3                  `json:"force_sslv3,omitempty"`
	ForceTlsv10        *ServerForceTlsv10                 `json:"force_tlsv10,omitempty"`
	ForceTlsv11        *ServerForceTlsv11                 `json:"force_tlsv11,omitempty"`
	ForceTlsv12        *ServerForceTlsv12                 `json:"force_tlsv12,omitempty"`
	ForceTlsv13        *ServerForceTlsv13                 `json:"force_tlsv13,omitempty"`
	Guid               *string                            `json:"guid,omitempty"`
	HashKey            *string                            `json:"hash_key,omitempty"`
	HealthCheckAddress *string                            `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                               `json:"health_check_port"`
	Id                 *int                               `json:"id"`
	InitAddr           *string                            `json:"init-addr"`
	Inter              *int                               `json:"inter"`
	LogBufsize         *int                               `json:"log-bufsize"`
	LogProto           *ServerLogProto                    `json:"log_proto,omitempty"`
	Maintenance        *ServerMaintenance                 `json:"maintenance,omitempty"`
	MaxReuse           *int                               `json:"max_reuse"`
	Maxconn            *int                               `json:"maxconn"`
	Maxqueue           *int                               `json:"maxqueue"`
	Metadata           *map[string]map[string]interface{} `json:"metadata,omitempty"`
	Minconn            *int                               `json:"minconn"`
	Name               string                             `json:"name"`
	Namespace          *string                            `json:"namespace,omitempty"`
	NoSslv3            *ServerNoSslv3                     `json:"no_sslv3,omitempty"`
	NoTlsv10           *ServerNoTlsv10                    `json:"no_tlsv10,omitempty"`
	NoTlsv11           *ServerNoTlsv11                    `json:"no_tlsv11,omitempty"`
	NoTlsv12           *ServerNoTlsv12                    `json:"no_tlsv12,omitempty"`
	NoTlsv13           *ServerNoTlsv13                    `json:"no_tlsv13,omitempty"`
	NoVerifyhost       *ServerNoVerifyhost                `json:"no_verifyhost,omitempty"`
	Npn                *string                            `json:"npn,omitempty"`
	Observe            *ServerObserve                     `json:"observe,omitempty"`
	OnError            *ServerOnError                     `json:"on-error,omitempty"`
	OnMarkedDown       *ServerOnMarkedDown                `json:"on-marked-down,omitempty"`
	OnMarkedUp         *ServerOnMarkedUp                  `json:"on-marked-up,omitempty"`
	PoolConnName       *string                            `json:"pool_conn_name,omitempty"`
	PoolLowConn        *int                               `json:"pool_low_conn"`
	PoolMaxConn        *int                               `json:"pool_max_conn"`
	PoolPurgeDelay     *int                               `json:"pool_purge_delay"`
	Port               *int                               `json:"port"`
	Proto              *string                            `json:"proto,omitempty"`
	ProxyV2Options     *[]ServerProxyV2Options            `json:"proxy-v2-options,omitempty"`
	Redir              *string                            `json:"redir,omitempty"`
	ResolveNet         *string                            `json:"resolve-net,omitempty"`
	ResolvePrefer      *ServerResolvePrefer               `json:"resolve-prefer,omitempty"`
	ResolveOpts        *string                            `json:"resolve_opts,omitempty"`
	Resolvers          *string                            `json:"resolvers,omitempty"`
	Rise               *int                               `json:"rise"`
	SendProxy          *ServerSendProxy                   `json:"send-proxy,omitempty"`
	SendProxyV2        *ServerSendProxyV2                 `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl     *ServerSendProxyV2Ssl              `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn   *ServerSendProxyV2SslCn            `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt   *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int              `json:"shard,omitempty"`
	Sigalgs        *string           `json:"sigalgs,omitempty"`
	Slowstart      *int              `json:"slowstart"`
	Sni            *string           `json:"sni,omitempty"`
	Socks4         *string           `json:"socks4,omitempty"`
	Source         *string           `json:"source,omitempty"`
	Ssl            *ServerSsl        `json:"ssl,omitempty"`
	SslCafile      *string           `json:"ssl_cafile,omitempty"`
	SslCertificate *string           `json:"ssl_certificate,omitempty"`
	SslMaxVer      *ServerSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *ServerSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *ServerSslReuse   `json:"ssl_reuse,omitempty"`
	Stick          *ServerStick      `json:"stick,omitempty"`
	TcpUt          *int              `json:"tcp_ut"`
	Tfo            *ServerTfo        `json:"tfo,omitempty"`
	TlsTickets     *ServerTlsTickets `json:"tls_tickets,omitempty"`
	Track          *string           `json:"track,omitempty"`
	Verify         *ServerVerify     `json:"verify,omitempty"`
	Verifyhost     *string           `json:"verifyhost,omitempty"`
	Weight         *int              `json:"weight"`
	Ws             *ServerWs         `json:"ws,omitempty"`
}

// ServerAgentCheck defines model for Server.AgentCheck.
type ServerAgentCheck string

// ServerBackup defines model for Server.Backup.
type ServerBackup string

// ServerCheck defines model for Server.Check.
type ServerCheck string

// ServerCheckSendProxy defines model for Server.CheckSendProxy.
type ServerCheckSendProxy string

// ServerCheckSsl defines model for Server.CheckSsl.
type ServerCheckSsl string

// ServerCheckViaSocks4 defines model for Server.CheckViaSocks4.
type ServerCheckViaSocks4 string

// ServerForceSslv3 defines model for Server.ForceSslv3.
type ServerForceSslv3 string

// ServerForceTlsv10 defines model for Server.ForceTlsv10.
type ServerForceTlsv10 string

// ServerForceTlsv11 defines model for Server.ForceTlsv11.
type ServerForceTlsv11 string

// ServerForceTlsv12 defines model for Server.ForceTlsv12.
type ServerForceTlsv12 string

// ServerForceTlsv13 defines model for Server.ForceTlsv13.
type ServerForceTlsv13 string

// ServerLogProto defines model for Server.LogProto.
type ServerLogProto string

// ServerMaintenance defines model for Server.Maintenance.
type ServerMaintenance string

// ServerNoSslv3 defines model for Server.NoSslv3.
type ServerNoSslv3 string

// ServerNoTlsv10 defines model for Server.NoTlsv10.
type ServerNoTlsv10 string

// ServerNoTlsv11 defines model for Server.NoTlsv11.
type ServerNoTlsv11 string

// ServerNoTlsv12 defines model for Server.NoTlsv12.
type ServerNoTlsv12 string

// ServerNoTlsv13 defines model for Server.NoTlsv13.
type ServerNoTlsv13 string

// ServerNoVerifyhost defines model for Server.NoVerifyhost.
type ServerNoVerifyhost string

// ServerObserve defines model for Server.Observe.
type ServerObserve string

// ServerOnError defines model for Server.OnError.
type ServerOnError string

// ServerOnMarkedDown defines model for Server.OnMarkedDown.
type ServerOnMarkedDown string

// ServerOnMarkedUp defines model for Server.OnMarkedUp.
type ServerOnMarkedUp string

// ServerProxyV2Options defines model for Server.ProxyV2Options.
type ServerProxyV2Options string

// ServerResolvePrefer defines model for Server.ResolvePrefer.
type ServerResolvePrefer string

// ServerSendProxy defines model for Server.SendProxy.
type ServerSendProxy string

// ServerSendProxyV2 defines model for Server.SendProxyV2.
type ServerSendProxyV2 string

// ServerSendProxyV2Ssl defines model for Server.SendProxyV2Ssl.
type ServerSendProxyV2Ssl string

// ServerSendProxyV2SslCn defines model for Server.SendProxyV2SslCn.
type ServerSendProxyV2SslCn string

// ServerSsl defines model for Server.Ssl.
type ServerSsl string

// ServerSslMaxVer defines model for Server.SslMaxVer.
type ServerSslMaxVer string

// ServerSslMinVer defines model for Server.SslMinVer.
type ServerSslMinVer string

// ServerSslReuse defines model for Server.SslReuse.
type ServerSslReuse string

// ServerStick defines model for Server.Stick.
type ServerStick string

// ServerTfo defines model for Server.Tfo.
type ServerTfo string

// ServerTlsTickets defines model for Server.TlsTickets.
type ServerTlsTickets string

// ServerVerify defines model for Server.Verify.
type ServerVerify string

// ServerWs defines model for Server.Ws.
type ServerWs string

// ServerParams defines model for server_params.
type ServerParams struct {
	AgentAddr          *string                       `json:"agent-addr,omitempty"`
	AgentCheck         *ServerParamsAgentCheck       `json:"agent-check,omitempty"`
	AgentInter         *int                          `json:"agent-inter"`
	AgentPort          *int                          `json:"agent-port"`
	AgentSend          *string                       `json:"agent-send,omitempty"`
	Allow0rtt          *bool                         `json:"allow_0rtt,omitempty"`
	Alpn               *string                       `json:"alpn,omitempty"`
	Backup             *ServerParamsBackup           `json:"backup,omitempty"`
	Check              *ServerParamsCheck            `json:"check,omitempty"`
	CheckSendProxy     *ServerParamsCheckSendProxy   `json:"check-send-proxy,omitempty"`
	CheckSni           *string                       `json:"check-sni,omitempty"`
	CheckSsl           *ServerParamsCheckSsl         `json:"check-ssl,omitempty"`
	CheckAlpn          *string                       `json:"check_alpn,omitempty"`
	CheckProto         *string                       `json:"check_proto,omitempty"`
	CheckViaSocks4     *ServerParamsCheckViaSocks4   `json:"check_via_socks4,omitempty"`
	Ciphers            *string                       `json:"ciphers,omitempty"`
	Ciphersuites       *string                       `json:"ciphersuites,omitempty"`
	ClientSigalgs      *string                       `json:"client_sigalgs,omitempty"`
	Cookie             *string                       `json:"cookie,omitempty"`
	CrlFile            *string                       `json:"crl_file,omitempty"`
	Curves             *string                       `json:"curves,omitempty"`
	Downinter          *int                          `json:"downinter"`
	ErrorLimit         *int                          `json:"error_limit,omitempty"`
	Fall               *int                          `json:"fall"`
	Fastinter          *int                          `json:"fastinter"`
	ForceSslv3         *ServerParamsForceSslv3       `json:"force_sslv3,omitempty"`
	ForceTlsv10        *ServerParamsForceTlsv10      `json:"force_tlsv10,omitempty"`
	ForceTlsv11        *ServerParamsForceTlsv11      `json:"force_tlsv11,omitempty"`
	ForceTlsv12        *ServerParamsForceTlsv12      `json:"force_tlsv12,omitempty"`
	ForceTlsv13        *ServerParamsForceTlsv13      `json:"force_tlsv13,omitempty"`
	Guid               *string                       `json:"guid,omitempty"`
	HashKey            *string                       `json:"hash_key,omitempty"`
	HealthCheckAddress *string                       `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                          `json:"health_check_port"`
	InitAddr           *string                       `json:"init-addr"`
	Inter              *int                          `json:"inter"`
	LogBufsize         *int                          `json:"log-bufsize"`
	LogProto           *ServerParamsLogProto         `json:"log_proto,omitempty"`
	Maintenance        *ServerParamsMaintenance      `json:"maintenance,omitempty"`
	MaxReuse           *int                          `json:"max_reuse"`
	Maxconn            *int                          `json:"maxconn"`
	Maxqueue           *int                          `json:"maxqueue"`
	Minconn            *int                          `json:"minconn"`
	Namespace          *string                       `json:"namespace,omitempty"`
	NoSslv3            *ServerParamsNoSslv3          `json:"no_sslv3,omitempty"`
	NoTlsv10           *ServerParamsNoTlsv10         `json:"no_tlsv10,omitempty"`
	NoTlsv11           *ServerParamsNoTlsv11         `json:"no_tlsv11,omitempty"`
	NoTlsv12           *ServerParamsNoTlsv12         `json:"no_tlsv12,omitempty"`
	NoTlsv13           *ServerParamsNoTlsv13         `json:"no_tlsv13,omitempty"`
	NoVerifyhost       *ServerParamsNoVerifyhost     `json:"no_verifyhost,omitempty"`
	Npn                *string                       `json:"npn,omitempty"`
	Observe            *ServerParamsObserve          `json:"observe,omitempty"`
	OnError            *ServerParamsOnError          `json:"on-error,omitempty"`
	OnMarkedDown       *ServerParamsOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp         *ServerParamsOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolConnName       *string                       `json:"pool_conn_name,omitempty"`
	PoolLowConn        *int                          `json:"pool_low_conn"`
	PoolMaxConn        *int                          `json:"pool_max_conn"`
	PoolPurgeDelay     *int                          `json:"pool_purge_delay"`
	Proto              *string                       `json:"proto,omitempty"`
	ProxyV2Options     *[]ServerParamsProxyV2Options `json:"proxy-v2-options,omitempty"`
	Redir              *string                       `json:"redir,omitempty"`
	ResolveNet         *string                       `json:"resolve-net,omitempty"`
	ResolvePrefer      *ServerParamsResolvePrefer    `json:"resolve-prefer,omitempty"`
	ResolveOpts        *string                       `json:"resolve_opts,omitempty"`
	Resolvers          *string                       `json:"resolvers,omitempty"`
	Rise               *int                          `json:"rise"`
	SendProxy          *ServerParamsSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2        *ServerParamsSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl     *ServerParamsSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn   *ServerParamsSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt   *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int                    `json:"shard,omitempty"`
	Sigalgs        *string                 `json:"sigalgs,omitempty"`
	Slowstart      *int                    `json:"slowstart"`
	Sni            *string                 `json:"sni,omitempty"`
	Socks4         *string                 `json:"socks4,omitempty"`
	Source         *string                 `json:"source,omitempty"`
	Ssl            *ServerParamsSsl        `json:"ssl,omitempty"`
	SslCafile      *string                 `json:"ssl_cafile,omitempty"`
	SslCertificate *string                 `json:"ssl_certificate,omitempty"`
	SslMaxVer      *ServerParamsSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *ServerParamsSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *ServerParamsSslReuse   `json:"ssl_reuse,omitempty"`
	Stick          *ServerParamsStick      `json:"stick,omitempty"`
	TcpUt          *int                    `json:"tcp_ut"`
	Tfo            *ServerParamsTfo        `json:"tfo,omitempty"`
	TlsTickets     *ServerParamsTlsTickets `json:"tls_tickets,omitempty"`
	Track          *string                 `json:"track,omitempty"`
	Verify         *ServerParamsVerify     `json:"verify,omitempty"`
	Verifyhost     *string                 `json:"verifyhost,omitempty"`
	Weight         *int                    `json:"weight"`
	Ws             *ServerParamsWs         `json:"ws,omitempty"`
}

// ServerParamsAgentCheck defines model for ServerParams.AgentCheck.
type ServerParamsAgentCheck string

// ServerParamsBackup defines model for ServerParams.Backup.
type ServerParamsBackup string

// ServerParamsCheck defines model for ServerParams.Check.
type ServerParamsCheck string

// ServerParamsCheckSendProxy defines model for ServerParams.CheckSendProxy.
type ServerParamsCheckSendProxy string

// ServerParamsCheckSsl defines model for ServerParams.CheckSsl.
type ServerParamsCheckSsl string

// ServerParamsCheckViaSocks4 defines model for ServerParams.CheckViaSocks4.
type ServerParamsCheckViaSocks4 string

// ServerParamsForceSslv3 defines model for ServerParams.ForceSslv3.
type ServerParamsForceSslv3 string

// ServerParamsForceTlsv10 defines model for ServerParams.ForceTlsv10.
type ServerParamsForceTlsv10 string

// ServerParamsForceTlsv11 defines model for ServerParams.ForceTlsv11.
type ServerParamsForceTlsv11 string

// ServerParamsForceTlsv12 defines model for ServerParams.ForceTlsv12.
type ServerParamsForceTlsv12 string

// ServerParamsForceTlsv13 defines model for ServerParams.ForceTlsv13.
type ServerParamsForceTlsv13 string

// ServerParamsLogProto defines model for ServerParams.LogProto.
type ServerParamsLogProto string

// ServerParamsMaintenance defines model for ServerParams.Maintenance.
type ServerParamsMaintenance string

// ServerParamsNoSslv3 defines model for ServerParams.NoSslv3.
type ServerParamsNoSslv3 string

// ServerParamsNoTlsv10 defines model for ServerParams.NoTlsv10.
type ServerParamsNoTlsv10 string

// ServerParamsNoTlsv11 defines model for ServerParams.NoTlsv11.
type ServerParamsNoTlsv11 string

// ServerParamsNoTlsv12 defines model for ServerParams.NoTlsv12.
type ServerParamsNoTlsv12 string

// ServerParamsNoTlsv13 defines model for ServerParams.NoTlsv13.
type ServerParamsNoTlsv13 string

// ServerParamsNoVerifyhost defines model for ServerParams.NoVerifyhost.
type ServerParamsNoVerifyhost string

// ServerParamsObserve defines model for ServerParams.Observe.
type ServerParamsObserve string

// ServerParamsOnError defines model for ServerParams.OnError.
type ServerParamsOnError string

// ServerParamsOnMarkedDown defines model for ServerParams.OnMarkedDown.
type ServerParamsOnMarkedDown string

// ServerParamsOnMarkedUp defines model for ServerParams.OnMarkedUp.
type ServerParamsOnMarkedUp string

// ServerParamsProxyV2Options defines model for ServerParams.ProxyV2Options.
type ServerParamsProxyV2Options string

// ServerParamsResolvePrefer defines model for ServerParams.ResolvePrefer.
type ServerParamsResolvePrefer string

// ServerParamsSendProxy defines model for ServerParams.SendProxy.
type ServerParamsSendProxy string

// ServerParamsSendProxyV2 defines model for ServerParams.SendProxyV2.
type ServerParamsSendProxyV2 string

// ServerParamsSendProxyV2Ssl defines model for ServerParams.SendProxyV2Ssl.
type ServerParamsSendProxyV2Ssl string

// ServerParamsSendProxyV2SslCn defines model for ServerParams.SendProxyV2SslCn.
type ServerParamsSendProxyV2SslCn string

// ServerParamsSsl defines model for ServerParams.Ssl.
type ServerParamsSsl string

// ServerParamsSslMaxVer defines model for ServerParams.SslMaxVer.
type ServerParamsSslMaxVer string

// ServerParamsSslMinVer defines model for ServerParams.SslMinVer.
type ServerParamsSslMinVer string

// ServerParamsSslReuse defines model for ServerParams.SslReuse.
type ServerParamsSslReuse string

// ServerParamsStick defines model for ServerParams.Stick.
type ServerParamsStick string

// ServerParamsTfo defines model for ServerParams.Tfo.
type ServerParamsTfo string

// ServerParamsTlsTickets defines model for ServerParams.TlsTickets.
type ServerParamsTlsTickets string

// ServerParamsVerify defines model for ServerParams.Verify.
type ServerParamsVerify string

// ServerParamsWs defines model for ServerParams.Ws.
type ServerParamsWs string

// ServerSwitchingRule HAProxy server switching rule configuration (corresponds to use-server directive)
type ServerSwitchingRule struct {
	Cond         *ServerSwitchingRuleCond `json:"cond,omitempty"`
	CondTest     *string                  `json:"cond_test,omitempty"`
	TargetServer string                   `json:"target_server"`
}

// ServerSwitchingRuleCond defines model for ServerSwitchingRule.Cond.
type ServerSwitchingRuleCond string

// ServerSwitchingRules HAProxy backend server switching rules array (corresponds to use-server directives)
type ServerSwitchingRules = []ServerSwitchingRule

// ServerTemplate defines model for server_template.
type ServerTemplate struct {
	AgentAddr          *string                         `json:"agent-addr,omitempty"`
	AgentCheck         *ServerTemplateAgentCheck       `json:"agent-check,omitempty"`
	AgentInter         *int                            `json:"agent-inter"`
	AgentPort          *int                            `json:"agent-port"`
	AgentSend          *string                         `json:"agent-send,omitempty"`
	Allow0rtt          *bool                           `json:"allow_0rtt,omitempty"`
	Alpn               *string                         `json:"alpn,omitempty"`
	Backup             *ServerTemplateBackup           `json:"backup,omitempty"`
	Check              *ServerTemplateCheck            `json:"check,omitempty"`
	CheckSendProxy     *ServerTemplateCheckSendProxy   `json:"check-send-proxy,omitempty"`
	CheckSni           *string                         `json:"check-sni,omitempty"`
	CheckSsl           *ServerTemplateCheckSsl         `json:"check-ssl,omitempty"`
	CheckAlpn          *string                         `json:"check_alpn,omitempty"`
	CheckProto         *string                         `json:"check_proto,omitempty"`
	CheckViaSocks4     *ServerTemplateCheckViaSocks4   `json:"check_via_socks4,omitempty"`
	Ciphers            *string                         `json:"ciphers,omitempty"`
	Ciphersuites       *string                         `json:"ciphersuites,omitempty"`
	ClientSigalgs      *string                         `json:"client_sigalgs,omitempty"`
	Cookie             *string                         `json:"cookie,omitempty"`
	CrlFile            *string                         `json:"crl_file,omitempty"`
	Curves             *string                         `json:"curves,omitempty"`
	Downinter          *int                            `json:"downinter"`
	ErrorLimit         *int                            `json:"error_limit,omitempty"`
	Fall               *int                            `json:"fall"`
	Fastinter          *int                            `json:"fastinter"`
	ForceSslv3         *ServerTemplateForceSslv3       `json:"force_sslv3,omitempty"`
	ForceTlsv10        *ServerTemplateForceTlsv10      `json:"force_tlsv10,omitempty"`
	ForceTlsv11        *ServerTemplateForceTlsv11      `json:"force_tlsv11,omitempty"`
	ForceTlsv12        *ServerTemplateForceTlsv12      `json:"force_tlsv12,omitempty"`
	ForceTlsv13        *ServerTemplateForceTlsv13      `json:"force_tlsv13,omitempty"`
	Fqdn               string                          `json:"fqdn"`
	Guid               *string                         `json:"guid,omitempty"`
	HashKey            *string                         `json:"hash_key,omitempty"`
	HealthCheckAddress *string                         `json:"health_check_address,omitempty"`
	HealthCheckPort    *int                            `json:"health_check_port"`
	Id                 *int                            `json:"id"`
	InitAddr           *string                         `json:"init-addr"`
	Inter              *int                            `json:"inter"`
	LogBufsize         *int                            `json:"log-bufsize"`
	LogProto           *ServerTemplateLogProto         `json:"log_proto,omitempty"`
	Maintenance        *ServerTemplateMaintenance      `json:"maintenance,omitempty"`
	MaxReuse           *int                            `json:"max_reuse"`
	Maxconn            *int                            `json:"maxconn"`
	Maxqueue           *int                            `json:"maxqueue"`
	Minconn            *int                            `json:"minconn"`
	Namespace          *string                         `json:"namespace,omitempty"`
	NoSslv3            *ServerTemplateNoSslv3          `json:"no_sslv3,omitempty"`
	NoTlsv10           *ServerTemplateNoTlsv10         `json:"no_tlsv10,omitempty"`
	NoTlsv11           *ServerTemplateNoTlsv11         `json:"no_tlsv11,omitempty"`
	NoTlsv12           *ServerTemplateNoTlsv12         `json:"no_tlsv12,omitempty"`
	NoTlsv13           *ServerTemplateNoTlsv13         `json:"no_tlsv13,omitempty"`
	NoVerifyhost       *ServerTemplateNoVerifyhost     `json:"no_verifyhost,omitempty"`
	Npn                *string                         `json:"npn,omitempty"`
	NumOrRange         string                          `json:"num_or_range"`
	Observe            *ServerTemplateObserve          `json:"observe,omitempty"`
	OnError            *ServerTemplateOnError          `json:"on-error,omitempty"`
	OnMarkedDown       *ServerTemplateOnMarkedDown     `json:"on-marked-down,omitempty"`
	OnMarkedUp         *ServerTemplateOnMarkedUp       `json:"on-marked-up,omitempty"`
	PoolConnName       *string                         `json:"pool_conn_name,omitempty"`
	PoolLowConn        *int                            `json:"pool_low_conn"`
	PoolMaxConn        *int                            `json:"pool_max_conn"`
	PoolPurgeDelay     *int                            `json:"pool_purge_delay"`
	Port               *int                            `json:"port"`
	Prefix             string                          `json:"prefix"`
	Proto              *string                         `json:"proto,omitempty"`
	ProxyV2Options     *[]ServerTemplateProxyV2Options `json:"proxy-v2-options,omitempty"`
	Redir              *string                         `json:"redir,omitempty"`
	ResolveNet         *string                         `json:"resolve-net,omitempty"`
	ResolvePrefer      *ServerTemplateResolvePrefer    `json:"resolve-prefer,omitempty"`
	ResolveOpts        *string                         `json:"resolve_opts,omitempty"`
	Resolvers          *string                         `json:"resolvers,omitempty"`
	Rise               *int                            `json:"rise"`
	SendProxy          *ServerTemplateSendProxy        `json:"send-proxy,omitempty"`
	SendProxyV2        *ServerTemplateSendProxyV2      `json:"send-proxy-v2,omitempty"`
	SendProxyV2Ssl     *ServerTemplateSendProxyV2Ssl   `json:"send_proxy_v2_ssl,omitempty"`
	SendProxyV2SslCn   *ServerTemplateSendProxyV2SslCn `json:"send_proxy_v2_ssl_cn,omitempty"`
	SetProxyV2TlvFmt   *struct {
		Id    string `json:"id"`
		Value string `json:"value"`
	} `json:"set-proxy-v2-tlv-fmt,omitempty"`
	Shard          *int                      `json:"shard,omitempty"`
	Sigalgs        *string                   `json:"sigalgs,omitempty"`
	Slowstart      *int                      `json:"slowstart"`
	Sni            *string                   `json:"sni,omitempty"`
	Socks4         *string                   `json:"socks4,omitempty"`
	Source         *string                   `json:"source,omitempty"`
	Ssl            *ServerTemplateSsl        `json:"ssl,omitempty"`
	SslCafile      *string                   `json:"ssl_cafile,omitempty"`
	SslCertificate *string                   `json:"ssl_certificate,omitempty"`
	SslMaxVer      *ServerTemplateSslMaxVer  `json:"ssl_max_ver,omitempty"`
	SslMinVer      *ServerTemplateSslMinVer  `json:"ssl_min_ver,omitempty"`
	SslReuse       *ServerTemplateSslReuse   `json:"ssl_reuse,omitempty"`
	Stick          *ServerTemplateStick      `json:"stick,omitempty"`
	TcpUt          *int                      `json:"tcp_ut"`
	Tfo            *ServerTemplateTfo        `json:"tfo,omitempty"`
	TlsTickets     *ServerTemplateTlsTickets `json:"tls_tickets,omitempty"`
	Track          *string                   `json:"track,omitempty"`
	Verify         *ServerTemplateVerify     `json:"verify,omitempty"`
	Verifyhost     *string                   `json:"verifyhost,omitempty"`
	Weight         *int                      `json:"weight"`
	Ws             *ServerTemplateWs         `json:"ws,omitempty"`
}

// ServerTemplateAgentCheck defines model for ServerTemplate.AgentCheck.
type ServerTemplateAgentCheck string

// ServerTemplateBackup defines model for ServerTemplate.Backup.
type ServerTemplateBackup string

// ServerTemplateCheck defines model for ServerTemplate.Check.
type ServerTemplateCheck string

// ServerTemplateCheckSendProxy defines model for ServerTemplate.CheckSendProxy.
type ServerTemplateCheckSendProxy string

// ServerTemplateCheckSsl defines model for ServerTemplate.CheckSsl.
type ServerTemplateCheckSsl string

// ServerTemplateCheckViaSocks4 defines model for ServerTemplate.CheckViaSocks4.
type ServerTemplateCheckViaSocks4 string

// ServerTemplateForceSslv3 defines model for ServerTemplate.ForceSslv3.
type ServerTemplateForceSslv3 string

// ServerTemplateForceTlsv10 defines model for ServerTemplate.ForceTlsv10.
type ServerTemplateForceTlsv10 string

// ServerTemplateForceTlsv11 defines model for ServerTemplate.ForceTlsv11.
type ServerTemplateForceTlsv11 string

// ServerTemplateForceTlsv12 defines model for ServerTemplate.ForceTlsv12.
type ServerTemplateForceTlsv12 string

// ServerTemplateForceTlsv13 defines model for ServerTemplate.ForceTlsv13.
type ServerTemplateForceTlsv13 string

// ServerTemplateLogProto defines model for ServerTemplate.LogProto.
type ServerTemplateLogProto string

// ServerTemplateMaintenance defines model for ServerTemplate.Maintenance.
type ServerTemplateMaintenance string

// ServerTemplateNoSslv3 defines model for ServerTemplate.NoSslv3.
type ServerTemplateNoSslv3 string

// ServerTemplateNoTlsv10 defines model for ServerTemplate.NoTlsv10.
type ServerTemplateNoTlsv10 string

// ServerTemplateNoTlsv11 defines model for ServerTemplate.NoTlsv11.
type ServerTemplateNoTlsv11 string

// ServerTemplateNoTlsv12 defines model for ServerTemplate.NoTlsv12.
type ServerTemplateNoTlsv12 string

// ServerTemplateNoTlsv13 defines model for ServerTemplate.NoTlsv13.
type ServerTemplateNoTlsv13 string

// ServerTemplateNoVerifyhost defines model for ServerTemplate.NoVerifyhost.
type ServerTemplateNoVerifyhost string

// ServerTemplateObserve defines model for ServerTemplate.Observe.
type ServerTemplateObserve string

// ServerTemplateOnError defines model for ServerTemplate.OnError.
type ServerTemplateOnError string

// ServerTemplateOnMarkedDown defines model for ServerTemplate.OnMarkedDown.
type ServerTemplateOnMarkedDown string

// ServerTemplateOnMarkedUp defines model for ServerTemplate.OnMarkedUp.
type ServerTemplateOnMarkedUp string

// ServerTemplateProxyV2Options defines model for ServerTemplate.ProxyV2Options.
type ServerTemplateProxyV2Options string

// ServerTemplateResolvePrefer defines model for ServerTemplate.ResolvePrefer.
type ServerTemplateResolvePrefer string

// ServerTemplateSendProxy defines model for ServerTemplate.SendProxy.
type ServerTemplateSendProxy string

// ServerTemplateSendProxyV2 defines model for ServerTemplate.SendProxyV2.
type ServerTemplateSendProxyV2 string

// ServerTemplateSendProxyV2Ssl defines model for ServerTemplate.SendProxyV2Ssl.
type ServerTemplateSendProxyV2Ssl string

// ServerTemplateSendProxyV2SslCn defines model for ServerTemplate.SendProxyV2SslCn.
type ServerTemplateSendProxyV2SslCn string

// ServerTemplateSsl defines model for ServerTemplate.Ssl.
type ServerTemplateSsl string

// ServerTemplateSslMaxVer defines model for ServerTemplate.SslMaxVer.
type ServerTemplateSslMaxVer string

// ServerTemplateSslMinVer defines model for ServerTemplate.SslMinVer.
type ServerTemplateSslMinVer string

// ServerTemplateSslReuse defines model for ServerTemplate.SslReuse.
type ServerTemplateSslReuse string

// ServerTemplateStick defines model for ServerTemplate.Stick.
type ServerTemplateStick string

// ServerTemplateTfo defines model for ServerTemplate.Tfo.
type ServerTemplateTfo string

// ServerTemplateTlsTickets defines model for ServerTemplate.TlsTickets.
type ServerTemplateTlsTickets string

// ServerTemplateVerify defines model for ServerTemplate.Verify.
type ServerTemplateVerify string

// ServerTemplateWs defines model for ServerTemplate.Ws.
type ServerTemplateWs string

// ServerTemplates HAProxy backend server templates array
type ServerTemplates = []ServerTemplate

// Servers HAProxy backend servers array
type Servers = []Server

// Site Site configuration. Sites are considered as one service and all farms connected to that service.
// Farms are connected to service using use-backend and default_backend directives. Sites let you
// configure simple HAProxy configurations, for more advanced options use /haproxy/configuration
// endpoints.
type Site struct {
	Farms *[]struct {
		Balance    *Balance       `json:"balance,omitempty"`
		Cond       *SiteFarmsCond `json:"cond,omitempty"`
		CondTest   *string        `json:"cond_test,omitempty"`
		Forwardfor *Forwardfor    `json:"forwardfor,omitempty"`
		Mode       *SiteFarmsMode `json:"mode,omitempty"`
		Name       string         `json:"name"`
		Servers    *[]Server      `json:"servers,omitempty"`
		UseAs      SiteFarmsUseAs `json:"use_as"`
	} `json:"farms,omitempty"`
	Name    string `json:"name"`
	Service *struct {
		HttpConnectionMode *SiteServiceHttpConnectionMode `json:"http_connection_mode,omitempty"`
		Listeners          *[]Bind                        `json:"listeners,omitempty"`
		Maxconn            *int                           `json:"maxconn"`
		Mode               *SiteServiceMode               `json:"mode,omitempty"`
	} `json:"service,omitempty"`
}

// SiteFarmsCond defines model for Site.Farms.Cond.
type SiteFarmsCond string

// SiteFarmsMode defines model for Site.Farms.Mode.
type SiteFarmsMode string

// SiteFarmsUseAs defines model for Site.Farms.UseAs.
type SiteFarmsUseAs string

// SiteServiceHttpConnectionMode defines model for Site.Service.HttpConnectionMode.
type SiteServiceHttpConnectionMode string

// SiteServiceMode defines model for Site.Service.Mode.
type SiteServiceMode string

// Sites Sites array. Sites are considered as one service and all farms connected to that service.
// Farms are connected to service using use-backend and default_backend directives. Sites let you
// configure simple HAProxy configurations, for more advanced options use /haproxy/configuration
// endpoints.
type Sites = []Site

// SmtpchkParams defines model for smtpchk_params.
type SmtpchkParams struct {
	Domain *string `json:"domain,omitempty"`
	Hello  *string `json:"hello,omitempty"`
}

// Source defines model for source.
type Source struct {
	Address       string        `json:"address"`
	AddressSecond *string       `json:"address_second,omitempty"`
	Hdr           *string       `json:"hdr,omitempty"`
	Interface     *string       `json:"interface,omitempty"`
	Occ           *string       `json:"occ,omitempty"`
	Port          *int          `json:"port,omitempty"`
	PortSecond    *int          `json:"port_second,omitempty"`
	Usesrc        *SourceUsesrc `json:"usesrc,omitempty"`
}

// SourceUsesrc defines model for Source.Usesrc.
type SourceUsesrc string

// SpoeAgent SPOE agent configuration
type SpoeAgent struct {
	Async           *SpoeAgentAsync           `json:"async,omitempty"`
	ContinueOnError *SpoeAgentContinueOnError `json:"continue-on-error,omitempty"`
	DontlogNormal   *SpoeAgentDontlogNormal   `json:"dontlog-normal,omitempty"`
	EngineName      *string                   `json:"engine-name,omitempty"`
	ForceSetVar     *SpoeAgentForceSetVar     `json:"force-set-var,omitempty"`
	Groups          *string                   `json:"groups,omitempty"`
	HelloTimeout    *int                      `json:"hello_timeout,omitempty"`
	IdleTimeout     *int                      `json:"idle_timeout,omitempty"`

	// Log HAProxy log target array (corresponds to log directives)
	Log                  *LogTargets               `json:"log,omitempty"`
	MaxFrameSize         *int                      `json:"max-frame-size,omitempty"`
	MaxWaitingFrames     *int                      `json:"max-waiting-frames,omitempty"`
	Maxconnrate          *int                      `json:"maxconnrate,omitempty"`
	Maxerrrate           *int                      `json:"maxerrrate,omitempty"`
	Messages             *string                   `json:"messages,omitempty"`
	Name                 string                    `json:"name"`
	OptionSetOnError     *string                   `json:"option_set-on-error,omitempty"`
	OptionSetProcessTime *string                   `json:"option_set-process-time,omitempty"`
	OptionSetTotalTime   *string                   `json:"option_set-total-time,omitempty"`
	OptionVarPrefix      *string                   `json:"option_var-prefix,omitempty"`
	Pipelining           *SpoeAgentPipelining      `json:"pipelining,omitempty"`
	ProcessingTimeout    *int                      `json:"processing_timeout,omitempty"`
	RegisterVarNames     *string                   `json:"register-var-names,omitempty"`
	SendFragPayload      *SpoeAgentSendFragPayload `json:"send-frag-payload,omitempty"`
	UseBackend           *string                   `json:"use-backend,omitempty"`
}

// SpoeAgentAsync defines model for SpoeAgent.Async.
type SpoeAgentAsync string

// SpoeAgentContinueOnError defines model for SpoeAgent.ContinueOnError.
type SpoeAgentContinueOnError string

// SpoeAgentDontlogNormal defines model for SpoeAgent.DontlogNormal.
type SpoeAgentDontlogNormal string

// SpoeAgentForceSetVar defines model for SpoeAgent.ForceSetVar.
type SpoeAgentForceSetVar string

// SpoeAgentPipelining defines model for SpoeAgent.Pipelining.
type SpoeAgentPipelining string

// SpoeAgentSendFragPayload defines model for SpoeAgent.SendFragPayload.
type SpoeAgentSendFragPayload string

// SpoeAgents SPOE Agents of one scope in SPOE file
type SpoeAgents = []SpoeAgent

// SpoeFiles SPOE files
type SpoeFiles = []string

// SpoeGroup SPOE group section configuration
type SpoeGroup struct {
	Messages *string `json:"messages,omitempty"`
	Name     string  `json:"name"`
}

// SpoeGroups SPOE Groups of one scope in SPOE file
type SpoeGroups = []SpoeGroup

// SpoeMessage SPOE message section configuration
type SpoeMessage struct {
	// Acl HAProxy ACL lines array (corresponds to acl directives)
	Acl   *Acls   `json:"acl,omitempty"`
	Args  *string `json:"args,omitempty"`
	Event *struct {
		Cond     *SpoeMessageEventCond `json:"cond,omitempty"`
		CondTest *string               `json:"cond_test,omitempty"`
		Name     SpoeMessageEventName  `json:"name"`
	} `json:"event,omitempty"`
	Name string `json:"name"`
}

// SpoeMessageEventCond defines model for SpoeMessage.Event.Cond.
type SpoeMessageEventCond string

// SpoeMessageEventName defines model for SpoeMessage.Event.Name.
type SpoeMessageEventName string

// SpoeMessages SPOE Messages of one scope in SPOE file
type SpoeMessages = []SpoeMessage

// SpoeScope SPOE scope name
type SpoeScope = string

// SpoeScopes All SPOE Scopes
type SpoeScopes = []SpoeScope

// SpoeTransaction SPOE configuration transaction
type SpoeTransaction struct {
	UnderscoreVersion *int                   `json:"_version,omitempty"`
	Id                *string                `json:"id,omitempty"`
	Status            *SpoeTransactionStatus `json:"status,omitempty"`
}

// SpoeTransactionStatus defines model for SpoeTransaction.Status.
type SpoeTransactionStatus string

// SpoeTransactions SPOE Configuration transactions array
type SpoeTransactions = []SpoeTransaction

// SslCertificate A file containing one or more SSL/TLS certificates and keys
type SslCertificate struct {
	Algorithm         *string    `json:"algorithm,omitempty"`
	AuthorityKeyId    *string    `json:"authority_key_id,omitempty"`
	Description       *string    `json:"description,omitempty"`
	Domains           *string    `json:"domains,omitempty"`
	File              *string    `json:"file,omitempty"`
	IpAddresses       *string    `json:"ip_addresses,omitempty"`
	Issuers           *string    `json:"issuers,omitempty"`
	NotAfter          *time.Time `json:"not_after"`
	NotBefore         *time.Time `json:"not_before"`
	Serial            *string    `json:"serial,omitempty"`
	Sha1FingerPrint   *string    `json:"sha1_finger_print,omitempty"`
	Sha256FingerPrint *string    `json:"sha256_finger_print,omitempty"`

	// Size File size in bytes.
	Size                    *int    `json:"size"`
	StorageName             *string `json:"storage_name,omitempty"`
	Subject                 *string `json:"subject,omitempty"`
	SubjectAlternativeNames *string `json:"subject_alternative_names,omitempty"`
	SubjectKeyId            *string `json:"subject_key_id,omitempty"`
}

// SslCertificates Array of ssl certificate files
type SslCertificates = []SslCertificate

// SslCrlOptions lb-sslcrl filter module for HAProxy configuration
type SslCrlOptions struct {
	// AddCrls This option includes adding new CRLs to ebtree when loading through CLI without deleting the previous ones.
	AddCrls *bool `json:"add_crls,omitempty"`

	// Debug Sets the module's debug level. The default debug level is 15. The same debug level is applied to all used SSLCRL filters simultaneously. The allowed value ranges from 0 to 255, which gives 8 different levels of debug output (each bit represents one level).
	Debug *int `json:"debug"`
}

// SslOptions defines model for ssl_options.
type SslOptions struct {
	CaBase                     *string `json:"ca_base,omitempty"`
	CrtBase                    *string `json:"crt_base,omitempty"`
	DefaultBindCiphers         *string `json:"default_bind_ciphers,omitempty"`
	DefaultBindCiphersuites    *string `json:"default_bind_ciphersuites,omitempty"`
	DefaultBindClientSigalgs   *string `json:"default_bind_client_sigalgs,omitempty"`
	DefaultBindCurves          *string `json:"default_bind_curves,omitempty"`
	DefaultBindOptions         *string `json:"default_bind_options,omitempty"`
	DefaultBindSigalgs         *string `json:"default_bind_sigalgs,omitempty"`
	DefaultServerCiphers       *string `json:"default_server_ciphers,omitempty"`
	DefaultServerCiphersuites  *string `json:"default_server_ciphersuites,omitempty"`
	DefaultServerClientSigalgs *string `json:"default_server_client_sigalgs,omitempty"`
	DefaultServerCurves        *string `json:"default_server_curves,omitempty"`
	DefaultServerOptions       *string `json:"default_server_options,omitempty"`
	DefaultServerSigalgs       *string `json:"default_server_sigalgs,omitempty"`
	DhParamFile                *string `json:"dh_param_file,omitempty"`
	SslEngines                 *[]struct {
		Algorithms *string `json:"algorithms"`
		Name       string  `json:"name"`
	} `json:"engines,omitempty"`
	IssuersChainPath *string                 `json:"issuers_chain_path,omitempty"`
	LoadExtraFiles   *string                 `json:"load_extra_files,omitempty"`
	Maxsslconn       *int                    `json:"maxsslconn,omitempty"`
	Maxsslrate       *int                    `json:"maxsslrate,omitempty"`
	ModeAsync        *SslOptionsModeAsync    `json:"mode_async,omitempty"`
	Propquery        *string                 `json:"propquery,omitempty"`
	Provider         *string                 `json:"provider,omitempty"`
	ProviderPath     *string                 `json:"provider_path,omitempty"`
	SecurityLevel    *int                    `json:"security_level"`
	ServerVerify     *SslOptionsServerVerify `json:"server_verify,omitempty"`
	SkipSelfIssuedCa *bool                   `json:"skip_self_issued_ca,omitempty"`
}

// SslOptionsModeAsync defines model for SslOptions.ModeAsync.
type SslOptionsModeAsync string

// SslOptionsServerVerify defines model for SslOptions.ServerVerify.
type SslOptionsServerVerify string

// StatsAuth defines model for stats_auth.
type StatsAuth struct {
	Passwd string `json:"passwd"`
	User   string `json:"user"`
}

// StatsHttpRequest defines model for stats_http_request.
type StatsHttpRequest struct {
	Cond     *string              `json:"cond,omitempty"`
	CondTest *string              `json:"cond_test,omitempty"`
	Realm    *string              `json:"realm,omitempty"`
	Type     StatsHttpRequestType `json:"type"`
}

// StatsHttpRequestType defines model for StatsHttpRequest.Type.
type StatsHttpRequestType string

// StatsOptions defines model for stats_options.
type StatsOptions struct {
	StatsAdmin         *bool                       `json:"stats_admin,omitempty"`
	StatsAdminCond     *StatsOptionsStatsAdminCond `json:"stats_admin_cond,omitempty"`
	StatsAdminCondTest *string                     `json:"stats_admin_cond_test,omitempty"`
	StatsAuths         *[]StatsAuth                `json:"stats_auths,omitempty"`
	StatsEnable        *bool                       `json:"stats_enable,omitempty"`
	StatsHideVersion   *bool                       `json:"stats_hide_version,omitempty"`
	StatsHttpRequests  *[]StatsHttpRequest         `json:"stats_http_requests,omitempty"`
	StatsMaxconn       *int                        `json:"stats_maxconn,omitempty"`
	StatsRealm         *bool                       `json:"stats_realm,omitempty"`
	StatsRealmRealm    *string                     `json:"stats_realm_realm"`
	StatsRefreshDelay  *int                        `json:"stats_refresh_delay"`
	StatsShowDesc      *string                     `json:"stats_show_desc"`
	StatsShowLegends   *bool                       `json:"stats_show_legends,omitempty"`
	StatsShowModules   *bool                       `json:"stats_show_modules,omitempty"`
	StatsShowNodeName  *string                     `json:"stats_show_node_name"`
	StatsUriPrefix     *string                     `json:"stats_uri_prefix,omitempty"`
}

// StatsOptionsStatsAdminCond defines model for StatsOptions.StatsAdminCond.
type StatsOptionsStatsAdminCond string

// StickRule Define a pattern used to create an entry in a stickiness table or matching condition or associate a user to a server.
type StickRule struct {
	Cond     *StickRuleCond `json:"cond,omitempty"`
	CondTest *string        `json:"cond_test,omitempty"`
	Pattern  string         `json:"pattern"`
	Table    *string        `json:"table,omitempty"`
	Type     StickRuleType  `json:"type"`
}

// StickRuleCond defines model for StickRule.Cond.
type StickRuleCond string

// StickRuleType defines model for StickRule.Type.
type StickRuleType string

// StickRules HAProxy backend stick rules array (corresponds to stick store-request, stick match, stick on, stick store-response)
type StickRules = []StickRule

// StickTable Stick Table Information
type StickTable struct {
	Fields *[]struct {
		Field  *StickTableFieldsField `json:"field,omitempty"`
		Idx    *int                   `json:"idx,omitempty"`
		Period *int                   `json:"period,omitempty"`
		Type   *StickTableFieldsType  `json:"type,omitempty"`
	} `json:"fields,omitempty"`
	Name *string         `json:"name,omitempty"`
	Size *int            `json:"size"`
	Type *StickTableType `json:"type,omitempty"`
	Used *int            `json:"used"`
}

// StickTableFieldsField defines model for StickTable.Fields.Field.
type StickTableFieldsField string

// StickTableFieldsType defines model for StickTable.Fields.Type.
type StickTableFieldsType string

// StickTableType defines model for StickTable.Type.
type StickTableType string

// StickTableEntries Entries of one runtime stick table
type StickTableEntries = []StickTableEntry

// StickTableEntry One entry in stick table
type StickTableEntry struct {
	BytesInCnt   *int `json:"bytes_in_cnt"`
	BytesInRate  *int `json:"bytes_in_rate"`
	BytesOutCnt  *int `json:"bytes_out_cnt"`
	BytesOutRate *int `json:"bytes_out_rate"`
	ConnCnt      *int `json:"conn_cnt"`
	ConnCur      *int `json:"conn_cur"`
	ConnRate     *int `json:"conn_rate"`
	Exp          *int `json:"exp"`
	GlitchCnt    *int `json:"glitch_cnt"`
	GlitchRate   *int `json:"glitch_rate"`
	Gpc          *struct {
		Idx   *int `json:"idx,omitempty"`
		Value *int `json:"value"`
	} `json:"gpc,omitempty"`
	Gpc0     *int `json:"gpc0"`
	Gpc0Rate *int `json:"gpc0_rate"`
	Gpc1     *int `json:"gpc1"`
	Gpc1Rate *int `json:"gpc1_rate"`
	GpcRate  *struct {
		Idx   *int `json:"idx,omitempty"`
		Value *int `json:"value"`
	} `json:"gpc_rate,omitempty"`
	Gpt *struct {
		Idx   *int `json:"idx,omitempty"`
		Value *int `json:"value"`
	} `json:"gpt,omitempty"`
	Gpt0         *int    `json:"gpt0"`
	HttpErrCnt   *int    `json:"http_err_cnt"`
	HttpErrRate  *int    `json:"http_err_rate"`
	HttpFailCnt  *int    `json:"http_fail_cnt"`
	HttpFailRate *int    `json:"http_fail_rate"`
	HttpReqCnt   *int    `json:"http_req_cnt"`
	HttpReqRate  *int    `json:"http_req_rate"`
	Id           *string `json:"id,omitempty"`
	Key          *string `json:"key,omitempty"`
	ServerId     *int    `json:"server_id"`
	SessCnt      *int    `json:"sess_cnt"`
	SessRate     *int    `json:"sess_rate"`
	Use          *bool   `json:"use,omitempty"`
}

// StickTables Array of runtime stick tables
type StickTables = []StickTable

// Structured Structured representation of configuration in one object
type Structured struct {
	Backends        *map[string]Backend        `json:"backends,omitempty"`
	BotmgmtProfiles *map[string]BotmgmtProfile `json:"botmgmt_profiles,omitempty"`
	Caches          *map[string]Cache          `json:"caches,omitempty"`
	Captchas        *map[string]Captcha        `json:"captchas,omitempty"`
	Defaults        *map[string]Defaults       `json:"defaults,omitempty"`

	// DynamicUpdateSection Dynamic update section with all it's children resources
	DynamicUpdateSection *struct {
		DynamicUpdateRuleList *DynamicUpdateRules `json:"dynamic_update_rule_list,omitempty"`
	} `json:"dynamic_update,omitempty"`
	FcgiApps  *map[string]FCGIApp  `json:"fcgi_apps,omitempty"`
	Frontends *map[string]Frontend `json:"frontends,omitempty"`

	// GlobalSection Global section with all it's children resources
	GlobalSection   *Global                       `json:"global,omitempty"`
	HttpErrors      *map[string]HttpErrorsSection `json:"http_errors,omitempty"`
	LogForwards     *map[string]LogForward        `json:"log_forwards,omitempty"`
	MailersSections *map[string]MailersSection    `json:"mailers_sections,omitempty"`
	Peers           *map[string]PeerSection       `json:"peers,omitempty"`
	Programs        *map[string]Program           `json:"programs,omitempty"`
	Resolvers       *map[string]Resolver          `json:"resolvers,omitempty"`
	Rings           *map[string]Ring              `json:"rings,omitempty"`
	UdpLbs          *map[string]UDPLb             `json:"udp_lbs,omitempty"`
	Userlists       *map[string]Userlist          `json:"userlists,omitempty"`
}

// Summary defines model for summary.
type Summary struct {
	// ApiInfo General API, OS and hardware information
	ApiInfo                      *Info `json:"api_info,omitempty"`
	SummaryConfigurationVersions *struct {
		Haproxy    *ClusterVersion `json:"haproxy,omitempty"`
		Keepalived *ClusterVersion `json:"keepalived,omitempty"`
	} `json:"configuration_versions,omitempty"`

	// Facts Facts stats map
	Facts *Facts `json:"facts,omitempty"`

	// HaproxyProcessInfo General HAProxy process information
	HaproxyProcessInfo *ProcessInfo `json:"haproxy_process_info,omitempty"`

	// HaproxyStats HAProxy stats array
	HaproxyStats *NativeStats `json:"haproxy_stats,omitempty"`
	Health       *Health      `json:"health,omitempty"`
}

// SyslogInput Collect Syslog messages with rfc5424 format through the network using UDP.
type SyslogInput struct {
	// Address Address on which to listen.
	Address string `json:"address"`

	// LogFormat Format of the HAProxy logs. It can be one of the predefined format:
	// * tcp
	// * http
	// * httpCLF
	// * https
	// Or it can be a regex. By example if HAProxy `log-format` is configured with `%b\ %f`
	// You can configure log_format with `(?P<b>\S+) (?P<f>\S+)`
	// The capture group names correspond to the HAProxy log-format's variables. Here is the list of the supported group
	// names:
	// | Capture group name | Description                                                                                                                                          | AccessLog field it is mapped to                               |
	// |--------------------|------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------|
	// | B                  | bytes_read (from server to client)                                                                                                                   | ResponseBytes                                                 |
	// | ST                 | status_code                                                                                                                                          | ResponseCode                                                  |
	// | Ta                 | Active time of the request (from TR to end)  %[txn.timer.total]                                                                                      | TimerTa                                                       |
	// | Tc                 | TC %[bc.timer.cserveronnect]                                                                                                                         | TimerTc                                                       |
	// | Tr                 | Tr (response time) %[res.timer.hdr]                                                                                                                  | TimerTr                                                       |
	// | TR                 | time to receive the full request from 1st byte. %[req.timer.hdr]                                                                                     | TimerTR                                                       |
	// | Tt                 | Tt c.timer.total]                                                                                                                                    | TimerTt                                                       |
	// | Tw                 | Tw %[req.timer.queue]                                                                                                                                | TimerTw                                                       |
	// | ac                 | actconn %[act_conn]                                                                                                                                  | ActiveConn                                                    |
	// | b                  | backend_name                                                                                                                                         | BackendName                                                   |
	// | bc                 | beconn      (backend concurrent connections)                                                                                                         | BackendConn                                                   |
	// | bq                 | backend_queue                                                                                                                                        | BackendQueue                                                  |
	// | ci                 | client_ip (accepted address) %[src]                                                                                                                  | ClientIP                                                      |
	// | cp                 | client_port  (accepted address)  %[src_port]                                                                                                         | ClientPort                                                    |
	// | ft                 | frontend_name_transport ('~' suffix for SSL)                                                                                                         | FrontendName                                                  |
	// | f                  | frontend_name                                                                                                                                        | FrontendName                                                  |
	// | fc                 | feconn (frontend concurrent connections)                                                                                                             | FrontendConn                                                  |
	// | fp                 | frontend_port (accepting address)   %[dst_port]                                                                                                      | FrontendPort                                                  |
	//  | ms                 | Accept date milliseconds %[accept_date(ms),ms_utime("%3N")                                                                                           | AcceptMs                                                      |
	// | rc                 | retries                                                                                                                                              | Retries                                                       |
	// | s                  | server_name                                                                                                                                          | ServerName                                                    |
	// | sc                 | srv_conn     (server concurrent connections)                                                                                                         | ServerConn                                                    |
	// | sq                 | srv_queue                                                                                                                                            | ServerQueue                                                   |
	// | ts                 | termination_state                                                                                                                                    | TerminationState                                              |
	// | tsc                | termination_state with cookie status                                                                                                                 | TerminationState                                              |
	// | pid                | PID                                                                                                                                                  | Process                                                       |
	// | HM                 | HTTP method (ex: POST)                                                                                                                               | RequestMethod                                                 |
	// | HP                 | HTTP request URI without query string                                                                                                                | RequestURI                                                    |
	// | HPO                | HTTP path only (without host nor query string)                                                                                                       | RequestURI                                                    |
	// | HU                 | HTTP request URI (ex: /foo?bar=baz)                                                                                                                  | RequestURI                                                    |
	// | HV                 | HTTP version (ex: HTTP/1.0)                                                                                                                          | RequestVersion                                                |
	// | r                  | http_request                                                                                                                                         | parsed and mapped toRequestVersion, RequestMethod, RequestURI |
	//  | U                  | bytes_uploaded  (from client to server)  %[bytes_in]                                                                                                 | BytesUploaded                                                 |
	// | fc_error           | status of the connection on the frontend's side. %[fc_err]                                                                                           | FcError                                                       |
	// | ssl_fc_err_hex     | last error of the first SSL error stack that was raised on the connection from the frontend's perspective. Encoded in Hexadecimal. %[ssl_fc_err,hex] | SslFcErrHex                                                   |
	// | ssl_c_err          | status of the client's certificate verification process. %[ssl_c_err]                                                                                | SslcErr                                                       |
	// | ssl_c_ca_err       | status of the client's certificate chain verification process. %[ssl_c_ca_err]                                                                       |  SslcCaErr                                                    |
	// | ssl_fc_is_resumed  | boolean indicating if the incoming TLS session was resumed with the stateful cache or a stateless ticket. %[ssl_fc_is_resumed]                       |  SslFcIsResumed                                               |
	// | ssl_fc_sni         | SNI (Server Name Indication) presented by the client to select the certificate to be used. %[ssl_fc_sni]                                             |  SslFcSni                                                     |
	// | ssl_version        | SSL version of the frontend %sslv                                                                                                                    |  SslVersion                                                   |
	// | ssl_cyphers        | ssl_ciphers (ex: AES-SHA) %sslc                                                                                                                      | SslCyphers                                                    |
	// If you use an unsupported group name, no error will be raised. If you want to collect information that is not
	// handled by a supported group. You should put it in the `structured data` using Haproxy `log-format-sd` keyword.
	// Structured Data are stored in `AccessLog.StructuredData` as an associative array of type string, string.
	LogFormat string `json:"log_format"`

	// MaxDatagramSize Maximum size of udp datagram in byte. Bigger message will truncated.
	MaxDatagramSize *int `json:"max_datagram_size,omitempty"`

	// NetworkNamespace Path of the network namespace in which the socket will be bound. Empty to bind to the default namespace.
	NetworkNamespace *string `json:"network_namespace,omitempty"`

	// Port Port on which to listen.
	Port int `json:"port"`

	// RawMessageBufferSize Size of the raw message buffer (in number of message). This buffer temporarily holds logs received from the connection before workers process them.
	RawMessageBufferSize *int `json:"raw_message_buffer_size,omitempty"`

	// WorkerCount Number of worker to process logs in parallel. It should not exceed number of CPU.
	WorkerCount *int `json:"worker_count,omitempty"`
}

// SyslogOutput Send collected logs to a Syslog server rfc5424 format.
type SyslogOutput struct {
	// Address Address on which to listen.
	Address string `json:"address"`

	// LogFormat Format of the syslog message part.
	//   * `tcp` will format message as `%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq`
	//   * `tcp-extended` will format message as `%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq %fp %U`
	//   * `tcp-extended-ssl` will format message as `%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq %fp %U %[fc_err]/%[ssl_fc_err,hex]/%[ssl_c_err]/%[ssl_c_ca_err]/%[ssl_fc_is_resumed] %[ssl_fc_sni]/%sslv/%sslc`
	//   * `http` will format message as `%ci:%cp [%tr] %ft %b/%s %TR/%Tw/%Tc/%Tr/%Ta %ST %B %tsc %ac/%fc/%bc/%sc/%rc %sq/%bq %{+Q}r`
	//   * `httpCLF` will format message as `%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \"\" \"\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq`
	//   * `https` will format message as `%ci:%cp [%tr] %ft %b/%s %TR/%Tw/%Tc/%Tr/%Ta %ST %B %tsc %ac/%fc/%bc/%sc/%rc %sq/%bq %{+Q}r %[fc_err]/%[ssl_fc_err,hex]/%[ssl_c_err]/%[ssl_c_ca_err]/%[ssl_fc_is_resumed] %[ssl_fc_sni]/%sslv/%sslc`
	LogFormat SyslogOutputLogFormat `json:"log_format"`

	// Port Port on which to listen.
	Port     int                  `json:"port"`
	Protocol SyslogOutputProtocol `json:"protocol"`
}

// SyslogOutputLogFormat Format of the syslog message part.
//   - `tcp` will format message as `%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq`
//   - `tcp-extended` will format message as `%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq %fp %U`
//   - `tcp-extended-ssl` will format message as `%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq %fp %U %[fc_err]/%[ssl_fc_err,hex]/%[ssl_c_err]/%[ssl_c_ca_err]/%[ssl_fc_is_resumed] %[ssl_fc_sni]/%sslv/%sslc`
//   - `http` will format message as `%ci:%cp [%tr] %ft %b/%s %TR/%Tw/%Tc/%Tr/%Ta %ST %B %tsc %ac/%fc/%bc/%sc/%rc %sq/%bq %{+Q}r`
//   - `httpCLF` will format message as `%{+Q}o %{-Q}ci - - [%trg] %r %ST %B \"\" \"\" %cp %ms %ft %b %s %TR %Tw %Tc %Tr %Ta %tsc %ac %fc %bc %sc %rc %sq %bq`
//   - `https` will format message as `%ci:%cp [%tr] %ft %b/%s %TR/%Tw/%Tc/%Tr/%Ta %ST %B %tsc %ac/%fc/%bc/%sc/%rc %sq/%bq %{+Q}r %[fc_err]/%[ssl_fc_err,hex]/%[ssl_c_err]/%[ssl_c_ca_err]/%[ssl_fc_is_resumed] %[ssl_fc_sni]/%sslv/%sslc`
type SyslogOutputLogFormat string

// SyslogOutputProtocol defines model for SyslogOutput.Protocol.
type SyslogOutputProtocol string

// Table defines model for table.
type Table struct {
	Expire  *string    `json:"expire"`
	Name    *string    `json:"name,omitempty"`
	NoPurge *bool      `json:"no_purge,omitempty"`
	Size    *string    `json:"size,omitempty"`
	Store   *string    `json:"store,omitempty"`
	Type    *TableType `json:"type,omitempty"`
	TypeLen *int       `json:"type_len"`
	WriteTo *string    `json:"write_to"`
}

// TableType defines model for Table.Type.
type TableType string

// Tables HAProxy table array
type Tables = []Table

// TcpCheck defines model for tcp_check.
type TcpCheck struct {
	Action          TcpCheckAction       `json:"action"`
	Addr            *string              `json:"addr,omitempty"`
	Alpn            *string              `json:"alpn,omitempty"`
	CheckComment    *string              `json:"check_comment,omitempty"`
	Data            *string              `json:"data,omitempty"`
	Default         *bool                `json:"default,omitempty"`
	ErrorStatus     *TcpCheckErrorStatus `json:"error_status,omitempty"`
	ExclamationMark *bool                `json:"exclamation_mark,omitempty"`
	Fmt             *string              `json:"fmt,omitempty"`
	HexFmt          *string              `json:"hex_fmt,omitempty"`
	HexString       *string              `json:"hex_string,omitempty"`
	Linger          *bool                `json:"linger,omitempty"`
	Match           *TcpCheckMatch       `json:"match,omitempty"`
	MinRecv         *int                 `json:"min_recv,omitempty"`
	OkStatus        *TcpCheckOkStatus    `json:"ok_status,omitempty"`
	OnError         *string              `json:"on_error,omitempty"`
	OnSuccess       *string              `json:"on_success,omitempty"`
	Pattern         *string              `json:"pattern,omitempty"`
	Port            *int                 `json:"port"`
	PortString      *string              `json:"port_string,omitempty"`
	Proto           *string              `json:"proto,omitempty"`
	SendProxy       *bool                `json:"send_proxy,omitempty"`
	Sni             *string              `json:"sni,omitempty"`
	Ssl             *bool                `json:"ssl,omitempty"`
	StatusCode      *string              `json:"status-code,omitempty"`
	ToutStatus      *TcpCheckToutStatus  `json:"tout_status,omitempty"`
	VarExpr         *string              `json:"var_expr,omitempty"`
	VarFmt          *string              `json:"var_fmt,omitempty"`
	VarName         *string              `json:"var_name,omitempty"`
	VarScope        *string              `json:"var_scope,omitempty"`
	ViaSocks4       *bool                `json:"via_socks4,omitempty"`
}

// TcpCheckAction defines model for TcpCheck.Action.
type TcpCheckAction string

// TcpCheckErrorStatus defines model for TcpCheck.ErrorStatus.
type TcpCheckErrorStatus string

// TcpCheckMatch defines model for TcpCheck.Match.
type TcpCheckMatch string

// TcpCheckOkStatus defines model for TcpCheck.OkStatus.
type TcpCheckOkStatus string

// TcpCheckToutStatus defines model for TcpCheck.ToutStatus.
type TcpCheckToutStatus string

// TcpChecks defines model for tcp_checks.
type TcpChecks = []TcpCheck

// TcpRequestRule HAProxy TCP Request Rule configuration (corresponds to tcp-request)
type TcpRequestRule struct {
	Action               *TcpRequestRuleAction          `json:"action,omitempty"`
	BandwidthLimitLimit  *string                        `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                        `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                        `json:"bandwidth_limit_period,omitempty"`
	CaptureLen           *int                           `json:"capture_len,omitempty"`
	CaptureSample        *string                        `json:"capture_sample,omitempty"`
	Cond                 *TcpRequestRuleCond            `json:"cond,omitempty"`
	CondTest             *string                        `json:"cond_test,omitempty"`
	Expr                 *string                        `json:"expr,omitempty"`
	GptValue             *string                        `json:"gpt_value,omitempty"`
	LogLevel             *TcpRequestRuleLogLevel        `json:"log_level,omitempty"`
	LuaAction            *string                        `json:"lua_action,omitempty"`
	LuaParams            *string                        `json:"lua_params,omitempty"`
	MarkValue            *string                        `json:"mark_value,omitempty"`
	NiceValue            *int                           `json:"nice_value,omitempty"`
	ResolveProtocol      *TcpRequestRuleResolveProtocol `json:"resolve_protocol,omitempty"`
	ResolveResolvers     *string                        `json:"resolve_resolvers,omitempty"`
	ResolveVar           *string                        `json:"resolve_var,omitempty"`
	RstTtl               *int                           `json:"rst_ttl,omitempty"`
	ScCnt                *int                           `json:"sc_cnt,omitempty"`
	ScIdx                *string                        `json:"sc_idx,omitempty"`
	ScIncId              *string                        `json:"sc_inc_id,omitempty"`
	ScInt                *int                           `json:"sc_int"`
	ScMessage            *string                        `json:"sc_message,omitempty"`
	ServerName           *string                        `json:"server_name,omitempty"`
	ServiceName          *string                        `json:"service_name,omitempty"`
	SpoeEngineName       *string                        `json:"spoe_engine_name,omitempty"`
	SpoeGroupName        *string                        `json:"spoe_group_name,omitempty"`
	SwitchModeProto      *string                        `json:"switch_mode_proto,omitempty"`
	Timeout              *int                           `json:"timeout"`
	TosValue             *string                        `json:"tos_value,omitempty"`
	TrackKey             *string                        `json:"track_key,omitempty"`
	TrackStickCounter    *int                           `json:"track_stick_counter"`
	TrackTable           *string                        `json:"track_table,omitempty"`
	Type                 TcpRequestRuleType             `json:"type"`
	VarFormat            *string                        `json:"var_format,omitempty"`
	VarName              *string                        `json:"var_name,omitempty"`
	VarScope             *string                        `json:"var_scope,omitempty"`
}

// TcpRequestRuleAction defines model for TcpRequestRule.Action.
type TcpRequestRuleAction string

// TcpRequestRuleCond defines model for TcpRequestRule.Cond.
type TcpRequestRuleCond string

// TcpRequestRuleLogLevel defines model for TcpRequestRule.LogLevel.
type TcpRequestRuleLogLevel string

// TcpRequestRuleResolveProtocol defines model for TcpRequestRule.ResolveProtocol.
type TcpRequestRuleResolveProtocol string

// TcpRequestRuleType defines model for TcpRequestRule.Type.
type TcpRequestRuleType string

// TcpRequestRules HAProxy TCP request rules array (corresponds to tcp-request directive)
type TcpRequestRules = []TcpRequestRule

// TcpResponseRule HAProxy TCP Response Rule configuration (corresponds to tcp-response)
type TcpResponseRule struct {
	Action               *TcpResponseRuleAction   `json:"action,omitempty"`
	BandwidthLimitLimit  *string                  `json:"bandwidth_limit_limit,omitempty"`
	BandwidthLimitName   *string                  `json:"bandwidth_limit_name,omitempty"`
	BandwidthLimitPeriod *string                  `json:"bandwidth_limit_period,omitempty"`
	Cond                 *TcpResponseRuleCond     `json:"cond,omitempty"`
	CondTest             *string                  `json:"cond_test,omitempty"`
	Expr                 *string                  `json:"expr,omitempty"`
	LogLevel             *TcpResponseRuleLogLevel `json:"log_level,omitempty"`
	LuaAction            *string                  `json:"lua_action,omitempty"`
	LuaParams            *string                  `json:"lua_params,omitempty"`
	MarkValue            *string                  `json:"mark_value,omitempty"`
	NiceValue            *int                     `json:"nice_value,omitempty"`
	RstTtl               *int                     `json:"rst_ttl,omitempty"`
	ScCnt                *int                     `json:"sc_cnt,omitempty"`
	ScExpr               *string                  `json:"sc_expr,omitempty"`
	ScId                 *int                     `json:"sc_id,omitempty"`
	ScIdx                *int                     `json:"sc_idx,omitempty"`
	ScInt                *int                     `json:"sc_int"`
	ScMessage            *string                  `json:"sc_message,omitempty"`
	SpoeEngine           *string                  `json:"spoe_engine,omitempty"`
	SpoeGroup            *string                  `json:"spoe_group,omitempty"`
	Timeout              *int                     `json:"timeout"`
	TosValue             *string                  `json:"tos_value,omitempty"`
	Type                 TcpResponseRuleType      `json:"type"`
	VarFormat            *string                  `json:"var_format,omitempty"`
	VarName              *string                  `json:"var_name,omitempty"`
	VarScope             *string                  `json:"var_scope,omitempty"`
}

// TcpResponseRuleAction defines model for TcpResponseRule.Action.
type TcpResponseRuleAction string

// TcpResponseRuleCond defines model for TcpResponseRule.Cond.
type TcpResponseRuleCond string

// TcpResponseRuleLogLevel defines model for TcpResponseRule.LogLevel.
type TcpResponseRuleLogLevel string

// TcpResponseRuleType defines model for TcpResponseRule.Type.
type TcpResponseRuleType string

// TcpResponseRules HAProxy TCP response rules array (corresponds to tcp-response directive)
type TcpResponseRules = []TcpResponseRule

// Transaction HAProxy configuration transaction
type Transaction struct {
	UnderscoreVersion *int               `json:"_version,omitempty"`
	Id                *string            `json:"id,omitempty"`
	Status            *TransactionStatus `json:"status,omitempty"`
}

// TransactionStatus defines model for Transaction.Status.
type TransactionStatus string

// Transactions Configuration transactions array
type Transactions = []Transaction

// TuneBufferOptions defines model for tune_buffer_options.
type TuneBufferOptions struct {
	BuffersLimit   *int `json:"buffers_limit"`
	BuffersReserve *int `json:"buffers_reserve,omitempty"`
	Bufsize        *int `json:"bufsize,omitempty"`
	Pipesize       *int `json:"pipesize,omitempty"`
	RcvbufBackend  *int `json:"rcvbuf_backend"`
	RcvbufClient   *int `json:"rcvbuf_client"`
	RcvbufFrontend *int `json:"rcvbuf_frontend"`
	RcvbufServer   *int `json:"rcvbuf_server"`
	RecvEnough     *int `json:"recv_enough,omitempty"`
	SndbufBackend  *int `json:"sndbuf_backend"`
	SndbufClient   *int `json:"sndbuf_client"`
	SndbufFrontend *int `json:"sndbuf_frontend"`
	SndbufServer   *int `json:"sndbuf_server"`
}

// TuneLuaOptions defines model for tune_lua_options.
type TuneLuaOptions struct {
	BurstTimeout   *int                      `json:"burst_timeout"`
	ForcedYield    *int                      `json:"forced_yield,omitempty"`
	LogLoggers     *TuneLuaOptionsLogLoggers `json:"log_loggers,omitempty"`
	LogStderr      *TuneLuaOptionsLogStderr  `json:"log_stderr,omitempty"`
	Maxmem         *int                      `json:"maxmem"`
	ServiceTimeout *int                      `json:"service_timeout"`
	SessionTimeout *int                      `json:"session_timeout"`
	TaskTimeout    *int                      `json:"task_timeout"`
}

// TuneLuaOptionsLogLoggers defines model for TuneLuaOptions.LogLoggers.
type TuneLuaOptionsLogLoggers string

// TuneLuaOptionsLogStderr defines model for TuneLuaOptions.LogStderr.
type TuneLuaOptionsLogStderr string

// TuneOptions defines model for tune_options.
type TuneOptions struct {
	AppletZeroCopyForwarding  *TuneOptionsAppletZeroCopyForwarding `json:"applet_zero_copy_forwarding,omitempty"`
	CompMaxlevel              *int                                 `json:"comp_maxlevel,omitempty"`
	DisableZeroCopyForwarding *bool                                `json:"disable_zero_copy_forwarding,omitempty"`
	EventsMaxEventsAtOnce     *int                                 `json:"events_max_events_at_once,omitempty"`
	FailAlloc                 *bool                                `json:"fail_alloc,omitempty"`
	FdEdgeTriggered           *TuneOptionsFdEdgeTriggered          `json:"fd_edge_triggered,omitempty"`
	H1ZeroCopyFwdRecv         *TuneOptionsH1ZeroCopyFwdRecv        `json:"h1_zero_copy_fwd_recv,omitempty"`
	H1ZeroCopyFwdSend         *TuneOptionsH1ZeroCopyFwdSend        `json:"h1_zero_copy_fwd_send,omitempty"`
	H2BeGlitchesThreshold     *int                                 `json:"h2_be_glitches_threshold"`
	H2BeInitialWindowSize     *int                                 `json:"h2_be_initial_window_size,omitempty"`
	H2BeMaxConcurrentStreams  *int                                 `json:"h2_be_max_concurrent_streams,omitempty"`
	H2FeGlitchesThreshold     *int                                 `json:"h2_fe_glitches_threshold"`
	H2FeInitialWindowSize     *int                                 `json:"h2_fe_initial_window_size,omitempty"`
	H2FeMaxConcurrentStreams  *int                                 `json:"h2_fe_max_concurrent_streams,omitempty"`
	H2FeMaxTotalStreams       *int                                 `json:"h2_fe_max_total_streams"`
	H2HeaderTableSize         *int                                 `json:"h2_header_table_size,omitempty"`
	H2InitialWindowSize       *int                                 `json:"h2_initial_window_size"`
	H2MaxConcurrentStreams    *int                                 `json:"h2_max_concurrent_streams,omitempty"`
	H2MaxFrameSize            *int                                 `json:"h2_max_frame_size,omitempty"`
	H2ZeroCopyFwdSend         *TuneOptionsH2ZeroCopyFwdSend        `json:"h2_zero_copy_fwd_send,omitempty"`
	HttpCookielen             *int                                 `json:"http_cookielen,omitempty"`
	HttpLogurilen             *int                                 `json:"http_logurilen,omitempty"`
	HttpMaxhdr                *int                                 `json:"http_maxhdr,omitempty"`
	IdlePoolShared            *TuneOptionsIdlePoolShared           `json:"idle_pool_shared,omitempty"`
	Idletimer                 *int                                 `json:"idletimer"`
	ListenerDefaultShards     *TuneOptionsListenerDefaultShards    `json:"listener_default_shards,omitempty"`
	ListenerMultiQueue        *TuneOptionsListenerMultiQueue       `json:"listener_multi_queue,omitempty"`
	MaxChecksPerThread        *int                                 `json:"max_checks_per_thread"`
	Maxaccept                 *int                                 `json:"maxaccept,omitempty"`
	Maxpollevents             *int                                 `json:"maxpollevents,omitempty"`
	Maxrewrite                *int                                 `json:"maxrewrite,omitempty"`
	MemoryHotSize             *int                                 `json:"memory_hot_size"`
	PatternCacheSize          *int                                 `json:"pattern_cache_size"`
	PeersMaxUpdatesAtOnce     *int                                 `json:"peers_max_updates_at_once,omitempty"`
	PoolHighFdRatio           *int                                 `json:"pool_high_fd_ratio,omitempty"`
	PoolLowFdRatio            *int                                 `json:"pool_low_fd_ratio,omitempty"`
	PtZeroCopyForwarding      *TuneOptionsPtZeroCopyForwarding     `json:"pt_zero_copy_forwarding,omitempty"`
	RingQueues                *int                                 `json:"ring_queues"`
	RunqueueDepth             *int                                 `json:"runqueue_depth,omitempty"`
	SchedLowLatency           *TuneOptionsSchedLowLatency          `json:"sched_low_latency,omitempty"`
	StickCounters             *int                                 `json:"stick_counters"`
}

// TuneOptionsAppletZeroCopyForwarding defines model for TuneOptions.AppletZeroCopyForwarding.
type TuneOptionsAppletZeroCopyForwarding string

// TuneOptionsFdEdgeTriggered defines model for TuneOptions.FdEdgeTriggered.
type TuneOptionsFdEdgeTriggered string

// TuneOptionsH1ZeroCopyFwdRecv defines model for TuneOptions.H1ZeroCopyFwdRecv.
type TuneOptionsH1ZeroCopyFwdRecv string

// TuneOptionsH1ZeroCopyFwdSend defines model for TuneOptions.H1ZeroCopyFwdSend.
type TuneOptionsH1ZeroCopyFwdSend string

// TuneOptionsH2ZeroCopyFwdSend defines model for TuneOptions.H2ZeroCopyFwdSend.
type TuneOptionsH2ZeroCopyFwdSend string

// TuneOptionsIdlePoolShared defines model for TuneOptions.IdlePoolShared.
type TuneOptionsIdlePoolShared string

// TuneOptionsListenerDefaultShards defines model for TuneOptions.ListenerDefaultShards.
type TuneOptionsListenerDefaultShards string

// TuneOptionsListenerMultiQueue defines model for TuneOptions.ListenerMultiQueue.
type TuneOptionsListenerMultiQueue string

// TuneOptionsPtZeroCopyForwarding defines model for TuneOptions.PtZeroCopyForwarding.
type TuneOptionsPtZeroCopyForwarding string

// TuneOptionsSchedLowLatency defines model for TuneOptions.SchedLowLatency.
type TuneOptionsSchedLowLatency string

// TuneQuicOptions defines model for tune_quic_options.
type TuneQuicOptions struct {
	FrontendConnTxBuffersLimit *int                            `json:"frontend_conn_tx_buffers_limit"`
	FrontendMaxIdleTimeout     *int                            `json:"frontend_max_idle_timeout"`
	FrontendMaxStreamsBidi     *int                            `json:"frontend_max_streams_bidi"`
	MaxFrameLoss               *int                            `json:"max_frame_loss"`
	ReorderRatio               *int                            `json:"reorder_ratio"`
	RetryThreshold             *int                            `json:"retry_threshold"`
	SocketOwner                *TuneQuicOptionsSocketOwner     `json:"socket_owner,omitempty"`
	ZeroCopyFwdSend            *TuneQuicOptionsZeroCopyFwdSend `json:"zero_copy_fwd_send,omitempty"`
}

// TuneQuicOptionsSocketOwner defines model for TuneQuicOptions.SocketOwner.
type TuneQuicOptionsSocketOwner string

// TuneQuicOptionsZeroCopyFwdSend defines model for TuneQuicOptions.ZeroCopyFwdSend.
type TuneQuicOptionsZeroCopyFwdSend string

// TuneSslOptions defines model for tune_ssl_options.
type TuneSslOptions struct {
	Cachesize          *int                  `json:"cachesize"`
	CaptureBufferSize  *int                  `json:"capture_buffer_size"`
	CtxCacheSize       *int                  `json:"ctx_cache_size,omitempty"`
	DefaultDhParam     *int                  `json:"default_dh_param,omitempty"`
	ForcePrivateCache  *bool                 `json:"force_private_cache,omitempty"`
	Keylog             *TuneSslOptionsKeylog `json:"keylog,omitempty"`
	Lifetime           *int                  `json:"lifetime"`
	Maxrecord          *int                  `json:"maxrecord"`
	OcspUpdateMaxDelay *int                  `json:"ocsp_update_max_delay"`
	OcspUpdateMinDelay *int                  `json:"ocsp_update_min_delay"`
}

// TuneSslOptionsKeylog defines model for TuneSslOptions.Keylog.
type TuneSslOptionsKeylog string

// TuneVarsOptions defines model for tune_vars_options.
type TuneVarsOptions struct {
	GlobalMaxSize *int `json:"global_max_size"`
	ProcMaxSize   *int `json:"proc_max_size"`
	ReqresMaxSize *int `json:"reqres_max_size"`
	SessMaxSize   *int `json:"sess_max_size"`
	TxnMaxSize    *int `json:"txn_max_size"`
}

// TuneZlibOptions defines model for tune_zlib_options.
type TuneZlibOptions struct {
	Memlevel   *int `json:"memlevel,omitempty"`
	Windowsize *int `json:"windowsize,omitempty"`
}

// UDPLb defines model for udp_lb.
type UDPLb struct {
	// AcceptedPayloadSize Accepted payload size in bytes, defaults to 1472 bytes.
	AcceptedPayloadSize *int                  `json:"accepted_payload_size,omitempty"`
	AdvCheck            *UdpLbAdvCheck        `json:"adv_check,omitempty"`
	Balance             *Balance              `json:"balance,omitempty"`
	ClientTimeout       *int                  `json:"client_timeout"`
	DefaultServer       *DefaultServer        `json:"default_server,omitempty"`
	DgramBinds          *map[string]DgramBind `json:"dgram_binds,omitempty"`
	Maxconn             *int                  `json:"maxconn"`
	Name                string                `json:"name"`
	ProxyRequests       *int                  `json:"proxy_requests"`
	ProxyResponses      *int                  `json:"proxy_responses"`
	ServerTimeout       *int                  `json:"server_timeout"`
	Servers             *map[string]Server    `json:"servers,omitempty"`
	Source              *Source               `json:"source,omitempty"`
	TcpCheckRuleList    *TcpChecks            `json:"tcp_check_rule_list,omitempty"`
}

// UdpLbAdvCheck defines model for UdpLb.AdvCheck.
type UdpLbAdvCheck string

// UdpLbBase defines model for udp_lb_base.
type UdpLbBase struct {
	// AcceptedPayloadSize Accepted payload size in bytes, defaults to 1472 bytes.
	AcceptedPayloadSize *int               `json:"accepted_payload_size,omitempty"`
	AdvCheck            *UdpLbBaseAdvCheck `json:"adv_check,omitempty"`
	Balance             *Balance           `json:"balance,omitempty"`
	ClientTimeout       *int               `json:"client_timeout"`
	DefaultServer       *DefaultServer     `json:"default_server,omitempty"`
	Maxconn             *int               `json:"maxconn"`
	Name                string             `json:"name"`
	ProxyRequests       *int               `json:"proxy_requests"`
	ProxyResponses      *int               `json:"proxy_responses"`
	ServerTimeout       *int               `json:"server_timeout"`
	Source              *Source            `json:"source,omitempty"`
}

// UdpLbBaseAdvCheck defines model for UdpLbBase.AdvCheck.
type UdpLbBaseAdvCheck string

// UdpLbs defines model for udp_lbs.
type UdpLbs = []UDPLb

// User HAProxy userlist user
type User struct {
	Groups         *string `json:"groups,omitempty"`
	Password       string  `json:"password"`
	SecurePassword bool    `json:"secure_password"`
	Username       string  `json:"username"`
}

// Userlist defines model for userlist.
type Userlist struct {
	Groups *map[string]Group `json:"groups,omitempty"`
	Name   string            `json:"name"`
	Users  *map[string]User  `json:"users,omitempty"`
}

// UserlistBase HAProxy configuration of access control
type UserlistBase struct {
	Name string `json:"name"`
}

// Userlists HAProxy userlists array
type Userlists = []Userlist

// Users HAProxy userlist users array
type Users = []User

// VrrpAuthentication Defines the authentication between the cluster nodes.
// When using the deprecated type named "pass" based on the basic password,
// the length cannot exceed 8 characters since keepalived truncates it up to this limit.
// The IPSec authentication header is highly encouraged.
type VrrpAuthentication struct {
	Pass string                 `json:"pass"`
	Type VrrpAuthenticationType `json:"type"`
}

// VrrpAuthenticationType defines model for VrrpAuthentication.Type.
type VrrpAuthenticationType string

// VrrpGlobalDefs Allows administrators to specify notification details when changes to the load balancer occurs.
// Note that the Global Definitions are optional and are not required for Keepalived configuration.
type VrrpGlobalDefs struct {
	// EnableScriptSecurity Toggle to allow or deny running scripts configured to be run as root.
	EnableScriptSecurity *bool `json:"enable_script_security,omitempty"`

	// ScriptUser Specify the default username/groupname to run scripts under.
	// The group name can be specified with the syntax "username group" as per Keepalived documentation.
	ScriptUser *string `json:"script_user,omitempty"`
}

// VrrpInstance keepalived VRRP instance definition
type VrrpInstance struct {
	// Authentication Defines the authentication between the cluster nodes.
	// When using the deprecated type named "pass" based on the basic password,
	// the length cannot exceed 8 characters since keepalived truncates it up to this limit.
	// The IPSec authentication header is highly encouraged.
	Authentication *VrrpAuthentication `json:"authentication,omitempty"`

	// Interface Physical interface or virtual interface.
	Interface    string                  `json:"interface"`
	Name         *string                 `json:"name,omitempty"`
	NotifyBackup *KeepalivedNotifyScript `json:"notify_backup,omitempty"`
	NotifyFault  *KeepalivedNotifyScript `json:"notify_fault,omitempty"`
	NotifyMaster *KeepalivedNotifyScript `json:"notify_master,omitempty"`

	// Priority Specifies the order in which the assigned interface takes over in a failover; the higher the number, the higher the priority. This priority value must be within the range of 0 to 255.
	Priority int `json:"priority"`

	// State Designates the state of the instance (active or backup server).
	State          VrrpInstanceState     `json:"state"`
	TrackInterface *[]VrrpTrackInterface `json:"track_interface,omitempty"`

	// TrackScript Configure how keepalived would take care of moving VIP addresses between the cluster if service goes down.
	TrackScript *[]string `json:"track_script,omitempty"`

	// UnicastPeers Allows to define a list of peers will send the VRRP packets.
	UnicastPeers *[]string `json:"unicast_peers,omitempty"`

	// UnicastSourceIp Defines the source IP of the VRRP packets.
	UnicastSourceIp *string `json:"unicast_source_ip,omitempty"`

	// VirtualIpaddressExcluded List of IP addresses that keepalived may bring up and down on the server but those defined as excluded are not listed in the VRRP packet itself.
	VirtualIpaddressExcluded *[]VrrpVirtualIpaddress `json:"virtual_ipaddress_excluded,omitempty"`

	// VirtualIpaddresses Deprecated: virtual_ipaddress_excluded should be used.
	// Limited list up to 20 IP addresses that keepalived may bring up and down on the server but those defined as excluded are not listed in the VRRP packet itself.
	VirtualIpaddresses *[]VrrpVirtualIpaddress `json:"virtual_ipaddresses,omitempty"`

	// VirtualRouterId Numerical identifier for the Virtual Router instance, it must be the same on all LVS Router systems participating in this Virtual Router, and unique per VRRP cluster.
	VirtualRouterId int `json:"virtual_router_id"`
}

// VrrpInstanceState Designates the state of the instance (active or backup server).
type VrrpInstanceState string

// VrrpInstances Keepalived VRRP Instances array
type VrrpInstances = []VrrpInstance

// VrrpSyncGroup Identify the VRRP synchronization instances group
type VrrpSyncGroup struct {
	// Group List of VRRP instances.
	Group        []string                `json:"group"`
	Name         *string                 `json:"name,omitempty"`
	NotifyBackup *KeepalivedNotifyScript `json:"notify_backup,omitempty"`
	NotifyFault  *KeepalivedNotifyScript `json:"notify_fault,omitempty"`
	NotifyMaster *KeepalivedNotifyScript `json:"notify_master,omitempty"`
}

// VrrpSyncGroups Keepalived VRRP sync groups array
type VrrpSyncGroups = []VrrpSyncGroup

// VrrpTrackInterface Interface monitored by keepalived
type VrrpTrackInterface struct {
	Name   string `json:"name"`
	Weight *int   `json:"weight"`
}

// VrrpTrackScript keepalived VRRP tracking script
type VrrpTrackScript struct {
	// Fall How many times the script must return unsuccessfully (or time out) in order for the host to be considered unhealthy.
	Fall *int `json:"fall,omitempty"`

	// Interval How often the script should be run.
	Interval *int    `json:"interval,omitempty"`
	Name     *string `json:"name,omitempty"`

	// Rise How many times the script must return successfully in order for the host to be considered healthy.
	Rise *int `json:"rise,omitempty"`

	// Script Command that should be executed to perform the check.
	Script string `json:"script"`

	// Timeout How long to wait for the script to return.
	Timeout *int                   `json:"timeout,omitempty"`
	Weight  *VrrpTrackScriptWeight `json:"weight,omitempty"`
}

// VrrpTrackScriptWeight defines model for vrrp_track_script_weight.
type VrrpTrackScriptWeight struct {
	// Reverse It will cause the vrrp instance to be down when the interface is up, and vice versa.
	Reverse *bool `json:"reverse,omitempty"`

	// Value Default weight
	Value int64 `json:"value"`
}

// VrrpTrackScripts Keepalived VRRP Script array
type VrrpTrackScripts = []VrrpTrackScript

// VrrpVirtualIpaddress defines model for vrrp_virtual_ipaddress.
type VrrpVirtualIpaddress struct {
	// Address IPv4 or IPv6 address
	Address string `json:"address"`

	// Device Device where IP address is exposed
	Device *string `json:"device,omitempty"`
}

// WafBodyRule defines model for waf_body_rule.
type WafBodyRule struct {
	Cond       *WafBodyRuleCond `json:"cond,omitempty"`
	CondTest   *string          `json:"cond_test,omitempty"`
	DenyStatus *int             `json:"deny_status"`
	Type       WafBodyRuleType  `json:"type"`
	VarExpr    *string          `json:"var_expr,omitempty"`
	VarName    *string          `json:"var_name,omitempty"`
	VarScope   *string          `json:"var_scope,omitempty"`
}

// WafBodyRuleCond defines model for WafBodyRule.Cond.
type WafBodyRuleCond string

// WafBodyRuleType defines model for WafBodyRule.Type.
type WafBodyRuleType string

// WafBodyRules defines model for waf_body_rules.
type WafBodyRules = []WafBodyRule

// WafFile Waf ruleset file
type WafFile struct {
	File        *string `json:"file,omitempty"`
	StorageName *string `json:"storage_name,omitempty"`
}

// WafFiles defines model for waf_files.
type WafFiles = []WafFile

// WafOptions defines model for waf_options.
type WafOptions struct {
	// AnalyzerCache The size of the LRU cache used for SQLi/XSS analyzer lookups. Disabled by default.
	AnalyzerCache *int    `json:"analyzer_cache"`
	BodyLimit     *int    `json:"body_limit,omitempty"`
	JsonLevels    *int    `json:"json_levels,omitempty"`
	Load          *string `json:"load,omitempty"`

	// LogHostHeaderLen Sets the maximum length of the Host header to be captured for use in WAF logs.
	// Defaults to 1024.
	LogHostHeaderLen *int `json:"log_host_header_len"`
	WafUpdate        *struct {
		// Delay Sets the download period. Defaults to 5 minutes.
		Delay *int `json:"delay"`

		// DontlogNormal Deactivates logging of successful updates.
		DontlogNormal *bool `json:"dontlog_normal,omitempty"`

		// Id The rules file initially loaded by the "waf-load" global keyword,
		// or by the "rules-file" filter parameter.
		Id string `json:"id"`

		// Log Enables logging using the configured "log" targets.
		Log *bool `json:"log,omitempty"`

		// Modified Enables the use of the time from the "Last-Modified" response HTTP header,
		// i.e. checking whether or not to update the data by setting the "If-Modified-Since" request HTTP header.
		Modified *bool `json:"modified,omitempty"`

		// Retries The number of retries to establish a connection to the server. If unspecified, the global "retries" value is used.
		Retries      *int          `json:"retries"`
		ServerParams *ServerParams `json:"server_params,omitempty"`

		// GlobalWafUpdateSource Sets the source address for outgoing connections. This is normally not needed,
		// but might be useful in some very specific cases.
		GlobalWafUpdateSource *struct {
			Address string `json:"address"`
			Port    *int   `json:"port"`
		} `json:"source"`

		// Timeout Specifies the HTTP connect timeout for attempts to download a new file version. Default is 5 seconds.
		Timeout *int `json:"timeout"`

		// Url The location from where the file can be downloaded.
		Url string `json:"url"`

		// Xmodified It is the same as the 'modified' parameter, with the difference that the file modification time is set immediately after reading this information from the file status (i.e. immediately after starting HAProxy).
		// This means that the first data download may also be rejected if the file to be downloaded is not more recent than the data originally loaded from the local file system.
		Xmodified *bool `json:"xmodified,omitempty"`
	} `json:"update,omitempty"`
}

// WafRuleset Waf ruleset
type WafRuleset struct {
	Directory   *string `json:"directory,omitempty"`
	StorageName *string `json:"storage_name,omitempty"`
}

// WafRulesets defines model for waf_rulesets.
type WafRulesets = []WafRuleset

// WurflOptions defines model for wurfl_options.
type WurflOptions struct {
	CacheSize                *int    `json:"cache_size,omitempty"`
	DataFile                 *string `json:"data_file,omitempty"`
	InformationList          *string `json:"information_list,omitempty"`
	InformationListSeparator *string `json:"information_list_separator,omitempty"`
	PatchFile                *string `json:"patch_file,omitempty"`
}

// ForceReload defines model for force_reload.
type ForceReload = bool

// FullSection defines model for full_section.
type FullSection = bool

// ParentName defines model for parent_name.
type ParentName = string

// RulesetName defines model for ruleset_name.
type RulesetName = string

// SkipReload defines model for skip_reload.
type SkipReload = bool

// SubDir defines model for sub_dir.
type SubDir = string

// TransactionId defines model for transaction_id.
type TransactionId = string

// Version defines model for version.
type Version = int

// AlreadyExists API Error
type AlreadyExists = Error

// BadRequest API Error
type BadRequest = Error

// DefaultError API Error
type DefaultError = Error

// NotAcceptable API Error
type NotAcceptable = Error

// NotFound API Error
type NotFound = Error

// DeleteClusterParams defines parameters for DeleteCluster.
type DeleteClusterParams struct {
	// Configuration In case of moving to single mode do we keep or clean configuration
	Configuration *DeleteClusterParamsConfiguration `form:"configuration,omitempty" json:"configuration,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteClusterParamsConfiguration defines parameters for DeleteCluster.
type DeleteClusterParamsConfiguration string

// PostClusterParams defines parameters for PostCluster.
type PostClusterParams struct {
	// Configuration In case of moving to single mode do we keep or clean configuration
	Configuration *PostClusterParamsConfiguration `form:"configuration,omitempty" json:"configuration,omitempty"`

	// AdvertisedAddress Force the advertised address when joining a cluster
	AdvertisedAddress *string `form:"advertised_address,omitempty" json:"advertised_address,omitempty"`

	// AdvertisedPort Force the advertised port when joining a cluster
	AdvertisedPort *int `form:"advertised_port,omitempty" json:"advertised_port,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// PostClusterParamsConfiguration defines parameters for PostCluster.
type PostClusterParamsConfiguration string

// EditClusterParams defines parameters for EditCluster.
type EditClusterParams struct {
	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetFactsParams defines parameters for GetFacts.
type GetFactsParams struct {
	// Refresh Force refreshing of the facts
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// ReplaceGitSettingsParams defines parameters for ReplaceGitSettings.
type ReplaceGitSettingsParams struct {
	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetBackendsParams defines parameters for GetBackends.
type GetBackendsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateBackendParams defines parameters for CreateBackend.
type CreateBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteBackendParams defines parameters for DeleteBackend.
type DeleteBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendParams defines parameters for GetBackend.
type GetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceBackendParams defines parameters for ReplaceBackend.
type ReplaceBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclBackendParams defines parameters for GetAllAclBackend.
type GetAllAclBackendParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclBackendParams defines parameters for ReplaceAllAclBackend.
type ReplaceAllAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclBackendParams defines parameters for DeleteAclBackend.
type DeleteAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclBackendParams defines parameters for GetAclBackend.
type GetAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclBackendParams defines parameters for CreateAclBackend.
type CreateAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclBackendParams defines parameters for ReplaceAclBackend.
type ReplaceAclBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllFilterBackendParams defines parameters for GetAllFilterBackend.
type GetAllFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllFilterBackendParams defines parameters for ReplaceAllFilterBackend.
type ReplaceAllFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteFilterBackendParams defines parameters for DeleteFilterBackend.
type DeleteFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFilterBackendParams defines parameters for GetFilterBackend.
type GetFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateFilterBackendParams defines parameters for CreateFilterBackend.
type CreateFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceFilterBackendParams defines parameters for ReplaceFilterBackend.
type ReplaceFilterBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPAfterResponseRuleBackendParams defines parameters for GetAllHTTPAfterResponseRuleBackend.
type GetAllHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPAfterResponseRuleBackendParams defines parameters for ReplaceAllHTTPAfterResponseRuleBackend.
type ReplaceAllHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPAfterResponseRuleBackendParams defines parameters for DeleteHTTPAfterResponseRuleBackend.
type DeleteHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPAfterResponseRuleBackendParams defines parameters for GetHTTPAfterResponseRuleBackend.
type GetHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPAfterResponseRuleBackendParams defines parameters for CreateHTTPAfterResponseRuleBackend.
type CreateHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPAfterResponseRuleBackendParams defines parameters for ReplaceHTTPAfterResponseRuleBackend.
type ReplaceHTTPAfterResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPCheckBackendParams defines parameters for GetAllHTTPCheckBackend.
type GetAllHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPCheckBackendParams defines parameters for ReplaceAllHTTPCheckBackend.
type ReplaceAllHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPCheckBackendParams defines parameters for DeleteHTTPCheckBackend.
type DeleteHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPCheckBackendParams defines parameters for GetHTTPCheckBackend.
type GetHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPCheckBackendParams defines parameters for CreateHTTPCheckBackend.
type CreateHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPCheckBackendParams defines parameters for ReplaceHTTPCheckBackend.
type ReplaceHTTPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPErrorRuleBackendParams defines parameters for GetAllHTTPErrorRuleBackend.
type GetAllHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPErrorRuleBackendParams defines parameters for ReplaceAllHTTPErrorRuleBackend.
type ReplaceAllHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorRuleBackendParams defines parameters for DeleteHTTPErrorRuleBackend.
type DeleteHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorRuleBackendParams defines parameters for GetHTTPErrorRuleBackend.
type GetHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorRuleBackendParams defines parameters for CreateHTTPErrorRuleBackend.
type CreateHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPErrorRuleBackendParams defines parameters for ReplaceHTTPErrorRuleBackend.
type ReplaceHTTPErrorRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPRequestRuleBackendParams defines parameters for GetAllHTTPRequestRuleBackend.
type GetAllHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPRequestRuleBackendParams defines parameters for ReplaceAllHTTPRequestRuleBackend.
type ReplaceAllHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPRequestRuleBackendParams defines parameters for DeleteHTTPRequestRuleBackend.
type DeleteHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPRequestRuleBackendParams defines parameters for GetHTTPRequestRuleBackend.
type GetHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPRequestRuleBackendParams defines parameters for CreateHTTPRequestRuleBackend.
type CreateHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPRequestRuleBackendParams defines parameters for ReplaceHTTPRequestRuleBackend.
type ReplaceHTTPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPResponseRuleBackendParams defines parameters for GetAllHTTPResponseRuleBackend.
type GetAllHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPResponseRuleBackendParams defines parameters for ReplaceAllHTTPResponseRuleBackend.
type ReplaceAllHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPResponseRuleBackendParams defines parameters for DeleteHTTPResponseRuleBackend.
type DeleteHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPResponseRuleBackendParams defines parameters for GetHTTPResponseRuleBackend.
type GetHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPResponseRuleBackendParams defines parameters for CreateHTTPResponseRuleBackend.
type CreateHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPResponseRuleBackendParams defines parameters for ReplaceHTTPResponseRuleBackend.
type ReplaceHTTPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetBackendParams defines parameters for GetAllLogTargetBackend.
type GetAllLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetBackendParams defines parameters for ReplaceAllLogTargetBackend.
type ReplaceAllLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetBackendParams defines parameters for DeleteLogTargetBackend.
type DeleteLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetBackendParams defines parameters for GetLogTargetBackend.
type GetLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetBackendParams defines parameters for CreateLogTargetBackend.
type CreateLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetBackendParams defines parameters for ReplaceLogTargetBackend.
type ReplaceLogTargetBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerSwitchingRulesParams defines parameters for GetServerSwitchingRules.
type GetServerSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerSwitchingRulesParams defines parameters for ReplaceServerSwitchingRules.
type ReplaceServerSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerSwitchingRuleParams defines parameters for DeleteServerSwitchingRule.
type DeleteServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerSwitchingRuleParams defines parameters for GetServerSwitchingRule.
type GetServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerSwitchingRuleParams defines parameters for CreateServerSwitchingRule.
type CreateServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceServerSwitchingRuleParams defines parameters for ReplaceServerSwitchingRule.
type ReplaceServerSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerTemplatesParams defines parameters for GetServerTemplates.
type GetServerTemplatesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerTemplateParams defines parameters for CreateServerTemplate.
type CreateServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerTemplateParams defines parameters for DeleteServerTemplate.
type DeleteServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerTemplateParams defines parameters for GetServerTemplate.
type GetServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerTemplateParams defines parameters for ReplaceServerTemplate.
type ReplaceServerTemplateParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllServerBackendParams defines parameters for GetAllServerBackend.
type GetAllServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerBackendParams defines parameters for CreateServerBackend.
type CreateServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerBackendParams defines parameters for DeleteServerBackend.
type DeleteServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerBackendParams defines parameters for GetServerBackend.
type GetServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerBackendParams defines parameters for ReplaceServerBackend.
type ReplaceServerBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetStickRulesParams defines parameters for GetStickRules.
type GetStickRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceStickRulesParams defines parameters for ReplaceStickRules.
type ReplaceStickRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteStickRuleParams defines parameters for DeleteStickRule.
type DeleteStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetStickRuleParams defines parameters for GetStickRule.
type GetStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateStickRuleParams defines parameters for CreateStickRule.
type CreateStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceStickRuleParams defines parameters for ReplaceStickRule.
type ReplaceStickRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPCheckBackendParams defines parameters for GetAllTCPCheckBackend.
type GetAllTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPCheckBackendParams defines parameters for ReplaceAllTCPCheckBackend.
type ReplaceAllTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPCheckBackendParams defines parameters for DeleteTCPCheckBackend.
type DeleteTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPCheckBackendParams defines parameters for GetTCPCheckBackend.
type GetTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPCheckBackendParams defines parameters for CreateTCPCheckBackend.
type CreateTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPCheckBackendParams defines parameters for ReplaceTCPCheckBackend.
type ReplaceTCPCheckBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPRequestRuleBackendParams defines parameters for GetAllTCPRequestRuleBackend.
type GetAllTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPRequestRuleBackendParams defines parameters for ReplaceAllTCPRequestRuleBackend.
type ReplaceAllTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPRequestRuleBackendParams defines parameters for DeleteTCPRequestRuleBackend.
type DeleteTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPRequestRuleBackendParams defines parameters for GetTCPRequestRuleBackend.
type GetTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPRequestRuleBackendParams defines parameters for CreateTCPRequestRuleBackend.
type CreateTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPRequestRuleBackendParams defines parameters for ReplaceTCPRequestRuleBackend.
type ReplaceTCPRequestRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPResponseRuleBackendParams defines parameters for GetAllTCPResponseRuleBackend.
type GetAllTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPResponseRuleBackendParams defines parameters for ReplaceAllTCPResponseRuleBackend.
type ReplaceAllTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPResponseRuleBackendParams defines parameters for DeleteTCPResponseRuleBackend.
type DeleteTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPResponseRuleBackendParams defines parameters for GetTCPResponseRuleBackend.
type GetTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPResponseRuleBackendParams defines parameters for CreateTCPResponseRuleBackend.
type CreateTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPResponseRuleBackendParams defines parameters for ReplaceTCPResponseRuleBackend.
type ReplaceTCPResponseRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllWafBodyRuleBackendParams defines parameters for GetAllWafBodyRuleBackend.
type GetAllWafBodyRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllWafBodyRuleBackendParams defines parameters for ReplaceAllWafBodyRuleBackend.
type ReplaceAllWafBodyRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteWafBodyRuleBackendParams defines parameters for DeleteWafBodyRuleBackend.
type DeleteWafBodyRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetWafBodyRuleBackendParams defines parameters for GetWafBodyRuleBackend.
type GetWafBodyRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateWafBodyRuleBackendParams defines parameters for CreateWafBodyRuleBackend.
type CreateWafBodyRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceWafBodyRuleBackendParams defines parameters for ReplaceWafBodyRuleBackend.
type ReplaceWafBodyRuleBackendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBotmgmtProfilesParams defines parameters for GetBotmgmtProfiles.
type GetBotmgmtProfilesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateBotmgmtProfileParams defines parameters for CreateBotmgmtProfile.
type CreateBotmgmtProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteBotmgmtProfileParams defines parameters for DeleteBotmgmtProfile.
type DeleteBotmgmtProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBotmgmtProfileParams defines parameters for GetBotmgmtProfile.
type GetBotmgmtProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// EditBotmgmtProfileParams defines parameters for EditBotmgmtProfile.
type EditBotmgmtProfileParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetCachesParams defines parameters for GetCaches.
type GetCachesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateCacheParams defines parameters for CreateCache.
type CreateCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteCacheParams defines parameters for DeleteCache.
type DeleteCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCacheParams defines parameters for GetCache.
type GetCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceCacheParams defines parameters for ReplaceCache.
type ReplaceCacheParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCaptchasParams defines parameters for GetCaptchas.
type GetCaptchasParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateCaptchaParams defines parameters for CreateCaptcha.
type CreateCaptchaParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteCaptchaParams defines parameters for DeleteCaptcha.
type DeleteCaptchaParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCaptchaParams defines parameters for GetCaptcha.
type GetCaptchaParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// EditCaptchaParams defines parameters for EditCaptcha.
type EditCaptchaParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetCrtLoadsParams defines parameters for GetCrtLoads.
type GetCrtLoadsParams struct {
	// CrtStore Parent crt_store name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateCrtLoadParams defines parameters for CreateCrtLoad.
type CreateCrtLoadParams struct {
	// CrtStore Parent crt_store section name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteCrtLoadParams defines parameters for DeleteCrtLoad.
type DeleteCrtLoadParams struct {
	// CrtStore Parent crt_store section name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtLoadParams defines parameters for GetCrtLoad.
type GetCrtLoadParams struct {
	// CrtStore Parent crt_store name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceCrtLoadParams defines parameters for ReplaceCrtLoad.
type ReplaceCrtLoadParams struct {
	// CrtStore Parent crt_store section name
	CrtStore string `form:"crt_store" json:"crt_store"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtStoresParams defines parameters for GetCrtStores.
type GetCrtStoresParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateCrtStoreParams defines parameters for CreateCrtStore.
type CreateCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteCrtStoreParams defines parameters for DeleteCrtStore.
type DeleteCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetCrtStoreParams defines parameters for GetCrtStore.
type GetCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// EditCrtStoreParams defines parameters for EditCrtStore.
type EditCrtStoreParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDefaultsSectionsParams defines parameters for GetDefaultsSections.
type GetDefaultsSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateDefaultsSectionParams defines parameters for CreateDefaultsSection.
type CreateDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteDefaultsSectionParams defines parameters for DeleteDefaultsSection.
type DeleteDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetDefaultsSectionParams defines parameters for GetDefaultsSection.
type GetDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceDefaultsSectionParams defines parameters for ReplaceDefaultsSection.
type ReplaceDefaultsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllHTTPCheckDefaultsParams defines parameters for GetAllHTTPCheckDefaults.
type GetAllHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPCheckDefaultsParams defines parameters for ReplaceAllHTTPCheckDefaults.
type ReplaceAllHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPCheckDefaultsParams defines parameters for DeleteHTTPCheckDefaults.
type DeleteHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPCheckDefaultsParams defines parameters for GetHTTPCheckDefaults.
type GetHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPCheckDefaultsParams defines parameters for CreateHTTPCheckDefaults.
type CreateHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPCheckDefaultsParams defines parameters for ReplaceHTTPCheckDefaults.
type ReplaceHTTPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPErrorRuleDefaultsParams defines parameters for GetAllHTTPErrorRuleDefaults.
type GetAllHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPErrorRuleDefaultsParams defines parameters for ReplaceAllHTTPErrorRuleDefaults.
type ReplaceAllHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorRuleDefaultsParams defines parameters for DeleteHTTPErrorRuleDefaults.
type DeleteHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorRuleDefaultsParams defines parameters for GetHTTPErrorRuleDefaults.
type GetHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorRuleDefaultsParams defines parameters for CreateHTTPErrorRuleDefaults.
type CreateHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPErrorRuleDefaultsParams defines parameters for ReplaceHTTPErrorRuleDefaults.
type ReplaceHTTPErrorRuleDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetDefaultsParams defines parameters for GetAllLogTargetDefaults.
type GetAllLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetDefaultsParams defines parameters for ReplaceAllLogTargetDefaults.
type ReplaceAllLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetDefaultsParams defines parameters for DeleteLogTargetDefaults.
type DeleteLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetDefaultsParams defines parameters for GetLogTargetDefaults.
type GetLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetDefaultsParams defines parameters for CreateLogTargetDefaults.
type CreateLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetDefaultsParams defines parameters for ReplaceLogTargetDefaults.
type ReplaceLogTargetDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPCheckDefaultsParams defines parameters for GetAllTCPCheckDefaults.
type GetAllTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPCheckDefaultsParams defines parameters for ReplaceAllTCPCheckDefaults.
type ReplaceAllTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPCheckDefaultsParams defines parameters for DeleteTCPCheckDefaults.
type DeleteTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPCheckDefaultsParams defines parameters for GetTCPCheckDefaults.
type GetTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPCheckDefaultsParams defines parameters for CreateTCPCheckDefaults.
type CreateTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPCheckDefaultsParams defines parameters for ReplaceTCPCheckDefaults.
type ReplaceTCPCheckDefaultsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDynamicUpdateRulesParams defines parameters for GetDynamicUpdateRules.
type GetDynamicUpdateRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceDynamicUpdateRulesParams defines parameters for ReplaceDynamicUpdateRules.
type ReplaceDynamicUpdateRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteDynamicUpdateRuleParams defines parameters for DeleteDynamicUpdateRule.
type DeleteDynamicUpdateRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDynamicUpdateRuleParams defines parameters for GetDynamicUpdateRule.
type GetDynamicUpdateRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateDynamicUpdateRuleParams defines parameters for CreateDynamicUpdateRule.
type CreateDynamicUpdateRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceDynamicUpdateRuleParams defines parameters for ReplaceDynamicUpdateRule.
type ReplaceDynamicUpdateRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteDynamicUpdateSectionParams defines parameters for DeleteDynamicUpdateSection.
type DeleteDynamicUpdateSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDynamicUpdateSectionParams defines parameters for GetDynamicUpdateSection.
type GetDynamicUpdateSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateDynamicUpdateSectionParams defines parameters for CreateDynamicUpdateSection.
type CreateDynamicUpdateSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFCGIAppsParams defines parameters for GetFCGIApps.
type GetFCGIAppsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateFCGIAppParams defines parameters for CreateFCGIApp.
type CreateFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteFCGIAppParams defines parameters for DeleteFCGIApp.
type DeleteFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFCGIAppParams defines parameters for GetFCGIApp.
type GetFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceFCGIAppParams defines parameters for ReplaceFCGIApp.
type ReplaceFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclFCGIAppParams defines parameters for GetAllAclFCGIApp.
type GetAllAclFCGIAppParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclFCGIAppParams defines parameters for ReplaceAllAclFCGIApp.
type ReplaceAllAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclFCGIAppParams defines parameters for DeleteAclFCGIApp.
type DeleteAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclFCGIAppParams defines parameters for GetAclFCGIApp.
type GetAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclFCGIAppParams defines parameters for CreateAclFCGIApp.
type CreateAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclFCGIAppParams defines parameters for ReplaceAclFCGIApp.
type ReplaceAclFCGIAppParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFrontendsParams defines parameters for GetFrontends.
type GetFrontendsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateFrontendParams defines parameters for CreateFrontend.
type CreateFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteFrontendParams defines parameters for DeleteFrontend.
type DeleteFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFrontendParams defines parameters for GetFrontend.
type GetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceFrontendParams defines parameters for ReplaceFrontend.
type ReplaceFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllAclFrontendParams defines parameters for GetAllAclFrontend.
type GetAllAclFrontendParams struct {
	// AclName ACL name
	AclName *string `form:"acl_name,omitempty" json:"acl_name,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllAclFrontendParams defines parameters for ReplaceAllAclFrontend.
type ReplaceAllAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteAclFrontendParams defines parameters for DeleteAclFrontend.
type DeleteAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAclFrontendParams defines parameters for GetAclFrontend.
type GetAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateAclFrontendParams defines parameters for CreateAclFrontend.
type CreateAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceAclFrontendParams defines parameters for ReplaceAclFrontend.
type ReplaceAclFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendSwitchingRulesParams defines parameters for GetBackendSwitchingRules.
type GetBackendSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBackendSwitchingRulesParams defines parameters for ReplaceBackendSwitchingRules.
type ReplaceBackendSwitchingRulesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBackendSwitchingRuleParams defines parameters for DeleteBackendSwitchingRule.
type DeleteBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBackendSwitchingRuleParams defines parameters for GetBackendSwitchingRule.
type GetBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBackendSwitchingRuleParams defines parameters for CreateBackendSwitchingRule.
type CreateBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceBackendSwitchingRuleParams defines parameters for ReplaceBackendSwitchingRule.
type ReplaceBackendSwitchingRuleParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllBindFrontendParams defines parameters for GetAllBindFrontend.
type GetAllBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBindFrontendParams defines parameters for CreateBindFrontend.
type CreateBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBindFrontendParams defines parameters for DeleteBindFrontend.
type DeleteBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBindFrontendParams defines parameters for GetBindFrontend.
type GetBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBindFrontendParams defines parameters for ReplaceBindFrontend.
type ReplaceBindFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDeclareCapturesParams defines parameters for GetDeclareCaptures.
type GetDeclareCapturesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceDeclareCapturesParams defines parameters for ReplaceDeclareCaptures.
type ReplaceDeclareCapturesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteDeclareCaptureParams defines parameters for DeleteDeclareCapture.
type DeleteDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDeclareCaptureParams defines parameters for GetDeclareCapture.
type GetDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateDeclareCaptureParams defines parameters for CreateDeclareCapture.
type CreateDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceDeclareCaptureParams defines parameters for ReplaceDeclareCapture.
type ReplaceDeclareCaptureParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllFilterFrontendParams defines parameters for GetAllFilterFrontend.
type GetAllFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllFilterFrontendParams defines parameters for ReplaceAllFilterFrontend.
type ReplaceAllFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteFilterFrontendParams defines parameters for DeleteFilterFrontend.
type DeleteFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetFilterFrontendParams defines parameters for GetFilterFrontend.
type GetFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateFilterFrontendParams defines parameters for CreateFilterFrontend.
type CreateFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceFilterFrontendParams defines parameters for ReplaceFilterFrontend.
type ReplaceFilterFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPAfterResponseRuleFrontendParams defines parameters for GetAllHTTPAfterResponseRuleFrontend.
type GetAllHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPAfterResponseRuleFrontendParams defines parameters for ReplaceAllHTTPAfterResponseRuleFrontend.
type ReplaceAllHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPAfterResponseRuleFrontendParams defines parameters for DeleteHTTPAfterResponseRuleFrontend.
type DeleteHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPAfterResponseRuleFrontendParams defines parameters for GetHTTPAfterResponseRuleFrontend.
type GetHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPAfterResponseRuleFrontendParams defines parameters for CreateHTTPAfterResponseRuleFrontend.
type CreateHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPAfterResponseRuleFrontendParams defines parameters for ReplaceHTTPAfterResponseRuleFrontend.
type ReplaceHTTPAfterResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPErrorRuleFrontendParams defines parameters for GetAllHTTPErrorRuleFrontend.
type GetAllHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPErrorRuleFrontendParams defines parameters for ReplaceAllHTTPErrorRuleFrontend.
type ReplaceAllHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorRuleFrontendParams defines parameters for DeleteHTTPErrorRuleFrontend.
type DeleteHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorRuleFrontendParams defines parameters for GetHTTPErrorRuleFrontend.
type GetHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorRuleFrontendParams defines parameters for CreateHTTPErrorRuleFrontend.
type CreateHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPErrorRuleFrontendParams defines parameters for ReplaceHTTPErrorRuleFrontend.
type ReplaceHTTPErrorRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPRequestRuleFrontendParams defines parameters for GetAllHTTPRequestRuleFrontend.
type GetAllHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPRequestRuleFrontendParams defines parameters for ReplaceAllHTTPRequestRuleFrontend.
type ReplaceAllHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPRequestRuleFrontendParams defines parameters for DeleteHTTPRequestRuleFrontend.
type DeleteHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPRequestRuleFrontendParams defines parameters for GetHTTPRequestRuleFrontend.
type GetHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPRequestRuleFrontendParams defines parameters for CreateHTTPRequestRuleFrontend.
type CreateHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPRequestRuleFrontendParams defines parameters for ReplaceHTTPRequestRuleFrontend.
type ReplaceHTTPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllHTTPResponseRuleFrontendParams defines parameters for GetAllHTTPResponseRuleFrontend.
type GetAllHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllHTTPResponseRuleFrontendParams defines parameters for ReplaceAllHTTPResponseRuleFrontend.
type ReplaceAllHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPResponseRuleFrontendParams defines parameters for DeleteHTTPResponseRuleFrontend.
type DeleteHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPResponseRuleFrontendParams defines parameters for GetHTTPResponseRuleFrontend.
type GetHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPResponseRuleFrontendParams defines parameters for CreateHTTPResponseRuleFrontend.
type CreateHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceHTTPResponseRuleFrontendParams defines parameters for ReplaceHTTPResponseRuleFrontend.
type ReplaceHTTPResponseRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetFrontendParams defines parameters for GetAllLogTargetFrontend.
type GetAllLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetFrontendParams defines parameters for ReplaceAllLogTargetFrontend.
type ReplaceAllLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetFrontendParams defines parameters for DeleteLogTargetFrontend.
type DeleteLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetFrontendParams defines parameters for GetLogTargetFrontend.
type GetLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetFrontendParams defines parameters for CreateLogTargetFrontend.
type CreateLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetFrontendParams defines parameters for ReplaceLogTargetFrontend.
type ReplaceLogTargetFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllTCPRequestRuleFrontendParams defines parameters for GetAllTCPRequestRuleFrontend.
type GetAllTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllTCPRequestRuleFrontendParams defines parameters for ReplaceAllTCPRequestRuleFrontend.
type ReplaceAllTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTCPRequestRuleFrontendParams defines parameters for DeleteTCPRequestRuleFrontend.
type DeleteTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTCPRequestRuleFrontendParams defines parameters for GetTCPRequestRuleFrontend.
type GetTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTCPRequestRuleFrontendParams defines parameters for CreateTCPRequestRuleFrontend.
type CreateTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceTCPRequestRuleFrontendParams defines parameters for ReplaceTCPRequestRuleFrontend.
type ReplaceTCPRequestRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllWafBodyRuleFrontendParams defines parameters for GetAllWafBodyRuleFrontend.
type GetAllWafBodyRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllWafBodyRuleFrontendParams defines parameters for ReplaceAllWafBodyRuleFrontend.
type ReplaceAllWafBodyRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteWafBodyRuleFrontendParams defines parameters for DeleteWafBodyRuleFrontend.
type DeleteWafBodyRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetWafBodyRuleFrontendParams defines parameters for GetWafBodyRuleFrontend.
type GetWafBodyRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateWafBodyRuleFrontendParams defines parameters for CreateWafBodyRuleFrontend.
type CreateWafBodyRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceWafBodyRuleFrontendParams defines parameters for ReplaceWafBodyRuleFrontend.
type ReplaceWafBodyRuleFrontendParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetGlobalParams defines parameters for GetGlobal.
type GetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceGlobalParams defines parameters for ReplaceGlobal.
type ReplaceGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllLogTargetGlobalParams defines parameters for GetAllLogTargetGlobal.
type GetAllLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetGlobalParams defines parameters for ReplaceAllLogTargetGlobal.
type ReplaceAllLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetGlobalParams defines parameters for DeleteLogTargetGlobal.
type DeleteLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetGlobalParams defines parameters for GetLogTargetGlobal.
type GetLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetGlobalParams defines parameters for CreateLogTargetGlobal.
type CreateLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetGlobalParams defines parameters for ReplaceLogTargetGlobal.
type ReplaceLogTargetGlobalParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetGroupsParams defines parameters for GetGroups.
type GetGroupsParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateGroupParams defines parameters for CreateGroup.
type CreateGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteGroupParams defines parameters for DeleteGroup.
type DeleteGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetGroupParams defines parameters for GetGroup.
type GetGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceGroupParams defines parameters for ReplaceGroup.
type ReplaceGroupParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorsSectionsParams defines parameters for GetHTTPErrorsSections.
type GetHTTPErrorsSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateHTTPErrorsSectionParams defines parameters for CreateHTTPErrorsSection.
type CreateHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteHTTPErrorsSectionParams defines parameters for DeleteHTTPErrorsSection.
type DeleteHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHTTPErrorsSectionParams defines parameters for GetHTTPErrorsSection.
type GetHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceHTTPErrorsSectionParams defines parameters for ReplaceHTTPErrorsSection.
type ReplaceHTTPErrorsSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogForwardsParams defines parameters for GetLogForwards.
type GetLogForwardsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateLogForwardParams defines parameters for CreateLogForward.
type CreateLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteLogForwardParams defines parameters for DeleteLogForward.
type DeleteLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogForwardParams defines parameters for GetLogForward.
type GetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceLogForwardParams defines parameters for ReplaceLogForward.
type ReplaceLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllBindLogForwardParams defines parameters for GetAllBindLogForward.
type GetAllBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBindLogForwardParams defines parameters for CreateBindLogForward.
type CreateBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBindLogForwardParams defines parameters for DeleteBindLogForward.
type DeleteBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBindLogForwardParams defines parameters for GetBindLogForward.
type GetBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBindLogForwardParams defines parameters for ReplaceBindLogForward.
type ReplaceBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllDgramBindLogForwardParams defines parameters for GetAllDgramBindLogForward.
type GetAllDgramBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateDgramBindLogForwardParams defines parameters for CreateDgramBindLogForward.
type CreateDgramBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteDgramBindLogForwardParams defines parameters for DeleteDgramBindLogForward.
type DeleteDgramBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDgramBindLogForwardParams defines parameters for GetDgramBindLogForward.
type GetDgramBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceDgramBindLogForwardParams defines parameters for ReplaceDgramBindLogForward.
type ReplaceDgramBindLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetLogForwardParams defines parameters for GetAllLogTargetLogForward.
type GetAllLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetLogForwardParams defines parameters for ReplaceAllLogTargetLogForward.
type ReplaceAllLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetLogForwardParams defines parameters for DeleteLogTargetLogForward.
type DeleteLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetLogForwardParams defines parameters for GetLogTargetLogForward.
type GetLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetLogForwardParams defines parameters for CreateLogTargetLogForward.
type CreateLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetLogForwardParams defines parameters for ReplaceLogTargetLogForward.
type ReplaceLogTargetLogForwardParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailerEntriesParams defines parameters for GetMailerEntries.
type GetMailerEntriesParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateMailerEntryParams defines parameters for CreateMailerEntry.
type CreateMailerEntryParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteMailerEntryParams defines parameters for DeleteMailerEntry.
type DeleteMailerEntryParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailerEntryParams defines parameters for GetMailerEntry.
type GetMailerEntryParams struct {
	// MailersSection Parent mailers name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceMailerEntryParams defines parameters for ReplaceMailerEntry.
type ReplaceMailerEntryParams struct {
	// MailersSection Parent mailers section name
	MailersSection string `form:"mailers_section" json:"mailers_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailersSectionsParams defines parameters for GetMailersSections.
type GetMailersSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateMailersSectionParams defines parameters for CreateMailersSection.
type CreateMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteMailersSectionParams defines parameters for DeleteMailersSection.
type DeleteMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetMailersSectionParams defines parameters for GetMailersSection.
type GetMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// EditMailersSectionParams defines parameters for EditMailersSection.
type EditMailersSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetNameserversParams defines parameters for GetNameservers.
type GetNameserversParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateNameserverParams defines parameters for CreateNameserver.
type CreateNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteNameserverParams defines parameters for DeleteNameserver.
type DeleteNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetNameserverParams defines parameters for GetNameserver.
type GetNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceNameserverParams defines parameters for ReplaceNameserver.
type ReplaceNameserverParams struct {
	// Resolver Parent resolver name
	Resolver string `form:"resolver" json:"resolver"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerEntriesParams defines parameters for GetPeerEntries.
type GetPeerEntriesParams struct {
	// PeerSection Parent peer section name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreatePeerEntryParams defines parameters for CreatePeerEntry.
type CreatePeerEntryParams struct {
	// PeerSection Parent peer section name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeletePeerEntryParams defines parameters for DeletePeerEntry.
type DeletePeerEntryParams struct {
	// PeerSection Parent peers name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerEntryParams defines parameters for GetPeerEntry.
type GetPeerEntryParams struct {
	// PeerSection Parent peers name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplacePeerEntryParams defines parameters for ReplacePeerEntry.
type ReplacePeerEntryParams struct {
	// PeerSection Parent peers name
	PeerSection string `form:"peer_section" json:"peer_section"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerSectionsParams defines parameters for GetPeerSections.
type GetPeerSectionsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreatePeerParams defines parameters for CreatePeer.
type CreatePeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeletePeerParams defines parameters for DeletePeer.
type DeletePeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetPeerSectionParams defines parameters for GetPeerSection.
type GetPeerSectionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllBindPeerParams defines parameters for GetAllBindPeer.
type GetAllBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateBindPeerParams defines parameters for CreateBindPeer.
type CreateBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteBindPeerParams defines parameters for DeleteBindPeer.
type DeleteBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetBindPeerParams defines parameters for GetBindPeer.
type GetBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceBindPeerParams defines parameters for ReplaceBindPeer.
type ReplaceBindPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetPeerParams defines parameters for GetAllLogTargetPeer.
type GetAllLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetPeerParams defines parameters for ReplaceAllLogTargetPeer.
type ReplaceAllLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetPeerParams defines parameters for DeleteLogTargetPeer.
type DeleteLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetPeerParams defines parameters for GetLogTargetPeer.
type GetLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetPeerParams defines parameters for CreateLogTargetPeer.
type CreateLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetPeerParams defines parameters for ReplaceLogTargetPeer.
type ReplaceLogTargetPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllServerPeerParams defines parameters for GetAllServerPeer.
type GetAllServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerPeerParams defines parameters for CreateServerPeer.
type CreateServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerPeerParams defines parameters for DeleteServerPeer.
type DeleteServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerPeerParams defines parameters for GetServerPeer.
type GetServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerPeerParams defines parameters for ReplaceServerPeer.
type ReplaceServerPeerParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTablesParams defines parameters for GetTables.
type GetTablesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateTableParams defines parameters for CreateTable.
type CreateTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteTableParams defines parameters for DeleteTable.
type DeleteTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTableParams defines parameters for GetTable.
type GetTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceTableParams defines parameters for ReplaceTable.
type ReplaceTableParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetProgramsParams defines parameters for GetPrograms.
type GetProgramsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateProgramParams defines parameters for CreateProgram.
type CreateProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteProgramParams defines parameters for DeleteProgram.
type DeleteProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetProgramParams defines parameters for GetProgram.
type GetProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceProgramParams defines parameters for ReplaceProgram.
type ReplaceProgramParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHAProxyConfigurationParams defines parameters for GetHAProxyConfiguration.
type GetHAProxyConfigurationParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// PostHAProxyConfigurationTextBody defines parameters for PostHAProxyConfiguration.
type PostHAProxyConfigurationTextBody = string

// PostHAProxyConfigurationParams defines parameters for PostHAProxyConfiguration.
type PostHAProxyConfigurationParams struct {
	// SkipVersion If set, no version check will be done and the pushed config will be enforced
	SkipVersion *bool `form:"skip_version,omitempty" json:"skip_version,omitempty"`

	// SkipReload If set, no reload will be initiated and runtime actions from X-Runtime-Actions will be applied
	SkipReload *bool `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// OnlyValidate If set, only validates configuration, without applying it
	OnlyValidate *bool `form:"only_validate,omitempty" json:"only_validate,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// XRuntimeActions List of Runtime API commands with parameters separated by ';'
	XRuntimeActions *string `json:"X-Runtime-Actions,omitempty"`
}

// GetResolversParams defines parameters for GetResolvers.
type GetResolversParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateResolverParams defines parameters for CreateResolver.
type CreateResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteResolverParams defines parameters for DeleteResolver.
type DeleteResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetResolverParams defines parameters for GetResolver.
type GetResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceResolverParams defines parameters for ReplaceResolver.
type ReplaceResolverParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetRingsParams defines parameters for GetRings.
type GetRingsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateRingParams defines parameters for CreateRing.
type CreateRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteRingParams defines parameters for DeleteRing.
type DeleteRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetRingParams defines parameters for GetRing.
type GetRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceRingParams defines parameters for ReplaceRing.
type ReplaceRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllServerRingParams defines parameters for GetAllServerRing.
type GetAllServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateServerRingParams defines parameters for CreateServerRing.
type CreateServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteServerRingParams defines parameters for DeleteServerRing.
type DeleteServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetServerRingParams defines parameters for GetServerRing.
type GetServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceServerRingParams defines parameters for ReplaceServerRing.
type ReplaceServerRingParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetHAProxyConfigurationStructuredParams defines parameters for GetHAProxyConfigurationStructured.
type GetHAProxyConfigurationStructuredParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceStructuredParams defines parameters for ReplaceStructured.
type ReplaceStructuredParams struct {
	// SkipVersion If set, no version check will be done and the pushed config will be enforced
	SkipVersion *bool `form:"skip_version,omitempty" json:"skip_version,omitempty"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUDPLbsParams defines parameters for GetUDPLbs.
type GetUDPLbsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateUDPLbParams defines parameters for CreateUDPLb.
type CreateUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteUDPLbParams defines parameters for DeleteUDPLb.
type DeleteUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetUDPlbParams defines parameters for GetUDPlb.
type GetUDPlbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// ReplaceUDPLbParams defines parameters for ReplaceUDPLb.
type ReplaceUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetAllDgramBindUDPLbParams defines parameters for GetAllDgramBindUDPLb.
type GetAllDgramBindUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateDgramBindUDPLbParams defines parameters for CreateDgramBindUDPLb.
type CreateDgramBindUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteDgramBindUDPLbParams defines parameters for DeleteDgramBindUDPLb.
type DeleteDgramBindUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetDgramBindUDPLbParams defines parameters for GetDgramBindUDPLb.
type GetDgramBindUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceDgramBindUDPLbParams defines parameters for ReplaceDgramBindUDPLb.
type ReplaceDgramBindUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllLogTargetUDPLbParams defines parameters for GetAllLogTargetUDPLb.
type GetAllLogTargetUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceAllLogTargetUDPLbParams defines parameters for ReplaceAllLogTargetUDPLb.
type ReplaceAllLogTargetUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteLogTargetUDPLbParams defines parameters for DeleteLogTargetUDPLb.
type DeleteLogTargetUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetLogTargetUDPLbParams defines parameters for GetLogTargetUDPLb.
type GetLogTargetUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateLogTargetUDPLbParams defines parameters for CreateLogTargetUDPLb.
type CreateLogTargetUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceLogTargetUDPLbParams defines parameters for ReplaceLogTargetUDPLb.
type ReplaceLogTargetUDPLbParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUserlistsParams defines parameters for GetUserlists.
type GetUserlistsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// CreateUserlistParams defines parameters for CreateUserlist.
type CreateUserlistParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// DeleteUserlistParams defines parameters for DeleteUserlist.
type DeleteUserlistParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUserlistParams defines parameters for GetUserlist.
type GetUserlistParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// FullSection Indicates if the action affects the specified child resources as well
	FullSection *FullSection `form:"full_section,omitempty" json:"full_section,omitempty"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateUserParams defines parameters for CreateUser.
type CreateUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteUserParams defines parameters for DeleteUser.
type DeleteUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetUserParams defines parameters for GetUser.
type GetUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceUserParams defines parameters for ReplaceUser.
type ReplaceUserParams struct {
	// Userlist Parent userlist name
	Userlist string `form:"userlist" json:"userlist"`

	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetConfigurationVersionParams defines parameters for GetConfigurationVersion.
type GetConfigurationVersionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// GetAllRuntimeMapFilesParams defines parameters for GetAllRuntimeMapFiles.
type GetAllRuntimeMapFilesParams struct {
	// IncludeUnmanaged If true, also show unmanaged map files loaded in haproxy
	IncludeUnmanaged *bool `form:"include_unmanaged,omitempty" json:"include_unmanaged,omitempty"`
}

// ClearRuntimeMapParams defines parameters for ClearRuntimeMap.
type ClearRuntimeMapParams struct {
	// ForceDelete If true, deletes file from disk
	ForceDelete *bool `form:"forceDelete,omitempty" json:"forceDelete,omitempty"`

	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// AddPayloadRuntimeMapParams defines parameters for AddPayloadRuntimeMap.
type AddPayloadRuntimeMapParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// AddMapEntryParams defines parameters for AddMapEntry.
type AddMapEntryParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// DeleteRuntimeMapEntryParams defines parameters for DeleteRuntimeMapEntry.
type DeleteRuntimeMapEntryParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// ReplaceRuntimeMapEntryJSONBody defines parameters for ReplaceRuntimeMapEntry.
type ReplaceRuntimeMapEntryJSONBody struct {
	// Value Map value
	Value string `json:"value"`
}

// ReplaceRuntimeMapEntryParams defines parameters for ReplaceRuntimeMapEntry.
type ReplaceRuntimeMapEntryParams struct {
	// ForceSync If true, immediately syncs changes to disk
	ForceSync *bool `form:"force_sync,omitempty" json:"force_sync,omitempty"`
}

// GetStickTableEntriesParams defines parameters for GetStickTableEntries.
type GetStickTableEntriesParams struct {
	// Filter A list of filters in format data.<type> <operator> <value> separated by comma
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Key Key which we want the entries for
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Count Max number of entries to be returned for pagination
	Count *int `form:"count,omitempty" json:"count,omitempty"`

	// Offset Offset which indicates how many items we skip in pagination
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// SetStickTableEntriesJSONBody defines parameters for SetStickTableEntries.
type SetStickTableEntriesJSONBody struct {
	// DataType One entry in stick table
	DataType StickTableEntry `json:"data_type"`
	Key      string          `json:"key"`
}

// GetSitesParams defines parameters for GetSites.
type GetSitesParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSiteParams defines parameters for CreateSite.
type CreateSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteSiteParams defines parameters for DeleteSite.
type DeleteSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetSiteParams defines parameters for GetSite.
type GetSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSiteParams defines parameters for ReplaceSite.
type ReplaceSiteParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateSpoeMultipartBody defines parameters for CreateSpoe.
type CreateSpoeMultipartBody struct {
	// FileUpload The spoe file to upload
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// GetAllSpoeScopeParams defines parameters for GetAllSpoeScope.
type GetAllSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeScopeParams defines parameters for CreateSpoeScope.
type CreateSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeScopeParams defines parameters for DeleteSpoeScope.
type DeleteSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeScopeParams defines parameters for GetSpoeScope.
type GetSpoeScopeParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// GetAllSpoeAgentParams defines parameters for GetAllSpoeAgent.
type GetAllSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeAgentParams defines parameters for CreateSpoeAgent.
type CreateSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeAgentParams defines parameters for DeleteSpoeAgent.
type DeleteSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeAgentParams defines parameters for GetSpoeAgent.
type GetSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSpoeAgentParams defines parameters for ReplaceSpoeAgent.
type ReplaceSpoeAgentParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAllSpoeGroupParams defines parameters for GetAllSpoeGroup.
type GetAllSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeGroupParams defines parameters for CreateSpoeGroup.
type CreateSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeGroupParams defines parameters for DeleteSpoeGroup.
type DeleteSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeGroupParams defines parameters for GetSpoeGroup.
type GetSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSpoeGroupParams defines parameters for ReplaceSpoeGroup.
type ReplaceSpoeGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAllSpoeMessageParams defines parameters for GetAllSpoeMessage.
type GetAllSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// CreateSpoeMessageParams defines parameters for CreateSpoeMessage.
type CreateSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// DeleteSpoeMessageParams defines parameters for DeleteSpoeMessage.
type DeleteSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetSpoeMessageParams defines parameters for GetSpoeMessage.
type GetSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// ReplaceSpoeMessageParams defines parameters for ReplaceSpoeMessage.
type ReplaceSpoeMessageParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`
}

// GetAllSpoeTransactionParams defines parameters for GetAllSpoeTransaction.
type GetAllSpoeTransactionParams struct {
	// Status Filter by transaction status
	Status *GetAllSpoeTransactionParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetAllSpoeTransactionParamsStatus defines parameters for GetAllSpoeTransaction.
type GetAllSpoeTransactionParamsStatus string

// StartSpoeTransactionParams defines parameters for StartSpoeTransaction.
type StartSpoeTransactionParams struct {
	// Version Configuration version on which to work on
	Version int `form:"version" json:"version"`
}

// CommitSpoeTransactionParams defines parameters for CommitSpoeTransaction.
type CommitSpoeTransactionParams struct {
	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetSpoeConfigurationVersionParams defines parameters for GetSpoeConfigurationVersion.
type GetSpoeConfigurationVersionParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`
}

// GetStatsParams defines parameters for GetStats.
type GetStatsParams struct {
	// Type Object type to get stats for (one of frontend, backend, server)
	Type *GetStatsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Name Object name to get stats for
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Parent Object parent name to get stats for, in case the object is a server
	Parent *string `form:"parent,omitempty" json:"parent,omitempty"`
}

// GetStatsParamsType defines parameters for GetStats.
type GetStatsParamsType string

// CreateStorageGeneralFileMultipartBody defines parameters for CreateStorageGeneralFile.
type CreateStorageGeneralFileMultipartBody struct {
	// FileUpload General use file content
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceStorageGeneralFileMultipartBody defines parameters for ReplaceStorageGeneralFile.
type ReplaceStorageGeneralFileMultipartBody struct {
	// FileUpload General use file content
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceStorageGeneralFileParams defines parameters for ReplaceStorageGeneralFile.
type ReplaceStorageGeneralFileParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateStorageMapFileMultipartBody defines parameters for CreateStorageMapFile.
type CreateStorageMapFileMultipartBody struct {
	// FileUpload The map file contents
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceStorageMapFileTextBody defines parameters for ReplaceStorageMapFile.
type ReplaceStorageMapFileTextBody = string

// ReplaceStorageMapFileParams defines parameters for ReplaceStorageMapFile.
type ReplaceStorageMapFileParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateStorageSSLCertificateMultipartBody defines parameters for CreateStorageSSLCertificate.
type CreateStorageSSLCertificateMultipartBody struct {
	// FileUpload The SSL certificate to upload
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// CreateStorageSSLCertificateParams defines parameters for CreateStorageSSLCertificate.
type CreateStorageSSLCertificateParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteStorageSSLCertificateParams defines parameters for DeleteStorageSSLCertificate.
type DeleteStorageSSLCertificateParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceStorageSSLCertificateTextBody defines parameters for ReplaceStorageSSLCertificate.
type ReplaceStorageSSLCertificateTextBody = string

// ReplaceStorageSSLCertificateParams defines parameters for ReplaceStorageSSLCertificate.
type ReplaceStorageSSLCertificateParams struct {
	// SkipReload If set, no reload will be initiated after update
	SkipReload *SkipReload `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetTransactionsParams defines parameters for GetTransactions.
type GetTransactionsParams struct {
	// Status Filter by transaction status
	Status *GetTransactionsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetTransactionsParamsStatus defines parameters for GetTransactions.
type GetTransactionsParamsStatus string

// StartTransactionParams defines parameters for StartTransaction.
type StartTransactionParams struct {
	// Version Configuration version on which to work on
	Version int `form:"version" json:"version"`
}

// CommitTransactionParams defines parameters for CommitTransaction.
type CommitTransactionParams struct {
	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateWafRulesetMultipartBody defines parameters for CreateWafRuleset.
type CreateWafRulesetMultipartBody struct {
	// FileUpload The waf ruleset
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// ReplaceWafRulesetMultipartBody defines parameters for ReplaceWafRuleset.
type ReplaceWafRulesetMultipartBody struct {
	// FileUpload The waf ruleset
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// GetWafFilesParams defines parameters for GetWafFiles.
type GetWafFilesParams struct {
	// SubDir Sub directory in the ruleset
	SubDir *SubDir `form:"sub_dir,omitempty" json:"sub_dir,omitempty"`
}

// CreateWafFileMultipartBody defines parameters for CreateWafFile.
type CreateWafFileMultipartBody struct {
	// FileUpload The waf file
	FileUpload *openapi_types.File `json:"file_upload,omitempty"`
}

// CreateWafFileParams defines parameters for CreateWafFile.
type CreateWafFileParams struct {
	// SubDir Sub directory in the ruleset
	SubDir *SubDir `form:"sub_dir,omitempty" json:"sub_dir,omitempty"`
}

// DeleteWafFileParams defines parameters for DeleteWafFile.
type DeleteWafFileParams struct {
	// SubDir Sub directory in the ruleset
	SubDir *SubDir `form:"sub_dir,omitempty" json:"sub_dir,omitempty"`
}

// GetWafFileParams defines parameters for GetWafFile.
type GetWafFileParams struct {
	// SubDir Sub directory in the ruleset
	SubDir *SubDir `form:"sub_dir,omitempty" json:"sub_dir,omitempty"`
}

// ReplaceWafFileTextBody defines parameters for ReplaceWafFile.
type ReplaceWafFileTextBody = string

// ReplaceWafFileParams defines parameters for ReplaceWafFile.
type ReplaceWafFileParams struct {
	// SubDir Sub directory in the ruleset
	SubDir *SubDir `form:"sub_dir,omitempty" json:"sub_dir,omitempty"`
}

// ReplaceGlobalDefsParams defines parameters for ReplaceGlobalDefs.
type ReplaceGlobalDefsParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceKeepalivedConfigurationTextBody defines parameters for ReplaceKeepalivedConfiguration.
type ReplaceKeepalivedConfigurationTextBody = string

// ReplaceKeepalivedConfigurationParams defines parameters for ReplaceKeepalivedConfiguration.
type ReplaceKeepalivedConfigurationParams struct {
	// SkipVersion If set, no version check will be done and the pushed config will be enforced
	SkipVersion *bool `form:"skip_version,omitempty" json:"skip_version,omitempty"`

	// SkipReload If set, no reload will be initiated
	SkipReload *bool `form:"skip_reload,omitempty" json:"skip_reload,omitempty"`

	// OnlyValidate If set, only validates configuration, without applying it
	OnlyValidate *bool `form:"only_validate,omitempty" json:"only_validate,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateVRRPInstanceParams defines parameters for CreateVRRPInstance.
type CreateVRRPInstanceParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteVRRPInstanceParams defines parameters for DeleteVRRPInstance.
type DeleteVRRPInstanceParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceVRRPInstanceParams defines parameters for ReplaceVRRPInstance.
type ReplaceVRRPInstanceParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateVRRPSyncGroupParams defines parameters for CreateVRRPSyncGroup.
type CreateVRRPSyncGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteVRRPSyncGroupParams defines parameters for DeleteVRRPSyncGroup.
type DeleteVRRPSyncGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceVRRPSyncGroupParams defines parameters for ReplaceVRRPSyncGroup.
type ReplaceVRRPSyncGroupParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// CreateVRRPScriptParams defines parameters for CreateVRRPScript.
type CreateVRRPScriptParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// DeleteVRRPScriptParams defines parameters for DeleteVRRPScript.
type DeleteVRRPScriptParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// ReplaceVRRPScriptParams defines parameters for ReplaceVRRPScript.
type ReplaceVRRPScriptParams struct {
	// TransactionId ID of the transaction where we want to add the operation. Cannot be used when version is specified.
	TransactionId *TransactionId `form:"transaction_id,omitempty" json:"transaction_id,omitempty"`

	// Version Version used for checking configuration version. Cannot be used when transaction is specified, transaction has it's own version.
	Version *Version `form:"version,omitempty" json:"version,omitempty"`

	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetAllKeepalivedTransactionParams defines parameters for GetAllKeepalivedTransaction.
type GetAllKeepalivedTransactionParams struct {
	// Status Filter by transaction status
	Status *GetAllKeepalivedTransactionParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// GetAllKeepalivedTransactionParamsStatus defines parameters for GetAllKeepalivedTransaction.
type GetAllKeepalivedTransactionParamsStatus string

// StartKeepalivedTransactionParams defines parameters for StartKeepalivedTransaction.
type StartKeepalivedTransactionParams struct {
	// Version Configuration version on which to work on
	Version int `form:"version" json:"version"`
}

// CommitKeepalivedTransactionParams defines parameters for CommitKeepalivedTransaction.
type CommitKeepalivedTransactionParams struct {
	// ForceReload If set, do a force reload, do not wait for the configured reload-delay. Cannot be used when transaction is specified, as changes in transaction are not applied directly to configuration.
	ForceReload *ForceReload `form:"force_reload,omitempty" json:"force_reload,omitempty"`
}

// GetSummaryParams defines parameters for GetSummary.
type GetSummaryParams struct {
	// Refresh Force refreshing of the facts
	Refresh *bool `form:"refresh,omitempty" json:"refresh,omitempty"`
}

// ExecuteAlohaActionJSONRequestBody defines body for ExecuteAlohaAction for application/json ContentType.
type ExecuteAlohaActionJSONRequestBody = AlohaAction

// PostClusterJSONRequestBody defines body for PostCluster for application/json ContentType.
type PostClusterJSONRequestBody = ClusterSettings

// EditClusterJSONRequestBody defines body for EditCluster for application/json ContentType.
type EditClusterJSONRequestBody = ClusterSettings

// CreateAWSRegionJSONRequestBody defines body for CreateAWSRegion for application/json ContentType.
type CreateAWSRegionJSONRequestBody = AwsRegion

// ReplaceAWSRegionJSONRequestBody defines body for ReplaceAWSRegion for application/json ContentType.
type ReplaceAWSRegionJSONRequestBody = AwsRegion

// CreateConsulJSONRequestBody defines body for CreateConsul for application/json ContentType.
type CreateConsulJSONRequestBody = Consul

// ReplaceConsulJSONRequestBody defines body for ReplaceConsul for application/json ContentType.
type ReplaceConsulJSONRequestBody = Consul

// RunActionsJSONRequestBody defines body for RunActions for application/json ContentType.
type RunActionsJSONRequestBody = Actions

// ExecuteGitActionJSONRequestBody defines body for ExecuteGitAction for application/json ContentType.
type ExecuteGitActionJSONRequestBody = GitAction

// ReplaceGitSettingsJSONRequestBody defines body for ReplaceGitSettings for application/json ContentType.
type ReplaceGitSettingsJSONRequestBody = GitSettings

// CreateBackendJSONRequestBody defines body for CreateBackend for application/json ContentType.
type CreateBackendJSONRequestBody = Backend

// ReplaceBackendJSONRequestBody defines body for ReplaceBackend for application/json ContentType.
type ReplaceBackendJSONRequestBody = Backend

// ReplaceAllAclBackendJSONRequestBody defines body for ReplaceAllAclBackend for application/json ContentType.
type ReplaceAllAclBackendJSONRequestBody = Acls

// CreateAclBackendJSONRequestBody defines body for CreateAclBackend for application/json ContentType.
type CreateAclBackendJSONRequestBody = Acl

// ReplaceAclBackendJSONRequestBody defines body for ReplaceAclBackend for application/json ContentType.
type ReplaceAclBackendJSONRequestBody = Acl

// ReplaceAllFilterBackendJSONRequestBody defines body for ReplaceAllFilterBackend for application/json ContentType.
type ReplaceAllFilterBackendJSONRequestBody = Filters

// CreateFilterBackendJSONRequestBody defines body for CreateFilterBackend for application/json ContentType.
type CreateFilterBackendJSONRequestBody = Filter

// ReplaceFilterBackendJSONRequestBody defines body for ReplaceFilterBackend for application/json ContentType.
type ReplaceFilterBackendJSONRequestBody = Filter

// ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody defines body for ReplaceAllHTTPAfterResponseRuleBackend for application/json ContentType.
type ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody = HttpAfterResponseRules

// CreateHTTPAfterResponseRuleBackendJSONRequestBody defines body for CreateHTTPAfterResponseRuleBackend for application/json ContentType.
type CreateHTTPAfterResponseRuleBackendJSONRequestBody = HttpAfterResponseRule

// ReplaceHTTPAfterResponseRuleBackendJSONRequestBody defines body for ReplaceHTTPAfterResponseRuleBackend for application/json ContentType.
type ReplaceHTTPAfterResponseRuleBackendJSONRequestBody = HttpAfterResponseRule

// ReplaceAllHTTPCheckBackendJSONRequestBody defines body for ReplaceAllHTTPCheckBackend for application/json ContentType.
type ReplaceAllHTTPCheckBackendJSONRequestBody = HttpChecks

// CreateHTTPCheckBackendJSONRequestBody defines body for CreateHTTPCheckBackend for application/json ContentType.
type CreateHTTPCheckBackendJSONRequestBody = HttpCheck

// ReplaceHTTPCheckBackendJSONRequestBody defines body for ReplaceHTTPCheckBackend for application/json ContentType.
type ReplaceHTTPCheckBackendJSONRequestBody = HttpCheck

// ReplaceAllHTTPErrorRuleBackendJSONRequestBody defines body for ReplaceAllHTTPErrorRuleBackend for application/json ContentType.
type ReplaceAllHTTPErrorRuleBackendJSONRequestBody = HttpErrorRules

// CreateHTTPErrorRuleBackendJSONRequestBody defines body for CreateHTTPErrorRuleBackend for application/json ContentType.
type CreateHTTPErrorRuleBackendJSONRequestBody = HttpErrorRule

// ReplaceHTTPErrorRuleBackendJSONRequestBody defines body for ReplaceHTTPErrorRuleBackend for application/json ContentType.
type ReplaceHTTPErrorRuleBackendJSONRequestBody = HttpErrorRule

// ReplaceAllHTTPRequestRuleBackendJSONRequestBody defines body for ReplaceAllHTTPRequestRuleBackend for application/json ContentType.
type ReplaceAllHTTPRequestRuleBackendJSONRequestBody = HttpRequestRules

// CreateHTTPRequestRuleBackendJSONRequestBody defines body for CreateHTTPRequestRuleBackend for application/json ContentType.
type CreateHTTPRequestRuleBackendJSONRequestBody = HttpRequestRule

// ReplaceHTTPRequestRuleBackendJSONRequestBody defines body for ReplaceHTTPRequestRuleBackend for application/json ContentType.
type ReplaceHTTPRequestRuleBackendJSONRequestBody = HttpRequestRule

// ReplaceAllHTTPResponseRuleBackendJSONRequestBody defines body for ReplaceAllHTTPResponseRuleBackend for application/json ContentType.
type ReplaceAllHTTPResponseRuleBackendJSONRequestBody = HttpResponseRules

// CreateHTTPResponseRuleBackendJSONRequestBody defines body for CreateHTTPResponseRuleBackend for application/json ContentType.
type CreateHTTPResponseRuleBackendJSONRequestBody = HttpResponseRule

// ReplaceHTTPResponseRuleBackendJSONRequestBody defines body for ReplaceHTTPResponseRuleBackend for application/json ContentType.
type ReplaceHTTPResponseRuleBackendJSONRequestBody = HttpResponseRule

// ReplaceAllLogTargetBackendJSONRequestBody defines body for ReplaceAllLogTargetBackend for application/json ContentType.
type ReplaceAllLogTargetBackendJSONRequestBody = LogTargets

// CreateLogTargetBackendJSONRequestBody defines body for CreateLogTargetBackend for application/json ContentType.
type CreateLogTargetBackendJSONRequestBody = LogTarget

// ReplaceLogTargetBackendJSONRequestBody defines body for ReplaceLogTargetBackend for application/json ContentType.
type ReplaceLogTargetBackendJSONRequestBody = LogTarget

// ReplaceServerSwitchingRulesJSONRequestBody defines body for ReplaceServerSwitchingRules for application/json ContentType.
type ReplaceServerSwitchingRulesJSONRequestBody = ServerSwitchingRules

// CreateServerSwitchingRuleJSONRequestBody defines body for CreateServerSwitchingRule for application/json ContentType.
type CreateServerSwitchingRuleJSONRequestBody = ServerSwitchingRule

// ReplaceServerSwitchingRuleJSONRequestBody defines body for ReplaceServerSwitchingRule for application/json ContentType.
type ReplaceServerSwitchingRuleJSONRequestBody = ServerSwitchingRule

// CreateServerTemplateJSONRequestBody defines body for CreateServerTemplate for application/json ContentType.
type CreateServerTemplateJSONRequestBody = ServerTemplate

// ReplaceServerTemplateJSONRequestBody defines body for ReplaceServerTemplate for application/json ContentType.
type ReplaceServerTemplateJSONRequestBody = ServerTemplate

// CreateServerBackendJSONRequestBody defines body for CreateServerBackend for application/json ContentType.
type CreateServerBackendJSONRequestBody = Server

// ReplaceServerBackendJSONRequestBody defines body for ReplaceServerBackend for application/json ContentType.
type ReplaceServerBackendJSONRequestBody = Server

// ReplaceStickRulesJSONRequestBody defines body for ReplaceStickRules for application/json ContentType.
type ReplaceStickRulesJSONRequestBody = StickRules

// CreateStickRuleJSONRequestBody defines body for CreateStickRule for application/json ContentType.
type CreateStickRuleJSONRequestBody = StickRule

// ReplaceStickRuleJSONRequestBody defines body for ReplaceStickRule for application/json ContentType.
type ReplaceStickRuleJSONRequestBody = StickRule

// ReplaceAllTCPCheckBackendJSONRequestBody defines body for ReplaceAllTCPCheckBackend for application/json ContentType.
type ReplaceAllTCPCheckBackendJSONRequestBody = TcpChecks

// CreateTCPCheckBackendJSONRequestBody defines body for CreateTCPCheckBackend for application/json ContentType.
type CreateTCPCheckBackendJSONRequestBody = TcpCheck

// ReplaceTCPCheckBackendJSONRequestBody defines body for ReplaceTCPCheckBackend for application/json ContentType.
type ReplaceTCPCheckBackendJSONRequestBody = TcpCheck

// ReplaceAllTCPRequestRuleBackendJSONRequestBody defines body for ReplaceAllTCPRequestRuleBackend for application/json ContentType.
type ReplaceAllTCPRequestRuleBackendJSONRequestBody = TcpRequestRules

// CreateTCPRequestRuleBackendJSONRequestBody defines body for CreateTCPRequestRuleBackend for application/json ContentType.
type CreateTCPRequestRuleBackendJSONRequestBody = TcpRequestRule

// ReplaceTCPRequestRuleBackendJSONRequestBody defines body for ReplaceTCPRequestRuleBackend for application/json ContentType.
type ReplaceTCPRequestRuleBackendJSONRequestBody = TcpRequestRule

// ReplaceAllTCPResponseRuleBackendJSONRequestBody defines body for ReplaceAllTCPResponseRuleBackend for application/json ContentType.
type ReplaceAllTCPResponseRuleBackendJSONRequestBody = TcpResponseRules

// CreateTCPResponseRuleBackendJSONRequestBody defines body for CreateTCPResponseRuleBackend for application/json ContentType.
type CreateTCPResponseRuleBackendJSONRequestBody = TcpResponseRule

// ReplaceTCPResponseRuleBackendJSONRequestBody defines body for ReplaceTCPResponseRuleBackend for application/json ContentType.
type ReplaceTCPResponseRuleBackendJSONRequestBody = TcpResponseRule

// ReplaceAllWafBodyRuleBackendJSONRequestBody defines body for ReplaceAllWafBodyRuleBackend for application/json ContentType.
type ReplaceAllWafBodyRuleBackendJSONRequestBody = WafBodyRules

// CreateWafBodyRuleBackendJSONRequestBody defines body for CreateWafBodyRuleBackend for application/json ContentType.
type CreateWafBodyRuleBackendJSONRequestBody = WafBodyRule

// ReplaceWafBodyRuleBackendJSONRequestBody defines body for ReplaceWafBodyRuleBackend for application/json ContentType.
type ReplaceWafBodyRuleBackendJSONRequestBody = WafBodyRule

// CreateBotmgmtProfileJSONRequestBody defines body for CreateBotmgmtProfile for application/json ContentType.
type CreateBotmgmtProfileJSONRequestBody = BotmgmtProfile

// EditBotmgmtProfileJSONRequestBody defines body for EditBotmgmtProfile for application/json ContentType.
type EditBotmgmtProfileJSONRequestBody = BotmgmtProfile

// CreateCacheJSONRequestBody defines body for CreateCache for application/json ContentType.
type CreateCacheJSONRequestBody = Cache

// ReplaceCacheJSONRequestBody defines body for ReplaceCache for application/json ContentType.
type ReplaceCacheJSONRequestBody = Cache

// CreateCaptchaJSONRequestBody defines body for CreateCaptcha for application/json ContentType.
type CreateCaptchaJSONRequestBody = Captcha

// EditCaptchaJSONRequestBody defines body for EditCaptcha for application/json ContentType.
type EditCaptchaJSONRequestBody = Captcha

// CreateCrtLoadJSONRequestBody defines body for CreateCrtLoad for application/json ContentType.
type CreateCrtLoadJSONRequestBody = CrtLoad

// ReplaceCrtLoadJSONRequestBody defines body for ReplaceCrtLoad for application/json ContentType.
type ReplaceCrtLoadJSONRequestBody = CrtLoad

// CreateCrtStoreJSONRequestBody defines body for CreateCrtStore for application/json ContentType.
type CreateCrtStoreJSONRequestBody = CrtStore

// EditCrtStoreJSONRequestBody defines body for EditCrtStore for application/json ContentType.
type EditCrtStoreJSONRequestBody = CrtStore

// CreateDefaultsSectionJSONRequestBody defines body for CreateDefaultsSection for application/json ContentType.
type CreateDefaultsSectionJSONRequestBody = Defaults

// ReplaceDefaultsSectionJSONRequestBody defines body for ReplaceDefaultsSection for application/json ContentType.
type ReplaceDefaultsSectionJSONRequestBody = Defaults

// ReplaceAllHTTPCheckDefaultsJSONRequestBody defines body for ReplaceAllHTTPCheckDefaults for application/json ContentType.
type ReplaceAllHTTPCheckDefaultsJSONRequestBody = HttpChecks

// CreateHTTPCheckDefaultsJSONRequestBody defines body for CreateHTTPCheckDefaults for application/json ContentType.
type CreateHTTPCheckDefaultsJSONRequestBody = HttpCheck

// ReplaceHTTPCheckDefaultsJSONRequestBody defines body for ReplaceHTTPCheckDefaults for application/json ContentType.
type ReplaceHTTPCheckDefaultsJSONRequestBody = HttpCheck

// ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody defines body for ReplaceAllHTTPErrorRuleDefaults for application/json ContentType.
type ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody = HttpErrorRules

// CreateHTTPErrorRuleDefaultsJSONRequestBody defines body for CreateHTTPErrorRuleDefaults for application/json ContentType.
type CreateHTTPErrorRuleDefaultsJSONRequestBody = HttpErrorRule

// ReplaceHTTPErrorRuleDefaultsJSONRequestBody defines body for ReplaceHTTPErrorRuleDefaults for application/json ContentType.
type ReplaceHTTPErrorRuleDefaultsJSONRequestBody = HttpErrorRule

// ReplaceAllLogTargetDefaultsJSONRequestBody defines body for ReplaceAllLogTargetDefaults for application/json ContentType.
type ReplaceAllLogTargetDefaultsJSONRequestBody = LogTargets

// CreateLogTargetDefaultsJSONRequestBody defines body for CreateLogTargetDefaults for application/json ContentType.
type CreateLogTargetDefaultsJSONRequestBody = LogTarget

// ReplaceLogTargetDefaultsJSONRequestBody defines body for ReplaceLogTargetDefaults for application/json ContentType.
type ReplaceLogTargetDefaultsJSONRequestBody = LogTarget

// ReplaceAllTCPCheckDefaultsJSONRequestBody defines body for ReplaceAllTCPCheckDefaults for application/json ContentType.
type ReplaceAllTCPCheckDefaultsJSONRequestBody = TcpChecks

// CreateTCPCheckDefaultsJSONRequestBody defines body for CreateTCPCheckDefaults for application/json ContentType.
type CreateTCPCheckDefaultsJSONRequestBody = TcpCheck

// ReplaceTCPCheckDefaultsJSONRequestBody defines body for ReplaceTCPCheckDefaults for application/json ContentType.
type ReplaceTCPCheckDefaultsJSONRequestBody = TcpCheck

// ReplaceDynamicUpdateRulesJSONRequestBody defines body for ReplaceDynamicUpdateRules for application/json ContentType.
type ReplaceDynamicUpdateRulesJSONRequestBody = DynamicUpdateRules

// CreateDynamicUpdateRuleJSONRequestBody defines body for CreateDynamicUpdateRule for application/json ContentType.
type CreateDynamicUpdateRuleJSONRequestBody = DynamicUpdateRule

// ReplaceDynamicUpdateRuleJSONRequestBody defines body for ReplaceDynamicUpdateRule for application/json ContentType.
type ReplaceDynamicUpdateRuleJSONRequestBody = DynamicUpdateRule

// CreateFCGIAppJSONRequestBody defines body for CreateFCGIApp for application/json ContentType.
type CreateFCGIAppJSONRequestBody = FCGIApp

// ReplaceFCGIAppJSONRequestBody defines body for ReplaceFCGIApp for application/json ContentType.
type ReplaceFCGIAppJSONRequestBody = FCGIApp

// ReplaceAllAclFCGIAppJSONRequestBody defines body for ReplaceAllAclFCGIApp for application/json ContentType.
type ReplaceAllAclFCGIAppJSONRequestBody = Acls

// CreateAclFCGIAppJSONRequestBody defines body for CreateAclFCGIApp for application/json ContentType.
type CreateAclFCGIAppJSONRequestBody = Acl

// ReplaceAclFCGIAppJSONRequestBody defines body for ReplaceAclFCGIApp for application/json ContentType.
type ReplaceAclFCGIAppJSONRequestBody = Acl

// CreateFrontendJSONRequestBody defines body for CreateFrontend for application/json ContentType.
type CreateFrontendJSONRequestBody = Frontend

// ReplaceFrontendJSONRequestBody defines body for ReplaceFrontend for application/json ContentType.
type ReplaceFrontendJSONRequestBody = Frontend

// ReplaceAllAclFrontendJSONRequestBody defines body for ReplaceAllAclFrontend for application/json ContentType.
type ReplaceAllAclFrontendJSONRequestBody = Acls

// CreateAclFrontendJSONRequestBody defines body for CreateAclFrontend for application/json ContentType.
type CreateAclFrontendJSONRequestBody = Acl

// ReplaceAclFrontendJSONRequestBody defines body for ReplaceAclFrontend for application/json ContentType.
type ReplaceAclFrontendJSONRequestBody = Acl

// ReplaceBackendSwitchingRulesJSONRequestBody defines body for ReplaceBackendSwitchingRules for application/json ContentType.
type ReplaceBackendSwitchingRulesJSONRequestBody = BackendSwitchingRules

// CreateBackendSwitchingRuleJSONRequestBody defines body for CreateBackendSwitchingRule for application/json ContentType.
type CreateBackendSwitchingRuleJSONRequestBody = BackendSwitchingRule

// ReplaceBackendSwitchingRuleJSONRequestBody defines body for ReplaceBackendSwitchingRule for application/json ContentType.
type ReplaceBackendSwitchingRuleJSONRequestBody = BackendSwitchingRule

// CreateBindFrontendJSONRequestBody defines body for CreateBindFrontend for application/json ContentType.
type CreateBindFrontendJSONRequestBody = Bind

// ReplaceBindFrontendJSONRequestBody defines body for ReplaceBindFrontend for application/json ContentType.
type ReplaceBindFrontendJSONRequestBody = Bind

// ReplaceDeclareCapturesJSONRequestBody defines body for ReplaceDeclareCaptures for application/json ContentType.
type ReplaceDeclareCapturesJSONRequestBody = Captures

// CreateDeclareCaptureJSONRequestBody defines body for CreateDeclareCapture for application/json ContentType.
type CreateDeclareCaptureJSONRequestBody = Capture

// ReplaceDeclareCaptureJSONRequestBody defines body for ReplaceDeclareCapture for application/json ContentType.
type ReplaceDeclareCaptureJSONRequestBody = Capture

// ReplaceAllFilterFrontendJSONRequestBody defines body for ReplaceAllFilterFrontend for application/json ContentType.
type ReplaceAllFilterFrontendJSONRequestBody = Filters

// CreateFilterFrontendJSONRequestBody defines body for CreateFilterFrontend for application/json ContentType.
type CreateFilterFrontendJSONRequestBody = Filter

// ReplaceFilterFrontendJSONRequestBody defines body for ReplaceFilterFrontend for application/json ContentType.
type ReplaceFilterFrontendJSONRequestBody = Filter

// ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPAfterResponseRuleFrontend for application/json ContentType.
type ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody = HttpAfterResponseRules

// CreateHTTPAfterResponseRuleFrontendJSONRequestBody defines body for CreateHTTPAfterResponseRuleFrontend for application/json ContentType.
type CreateHTTPAfterResponseRuleFrontendJSONRequestBody = HttpAfterResponseRule

// ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody defines body for ReplaceHTTPAfterResponseRuleFrontend for application/json ContentType.
type ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody = HttpAfterResponseRule

// ReplaceAllHTTPErrorRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPErrorRuleFrontend for application/json ContentType.
type ReplaceAllHTTPErrorRuleFrontendJSONRequestBody = HttpErrorRules

// CreateHTTPErrorRuleFrontendJSONRequestBody defines body for CreateHTTPErrorRuleFrontend for application/json ContentType.
type CreateHTTPErrorRuleFrontendJSONRequestBody = HttpErrorRule

// ReplaceHTTPErrorRuleFrontendJSONRequestBody defines body for ReplaceHTTPErrorRuleFrontend for application/json ContentType.
type ReplaceHTTPErrorRuleFrontendJSONRequestBody = HttpErrorRule

// ReplaceAllHTTPRequestRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPRequestRuleFrontend for application/json ContentType.
type ReplaceAllHTTPRequestRuleFrontendJSONRequestBody = HttpRequestRules

// CreateHTTPRequestRuleFrontendJSONRequestBody defines body for CreateHTTPRequestRuleFrontend for application/json ContentType.
type CreateHTTPRequestRuleFrontendJSONRequestBody = HttpRequestRule

// ReplaceHTTPRequestRuleFrontendJSONRequestBody defines body for ReplaceHTTPRequestRuleFrontend for application/json ContentType.
type ReplaceHTTPRequestRuleFrontendJSONRequestBody = HttpRequestRule

// ReplaceAllHTTPResponseRuleFrontendJSONRequestBody defines body for ReplaceAllHTTPResponseRuleFrontend for application/json ContentType.
type ReplaceAllHTTPResponseRuleFrontendJSONRequestBody = HttpResponseRules

// CreateHTTPResponseRuleFrontendJSONRequestBody defines body for CreateHTTPResponseRuleFrontend for application/json ContentType.
type CreateHTTPResponseRuleFrontendJSONRequestBody = HttpResponseRule

// ReplaceHTTPResponseRuleFrontendJSONRequestBody defines body for ReplaceHTTPResponseRuleFrontend for application/json ContentType.
type ReplaceHTTPResponseRuleFrontendJSONRequestBody = HttpResponseRule

// ReplaceAllLogTargetFrontendJSONRequestBody defines body for ReplaceAllLogTargetFrontend for application/json ContentType.
type ReplaceAllLogTargetFrontendJSONRequestBody = LogTargets

// CreateLogTargetFrontendJSONRequestBody defines body for CreateLogTargetFrontend for application/json ContentType.
type CreateLogTargetFrontendJSONRequestBody = LogTarget

// ReplaceLogTargetFrontendJSONRequestBody defines body for ReplaceLogTargetFrontend for application/json ContentType.
type ReplaceLogTargetFrontendJSONRequestBody = LogTarget

// ReplaceAllTCPRequestRuleFrontendJSONRequestBody defines body for ReplaceAllTCPRequestRuleFrontend for application/json ContentType.
type ReplaceAllTCPRequestRuleFrontendJSONRequestBody = TcpRequestRules

// CreateTCPRequestRuleFrontendJSONRequestBody defines body for CreateTCPRequestRuleFrontend for application/json ContentType.
type CreateTCPRequestRuleFrontendJSONRequestBody = TcpRequestRule

// ReplaceTCPRequestRuleFrontendJSONRequestBody defines body for ReplaceTCPRequestRuleFrontend for application/json ContentType.
type ReplaceTCPRequestRuleFrontendJSONRequestBody = TcpRequestRule

// ReplaceAllWafBodyRuleFrontendJSONRequestBody defines body for ReplaceAllWafBodyRuleFrontend for application/json ContentType.
type ReplaceAllWafBodyRuleFrontendJSONRequestBody = WafBodyRules

// CreateWafBodyRuleFrontendJSONRequestBody defines body for CreateWafBodyRuleFrontend for application/json ContentType.
type CreateWafBodyRuleFrontendJSONRequestBody = WafBodyRule

// ReplaceWafBodyRuleFrontendJSONRequestBody defines body for ReplaceWafBodyRuleFrontend for application/json ContentType.
type ReplaceWafBodyRuleFrontendJSONRequestBody = WafBodyRule

// ReplaceGlobalJSONRequestBody defines body for ReplaceGlobal for application/json ContentType.
type ReplaceGlobalJSONRequestBody = Global

// ReplaceAllLogTargetGlobalJSONRequestBody defines body for ReplaceAllLogTargetGlobal for application/json ContentType.
type ReplaceAllLogTargetGlobalJSONRequestBody = LogTargets

// CreateLogTargetGlobalJSONRequestBody defines body for CreateLogTargetGlobal for application/json ContentType.
type CreateLogTargetGlobalJSONRequestBody = LogTarget

// ReplaceLogTargetGlobalJSONRequestBody defines body for ReplaceLogTargetGlobal for application/json ContentType.
type ReplaceLogTargetGlobalJSONRequestBody = LogTarget

// CreateGroupJSONRequestBody defines body for CreateGroup for application/json ContentType.
type CreateGroupJSONRequestBody = Group

// ReplaceGroupJSONRequestBody defines body for ReplaceGroup for application/json ContentType.
type ReplaceGroupJSONRequestBody = Group

// CreateHTTPErrorsSectionJSONRequestBody defines body for CreateHTTPErrorsSection for application/json ContentType.
type CreateHTTPErrorsSectionJSONRequestBody = HttpErrorsSection

// ReplaceHTTPErrorsSectionJSONRequestBody defines body for ReplaceHTTPErrorsSection for application/json ContentType.
type ReplaceHTTPErrorsSectionJSONRequestBody = HttpErrorsSection

// CreateLogForwardJSONRequestBody defines body for CreateLogForward for application/json ContentType.
type CreateLogForwardJSONRequestBody = LogForward

// ReplaceLogForwardJSONRequestBody defines body for ReplaceLogForward for application/json ContentType.
type ReplaceLogForwardJSONRequestBody = LogForward

// CreateBindLogForwardJSONRequestBody defines body for CreateBindLogForward for application/json ContentType.
type CreateBindLogForwardJSONRequestBody = Bind

// ReplaceBindLogForwardJSONRequestBody defines body for ReplaceBindLogForward for application/json ContentType.
type ReplaceBindLogForwardJSONRequestBody = Bind

// CreateDgramBindLogForwardJSONRequestBody defines body for CreateDgramBindLogForward for application/json ContentType.
type CreateDgramBindLogForwardJSONRequestBody = DgramBind

// ReplaceDgramBindLogForwardJSONRequestBody defines body for ReplaceDgramBindLogForward for application/json ContentType.
type ReplaceDgramBindLogForwardJSONRequestBody = DgramBind

// ReplaceAllLogTargetLogForwardJSONRequestBody defines body for ReplaceAllLogTargetLogForward for application/json ContentType.
type ReplaceAllLogTargetLogForwardJSONRequestBody = LogTargets

// CreateLogTargetLogForwardJSONRequestBody defines body for CreateLogTargetLogForward for application/json ContentType.
type CreateLogTargetLogForwardJSONRequestBody = LogTarget

// ReplaceLogTargetLogForwardJSONRequestBody defines body for ReplaceLogTargetLogForward for application/json ContentType.
type ReplaceLogTargetLogForwardJSONRequestBody = LogTarget

// CreateMailerEntryJSONRequestBody defines body for CreateMailerEntry for application/json ContentType.
type CreateMailerEntryJSONRequestBody = MailerEntry

// ReplaceMailerEntryJSONRequestBody defines body for ReplaceMailerEntry for application/json ContentType.
type ReplaceMailerEntryJSONRequestBody = MailerEntry

// CreateMailersSectionJSONRequestBody defines body for CreateMailersSection for application/json ContentType.
type CreateMailersSectionJSONRequestBody = MailersSection

// EditMailersSectionJSONRequestBody defines body for EditMailersSection for application/json ContentType.
type EditMailersSectionJSONRequestBody = MailersSection

// CreateNameserverJSONRequestBody defines body for CreateNameserver for application/json ContentType.
type CreateNameserverJSONRequestBody = Nameserver

// ReplaceNameserverJSONRequestBody defines body for ReplaceNameserver for application/json ContentType.
type ReplaceNameserverJSONRequestBody = Nameserver

// CreatePeerEntryJSONRequestBody defines body for CreatePeerEntry for application/json ContentType.
type CreatePeerEntryJSONRequestBody = PeerEntry

// ReplacePeerEntryJSONRequestBody defines body for ReplacePeerEntry for application/json ContentType.
type ReplacePeerEntryJSONRequestBody = PeerEntry

// CreatePeerJSONRequestBody defines body for CreatePeer for application/json ContentType.
type CreatePeerJSONRequestBody = PeerSection

// CreateBindPeerJSONRequestBody defines body for CreateBindPeer for application/json ContentType.
type CreateBindPeerJSONRequestBody = Bind

// ReplaceBindPeerJSONRequestBody defines body for ReplaceBindPeer for application/json ContentType.
type ReplaceBindPeerJSONRequestBody = Bind

// ReplaceAllLogTargetPeerJSONRequestBody defines body for ReplaceAllLogTargetPeer for application/json ContentType.
type ReplaceAllLogTargetPeerJSONRequestBody = LogTargets

// CreateLogTargetPeerJSONRequestBody defines body for CreateLogTargetPeer for application/json ContentType.
type CreateLogTargetPeerJSONRequestBody = LogTarget

// ReplaceLogTargetPeerJSONRequestBody defines body for ReplaceLogTargetPeer for application/json ContentType.
type ReplaceLogTargetPeerJSONRequestBody = LogTarget

// CreateServerPeerJSONRequestBody defines body for CreateServerPeer for application/json ContentType.
type CreateServerPeerJSONRequestBody = Server

// ReplaceServerPeerJSONRequestBody defines body for ReplaceServerPeer for application/json ContentType.
type ReplaceServerPeerJSONRequestBody = Server

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody = Table

// ReplaceTableJSONRequestBody defines body for ReplaceTable for application/json ContentType.
type ReplaceTableJSONRequestBody = Table

// CreateProgramJSONRequestBody defines body for CreateProgram for application/json ContentType.
type CreateProgramJSONRequestBody = Program

// ReplaceProgramJSONRequestBody defines body for ReplaceProgram for application/json ContentType.
type ReplaceProgramJSONRequestBody = Program

// PostHAProxyConfigurationTextRequestBody defines body for PostHAProxyConfiguration for text/plain ContentType.
type PostHAProxyConfigurationTextRequestBody = PostHAProxyConfigurationTextBody

// CreateResolverJSONRequestBody defines body for CreateResolver for application/json ContentType.
type CreateResolverJSONRequestBody = Resolver

// ReplaceResolverJSONRequestBody defines body for ReplaceResolver for application/json ContentType.
type ReplaceResolverJSONRequestBody = Resolver

// CreateRingJSONRequestBody defines body for CreateRing for application/json ContentType.
type CreateRingJSONRequestBody = Ring

// ReplaceRingJSONRequestBody defines body for ReplaceRing for application/json ContentType.
type ReplaceRingJSONRequestBody = Ring

// CreateServerRingJSONRequestBody defines body for CreateServerRing for application/json ContentType.
type CreateServerRingJSONRequestBody = Server

// ReplaceServerRingJSONRequestBody defines body for ReplaceServerRing for application/json ContentType.
type ReplaceServerRingJSONRequestBody = Server

// ReplaceStructuredJSONRequestBody defines body for ReplaceStructured for application/json ContentType.
type ReplaceStructuredJSONRequestBody = Structured

// CreateUDPLbJSONRequestBody defines body for CreateUDPLb for application/json ContentType.
type CreateUDPLbJSONRequestBody = UDPLb

// ReplaceUDPLbJSONRequestBody defines body for ReplaceUDPLb for application/json ContentType.
type ReplaceUDPLbJSONRequestBody = UDPLb

// CreateDgramBindUDPLbJSONRequestBody defines body for CreateDgramBindUDPLb for application/json ContentType.
type CreateDgramBindUDPLbJSONRequestBody = DgramBind

// ReplaceDgramBindUDPLbJSONRequestBody defines body for ReplaceDgramBindUDPLb for application/json ContentType.
type ReplaceDgramBindUDPLbJSONRequestBody = DgramBind

// ReplaceAllLogTargetUDPLbJSONRequestBody defines body for ReplaceAllLogTargetUDPLb for application/json ContentType.
type ReplaceAllLogTargetUDPLbJSONRequestBody = LogTargets

// CreateLogTargetUDPLbJSONRequestBody defines body for CreateLogTargetUDPLb for application/json ContentType.
type CreateLogTargetUDPLbJSONRequestBody = LogTarget

// ReplaceLogTargetUDPLbJSONRequestBody defines body for ReplaceLogTargetUDPLb for application/json ContentType.
type ReplaceLogTargetUDPLbJSONRequestBody = LogTarget

// CreateUserlistJSONRequestBody defines body for CreateUserlist for application/json ContentType.
type CreateUserlistJSONRequestBody = Userlist

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody = User

// ReplaceUserJSONRequestBody defines body for ReplaceUser for application/json ContentType.
type ReplaceUserJSONRequestBody = User

// ReplaceLogConfigJSONRequestBody defines body for ReplaceLogConfig for application/json ContentType.
type ReplaceLogConfigJSONRequestBody = LogConfiguration

// CreateLogInputJSONRequestBody defines body for CreateLogInput for application/json ContentType.
type CreateLogInputJSONRequestBody = LogInput

// ReplaceLogInputJSONRequestBody defines body for ReplaceLogInput for application/json ContentType.
type ReplaceLogInputJSONRequestBody = LogInput

// CreateLogOutputJSONRequestBody defines body for CreateLogOutput for application/json ContentType.
type CreateLogOutputJSONRequestBody = LogOutput

// ReplaceLogOutputJSONRequestBody defines body for ReplaceLogOutput for application/json ContentType.
type ReplaceLogOutputJSONRequestBody = LogOutput

// PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody defines body for PostServicesHaproxyRuntimeAclsParentNameEntries for application/json ContentType.
type PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody = AclFileEntry

// AddPayloadRuntimeACLJSONRequestBody defines body for AddPayloadRuntimeACL for application/json ContentType.
type AddPayloadRuntimeACLJSONRequestBody = AclFilesEntries

// AddRuntimeServerJSONRequestBody defines body for AddRuntimeServer for application/json ContentType.
type AddRuntimeServerJSONRequestBody = RuntimeAddServer

// ReplaceRuntimeServerJSONRequestBody defines body for ReplaceRuntimeServer for application/json ContentType.
type ReplaceRuntimeServerJSONRequestBody = RuntimeServer

// AddPayloadRuntimeMapJSONRequestBody defines body for AddPayloadRuntimeMap for application/json ContentType.
type AddPayloadRuntimeMapJSONRequestBody = MapEntries

// AddMapEntryJSONRequestBody defines body for AddMapEntry for application/json ContentType.
type AddMapEntryJSONRequestBody = MapEntry

// ReplaceRuntimeMapEntryJSONRequestBody defines body for ReplaceRuntimeMapEntry for application/json ContentType.
type ReplaceRuntimeMapEntryJSONRequestBody ReplaceRuntimeMapEntryJSONBody

// SetStickTableEntriesJSONRequestBody defines body for SetStickTableEntries for application/json ContentType.
type SetStickTableEntriesJSONRequestBody SetStickTableEntriesJSONBody

// CreateSiteJSONRequestBody defines body for CreateSite for application/json ContentType.
type CreateSiteJSONRequestBody = Site

// ReplaceSiteJSONRequestBody defines body for ReplaceSite for application/json ContentType.
type ReplaceSiteJSONRequestBody = Site

// CreateSpoeMultipartRequestBody defines body for CreateSpoe for multipart/form-data ContentType.
type CreateSpoeMultipartRequestBody CreateSpoeMultipartBody

// CreateSpoeScopeJSONRequestBody defines body for CreateSpoeScope for application/json ContentType.
type CreateSpoeScopeJSONRequestBody = SpoeScope

// CreateSpoeAgentJSONRequestBody defines body for CreateSpoeAgent for application/json ContentType.
type CreateSpoeAgentJSONRequestBody = SpoeAgent

// ReplaceSpoeAgentJSONRequestBody defines body for ReplaceSpoeAgent for application/json ContentType.
type ReplaceSpoeAgentJSONRequestBody = SpoeAgent

// CreateSpoeGroupJSONRequestBody defines body for CreateSpoeGroup for application/json ContentType.
type CreateSpoeGroupJSONRequestBody = SpoeGroup

// ReplaceSpoeGroupJSONRequestBody defines body for ReplaceSpoeGroup for application/json ContentType.
type ReplaceSpoeGroupJSONRequestBody = SpoeGroup

// CreateSpoeMessageJSONRequestBody defines body for CreateSpoeMessage for application/json ContentType.
type CreateSpoeMessageJSONRequestBody = SpoeMessage

// ReplaceSpoeMessageJSONRequestBody defines body for ReplaceSpoeMessage for application/json ContentType.
type ReplaceSpoeMessageJSONRequestBody = SpoeMessage

// CreateStorageGeneralFileMultipartRequestBody defines body for CreateStorageGeneralFile for multipart/form-data ContentType.
type CreateStorageGeneralFileMultipartRequestBody CreateStorageGeneralFileMultipartBody

// ReplaceStorageGeneralFileMultipartRequestBody defines body for ReplaceStorageGeneralFile for multipart/form-data ContentType.
type ReplaceStorageGeneralFileMultipartRequestBody ReplaceStorageGeneralFileMultipartBody

// CreateStorageMapFileMultipartRequestBody defines body for CreateStorageMapFile for multipart/form-data ContentType.
type CreateStorageMapFileMultipartRequestBody CreateStorageMapFileMultipartBody

// ReplaceStorageMapFileTextRequestBody defines body for ReplaceStorageMapFile for text/plain ContentType.
type ReplaceStorageMapFileTextRequestBody = ReplaceStorageMapFileTextBody

// CreateStorageSSLCertificateMultipartRequestBody defines body for CreateStorageSSLCertificate for multipart/form-data ContentType.
type CreateStorageSSLCertificateMultipartRequestBody CreateStorageSSLCertificateMultipartBody

// ReplaceStorageSSLCertificateTextRequestBody defines body for ReplaceStorageSSLCertificate for text/plain ContentType.
type ReplaceStorageSSLCertificateTextRequestBody = ReplaceStorageSSLCertificateTextBody

// CreateWafRulesetMultipartRequestBody defines body for CreateWafRuleset for multipart/form-data ContentType.
type CreateWafRulesetMultipartRequestBody CreateWafRulesetMultipartBody

// ReplaceWafRulesetMultipartRequestBody defines body for ReplaceWafRuleset for multipart/form-data ContentType.
type ReplaceWafRulesetMultipartRequestBody ReplaceWafRulesetMultipartBody

// CreateWafFileMultipartRequestBody defines body for CreateWafFile for multipart/form-data ContentType.
type CreateWafFileMultipartRequestBody CreateWafFileMultipartBody

// ReplaceWafFileTextRequestBody defines body for ReplaceWafFile for text/plain ContentType.
type ReplaceWafFileTextRequestBody = ReplaceWafFileTextBody

// ReplaceGlobalDefsJSONRequestBody defines body for ReplaceGlobalDefs for application/json ContentType.
type ReplaceGlobalDefsJSONRequestBody = VrrpGlobalDefs

// ReplaceKeepalivedConfigurationTextRequestBody defines body for ReplaceKeepalivedConfiguration for text/plain ContentType.
type ReplaceKeepalivedConfigurationTextRequestBody = ReplaceKeepalivedConfigurationTextBody

// CreateVRRPInstanceJSONRequestBody defines body for CreateVRRPInstance for application/json ContentType.
type CreateVRRPInstanceJSONRequestBody = VrrpInstance

// ReplaceVRRPInstanceJSONRequestBody defines body for ReplaceVRRPInstance for application/json ContentType.
type ReplaceVRRPInstanceJSONRequestBody = VrrpInstance

// CreateVRRPSyncGroupJSONRequestBody defines body for CreateVRRPSyncGroup for application/json ContentType.
type CreateVRRPSyncGroupJSONRequestBody = VrrpSyncGroup

// ReplaceVRRPSyncGroupJSONRequestBody defines body for ReplaceVRRPSyncGroup for application/json ContentType.
type ReplaceVRRPSyncGroupJSONRequestBody = VrrpSyncGroup

// CreateVRRPScriptJSONRequestBody defines body for CreateVRRPScript for application/json ContentType.
type CreateVRRPScriptJSONRequestBody = VrrpTrackScript

// ReplaceVRRPScriptJSONRequestBody defines body for ReplaceVRRPScript for application/json ContentType.
type ReplaceVRRPScriptJSONRequestBody = VrrpTrackScript

// Getter for additional properties for Error. Returns the specified
// element and whether it was found
func (a Error) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Error
func (a *Error) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Error to handle AdditionalProperties
func (a *Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["code"]; found {
		err = json.Unmarshal(raw, &a.Code)
		if err != nil {
			return fmt.Errorf("error reading 'code': %w", err)
		}
		delete(object, "code")
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["sha"]; found {
		err = json.Unmarshal(raw, &a.Sha)
		if err != nil {
			return fmt.Errorf("error reading 'sha': %w", err)
		}
		delete(object, "sha")
	}

	if raw, found := object["uid"]; found {
		err = json.Unmarshal(raw, &a.Uid)
		if err != nil {
			return fmt.Errorf("error reading 'uid': %w", err)
		}
		delete(object, "uid")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Error to handle AdditionalProperties
func (a Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["code"], err = json.Marshal(a.Code)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'code': %w", err)
	}

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	if a.Sha != nil {
		object["sha"], err = json.Marshal(a.Sha)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sha': %w", err)
		}
	}

	if a.Uid != nil {
		object["uid"], err = json.Marshal(a.Uid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'uid': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAPIEndpoints request
	GetAPIEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlohaEndpoints request
	GetAlohaEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlohaActions request
	GetAlohaActions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteAlohaActionWithBody request with any body
	ExecuteAlohaActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteAlohaAction(ctx context.Context, body ExecuteAlohaActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAlohaAction request
	GetAlohaAction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostClusterWithBody request with any body
	PostClusterWithBody(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCluster(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditClusterWithBody request with any body
	EditClusterWithBody(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCluster(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InitiateCertificateRefresh request
	InitiateCertificateRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFacts request
	GetFacts(ctx context.Context, params *GetFactsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHealth request
	GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInfo request
	GetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAWSRegions request
	GetAWSRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAWSRegionWithBody request with any body
	CreateAWSRegionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAWSRegion(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAWSRegion request
	DeleteAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAWSRegion request
	GetAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAWSRegionWithBody request with any body
	ReplaceAWSRegionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAWSRegion(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsuls request
	GetConsuls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConsulWithBody request with any body
	CreateConsulWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConsul(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConsul request
	DeleteConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConsul request
	GetConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceConsulWithBody request with any body
	ReplaceConsulWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceConsul(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesEndpoints request
	GetServicesEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunActionsWithBody request with any body
	RunActionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunActions(ctx context.Context, body RunActionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGitEndpoints request
	GetGitEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGitActions request
	GetGitActions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExecuteGitActionWithBody request with any body
	ExecuteGitActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExecuteGitAction(ctx context.Context, body ExecuteGitActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGitAction request
	GetGitAction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGitSettings request
	GetGitSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceGitSettingsWithBody request with any body
	ReplaceGitSettingsWithBody(ctx context.Context, params *ReplaceGitSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceGitSettings(ctx context.Context, params *ReplaceGitSettingsParams, body ReplaceGitSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHaproxyEndpoints request
	GetHaproxyEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationEndpoints request
	GetConfigurationEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackends request
	GetBackends(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackendWithBody request with any body
	CreateBackendWithBody(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackend(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackend request
	DeleteBackend(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackend request
	GetBackend(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBackendWithBody request with any body
	ReplaceBackendWithBody(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBackend(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclBackend request
	GetAllAclBackend(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclBackendWithBody request with any body
	ReplaceAllAclBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclBackend(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclBackend request
	DeleteAclBackend(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclBackend request
	GetAclBackend(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclBackendWithBody request with any body
	CreateAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclBackend(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclBackendWithBody request with any body
	ReplaceAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllFilterBackend request
	GetAllFilterBackend(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllFilterBackendWithBody request with any body
	ReplaceAllFilterBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllFilterBackend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilterBackend request
	DeleteFilterBackend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterBackend request
	GetFilterBackend(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFilterBackendWithBody request with any body
	CreateFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFilterBackend(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFilterBackendWithBody request with any body
	ReplaceFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFilterBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPAfterResponseRuleBackend request
	GetAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPAfterResponseRuleBackendWithBody request with any body
	ReplaceAllHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPAfterResponseRuleBackend request
	DeleteHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPAfterResponseRuleBackend request
	GetHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPAfterResponseRuleBackendWithBody request with any body
	CreateHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPAfterResponseRuleBackendWithBody request with any body
	ReplaceHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPCheckBackend request
	GetAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPCheckBackendWithBody request with any body
	ReplaceAllHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPCheckBackend request
	DeleteHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPCheckBackend request
	GetHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPCheckBackendWithBody request with any body
	CreateHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPCheckBackendWithBody request with any body
	ReplaceHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPErrorRuleBackend request
	GetAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPErrorRuleBackendWithBody request with any body
	ReplaceAllHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorRuleBackend request
	DeleteHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorRuleBackend request
	GetHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorRuleBackendWithBody request with any body
	CreateHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorRuleBackendWithBody request with any body
	ReplaceHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPRequestRuleBackend request
	GetAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPRequestRuleBackendWithBody request with any body
	ReplaceAllHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPRequestRuleBackend request
	DeleteHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPRequestRuleBackend request
	GetHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPRequestRuleBackendWithBody request with any body
	CreateHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPRequestRuleBackendWithBody request with any body
	ReplaceHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPResponseRuleBackend request
	GetAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPResponseRuleBackendWithBody request with any body
	ReplaceAllHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPResponseRuleBackend request
	DeleteHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPResponseRuleBackend request
	GetHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPResponseRuleBackendWithBody request with any body
	CreateHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPResponseRuleBackendWithBody request with any body
	ReplaceHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetBackend request
	GetAllLogTargetBackend(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetBackendWithBody request with any body
	ReplaceAllLogTargetBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetBackend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetBackend request
	DeleteLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetBackend request
	GetLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetBackendWithBody request with any body
	CreateLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetBackendWithBody request with any body
	ReplaceLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerSwitchingRules request
	GetServerSwitchingRules(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerSwitchingRulesWithBody request with any body
	ReplaceServerSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerSwitchingRule request
	DeleteServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerSwitchingRule request
	GetServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerSwitchingRuleWithBody request with any body
	CreateServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerSwitchingRuleWithBody request with any body
	ReplaceServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerTemplates request
	GetServerTemplates(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerTemplateWithBody request with any body
	CreateServerTemplateWithBody(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerTemplate(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerTemplate request
	DeleteServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerTemplate request
	GetServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerTemplateWithBody request with any body
	ReplaceServerTemplateWithBody(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerBackend request
	GetAllServerBackend(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerBackendWithBody request with any body
	CreateServerBackendWithBody(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerBackend(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerBackend request
	DeleteServerBackend(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerBackend request
	GetServerBackend(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerBackendWithBody request with any body
	ReplaceServerBackendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerBackend(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickRules request
	GetStickRules(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStickRulesWithBody request with any body
	ReplaceStickRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStickRules(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStickRule request
	DeleteStickRule(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickRule request
	GetStickRule(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStickRuleWithBody request with any body
	CreateStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStickRule(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStickRuleWithBody request with any body
	ReplaceStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStickRule(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPCheckBackend request
	GetAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPCheckBackendWithBody request with any body
	ReplaceAllTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPCheckBackend request
	DeleteTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPCheckBackend request
	GetTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPCheckBackendWithBody request with any body
	CreateTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPCheckBackendWithBody request with any body
	ReplaceTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPRequestRuleBackend request
	GetAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPRequestRuleBackendWithBody request with any body
	ReplaceAllTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPRequestRuleBackend request
	DeleteTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPRequestRuleBackend request
	GetTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPRequestRuleBackendWithBody request with any body
	CreateTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPRequestRuleBackendWithBody request with any body
	ReplaceTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPResponseRuleBackend request
	GetAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPResponseRuleBackendWithBody request with any body
	ReplaceAllTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPResponseRuleBackend request
	DeleteTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPResponseRuleBackend request
	GetTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPResponseRuleBackendWithBody request with any body
	CreateTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPResponseRuleBackendWithBody request with any body
	ReplaceTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllWafBodyRuleBackend request
	GetAllWafBodyRuleBackend(ctx context.Context, parentName ParentName, params *GetAllWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllWafBodyRuleBackendWithBody request with any body
	ReplaceAllWafBodyRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllWafBodyRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, body ReplaceAllWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWafBodyRuleBackend request
	DeleteWafBodyRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWafBodyRuleBackend request
	GetWafBodyRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWafBodyRuleBackendWithBody request with any body
	CreateWafBodyRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWafBodyRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, body CreateWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceWafBodyRuleBackendWithBody request with any body
	ReplaceWafBodyRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceWafBodyRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, body ReplaceWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBotmgmtProfiles request
	GetBotmgmtProfiles(ctx context.Context, params *GetBotmgmtProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBotmgmtProfileWithBody request with any body
	CreateBotmgmtProfileWithBody(ctx context.Context, params *CreateBotmgmtProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBotmgmtProfile(ctx context.Context, params *CreateBotmgmtProfileParams, body CreateBotmgmtProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBotmgmtProfile request
	DeleteBotmgmtProfile(ctx context.Context, name string, params *DeleteBotmgmtProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBotmgmtProfile request
	GetBotmgmtProfile(ctx context.Context, name string, params *GetBotmgmtProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditBotmgmtProfileWithBody request with any body
	EditBotmgmtProfileWithBody(ctx context.Context, name string, params *EditBotmgmtProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditBotmgmtProfile(ctx context.Context, name string, params *EditBotmgmtProfileParams, body EditBotmgmtProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaches request
	GetCaches(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCacheWithBody request with any body
	CreateCacheWithBody(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCache(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCache request
	DeleteCache(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCache request
	GetCache(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceCacheWithBody request with any body
	ReplaceCacheWithBody(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceCache(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaptchas request
	GetCaptchas(ctx context.Context, params *GetCaptchasParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCaptchaWithBody request with any body
	CreateCaptchaWithBody(ctx context.Context, params *CreateCaptchaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCaptcha(ctx context.Context, params *CreateCaptchaParams, body CreateCaptchaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCaptcha request
	DeleteCaptcha(ctx context.Context, name string, params *DeleteCaptchaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaptcha request
	GetCaptcha(ctx context.Context, name string, params *GetCaptchaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCaptchaWithBody request with any body
	EditCaptchaWithBody(ctx context.Context, name string, params *EditCaptchaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCaptcha(ctx context.Context, name string, params *EditCaptchaParams, body EditCaptchaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClusterConfigurationVersion request
	GetClusterConfigurationVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtLoads request
	GetCrtLoads(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCrtLoadWithBody request with any body
	CreateCrtLoadWithBody(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCrtLoad(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCrtLoad request
	DeleteCrtLoad(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtLoad request
	GetCrtLoad(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceCrtLoadWithBody request with any body
	ReplaceCrtLoadWithBody(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceCrtLoad(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtStores request
	GetCrtStores(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCrtStoreWithBody request with any body
	CreateCrtStoreWithBody(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCrtStore(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCrtStore request
	DeleteCrtStore(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCrtStore request
	GetCrtStore(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCrtStoreWithBody request with any body
	EditCrtStoreWithBody(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCrtStore(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultsSections request
	GetDefaultsSections(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDefaultsSectionWithBody request with any body
	CreateDefaultsSectionWithBody(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDefaultsSection(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDefaultsSection request
	DeleteDefaultsSection(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultsSection request
	GetDefaultsSection(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDefaultsSectionWithBody request with any body
	ReplaceDefaultsSectionWithBody(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDefaultsSection(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPCheckDefaults request
	GetAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPCheckDefaultsWithBody request with any body
	ReplaceAllHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPCheckDefaults request
	DeleteHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPCheckDefaults request
	GetHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPCheckDefaultsWithBody request with any body
	CreateHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPCheckDefaultsWithBody request with any body
	ReplaceHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPErrorRuleDefaults request
	GetAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPErrorRuleDefaultsWithBody request with any body
	ReplaceAllHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorRuleDefaults request
	DeleteHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorRuleDefaults request
	GetHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorRuleDefaultsWithBody request with any body
	CreateHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorRuleDefaultsWithBody request with any body
	ReplaceHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetDefaults request
	GetAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetDefaultsWithBody request with any body
	ReplaceAllLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetDefaults request
	DeleteLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetDefaults request
	GetLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetDefaultsWithBody request with any body
	CreateLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetDefaultsWithBody request with any body
	ReplaceLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPCheckDefaults request
	GetAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPCheckDefaultsWithBody request with any body
	ReplaceAllTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPCheckDefaults request
	DeleteTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPCheckDefaults request
	GetTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPCheckDefaultsWithBody request with any body
	CreateTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPCheckDefaultsWithBody request with any body
	ReplaceTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDynamicUpdateRules request
	GetDynamicUpdateRules(ctx context.Context, params *GetDynamicUpdateRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDynamicUpdateRulesWithBody request with any body
	ReplaceDynamicUpdateRulesWithBody(ctx context.Context, params *ReplaceDynamicUpdateRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDynamicUpdateRules(ctx context.Context, params *ReplaceDynamicUpdateRulesParams, body ReplaceDynamicUpdateRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDynamicUpdateRule request
	DeleteDynamicUpdateRule(ctx context.Context, index int, params *DeleteDynamicUpdateRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDynamicUpdateRule request
	GetDynamicUpdateRule(ctx context.Context, index int, params *GetDynamicUpdateRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDynamicUpdateRuleWithBody request with any body
	CreateDynamicUpdateRuleWithBody(ctx context.Context, index int, params *CreateDynamicUpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDynamicUpdateRule(ctx context.Context, index int, params *CreateDynamicUpdateRuleParams, body CreateDynamicUpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDynamicUpdateRuleWithBody request with any body
	ReplaceDynamicUpdateRuleWithBody(ctx context.Context, index int, params *ReplaceDynamicUpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDynamicUpdateRule(ctx context.Context, index int, params *ReplaceDynamicUpdateRuleParams, body ReplaceDynamicUpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDynamicUpdateSection request
	DeleteDynamicUpdateSection(ctx context.Context, params *DeleteDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDynamicUpdateSection request
	GetDynamicUpdateSection(ctx context.Context, params *GetDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDynamicUpdateSection request
	CreateDynamicUpdateSection(ctx context.Context, params *CreateDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFCGIApps request
	GetFCGIApps(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFCGIAppWithBody request with any body
	CreateFCGIAppWithBody(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFCGIApp(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFCGIApp request
	DeleteFCGIApp(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFCGIApp request
	GetFCGIApp(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFCGIAppWithBody request with any body
	ReplaceFCGIAppWithBody(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFCGIApp(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclFCGIApp request
	GetAllAclFCGIApp(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclFCGIAppWithBody request with any body
	ReplaceAllAclFCGIAppWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclFCGIApp(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclFCGIApp request
	DeleteAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclFCGIApp request
	GetAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclFCGIAppWithBody request with any body
	CreateAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclFCGIAppWithBody request with any body
	ReplaceAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFrontends request
	GetFrontends(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFrontendWithBody request with any body
	CreateFrontendWithBody(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFrontend(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFrontend request
	DeleteFrontend(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFrontend request
	GetFrontend(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFrontendWithBody request with any body
	ReplaceFrontendWithBody(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFrontend(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllAclFrontend request
	GetAllAclFrontend(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllAclFrontendWithBody request with any body
	ReplaceAllAclFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllAclFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAclFrontend request
	DeleteAclFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAclFrontend request
	GetAclFrontend(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAclFrontendWithBody request with any body
	CreateAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAclFrontend(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAclFrontendWithBody request with any body
	ReplaceAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAclFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackendSwitchingRules request
	GetBackendSwitchingRules(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBackendSwitchingRulesWithBody request with any body
	ReplaceBackendSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBackendSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBackendSwitchingRule request
	DeleteBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackendSwitchingRule request
	GetBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackendSwitchingRuleWithBody request with any body
	CreateBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBackendSwitchingRuleWithBody request with any body
	ReplaceBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBindFrontend request
	GetAllBindFrontend(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBindFrontendWithBody request with any body
	CreateBindFrontendWithBody(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBindFrontend(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBindFrontend request
	DeleteBindFrontend(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindFrontend request
	GetBindFrontend(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBindFrontendWithBody request with any body
	ReplaceBindFrontendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBindFrontend(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeclareCaptures request
	GetDeclareCaptures(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDeclareCapturesWithBody request with any body
	ReplaceDeclareCapturesWithBody(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDeclareCaptures(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDeclareCapture request
	DeleteDeclareCapture(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDeclareCapture request
	GetDeclareCapture(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDeclareCaptureWithBody request with any body
	CreateDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDeclareCapture(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDeclareCaptureWithBody request with any body
	ReplaceDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDeclareCapture(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllFilterFrontend request
	GetAllFilterFrontend(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllFilterFrontendWithBody request with any body
	ReplaceAllFilterFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllFilterFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFilterFrontend request
	DeleteFilterFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFilterFrontend request
	GetFilterFrontend(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFilterFrontendWithBody request with any body
	CreateFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFilterFrontend(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceFilterFrontendWithBody request with any body
	ReplaceFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceFilterFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPAfterResponseRuleFrontend request
	GetAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPAfterResponseRuleFrontendWithBody request with any body
	ReplaceAllHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPAfterResponseRuleFrontend request
	DeleteHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPAfterResponseRuleFrontend request
	GetHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPAfterResponseRuleFrontendWithBody request with any body
	CreateHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPAfterResponseRuleFrontendWithBody request with any body
	ReplaceHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPErrorRuleFrontend request
	GetAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPErrorRuleFrontendWithBody request with any body
	ReplaceAllHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorRuleFrontend request
	DeleteHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorRuleFrontend request
	GetHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorRuleFrontendWithBody request with any body
	CreateHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorRuleFrontendWithBody request with any body
	ReplaceHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPRequestRuleFrontend request
	GetAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPRequestRuleFrontendWithBody request with any body
	ReplaceAllHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPRequestRuleFrontend request
	DeleteHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPRequestRuleFrontend request
	GetHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPRequestRuleFrontendWithBody request with any body
	CreateHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPRequestRuleFrontendWithBody request with any body
	ReplaceHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllHTTPResponseRuleFrontend request
	GetAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllHTTPResponseRuleFrontendWithBody request with any body
	ReplaceAllHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPResponseRuleFrontend request
	DeleteHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPResponseRuleFrontend request
	GetHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPResponseRuleFrontendWithBody request with any body
	CreateHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPResponseRuleFrontendWithBody request with any body
	ReplaceHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetFrontend request
	GetAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetFrontendWithBody request with any body
	ReplaceAllLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetFrontend request
	DeleteLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetFrontend request
	GetLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetFrontendWithBody request with any body
	CreateLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetFrontendWithBody request with any body
	ReplaceLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllTCPRequestRuleFrontend request
	GetAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllTCPRequestRuleFrontendWithBody request with any body
	ReplaceAllTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTCPRequestRuleFrontend request
	DeleteTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTCPRequestRuleFrontend request
	GetTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTCPRequestRuleFrontendWithBody request with any body
	CreateTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTCPRequestRuleFrontendWithBody request with any body
	ReplaceTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllWafBodyRuleFrontend request
	GetAllWafBodyRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllWafBodyRuleFrontendWithBody request with any body
	ReplaceAllWafBodyRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllWafBodyRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, body ReplaceAllWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWafBodyRuleFrontend request
	DeleteWafBodyRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWafBodyRuleFrontend request
	GetWafBodyRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWafBodyRuleFrontendWithBody request with any body
	CreateWafBodyRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWafBodyRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, body CreateWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceWafBodyRuleFrontendWithBody request with any body
	ReplaceWafBodyRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceWafBodyRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, body ReplaceWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobal request
	GetGlobal(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceGlobalWithBody request with any body
	ReplaceGlobalWithBody(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceGlobal(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetGlobal request
	GetAllLogTargetGlobal(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetGlobalWithBody request with any body
	ReplaceAllLogTargetGlobalWithBody(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetGlobal(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetGlobal request
	DeleteLogTargetGlobal(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetGlobal request
	GetLogTargetGlobal(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetGlobalWithBody request with any body
	CreateLogTargetGlobalWithBody(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetGlobal(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetGlobalWithBody request with any body
	ReplaceLogTargetGlobalWithBody(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetGlobal(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroups request
	GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupWithBody request with any body
	CreateGroupWithBody(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroup(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroup request
	DeleteGroup(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroup request
	GetGroup(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceGroupWithBody request with any body
	ReplaceGroupWithBody(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceGroup(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorsSections request
	GetHTTPErrorsSections(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateHTTPErrorsSectionWithBody request with any body
	CreateHTTPErrorsSectionWithBody(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateHTTPErrorsSection(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteHTTPErrorsSection request
	DeleteHTTPErrorsSection(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHTTPErrorsSection request
	GetHTTPErrorsSection(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceHTTPErrorsSectionWithBody request with any body
	ReplaceHTTPErrorsSectionWithBody(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceHTTPErrorsSection(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogForwards request
	GetLogForwards(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogForwardWithBody request with any body
	CreateLogForwardWithBody(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogForward(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogForward request
	DeleteLogForward(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogForward request
	GetLogForward(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogForwardWithBody request with any body
	ReplaceLogForwardWithBody(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogForward(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBindLogForward request
	GetAllBindLogForward(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBindLogForwardWithBody request with any body
	CreateBindLogForwardWithBody(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBindLogForward(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBindLogForward request
	DeleteBindLogForward(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindLogForward request
	GetBindLogForward(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBindLogForwardWithBody request with any body
	ReplaceBindLogForwardWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBindLogForward(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDgramBindLogForward request
	GetAllDgramBindLogForward(ctx context.Context, parentName ParentName, params *GetAllDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDgramBindLogForwardWithBody request with any body
	CreateDgramBindLogForwardWithBody(ctx context.Context, parentName ParentName, params *CreateDgramBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDgramBindLogForward(ctx context.Context, parentName ParentName, params *CreateDgramBindLogForwardParams, body CreateDgramBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDgramBindLogForward request
	DeleteDgramBindLogForward(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDgramBindLogForward request
	GetDgramBindLogForward(ctx context.Context, parentName ParentName, name string, params *GetDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDgramBindLogForwardWithBody request with any body
	ReplaceDgramBindLogForwardWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDgramBindLogForward(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, body ReplaceDgramBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetLogForward request
	GetAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetLogForwardWithBody request with any body
	ReplaceAllLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetLogForward request
	DeleteLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetLogForward request
	GetLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetLogForwardWithBody request with any body
	CreateLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetLogForwardWithBody request with any body
	ReplaceLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailerEntries request
	GetMailerEntries(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMailerEntryWithBody request with any body
	CreateMailerEntryWithBody(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMailerEntry(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMailerEntry request
	DeleteMailerEntry(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailerEntry request
	GetMailerEntry(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceMailerEntryWithBody request with any body
	ReplaceMailerEntryWithBody(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceMailerEntry(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailersSections request
	GetMailersSections(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateMailersSectionWithBody request with any body
	CreateMailersSectionWithBody(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateMailersSection(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMailersSection request
	DeleteMailersSection(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMailersSection request
	GetMailersSection(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditMailersSectionWithBody request with any body
	EditMailersSectionWithBody(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditMailersSection(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNameservers request
	GetNameservers(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNameserverWithBody request with any body
	CreateNameserverWithBody(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNameserver(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNameserver request
	DeleteNameserver(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNameserver request
	GetNameserver(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceNameserverWithBody request with any body
	ReplaceNameserverWithBody(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceNameserver(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerEntries request
	GetPeerEntries(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePeerEntryWithBody request with any body
	CreatePeerEntryWithBody(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePeerEntry(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePeerEntry request
	DeletePeerEntry(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerEntry request
	GetPeerEntry(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplacePeerEntryWithBody request with any body
	ReplacePeerEntryWithBody(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplacePeerEntry(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerSections request
	GetPeerSections(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePeerWithBody request with any body
	CreatePeerWithBody(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePeer(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePeer request
	DeletePeer(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeerSection request
	GetPeerSection(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllBindPeer request
	GetAllBindPeer(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBindPeerWithBody request with any body
	CreateBindPeerWithBody(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBindPeer(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBindPeer request
	DeleteBindPeer(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBindPeer request
	GetBindPeer(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceBindPeerWithBody request with any body
	ReplaceBindPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceBindPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetPeer request
	GetAllLogTargetPeer(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetPeerWithBody request with any body
	ReplaceAllLogTargetPeerWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetPeer(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetPeer request
	DeleteLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetPeer request
	GetLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetPeerWithBody request with any body
	CreateLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetPeerWithBody request with any body
	ReplaceLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerPeer request
	GetAllServerPeer(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerPeerWithBody request with any body
	CreateServerPeerWithBody(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerPeer(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerPeer request
	DeleteServerPeer(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerPeer request
	GetServerPeer(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerPeerWithBody request with any body
	ReplaceServerPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTables request
	GetTables(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTable request
	DeleteTable(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceTableWithBody request with any body
	ReplaceTableWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceTable(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPrograms request
	GetPrograms(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateProgramWithBody request with any body
	CreateProgramWithBody(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateProgram(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProgram request
	DeleteProgram(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProgram request
	GetProgram(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceProgramWithBody request with any body
	ReplaceProgramWithBody(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceProgram(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHAProxyConfiguration request
	GetHAProxyConfiguration(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostHAProxyConfigurationWithBody request with any body
	PostHAProxyConfigurationWithBody(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostHAProxyConfigurationWithTextBody(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResolvers request
	GetResolvers(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateResolverWithBody request with any body
	CreateResolverWithBody(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateResolver(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteResolver request
	DeleteResolver(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResolver request
	GetResolver(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceResolverWithBody request with any body
	ReplaceResolverWithBody(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceResolver(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRings request
	GetRings(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRingWithBody request with any body
	CreateRingWithBody(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRing(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRing request
	DeleteRing(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRing request
	GetRing(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRingWithBody request with any body
	ReplaceRingWithBody(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRing(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllServerRing request
	GetAllServerRing(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServerRingWithBody request with any body
	CreateServerRingWithBody(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServerRing(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServerRing request
	DeleteServerRing(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServerRing request
	GetServerRing(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceServerRingWithBody request with any body
	ReplaceServerRingWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceServerRing(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHAProxyConfigurationStructured request
	GetHAProxyConfigurationStructured(ctx context.Context, params *GetHAProxyConfigurationStructuredParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStructuredWithBody request with any body
	ReplaceStructuredWithBody(ctx context.Context, params *ReplaceStructuredParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStructured(ctx context.Context, params *ReplaceStructuredParams, body ReplaceStructuredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUDPLbs request
	GetUDPLbs(ctx context.Context, params *GetUDPLbsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUDPLbWithBody request with any body
	CreateUDPLbWithBody(ctx context.Context, params *CreateUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUDPLb(ctx context.Context, params *CreateUDPLbParams, body CreateUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUDPLb request
	DeleteUDPLb(ctx context.Context, name string, params *DeleteUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUDPlb request
	GetUDPlb(ctx context.Context, name string, params *GetUDPlbParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceUDPLbWithBody request with any body
	ReplaceUDPLbWithBody(ctx context.Context, name string, params *ReplaceUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceUDPLb(ctx context.Context, name string, params *ReplaceUDPLbParams, body ReplaceUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDgramBindUDPLb request
	GetAllDgramBindUDPLb(ctx context.Context, parentName ParentName, params *GetAllDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDgramBindUDPLbWithBody request with any body
	CreateDgramBindUDPLbWithBody(ctx context.Context, parentName ParentName, params *CreateDgramBindUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDgramBindUDPLb(ctx context.Context, parentName ParentName, params *CreateDgramBindUDPLbParams, body CreateDgramBindUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDgramBindUDPLb request
	DeleteDgramBindUDPLb(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDgramBindUDPLb request
	GetDgramBindUDPLb(ctx context.Context, parentName ParentName, name string, params *GetDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceDgramBindUDPLbWithBody request with any body
	ReplaceDgramBindUDPLbWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceDgramBindUDPLb(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, body ReplaceDgramBindUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllLogTargetUDPLb request
	GetAllLogTargetUDPLb(ctx context.Context, parentName ParentName, params *GetAllLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceAllLogTargetUDPLbWithBody request with any body
	ReplaceAllLogTargetUDPLbWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceAllLogTargetUDPLb(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, body ReplaceAllLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogTargetUDPLb request
	DeleteLogTargetUDPLb(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogTargetUDPLb request
	GetLogTargetUDPLb(ctx context.Context, parentName ParentName, index int, params *GetLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogTargetUDPLbWithBody request with any body
	CreateLogTargetUDPLbWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogTargetUDPLb(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, body CreateLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogTargetUDPLbWithBody request with any body
	ReplaceLogTargetUDPLbWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogTargetUDPLb(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, body ReplaceLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserlists request
	GetUserlists(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserlistWithBody request with any body
	CreateUserlistWithBody(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserlist(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserlist request
	DeleteUserlist(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserlist request
	GetUserlist(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserWithBody request with any body
	CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUser request
	DeleteUser(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceUserWithBody request with any body
	ReplaceUserWithBody(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceUser(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfigurationVersion request
	GetConfigurationVersion(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogConfig request
	GetLogConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogConfigWithBody request with any body
	ReplaceLogConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogConfig(ctx context.Context, body ReplaceLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogInputs request
	GetLogInputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogInputWithBody request with any body
	CreateLogInputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogInput(ctx context.Context, body CreateLogInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogInput request
	DeleteLogInput(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogInput request
	GetLogInput(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogInputWithBody request with any body
	ReplaceLogInputWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogInput(ctx context.Context, id string, body ReplaceLogInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogOutputs request
	GetLogOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLogOutputWithBody request with any body
	CreateLogOutputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateLogOutput(ctx context.Context, body CreateLogOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLogOutput request
	DeleteLogOutput(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLogOutput request
	GetLogOutput(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceLogOutputWithBody request with any body
	ReplaceLogOutputWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceLogOutput(ctx context.Context, id string, body ReplaceLogOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReloads request
	GetReloads(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReload request
	GetReload(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeEndpoints request
	GetRuntimeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAcls request
	GetServicesHaproxyRuntimeAcls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAclsId request
	GetServicesHaproxyRuntimeAclsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntries request
	GetServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody request with any body
	PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPayloadRuntimeACLWithBody request with any body
	AddPayloadRuntimeACLWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPayloadRuntimeACL(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServicesHaproxyRuntimeAclsParentNameEntriesId request
	DeleteServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntriesId request
	GetServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRuntimeServer request
	GetAllRuntimeServer(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRuntimeServerWithBody request with any body
	AddRuntimeServerWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRuntimeServer(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuntimeServer request
	DeleteRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeServer request
	GetRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRuntimeServerWithBody request with any body
	ReplaceRuntimeServerWithBody(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRuntimeServer(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHaproxyProcessInfo request
	GetHaproxyProcessInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllRuntimeMapFiles request
	GetAllRuntimeMapFiles(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearRuntimeMap request
	ClearRuntimeMap(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneRuntimeMap request
	GetOneRuntimeMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPayloadRuntimeMapWithBody request with any body
	AddPayloadRuntimeMapWithBody(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPayloadRuntimeMap(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowRuntimeMap request
	ShowRuntimeMap(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMapEntryWithBody request with any body
	AddMapEntryWithBody(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMapEntry(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRuntimeMapEntry request
	DeleteRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRuntimeMapEntry request
	GetRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceRuntimeMapEntryWithBody request with any body
	ReplaceRuntimeMapEntryWithBody(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickTables request
	GetStickTables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickTable request
	GetStickTable(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStickTableEntries request
	GetStickTableEntries(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetStickTableEntriesWithBody request with any body
	SetStickTableEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetStickTableEntries(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSites request
	GetSites(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSiteWithBody request with any body
	CreateSiteWithBody(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSite(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSite request
	DeleteSite(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSite request
	GetSite(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSiteWithBody request with any body
	ReplaceSiteWithBody(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSite(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeEndpoints request
	GetSpoeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeFiles request
	GetAllSpoeFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeWithBody request with any body
	CreateSpoeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeFile request
	DeleteSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneSpoeFile request
	GetOneSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeScope request
	GetAllSpoeScope(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeScopeWithBody request with any body
	CreateSpoeScopeWithBody(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeScope(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeScope request
	DeleteSpoeScope(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeScope request
	GetSpoeScope(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeAgent request
	GetAllSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeAgentWithBody request with any body
	CreateSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeAgent request
	DeleteSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeAgent request
	GetSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSpoeAgentWithBody request with any body
	ReplaceSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeGroup request
	GetAllSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeGroupWithBody request with any body
	CreateSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeGroup request
	DeleteSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeGroup request
	GetSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSpoeGroupWithBody request with any body
	ReplaceSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeMessage request
	GetAllSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpoeMessageWithBody request with any body
	CreateSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeMessage request
	DeleteSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeMessage request
	GetSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceSpoeMessageWithBody request with any body
	ReplaceSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllSpoeTransaction request
	GetAllSpoeTransaction(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartSpoeTransaction request
	StartSpoeTransaction(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpoeTransaction request
	DeleteSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeTransaction request
	GetSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitSpoeTransaction request
	CommitSpoeTransaction(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpoeConfigurationVersion request
	GetSpoeConfigurationVersion(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatsEndpoints request
	GetStatsEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStorageEndpoints request
	GetStorageEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageGeneralFiles request
	GetAllStorageGeneralFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageGeneralFileWithBody request with any body
	CreateStorageGeneralFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageGeneralFile request
	DeleteStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageGeneralFile request
	GetOneStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageGeneralFileWithBody request with any body
	ReplaceStorageGeneralFileWithBody(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageMapFiles request
	GetAllStorageMapFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageMapFileWithBody request with any body
	CreateStorageMapFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageMap request
	DeleteStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageMap request
	GetOneStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageMapFileWithBody request with any body
	ReplaceStorageMapFileWithBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStorageMapFileWithTextBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStorageSSLCertificates request
	GetAllStorageSSLCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStorageSSLCertificateWithBody request with any body
	CreateStorageSSLCertificateWithBody(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStorageSSLCertificate request
	DeleteStorageSSLCertificate(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOneStorageSSLCertificate request
	GetOneStorageSSLCertificate(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceStorageSSLCertificateWithBody request with any body
	ReplaceStorageSSLCertificateWithBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceStorageSSLCertificateWithTextBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactions request
	GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartTransaction request
	StartTransaction(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransaction request
	DeleteTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransaction request
	GetTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitTransaction request
	CommitTransaction(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWafRulesets request
	GetWafRulesets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWafRulesetWithBody request with any body
	CreateWafRulesetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWafRuleset request
	DeleteWafRuleset(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWafRuleset request
	GetWafRuleset(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceWafRulesetWithBody request with any body
	ReplaceWafRulesetWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWafFiles request
	GetWafFiles(ctx context.Context, rulesetName RulesetName, params *GetWafFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWafFileWithBody request with any body
	CreateWafFileWithBody(ctx context.Context, rulesetName RulesetName, params *CreateWafFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWafFile request
	DeleteWafFile(ctx context.Context, rulesetName RulesetName, name string, params *DeleteWafFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWafFile request
	GetWafFile(ctx context.Context, rulesetName RulesetName, name string, params *GetWafFileParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceWafFileWithBody request with any body
	ReplaceWafFileWithBody(ctx context.Context, rulesetName RulesetName, name string, params *ReplaceWafFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceWafFileWithTextBody(ctx context.Context, rulesetName RulesetName, name string, params *ReplaceWafFileParams, body ReplaceWafFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeepalivedClusterConfigurationVersion request
	GetKeepalivedClusterConfigurationVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalDefs request
	GetGlobalDefs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceGlobalDefsWithBody request with any body
	ReplaceGlobalDefsWithBody(ctx context.Context, params *ReplaceGlobalDefsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceGlobalDefs(ctx context.Context, params *ReplaceGlobalDefsParams, body ReplaceGlobalDefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeepalivedConfiguration request
	GetKeepalivedConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceKeepalivedConfigurationWithBody request with any body
	ReplaceKeepalivedConfigurationWithBody(ctx context.Context, params *ReplaceKeepalivedConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceKeepalivedConfigurationWithTextBody(ctx context.Context, params *ReplaceKeepalivedConfigurationParams, body ReplaceKeepalivedConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllVRRPInstance request
	GetAllVRRPInstance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVRRPInstanceWithBody request with any body
	CreateVRRPInstanceWithBody(ctx context.Context, params *CreateVRRPInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVRRPInstance(ctx context.Context, params *CreateVRRPInstanceParams, body CreateVRRPInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVRRPInstance request
	DeleteVRRPInstance(ctx context.Context, parentName ParentName, params *DeleteVRRPInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVRRPInstance request
	GetVRRPInstance(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceVRRPInstanceWithBody request with any body
	ReplaceVRRPInstanceWithBody(ctx context.Context, parentName ParentName, params *ReplaceVRRPInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceVRRPInstance(ctx context.Context, parentName ParentName, params *ReplaceVRRPInstanceParams, body ReplaceVRRPInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllVRRPSyncGroup request
	GetAllVRRPSyncGroup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVRRPSyncGroupWithBody request with any body
	CreateVRRPSyncGroupWithBody(ctx context.Context, params *CreateVRRPSyncGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVRRPSyncGroup(ctx context.Context, params *CreateVRRPSyncGroupParams, body CreateVRRPSyncGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVRRPSyncGroup request
	DeleteVRRPSyncGroup(ctx context.Context, parentName ParentName, params *DeleteVRRPSyncGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVRRPSyncGroup request
	GetVRRPSyncGroup(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceVRRPSyncGroupWithBody request with any body
	ReplaceVRRPSyncGroupWithBody(ctx context.Context, parentName ParentName, params *ReplaceVRRPSyncGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceVRRPSyncGroup(ctx context.Context, parentName ParentName, params *ReplaceVRRPSyncGroupParams, body ReplaceVRRPSyncGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllVRRPScript request
	GetAllVRRPScript(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateVRRPScriptWithBody request with any body
	CreateVRRPScriptWithBody(ctx context.Context, params *CreateVRRPScriptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateVRRPScript(ctx context.Context, params *CreateVRRPScriptParams, body CreateVRRPScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVRRPScript request
	DeleteVRRPScript(ctx context.Context, parentName ParentName, params *DeleteVRRPScriptParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVRRPScript request
	GetVRRPScript(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReplaceVRRPScriptWithBody request with any body
	ReplaceVRRPScriptWithBody(ctx context.Context, parentName ParentName, params *ReplaceVRRPScriptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReplaceVRRPScript(ctx context.Context, parentName ParentName, params *ReplaceVRRPScriptParams, body ReplaceVRRPScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllKeepalivedReload request
	GetAllKeepalivedReload(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeepalivedReload request
	GetKeepalivedReload(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllKeepalivedTransaction request
	GetAllKeepalivedTransaction(ctx context.Context, params *GetAllKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartKeepalivedTransaction request
	StartKeepalivedTransaction(ctx context.Context, params *StartKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteKeepalivedTransaction request
	DeleteKeepalivedTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeepalivedTransaction request
	GetKeepalivedTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitKeepalivedTransaction request
	CommitKeepalivedTransaction(ctx context.Context, id string, params *CommitKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpecification request
	GetSpecification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOpenapiv3Specification request
	GetOpenapiv3Specification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSummary request
	GetSummary(ctx context.Context, params *GetSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAPIEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAPIEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlohaEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlohaEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlohaActions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlohaActionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteAlohaActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteAlohaActionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteAlohaAction(ctx context.Context, body ExecuteAlohaActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteAlohaActionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAlohaAction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAlohaActionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostClusterWithBody(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCluster(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostClusterRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditClusterWithBody(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditClusterRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCluster(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditClusterRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InitiateCertificateRefresh(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInitiateCertificateRefreshRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFacts(ctx context.Context, params *GetFactsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFactsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHealth(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHealthRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAWSRegions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAWSRegionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAWSRegionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAWSRegionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAWSRegion(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAWSRegionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAWSRegionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAWSRegion(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAWSRegionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAWSRegionWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAWSRegionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAWSRegion(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAWSRegionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsuls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsulsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsulWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsulRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConsul(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConsulRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConsulRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConsul(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConsulRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceConsulWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceConsulRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceConsul(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceConsulRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunActionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunActionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunActions(ctx context.Context, body RunActionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunActionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGitEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGitEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGitActions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGitActionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteGitActionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteGitActionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExecuteGitAction(ctx context.Context, body ExecuteGitActionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExecuteGitActionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGitAction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGitActionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGitSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGitSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGitSettingsWithBody(ctx context.Context, params *ReplaceGitSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGitSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGitSettings(ctx context.Context, params *ReplaceGitSettingsParams, body ReplaceGitSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGitSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHaproxyEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHaproxyEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackends(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackendWithBody(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackend(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackend(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackend(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendWithBody(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackend(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclBackend(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclBackend(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclBackend(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclBackend(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclBackend(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllFilterBackend(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllFilterBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterBackend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilterBackend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFilterBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterBackend(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterBackend(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPAfterResponseRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPCheckBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPErrorRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPRequestRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPResponseRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetBackend(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetBackend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerSwitchingRules(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerSwitchingRulesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRulesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRulesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerTemplates(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerTemplatesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerTemplateWithBody(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerTemplateRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerTemplate(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerTemplateRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerTemplateRequest(c.Server, parentName, prefix, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerTemplateRequest(c.Server, parentName, prefix, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerTemplateWithBody(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerTemplateRequestWithBody(c.Server, parentName, prefix, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerTemplate(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerTemplateRequest(c.Server, parentName, prefix, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerBackend(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerBackendWithBody(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerBackend(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerBackend(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerBackendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerBackend(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerBackendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerBackendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerBackendRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerBackend(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerBackendRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickRules(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickRulesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRulesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRules(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRulesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStickRule(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStickRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickRule(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStickRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStickRule(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStickRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStickRule(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStickRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPCheckBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPCheckBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPRequestRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPRequestRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPResponseRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPResponseRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPResponseRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPResponseRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPResponseRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPResponseRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPResponseRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPResponseRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPResponseRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllWafBodyRuleBackend(ctx context.Context, parentName ParentName, params *GetAllWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllWafBodyRuleBackendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllWafBodyRuleBackendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllWafBodyRuleBackendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllWafBodyRuleBackend(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, body ReplaceAllWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllWafBodyRuleBackendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWafBodyRuleBackend(ctx context.Context, parentName ParentName, index int, params *DeleteWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWafBodyRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWafBodyRuleBackend(ctx context.Context, parentName ParentName, index int, params *GetWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWafBodyRuleBackendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWafBodyRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWafBodyRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWafBodyRuleBackend(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, body CreateWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWafBodyRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceWafBodyRuleBackendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceWafBodyRuleBackendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceWafBodyRuleBackend(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, body ReplaceWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceWafBodyRuleBackendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBotmgmtProfiles(ctx context.Context, params *GetBotmgmtProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBotmgmtProfilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBotmgmtProfileWithBody(ctx context.Context, params *CreateBotmgmtProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBotmgmtProfileRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBotmgmtProfile(ctx context.Context, params *CreateBotmgmtProfileParams, body CreateBotmgmtProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBotmgmtProfileRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBotmgmtProfile(ctx context.Context, name string, params *DeleteBotmgmtProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBotmgmtProfileRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBotmgmtProfile(ctx context.Context, name string, params *GetBotmgmtProfileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBotmgmtProfileRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditBotmgmtProfileWithBody(ctx context.Context, name string, params *EditBotmgmtProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditBotmgmtProfileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditBotmgmtProfile(ctx context.Context, name string, params *EditBotmgmtProfileParams, body EditBotmgmtProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditBotmgmtProfileRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaches(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCachesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCacheWithBody(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCacheRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCache(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCacheRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCache(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCacheRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCache(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCacheRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCacheWithBody(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCacheRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCache(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCacheRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaptchas(ctx context.Context, params *GetCaptchasParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaptchasRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCaptchaWithBody(ctx context.Context, params *CreateCaptchaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCaptchaRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCaptcha(ctx context.Context, params *CreateCaptchaParams, body CreateCaptchaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCaptchaRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCaptcha(ctx context.Context, name string, params *DeleteCaptchaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCaptchaRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaptcha(ctx context.Context, name string, params *GetCaptchaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaptchaRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCaptchaWithBody(ctx context.Context, name string, params *EditCaptchaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCaptchaRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCaptcha(ctx context.Context, name string, params *EditCaptchaParams, body EditCaptchaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCaptchaRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClusterConfigurationVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterConfigurationVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtLoads(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtLoadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtLoadWithBody(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtLoadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtLoad(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtLoadRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCrtLoad(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCrtLoadRequest(c.Server, certificate, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtLoad(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtLoadRequest(c.Server, certificate, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCrtLoadWithBody(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCrtLoadRequestWithBody(c.Server, certificate, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceCrtLoad(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceCrtLoadRequest(c.Server, certificate, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtStores(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtStoresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtStoreWithBody(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtStoreRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCrtStore(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCrtStoreRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCrtStore(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCrtStoreRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCrtStore(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCrtStoreRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCrtStoreWithBody(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCrtStoreRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCrtStore(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCrtStoreRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultsSections(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultsSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDefaultsSectionWithBody(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDefaultsSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDefaultsSection(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDefaultsSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDefaultsSection(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDefaultsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultsSection(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDefaultsSectionWithBody(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDefaultsSectionRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDefaultsSection(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDefaultsSectionRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPCheckDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPCheckDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPErrorRuleDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPCheckDefaultsRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckDefaultsRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPCheckDefaults(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPCheckDefaultsRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPCheckDefaultsRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckDefaultsWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckDefaultsRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPCheckDefaults(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPCheckDefaultsRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDynamicUpdateRules(ctx context.Context, params *GetDynamicUpdateRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDynamicUpdateRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDynamicUpdateRulesWithBody(ctx context.Context, params *ReplaceDynamicUpdateRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDynamicUpdateRulesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDynamicUpdateRules(ctx context.Context, params *ReplaceDynamicUpdateRulesParams, body ReplaceDynamicUpdateRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDynamicUpdateRulesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDynamicUpdateRule(ctx context.Context, index int, params *DeleteDynamicUpdateRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDynamicUpdateRuleRequest(c.Server, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDynamicUpdateRule(ctx context.Context, index int, params *GetDynamicUpdateRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDynamicUpdateRuleRequest(c.Server, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDynamicUpdateRuleWithBody(ctx context.Context, index int, params *CreateDynamicUpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDynamicUpdateRuleRequestWithBody(c.Server, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDynamicUpdateRule(ctx context.Context, index int, params *CreateDynamicUpdateRuleParams, body CreateDynamicUpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDynamicUpdateRuleRequest(c.Server, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDynamicUpdateRuleWithBody(ctx context.Context, index int, params *ReplaceDynamicUpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDynamicUpdateRuleRequestWithBody(c.Server, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDynamicUpdateRule(ctx context.Context, index int, params *ReplaceDynamicUpdateRuleParams, body ReplaceDynamicUpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDynamicUpdateRuleRequest(c.Server, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDynamicUpdateSection(ctx context.Context, params *DeleteDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDynamicUpdateSectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDynamicUpdateSection(ctx context.Context, params *GetDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDynamicUpdateSectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDynamicUpdateSection(ctx context.Context, params *CreateDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDynamicUpdateSectionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFCGIApps(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFCGIAppsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFCGIAppWithBody(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFCGIAppRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFCGIApp(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFCGIAppRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFCGIApp(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFCGIAppRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFCGIApp(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFCGIAppRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFCGIAppWithBody(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFCGIAppRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFCGIApp(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFCGIAppRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclFCGIApp(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclFCGIAppRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFCGIAppWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFCGIAppRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFCGIApp(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFCGIAppRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclFCGIAppRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclFCGIAppRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFCGIAppRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFCGIAppRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFCGIAppWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFCGIAppRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFCGIApp(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFCGIAppRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFrontends(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFrontendsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFrontendWithBody(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFrontendRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFrontend(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFrontendRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFrontend(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFrontendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFrontend(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFrontendRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFrontendWithBody(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFrontendRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFrontend(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFrontendRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllAclFrontend(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllAclFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllAclFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllAclFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAclFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAclFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAclFrontend(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAclFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAclFrontend(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAclFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAclFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAclFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackendSwitchingRules(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendSwitchingRulesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRulesWithBody(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRulesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRules(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRulesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBackendSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackendSwitchingRuleRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackendSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRuleWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRuleRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBackendSwitchingRule(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBackendSwitchingRuleRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBindFrontend(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBindFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindFrontendWithBody(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindFrontend(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBindFrontend(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBindFrontendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindFrontend(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindFrontendRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindFrontendWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindFrontendRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindFrontend(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindFrontendRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeclareCaptures(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeclareCapturesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCapturesWithBody(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCapturesRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCaptures(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCapturesRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDeclareCapture(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDeclareCaptureRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDeclareCapture(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDeclareCaptureRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeclareCaptureRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDeclareCapture(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDeclareCaptureRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCaptureWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCaptureRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDeclareCapture(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDeclareCaptureRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllFilterFrontend(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllFilterFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllFilterFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllFilterFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFilterFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFilterFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFilterFrontend(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFilterFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFilterFrontend(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFilterFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceFilterFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceFilterFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPAfterResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPAfterResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPErrorRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPErrorRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPRequestRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPRequestRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllHTTPResponseRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllHTTPResponseRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPResponseRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPResponseRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllTCPRequestRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllTCPRequestRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTCPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTCPRequestRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTCPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTCPRequestRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTCPRequestRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllWafBodyRuleFrontend(ctx context.Context, parentName ParentName, params *GetAllWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllWafBodyRuleFrontendRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllWafBodyRuleFrontendWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllWafBodyRuleFrontendRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllWafBodyRuleFrontend(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, body ReplaceAllWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllWafBodyRuleFrontendRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWafBodyRuleFrontend(ctx context.Context, parentName ParentName, index int, params *DeleteWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWafBodyRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWafBodyRuleFrontend(ctx context.Context, parentName ParentName, index int, params *GetWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWafBodyRuleFrontendRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWafBodyRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWafBodyRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWafBodyRuleFrontend(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, body CreateWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWafBodyRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceWafBodyRuleFrontendWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceWafBodyRuleFrontendRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceWafBodyRuleFrontend(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, body ReplaceWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceWafBodyRuleFrontendRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobal(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGlobalWithBody(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGlobalRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGlobal(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGlobalRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetGlobal(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetGlobalRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetGlobalWithBody(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetGlobalRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetGlobal(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetGlobalRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetGlobal(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetGlobalRequest(c.Server, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetGlobal(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetGlobalRequest(c.Server, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetGlobalWithBody(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetGlobalRequestWithBody(c.Server, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetGlobal(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetGlobalRequest(c.Server, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetGlobalWithBody(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetGlobalRequestWithBody(c.Server, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetGlobal(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetGlobalRequest(c.Server, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroups(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupWithBody(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroup(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroup(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroup(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGroupWithBody(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGroupRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGroup(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGroupRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorsSections(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorsSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorsSectionWithBody(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorsSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateHTTPErrorsSection(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateHTTPErrorsSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteHTTPErrorsSection(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteHTTPErrorsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHTTPErrorsSection(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHTTPErrorsSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorsSectionWithBody(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorsSectionRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceHTTPErrorsSection(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceHTTPErrorsSectionRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogForwards(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogForwardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogForwardWithBody(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogForwardRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogForward(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogForwardRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogForward(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogForwardRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogForward(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogForwardRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogForwardWithBody(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogForwardRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogForward(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogForwardRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBindLogForward(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBindLogForwardRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindLogForwardWithBody(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindLogForwardRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindLogForward(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindLogForwardRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBindLogForward(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBindLogForwardRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindLogForward(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindLogForwardRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindLogForwardWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindLogForwardRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindLogForward(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindLogForwardRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDgramBindLogForward(ctx context.Context, parentName ParentName, params *GetAllDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDgramBindLogForwardRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDgramBindLogForwardWithBody(ctx context.Context, parentName ParentName, params *CreateDgramBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDgramBindLogForwardRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDgramBindLogForward(ctx context.Context, parentName ParentName, params *CreateDgramBindLogForwardParams, body CreateDgramBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDgramBindLogForwardRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDgramBindLogForward(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDgramBindLogForwardRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDgramBindLogForward(ctx context.Context, parentName ParentName, name string, params *GetDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDgramBindLogForwardRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDgramBindLogForwardWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDgramBindLogForwardRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDgramBindLogForward(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, body ReplaceDgramBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDgramBindLogForwardRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetLogForwardRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetLogForwardRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetLogForward(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetLogForwardRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetLogForwardRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetLogForwardRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetLogForwardRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetLogForwardRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetLogForwardWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetLogForwardRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetLogForward(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetLogForwardRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailerEntries(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailerEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailerEntryWithBody(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailerEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailerEntry(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailerEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMailerEntry(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMailerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailerEntry(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceMailerEntryWithBody(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceMailerEntryRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceMailerEntry(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceMailerEntryRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailersSections(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailersSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailersSectionWithBody(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailersSectionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateMailersSection(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateMailersSectionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMailersSection(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMailersSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMailersSection(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMailersSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMailersSectionWithBody(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMailersSectionRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditMailersSection(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditMailersSectionRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNameservers(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNameserversRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNameserverWithBody(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNameserverRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNameserver(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNameserverRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNameserver(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNameserverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNameserver(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNameserverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceNameserverWithBody(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceNameserverRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceNameserver(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceNameserverRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerEntries(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeerEntryWithBody(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerEntryRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeerEntry(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerEntryRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePeerEntry(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePeerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerEntry(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerEntryRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplacePeerEntryWithBody(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplacePeerEntryRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplacePeerEntry(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplacePeerEntryRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerSections(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerSectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeerWithBody(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePeer(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePeerRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePeer(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePeerRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeerSection(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeerSectionRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllBindPeer(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllBindPeerRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindPeerWithBody(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindPeerRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBindPeer(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBindPeerRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBindPeer(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBindPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBindPeer(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBindPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindPeerRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceBindPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceBindPeerRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetPeer(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetPeerRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetPeerWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetPeerRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetPeer(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetPeerRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetPeerRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetPeerRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetPeerRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetPeerRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetPeerWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetPeerRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetPeer(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetPeerRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerPeer(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerPeerRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerPeerWithBody(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerPeerRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerPeer(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerPeerRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerPeer(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerPeer(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerPeerRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerPeerWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerPeerRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerPeer(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerPeerRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTables(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTablesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTable(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTableRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTableWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTableRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceTable(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceTableRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPrograms(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgramWithBody(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateProgram(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateProgramRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProgram(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProgramRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProgram(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProgramRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceProgramWithBody(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceProgramRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceProgram(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceProgramRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHAProxyConfiguration(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHAProxyConfigurationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHAProxyConfigurationWithBody(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHAProxyConfigurationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostHAProxyConfigurationWithTextBody(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostHAProxyConfigurationRequestWithTextBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResolvers(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResolversRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResolverWithBody(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResolverRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateResolver(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateResolverRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteResolver(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteResolverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResolver(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResolverRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResolverWithBody(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResolverRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceResolver(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceResolverRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRings(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRingWithBody(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRingRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRing(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRingRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRing(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRingRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRing(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRingRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRingWithBody(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRingRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRing(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRingRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllServerRing(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllServerRingRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerRingWithBody(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRingRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServerRing(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServerRingRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServerRing(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServerRingRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServerRing(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServerRingRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerRingWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerRingRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceServerRing(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceServerRingRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHAProxyConfigurationStructured(ctx context.Context, params *GetHAProxyConfigurationStructuredParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHAProxyConfigurationStructuredRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStructuredWithBody(ctx context.Context, params *ReplaceStructuredParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStructuredRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStructured(ctx context.Context, params *ReplaceStructuredParams, body ReplaceStructuredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStructuredRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUDPLbs(ctx context.Context, params *GetUDPLbsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUDPLbsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUDPLbWithBody(ctx context.Context, params *CreateUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUDPLbRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUDPLb(ctx context.Context, params *CreateUDPLbParams, body CreateUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUDPLbRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUDPLb(ctx context.Context, name string, params *DeleteUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUDPLbRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUDPlb(ctx context.Context, name string, params *GetUDPlbParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUDPlbRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceUDPLbWithBody(ctx context.Context, name string, params *ReplaceUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceUDPLbRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceUDPLb(ctx context.Context, name string, params *ReplaceUDPLbParams, body ReplaceUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceUDPLbRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDgramBindUDPLb(ctx context.Context, parentName ParentName, params *GetAllDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDgramBindUDPLbRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDgramBindUDPLbWithBody(ctx context.Context, parentName ParentName, params *CreateDgramBindUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDgramBindUDPLbRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDgramBindUDPLb(ctx context.Context, parentName ParentName, params *CreateDgramBindUDPLbParams, body CreateDgramBindUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDgramBindUDPLbRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDgramBindUDPLb(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDgramBindUDPLbRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDgramBindUDPLb(ctx context.Context, parentName ParentName, name string, params *GetDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDgramBindUDPLbRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDgramBindUDPLbWithBody(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDgramBindUDPLbRequestWithBody(c.Server, parentName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceDgramBindUDPLb(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, body ReplaceDgramBindUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceDgramBindUDPLbRequest(c.Server, parentName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllLogTargetUDPLb(ctx context.Context, parentName ParentName, params *GetAllLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllLogTargetUDPLbRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetUDPLbWithBody(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetUDPLbRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceAllLogTargetUDPLb(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, body ReplaceAllLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceAllLogTargetUDPLbRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogTargetUDPLb(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogTargetUDPLbRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogTargetUDPLb(ctx context.Context, parentName ParentName, index int, params *GetLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogTargetUDPLbRequest(c.Server, parentName, index, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetUDPLbWithBody(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetUDPLbRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogTargetUDPLb(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, body CreateLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogTargetUDPLbRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetUDPLbWithBody(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetUDPLbRequestWithBody(c.Server, parentName, index, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogTargetUDPLb(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, body ReplaceLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogTargetUDPLbRequest(c.Server, parentName, index, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserlists(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserlistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserlistWithBody(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserlistRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserlist(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserlistRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserlist(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserlistRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserlist(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserlistRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserWithBody(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUser(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUser(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceUserWithBody(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceUserRequestWithBody(c.Server, username, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceUser(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceUserRequest(c.Server, username, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfigurationVersion(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigurationVersionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogConfig(ctx context.Context, body ReplaceLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogInputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogInputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogInputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogInputRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogInput(ctx context.Context, body CreateLogInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogInputRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogInput(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogInputRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogInput(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogInputRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogInputWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogInputRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogInput(ctx context.Context, id string, body ReplaceLogInputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogInputRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogOutputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogOutputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogOutputRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLogOutput(ctx context.Context, body CreateLogOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLogOutputRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLogOutput(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLogOutputRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLogOutput(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLogOutputRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogOutputWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogOutputRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceLogOutput(ctx context.Context, id string, body ReplaceLogOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceLogOutputRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReloads(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReloadsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReload(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReloadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAcls(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAclsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsParentNameEntriesRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostServicesHaproxyRuntimeAclsParentNameEntries(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeACLWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeACLRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeACL(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeACLRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServicesHaproxyRuntimeAclsParentNameEntriesId(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRuntimeServer(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRuntimeServerRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRuntimeServerWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuntimeServerRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRuntimeServer(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRuntimeServerRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuntimeServerRequest(c.Server, parentName, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeServer(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeServerRequest(c.Server, parentName, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeServerWithBody(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeServerRequestWithBody(c.Server, parentName, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeServer(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeServerRequest(c.Server, parentName, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHaproxyProcessInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHaproxyProcessInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllRuntimeMapFiles(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllRuntimeMapFilesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearRuntimeMap(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearRuntimeMapRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneRuntimeMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneRuntimeMapRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeMapWithBody(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeMapRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPayloadRuntimeMap(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPayloadRuntimeMapRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowRuntimeMap(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowRuntimeMapRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMapEntryWithBody(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMapEntryRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMapEntry(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMapEntryRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuntimeMapEntryRequest(c.Server, parentName, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRuntimeMapEntryRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeMapEntryWithBody(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeMapEntryRequestWithBody(c.Server, parentName, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceRuntimeMapEntry(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceRuntimeMapEntryRequest(c.Server, parentName, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickTables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickTablesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickTable(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickTableRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStickTableEntries(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStickTableEntriesRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetStickTableEntriesWithBody(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetStickTableEntriesRequestWithBody(c.Server, parentName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetStickTableEntries(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetStickTableEntriesRequest(c.Server, parentName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSites(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSiteWithBody(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSite(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSiteRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSite(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSiteRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSite(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSiteRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSiteWithBody(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSiteRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSite(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSiteRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneSpoeFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneSpoeFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeScope(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeScopeRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeScopeWithBody(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeScopeRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeScope(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeScopeRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeScope(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeScopeRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeScope(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeScopeRequest(c.Server, parentName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeAgentRequest(c.Server, parentName, scopeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeAgentRequestWithBody(c.Server, parentName, scopeName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeAgentRequest(c.Server, parentName, scopeName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeAgentRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeAgentRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeAgentWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeAgentRequestWithBody(c.Server, parentName, scopeName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeAgent(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeAgentRequest(c.Server, parentName, scopeName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeGroupRequest(c.Server, parentName, scopeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeGroupRequestWithBody(c.Server, parentName, scopeName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeGroupRequest(c.Server, parentName, scopeName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeGroupRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeGroupRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeGroupWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeGroupRequestWithBody(c.Server, parentName, scopeName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeGroup(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeGroupRequest(c.Server, parentName, scopeName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeMessageRequest(c.Server, parentName, scopeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeMessageRequestWithBody(c.Server, parentName, scopeName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpoeMessageRequest(c.Server, parentName, scopeName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeMessageRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeMessageRequest(c.Server, parentName, scopeName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeMessageWithBody(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeMessageRequestWithBody(c.Server, parentName, scopeName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceSpoeMessage(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceSpoeMessageRequest(c.Server, parentName, scopeName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllSpoeTransaction(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllSpoeTransactionRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartSpoeTransaction(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartSpoeTransactionRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpoeTransactionRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeTransaction(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeTransactionRequest(c.Server, parentName, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitSpoeTransaction(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitSpoeTransactionRequest(c.Server, parentName, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpoeConfigurationVersion(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpoeConfigurationVersionRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatsEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStorageEndpoints(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStorageEndpointsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageGeneralFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageGeneralFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageGeneralFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageGeneralFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageGeneralFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageGeneralFile(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageGeneralFileRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageGeneralFileWithBody(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageGeneralFileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageMapFiles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageMapFilesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageMapFileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageMapFileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageMapRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageMap(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageMapRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageMapFileWithBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageMapFileRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageMapFileWithTextBody(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageMapFileRequestWithTextBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStorageSSLCertificates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStorageSSLCertificatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStorageSSLCertificateWithBody(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStorageSSLCertificateRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStorageSSLCertificate(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStorageSSLCertificateRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOneStorageSSLCertificate(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOneStorageSSLCertificateRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageSSLCertificateWithBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageSSLCertificateRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceStorageSSLCertificateWithTextBody(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceStorageSSLCertificateRequestWithTextBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartTransaction(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartTransactionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitTransaction(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitTransactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWafRulesets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWafRulesetsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWafRulesetWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWafRulesetRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWafRuleset(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWafRulesetRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWafRuleset(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWafRulesetRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceWafRulesetWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceWafRulesetRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWafFiles(ctx context.Context, rulesetName RulesetName, params *GetWafFilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWafFilesRequest(c.Server, rulesetName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWafFileWithBody(ctx context.Context, rulesetName RulesetName, params *CreateWafFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWafFileRequestWithBody(c.Server, rulesetName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWafFile(ctx context.Context, rulesetName RulesetName, name string, params *DeleteWafFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWafFileRequest(c.Server, rulesetName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWafFile(ctx context.Context, rulesetName RulesetName, name string, params *GetWafFileParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWafFileRequest(c.Server, rulesetName, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceWafFileWithBody(ctx context.Context, rulesetName RulesetName, name string, params *ReplaceWafFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceWafFileRequestWithBody(c.Server, rulesetName, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceWafFileWithTextBody(ctx context.Context, rulesetName RulesetName, name string, params *ReplaceWafFileParams, body ReplaceWafFileTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceWafFileRequestWithTextBody(c.Server, rulesetName, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeepalivedClusterConfigurationVersion(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeepalivedClusterConfigurationVersionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalDefs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalDefsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGlobalDefsWithBody(ctx context.Context, params *ReplaceGlobalDefsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGlobalDefsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceGlobalDefs(ctx context.Context, params *ReplaceGlobalDefsParams, body ReplaceGlobalDefsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceGlobalDefsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeepalivedConfiguration(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeepalivedConfigurationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceKeepalivedConfigurationWithBody(ctx context.Context, params *ReplaceKeepalivedConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceKeepalivedConfigurationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceKeepalivedConfigurationWithTextBody(ctx context.Context, params *ReplaceKeepalivedConfigurationParams, body ReplaceKeepalivedConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceKeepalivedConfigurationRequestWithTextBody(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllVRRPInstance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllVRRPInstanceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVRRPInstanceWithBody(ctx context.Context, params *CreateVRRPInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVRRPInstanceRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVRRPInstance(ctx context.Context, params *CreateVRRPInstanceParams, body CreateVRRPInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVRRPInstanceRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVRRPInstance(ctx context.Context, parentName ParentName, params *DeleteVRRPInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVRRPInstanceRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVRRPInstance(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVRRPInstanceRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceVRRPInstanceWithBody(ctx context.Context, parentName ParentName, params *ReplaceVRRPInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceVRRPInstanceRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceVRRPInstance(ctx context.Context, parentName ParentName, params *ReplaceVRRPInstanceParams, body ReplaceVRRPInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceVRRPInstanceRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllVRRPSyncGroup(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllVRRPSyncGroupRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVRRPSyncGroupWithBody(ctx context.Context, params *CreateVRRPSyncGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVRRPSyncGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVRRPSyncGroup(ctx context.Context, params *CreateVRRPSyncGroupParams, body CreateVRRPSyncGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVRRPSyncGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVRRPSyncGroup(ctx context.Context, parentName ParentName, params *DeleteVRRPSyncGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVRRPSyncGroupRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVRRPSyncGroup(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVRRPSyncGroupRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceVRRPSyncGroupWithBody(ctx context.Context, parentName ParentName, params *ReplaceVRRPSyncGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceVRRPSyncGroupRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceVRRPSyncGroup(ctx context.Context, parentName ParentName, params *ReplaceVRRPSyncGroupParams, body ReplaceVRRPSyncGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceVRRPSyncGroupRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllVRRPScript(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllVRRPScriptRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVRRPScriptWithBody(ctx context.Context, params *CreateVRRPScriptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVRRPScriptRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateVRRPScript(ctx context.Context, params *CreateVRRPScriptParams, body CreateVRRPScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateVRRPScriptRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVRRPScript(ctx context.Context, parentName ParentName, params *DeleteVRRPScriptParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVRRPScriptRequest(c.Server, parentName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVRRPScript(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVRRPScriptRequest(c.Server, parentName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceVRRPScriptWithBody(ctx context.Context, parentName ParentName, params *ReplaceVRRPScriptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceVRRPScriptRequestWithBody(c.Server, parentName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReplaceVRRPScript(ctx context.Context, parentName ParentName, params *ReplaceVRRPScriptParams, body ReplaceVRRPScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReplaceVRRPScriptRequest(c.Server, parentName, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllKeepalivedReload(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllKeepalivedReloadRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeepalivedReload(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeepalivedReloadRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllKeepalivedTransaction(ctx context.Context, params *GetAllKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllKeepalivedTransactionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartKeepalivedTransaction(ctx context.Context, params *StartKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartKeepalivedTransactionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteKeepalivedTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteKeepalivedTransactionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeepalivedTransaction(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeepalivedTransactionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitKeepalivedTransaction(ctx context.Context, id string, params *CommitKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitKeepalivedTransactionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpecification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpecificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOpenapiv3Specification(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOpenapiv3SpecificationRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSummary(ctx context.Context, params *GetSummaryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSummaryRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAPIEndpointsRequest generates requests for GetAPIEndpoints
func NewGetAPIEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlohaEndpointsRequest generates requests for GetAlohaEndpoints
func NewGetAlohaEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aloha")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAlohaActionsRequest generates requests for GetAlohaActions
func NewGetAlohaActionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aloha/actions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecuteAlohaActionRequest calls the generic ExecuteAlohaAction builder with application/json body
func NewExecuteAlohaActionRequest(server string, body ExecuteAlohaActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteAlohaActionRequestWithBody(server, "application/json", bodyReader)
}

// NewExecuteAlohaActionRequestWithBody generates requests for ExecuteAlohaAction with any type of body
func NewExecuteAlohaActionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aloha/actions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAlohaActionRequest generates requests for GetAlohaAction
func NewGetAlohaActionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/aloha/actions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, params *DeleteClusterParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Configuration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configuration", runtime.ParamLocationQuery, *params.Configuration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostClusterRequest calls the generic PostCluster builder with application/json body
func NewPostClusterRequest(server string, params *PostClusterParams, body PostClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostClusterRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostClusterRequestWithBody generates requests for PostCluster with any type of body
func NewPostClusterRequestWithBody(server string, params *PostClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Configuration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "configuration", runtime.ParamLocationQuery, *params.Configuration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdvertisedAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "advertised_address", runtime.ParamLocationQuery, *params.AdvertisedAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AdvertisedPort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "advertised_port", runtime.ParamLocationQuery, *params.AdvertisedPort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEditClusterRequest calls the generic EditCluster builder with application/json body
func NewEditClusterRequest(server string, params *EditClusterParams, body EditClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditClusterRequestWithBody(server, params, "application/json", bodyReader)
}

// NewEditClusterRequestWithBody generates requests for EditCluster with any type of body
func NewEditClusterRequestWithBody(server string, params *EditClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewInitiateCertificateRefreshRequest generates requests for InitiateCertificateRefresh
func NewInitiateCertificateRefreshRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cluster/certificate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFactsRequest generates requests for GetFacts
func NewGetFactsRequest(server string, params *GetFactsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/facts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Refresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh", runtime.ParamLocationQuery, *params.Refresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHealthRequest generates requests for GetHealth
func NewGetHealthRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInfoRequest generates requests for GetInfo
func NewGetInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAWSRegionsRequest generates requests for GetAWSRegions
func NewGetAWSRegionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAWSRegionRequest calls the generic CreateAWSRegion builder with application/json body
func NewCreateAWSRegionRequest(server string, body CreateAWSRegionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAWSRegionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAWSRegionRequestWithBody generates requests for CreateAWSRegion with any type of body
func NewCreateAWSRegionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAWSRegionRequest generates requests for DeleteAWSRegion
func NewDeleteAWSRegionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAWSRegionRequest generates requests for GetAWSRegion
func NewGetAWSRegionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAWSRegionRequest calls the generic ReplaceAWSRegion builder with application/json body
func NewReplaceAWSRegionRequest(server string, id string, body ReplaceAWSRegionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAWSRegionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceAWSRegionRequestWithBody generates requests for ReplaceAWSRegion with any type of body
func NewReplaceAWSRegionRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/aws/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConsulsRequest generates requests for GetConsuls
func NewGetConsulsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateConsulRequest calls the generic CreateConsul builder with application/json body
func NewCreateConsulRequest(server string, body CreateConsulJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConsulRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConsulRequestWithBody generates requests for CreateConsul with any type of body
func NewCreateConsulRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConsulRequest generates requests for DeleteConsul
func NewDeleteConsulRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConsulRequest generates requests for GetConsul
func NewGetConsulRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceConsulRequest calls the generic ReplaceConsul builder with application/json body
func NewReplaceConsulRequest(server string, id string, body ReplaceConsulJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceConsulRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceConsulRequestWithBody generates requests for ReplaceConsul with any type of body
func NewReplaceConsulRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/service_discovery/consul/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServicesEndpointsRequest generates requests for GetServicesEndpoints
func NewGetServicesEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunActionsRequest calls the generic RunActions builder with application/json body
func NewRunActionsRequest(server string, body RunActionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunActionsRequestWithBody(server, "application/json", bodyReader)
}

// NewRunActionsRequestWithBody generates requests for RunActions with any type of body
func NewRunActionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/actions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGitEndpointsRequest generates requests for GetGitEndpoints
func NewGetGitEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/git")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGitActionsRequest generates requests for GetGitActions
func NewGetGitActionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/git/actions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExecuteGitActionRequest calls the generic ExecuteGitAction builder with application/json body
func NewExecuteGitActionRequest(server string, body ExecuteGitActionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExecuteGitActionRequestWithBody(server, "application/json", bodyReader)
}

// NewExecuteGitActionRequestWithBody generates requests for ExecuteGitAction with any type of body
func NewExecuteGitActionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/git/actions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGitActionRequest generates requests for GetGitAction
func NewGetGitActionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/git/actions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGitSettingsRequest generates requests for GetGitSettings
func NewGetGitSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/git/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceGitSettingsRequest calls the generic ReplaceGitSettings builder with application/json body
func NewReplaceGitSettingsRequest(server string, params *ReplaceGitSettingsParams, body ReplaceGitSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceGitSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceGitSettingsRequestWithBody generates requests for ReplaceGitSettings with any type of body
func NewReplaceGitSettingsRequestWithBody(server string, params *ReplaceGitSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/git/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHaproxyEndpointsRequest generates requests for GetHaproxyEndpoints
func NewGetHaproxyEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConfigurationEndpointsRequest generates requests for GetConfigurationEndpoints
func NewGetConfigurationEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackendsRequest generates requests for GetBackends
func NewGetBackendsRequest(server string, params *GetBackendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackendRequest calls the generic CreateBackend builder with application/json body
func NewCreateBackendRequest(server string, params *CreateBackendParams, body CreateBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackendRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBackendRequestWithBody generates requests for CreateBackend with any type of body
func NewCreateBackendRequestWithBody(server string, params *CreateBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBackendRequest generates requests for DeleteBackend
func NewDeleteBackendRequest(server string, name string, params *DeleteBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackendRequest generates requests for GetBackend
func NewGetBackendRequest(server string, name string, params *GetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBackendRequest calls the generic ReplaceBackend builder with application/json body
func NewReplaceBackendRequest(server string, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBackendRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceBackendRequestWithBody generates requests for ReplaceBackend with any type of body
func NewReplaceBackendRequestWithBody(server string, name string, params *ReplaceBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclBackendRequest generates requests for GetAllAclBackend
func NewGetAllAclBackendRequest(server string, parentName ParentName, params *GetAllAclBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclBackendRequest calls the generic ReplaceAllAclBackend builder with application/json body
func NewReplaceAllAclBackendRequest(server string, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclBackendRequestWithBody generates requests for ReplaceAllAclBackend with any type of body
func NewReplaceAllAclBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclBackendRequest generates requests for DeleteAclBackend
func NewDeleteAclBackendRequest(server string, parentName ParentName, index int, params *DeleteAclBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclBackendRequest generates requests for GetAclBackend
func NewGetAclBackendRequest(server string, parentName ParentName, index int, params *GetAclBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclBackendRequest calls the generic CreateAclBackend builder with application/json body
func NewCreateAclBackendRequest(server string, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclBackendRequestWithBody generates requests for CreateAclBackend with any type of body
func NewCreateAclBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclBackendRequest calls the generic ReplaceAclBackend builder with application/json body
func NewReplaceAclBackendRequest(server string, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclBackendRequestWithBody generates requests for ReplaceAclBackend with any type of body
func NewReplaceAclBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllFilterBackendRequest generates requests for GetAllFilterBackend
func NewGetAllFilterBackendRequest(server string, parentName ParentName, params *GetAllFilterBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllFilterBackendRequest calls the generic ReplaceAllFilterBackend builder with application/json body
func NewReplaceAllFilterBackendRequest(server string, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllFilterBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllFilterBackendRequestWithBody generates requests for ReplaceAllFilterBackend with any type of body
func NewReplaceAllFilterBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFilterBackendRequest generates requests for DeleteFilterBackend
func NewDeleteFilterBackendRequest(server string, parentName ParentName, index int, params *DeleteFilterBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterBackendRequest generates requests for GetFilterBackend
func NewGetFilterBackendRequest(server string, parentName ParentName, index int, params *GetFilterBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFilterBackendRequest calls the generic CreateFilterBackend builder with application/json body
func NewCreateFilterBackendRequest(server string, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFilterBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateFilterBackendRequestWithBody generates requests for CreateFilterBackend with any type of body
func NewCreateFilterBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceFilterBackendRequest calls the generic ReplaceFilterBackend builder with application/json body
func NewReplaceFilterBackendRequest(server string, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFilterBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceFilterBackendRequestWithBody generates requests for ReplaceFilterBackend with any type of body
func NewReplaceFilterBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPAfterResponseRuleBackendRequest generates requests for GetAllHTTPAfterResponseRuleBackend
func NewGetAllHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPAfterResponseRuleBackendRequest calls the generic ReplaceAllHTTPAfterResponseRuleBackend builder with application/json body
func NewReplaceAllHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody generates requests for ReplaceAllHTTPAfterResponseRuleBackend with any type of body
func NewReplaceAllHTTPAfterResponseRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPAfterResponseRuleBackendRequest generates requests for DeleteHTTPAfterResponseRuleBackend
func NewDeleteHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPAfterResponseRuleBackendRequest generates requests for GetHTTPAfterResponseRuleBackend
func NewGetHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPAfterResponseRuleBackendRequest calls the generic CreateHTTPAfterResponseRuleBackend builder with application/json body
func NewCreateHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPAfterResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPAfterResponseRuleBackendRequestWithBody generates requests for CreateHTTPAfterResponseRuleBackend with any type of body
func NewCreateHTTPAfterResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPAfterResponseRuleBackendRequest calls the generic ReplaceHTTPAfterResponseRuleBackend builder with application/json body
func NewReplaceHTTPAfterResponseRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPAfterResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPAfterResponseRuleBackendRequestWithBody generates requests for ReplaceHTTPAfterResponseRuleBackend with any type of body
func NewReplaceHTTPAfterResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPCheckBackendRequest generates requests for GetAllHTTPCheckBackend
func NewGetAllHTTPCheckBackendRequest(server string, parentName ParentName, params *GetAllHTTPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPCheckBackendRequest calls the generic ReplaceAllHTTPCheckBackend builder with application/json body
func NewReplaceAllHTTPCheckBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPCheckBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPCheckBackendRequestWithBody generates requests for ReplaceAllHTTPCheckBackend with any type of body
func NewReplaceAllHTTPCheckBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPCheckBackendRequest generates requests for DeleteHTTPCheckBackend
func NewDeleteHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPCheckBackendRequest generates requests for GetHTTPCheckBackend
func NewGetHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *GetHTTPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPCheckBackendRequest calls the generic CreateHTTPCheckBackend builder with application/json body
func NewCreateHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPCheckBackendRequestWithBody generates requests for CreateHTTPCheckBackend with any type of body
func NewCreateHTTPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPCheckBackendRequest calls the generic ReplaceHTTPCheckBackend builder with application/json body
func NewReplaceHTTPCheckBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPCheckBackendRequestWithBody generates requests for ReplaceHTTPCheckBackend with any type of body
func NewReplaceHTTPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPErrorRuleBackendRequest generates requests for GetAllHTTPErrorRuleBackend
func NewGetAllHTTPErrorRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPErrorRuleBackendRequest calls the generic ReplaceAllHTTPErrorRuleBackend builder with application/json body
func NewReplaceAllHTTPErrorRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPErrorRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPErrorRuleBackendRequestWithBody generates requests for ReplaceAllHTTPErrorRuleBackend with any type of body
func NewReplaceAllHTTPErrorRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorRuleBackendRequest generates requests for DeleteHTTPErrorRuleBackend
func NewDeleteHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorRuleBackendRequest generates requests for GetHTTPErrorRuleBackend
func NewGetHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorRuleBackendRequest calls the generic CreateHTTPErrorRuleBackend builder with application/json body
func NewCreateHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorRuleBackendRequestWithBody generates requests for CreateHTTPErrorRuleBackend with any type of body
func NewCreateHTTPErrorRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPErrorRuleBackendRequest calls the generic ReplaceHTTPErrorRuleBackend builder with application/json body
func NewReplaceHTTPErrorRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorRuleBackendRequestWithBody generates requests for ReplaceHTTPErrorRuleBackend with any type of body
func NewReplaceHTTPErrorRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPRequestRuleBackendRequest generates requests for GetAllHTTPRequestRuleBackend
func NewGetAllHTTPRequestRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPRequestRuleBackendRequest calls the generic ReplaceAllHTTPRequestRuleBackend builder with application/json body
func NewReplaceAllHTTPRequestRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPRequestRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPRequestRuleBackendRequestWithBody generates requests for ReplaceAllHTTPRequestRuleBackend with any type of body
func NewReplaceAllHTTPRequestRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPRequestRuleBackendRequest generates requests for DeleteHTTPRequestRuleBackend
func NewDeleteHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPRequestRuleBackendRequest generates requests for GetHTTPRequestRuleBackend
func NewGetHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPRequestRuleBackendRequest calls the generic CreateHTTPRequestRuleBackend builder with application/json body
func NewCreateHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPRequestRuleBackendRequestWithBody generates requests for CreateHTTPRequestRuleBackend with any type of body
func NewCreateHTTPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPRequestRuleBackendRequest calls the generic ReplaceHTTPRequestRuleBackend builder with application/json body
func NewReplaceHTTPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPRequestRuleBackendRequestWithBody generates requests for ReplaceHTTPRequestRuleBackend with any type of body
func NewReplaceHTTPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPResponseRuleBackendRequest generates requests for GetAllHTTPResponseRuleBackend
func NewGetAllHTTPResponseRuleBackendRequest(server string, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPResponseRuleBackendRequest calls the generic ReplaceAllHTTPResponseRuleBackend builder with application/json body
func NewReplaceAllHTTPResponseRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPResponseRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPResponseRuleBackendRequestWithBody generates requests for ReplaceAllHTTPResponseRuleBackend with any type of body
func NewReplaceAllHTTPResponseRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPResponseRuleBackendRequest generates requests for DeleteHTTPResponseRuleBackend
func NewDeleteHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPResponseRuleBackendRequest generates requests for GetHTTPResponseRuleBackend
func NewGetHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPResponseRuleBackendRequest calls the generic CreateHTTPResponseRuleBackend builder with application/json body
func NewCreateHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPResponseRuleBackendRequestWithBody generates requests for CreateHTTPResponseRuleBackend with any type of body
func NewCreateHTTPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPResponseRuleBackendRequest calls the generic ReplaceHTTPResponseRuleBackend builder with application/json body
func NewReplaceHTTPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPResponseRuleBackendRequestWithBody generates requests for ReplaceHTTPResponseRuleBackend with any type of body
func NewReplaceHTTPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetBackendRequest generates requests for GetAllLogTargetBackend
func NewGetAllLogTargetBackendRequest(server string, parentName ParentName, params *GetAllLogTargetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetBackendRequest calls the generic ReplaceAllLogTargetBackend builder with application/json body
func NewReplaceAllLogTargetBackendRequest(server string, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetBackendRequestWithBody generates requests for ReplaceAllLogTargetBackend with any type of body
func NewReplaceAllLogTargetBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetBackendRequest generates requests for DeleteLogTargetBackend
func NewDeleteLogTargetBackendRequest(server string, parentName ParentName, index int, params *DeleteLogTargetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetBackendRequest generates requests for GetLogTargetBackend
func NewGetLogTargetBackendRequest(server string, parentName ParentName, index int, params *GetLogTargetBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetBackendRequest calls the generic CreateLogTargetBackend builder with application/json body
func NewCreateLogTargetBackendRequest(server string, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetBackendRequestWithBody generates requests for CreateLogTargetBackend with any type of body
func NewCreateLogTargetBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetBackendRequest calls the generic ReplaceLogTargetBackend builder with application/json body
func NewReplaceLogTargetBackendRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetBackendRequestWithBody generates requests for ReplaceLogTargetBackend with any type of body
func NewReplaceLogTargetBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerSwitchingRulesRequest generates requests for GetServerSwitchingRules
func NewGetServerSwitchingRulesRequest(server string, parentName ParentName, params *GetServerSwitchingRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerSwitchingRulesRequest calls the generic ReplaceServerSwitchingRules builder with application/json body
func NewReplaceServerSwitchingRulesRequest(server string, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerSwitchingRulesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceServerSwitchingRulesRequestWithBody generates requests for ReplaceServerSwitchingRules with any type of body
func NewReplaceServerSwitchingRulesRequestWithBody(server string, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerSwitchingRuleRequest generates requests for DeleteServerSwitchingRule
func NewDeleteServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerSwitchingRuleRequest generates requests for GetServerSwitchingRule
func NewGetServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *GetServerSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerSwitchingRuleRequest calls the generic CreateServerSwitchingRule builder with application/json body
func NewCreateServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateServerSwitchingRuleRequestWithBody generates requests for CreateServerSwitchingRule with any type of body
func NewCreateServerSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceServerSwitchingRuleRequest calls the generic ReplaceServerSwitchingRule builder with application/json body
func NewReplaceServerSwitchingRuleRequest(server string, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceServerSwitchingRuleRequestWithBody generates requests for ReplaceServerSwitchingRule with any type of body
func NewReplaceServerSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetServerTemplatesRequest generates requests for GetServerTemplates
func NewGetServerTemplatesRequest(server string, parentName ParentName, params *GetServerTemplatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerTemplateRequest calls the generic CreateServerTemplate builder with application/json body
func NewCreateServerTemplateRequest(server string, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerTemplateRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerTemplateRequestWithBody generates requests for CreateServerTemplate with any type of body
func NewCreateServerTemplateRequestWithBody(server string, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerTemplateRequest generates requests for DeleteServerTemplate
func NewDeleteServerTemplateRequest(server string, parentName ParentName, prefix string, params *DeleteServerTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerTemplateRequest generates requests for GetServerTemplate
func NewGetServerTemplateRequest(server string, parentName ParentName, prefix string, params *GetServerTemplateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerTemplateRequest calls the generic ReplaceServerTemplate builder with application/json body
func NewReplaceServerTemplateRequest(server string, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerTemplateRequestWithBody(server, parentName, prefix, params, "application/json", bodyReader)
}

// NewReplaceServerTemplateRequestWithBody generates requests for ReplaceServerTemplate with any type of body
func NewReplaceServerTemplateRequestWithBody(server string, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "prefix", runtime.ParamLocationPath, prefix)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/server_templates/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerBackendRequest generates requests for GetAllServerBackend
func NewGetAllServerBackendRequest(server string, parentName ParentName, params *GetAllServerBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerBackendRequest calls the generic CreateServerBackend builder with application/json body
func NewCreateServerBackendRequest(server string, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerBackendRequestWithBody generates requests for CreateServerBackend with any type of body
func NewCreateServerBackendRequestWithBody(server string, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerBackendRequest generates requests for DeleteServerBackend
func NewDeleteServerBackendRequest(server string, parentName ParentName, name string, params *DeleteServerBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerBackendRequest generates requests for GetServerBackend
func NewGetServerBackendRequest(server string, parentName ParentName, name string, params *GetServerBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerBackendRequest calls the generic ReplaceServerBackend builder with application/json body
func NewReplaceServerBackendRequest(server string, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerBackendRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceServerBackendRequestWithBody generates requests for ReplaceServerBackend with any type of body
func NewReplaceServerBackendRequestWithBody(server string, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStickRulesRequest generates requests for GetStickRules
func NewGetStickRulesRequest(server string, parentName ParentName, params *GetStickRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStickRulesRequest calls the generic ReplaceStickRules builder with application/json body
func NewReplaceStickRulesRequest(server string, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceStickRulesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceStickRulesRequestWithBody generates requests for ReplaceStickRules with any type of body
func NewReplaceStickRulesRequestWithBody(server string, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStickRuleRequest generates requests for DeleteStickRule
func NewDeleteStickRuleRequest(server string, parentName ParentName, index int, params *DeleteStickRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStickRuleRequest generates requests for GetStickRule
func NewGetStickRuleRequest(server string, parentName ParentName, index int, params *GetStickRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStickRuleRequest calls the generic CreateStickRule builder with application/json body
func NewCreateStickRuleRequest(server string, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStickRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateStickRuleRequestWithBody generates requests for CreateStickRule with any type of body
func NewCreateStickRuleRequestWithBody(server string, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceStickRuleRequest calls the generic ReplaceStickRule builder with application/json body
func NewReplaceStickRuleRequest(server string, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceStickRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceStickRuleRequestWithBody generates requests for ReplaceStickRule with any type of body
func NewReplaceStickRuleRequestWithBody(server string, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/stick_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPCheckBackendRequest generates requests for GetAllTCPCheckBackend
func NewGetAllTCPCheckBackendRequest(server string, parentName ParentName, params *GetAllTCPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPCheckBackendRequest calls the generic ReplaceAllTCPCheckBackend builder with application/json body
func NewReplaceAllTCPCheckBackendRequest(server string, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPCheckBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPCheckBackendRequestWithBody generates requests for ReplaceAllTCPCheckBackend with any type of body
func NewReplaceAllTCPCheckBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPCheckBackendRequest generates requests for DeleteTCPCheckBackend
func NewDeleteTCPCheckBackendRequest(server string, parentName ParentName, index int, params *DeleteTCPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPCheckBackendRequest generates requests for GetTCPCheckBackend
func NewGetTCPCheckBackendRequest(server string, parentName ParentName, index int, params *GetTCPCheckBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPCheckBackendRequest calls the generic CreateTCPCheckBackend builder with application/json body
func NewCreateTCPCheckBackendRequest(server string, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPCheckBackendRequestWithBody generates requests for CreateTCPCheckBackend with any type of body
func NewCreateTCPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPCheckBackendRequest calls the generic ReplaceTCPCheckBackend builder with application/json body
func NewReplaceTCPCheckBackendRequest(server string, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPCheckBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPCheckBackendRequestWithBody generates requests for ReplaceTCPCheckBackend with any type of body
func NewReplaceTCPCheckBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPRequestRuleBackendRequest generates requests for GetAllTCPRequestRuleBackend
func NewGetAllTCPRequestRuleBackendRequest(server string, parentName ParentName, params *GetAllTCPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPRequestRuleBackendRequest calls the generic ReplaceAllTCPRequestRuleBackend builder with application/json body
func NewReplaceAllTCPRequestRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPRequestRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPRequestRuleBackendRequestWithBody generates requests for ReplaceAllTCPRequestRuleBackend with any type of body
func NewReplaceAllTCPRequestRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPRequestRuleBackendRequest generates requests for DeleteTCPRequestRuleBackend
func NewDeleteTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPRequestRuleBackendRequest generates requests for GetTCPRequestRuleBackend
func NewGetTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPRequestRuleBackendRequest calls the generic CreateTCPRequestRuleBackend builder with application/json body
func NewCreateTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPRequestRuleBackendRequestWithBody generates requests for CreateTCPRequestRuleBackend with any type of body
func NewCreateTCPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPRequestRuleBackendRequest calls the generic ReplaceTCPRequestRuleBackend builder with application/json body
func NewReplaceTCPRequestRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPRequestRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPRequestRuleBackendRequestWithBody generates requests for ReplaceTCPRequestRuleBackend with any type of body
func NewReplaceTCPRequestRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPResponseRuleBackendRequest generates requests for GetAllTCPResponseRuleBackend
func NewGetAllTCPResponseRuleBackendRequest(server string, parentName ParentName, params *GetAllTCPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPResponseRuleBackendRequest calls the generic ReplaceAllTCPResponseRuleBackend builder with application/json body
func NewReplaceAllTCPResponseRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPResponseRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPResponseRuleBackendRequestWithBody generates requests for ReplaceAllTCPResponseRuleBackend with any type of body
func NewReplaceAllTCPResponseRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPResponseRuleBackendRequest generates requests for DeleteTCPResponseRuleBackend
func NewDeleteTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPResponseRuleBackendRequest generates requests for GetTCPResponseRuleBackend
func NewGetTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPResponseRuleBackendRequest calls the generic CreateTCPResponseRuleBackend builder with application/json body
func NewCreateTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPResponseRuleBackendRequestWithBody generates requests for CreateTCPResponseRuleBackend with any type of body
func NewCreateTCPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPResponseRuleBackendRequest calls the generic ReplaceTCPResponseRuleBackend builder with application/json body
func NewReplaceTCPResponseRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPResponseRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPResponseRuleBackendRequestWithBody generates requests for ReplaceTCPResponseRuleBackend with any type of body
func NewReplaceTCPResponseRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/tcp_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllWafBodyRuleBackendRequest generates requests for GetAllWafBodyRuleBackend
func NewGetAllWafBodyRuleBackendRequest(server string, parentName ParentName, params *GetAllWafBodyRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/waf_body_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllWafBodyRuleBackendRequest calls the generic ReplaceAllWafBodyRuleBackend builder with application/json body
func NewReplaceAllWafBodyRuleBackendRequest(server string, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, body ReplaceAllWafBodyRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllWafBodyRuleBackendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllWafBodyRuleBackendRequestWithBody generates requests for ReplaceAllWafBodyRuleBackend with any type of body
func NewReplaceAllWafBodyRuleBackendRequestWithBody(server string, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/waf_body_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWafBodyRuleBackendRequest generates requests for DeleteWafBodyRuleBackend
func NewDeleteWafBodyRuleBackendRequest(server string, parentName ParentName, index int, params *DeleteWafBodyRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/waf_body_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWafBodyRuleBackendRequest generates requests for GetWafBodyRuleBackend
func NewGetWafBodyRuleBackendRequest(server string, parentName ParentName, index int, params *GetWafBodyRuleBackendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/waf_body_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWafBodyRuleBackendRequest calls the generic CreateWafBodyRuleBackend builder with application/json body
func NewCreateWafBodyRuleBackendRequest(server string, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, body CreateWafBodyRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWafBodyRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateWafBodyRuleBackendRequestWithBody generates requests for CreateWafBodyRuleBackend with any type of body
func NewCreateWafBodyRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/waf_body_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceWafBodyRuleBackendRequest calls the generic ReplaceWafBodyRuleBackend builder with application/json body
func NewReplaceWafBodyRuleBackendRequest(server string, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, body ReplaceWafBodyRuleBackendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceWafBodyRuleBackendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceWafBodyRuleBackendRequestWithBody generates requests for ReplaceWafBodyRuleBackend with any type of body
func NewReplaceWafBodyRuleBackendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/backends/%s/waf_body_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBotmgmtProfilesRequest generates requests for GetBotmgmtProfiles
func NewGetBotmgmtProfilesRequest(server string, params *GetBotmgmtProfilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/botmgmt_profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBotmgmtProfileRequest calls the generic CreateBotmgmtProfile builder with application/json body
func NewCreateBotmgmtProfileRequest(server string, params *CreateBotmgmtProfileParams, body CreateBotmgmtProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBotmgmtProfileRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateBotmgmtProfileRequestWithBody generates requests for CreateBotmgmtProfile with any type of body
func NewCreateBotmgmtProfileRequestWithBody(server string, params *CreateBotmgmtProfileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/botmgmt_profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBotmgmtProfileRequest generates requests for DeleteBotmgmtProfile
func NewDeleteBotmgmtProfileRequest(server string, name string, params *DeleteBotmgmtProfileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/botmgmt_profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBotmgmtProfileRequest generates requests for GetBotmgmtProfile
func NewGetBotmgmtProfileRequest(server string, name string, params *GetBotmgmtProfileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/botmgmt_profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditBotmgmtProfileRequest calls the generic EditBotmgmtProfile builder with application/json body
func NewEditBotmgmtProfileRequest(server string, name string, params *EditBotmgmtProfileParams, body EditBotmgmtProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditBotmgmtProfileRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditBotmgmtProfileRequestWithBody generates requests for EditBotmgmtProfile with any type of body
func NewEditBotmgmtProfileRequestWithBody(server string, name string, params *EditBotmgmtProfileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/botmgmt_profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCachesRequest generates requests for GetCaches
func NewGetCachesRequest(server string, params *GetCachesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCacheRequest calls the generic CreateCache builder with application/json body
func NewCreateCacheRequest(server string, params *CreateCacheParams, body CreateCacheJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCacheRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCacheRequestWithBody generates requests for CreateCache with any type of body
func NewCreateCacheRequestWithBody(server string, params *CreateCacheParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCacheRequest generates requests for DeleteCache
func NewDeleteCacheRequest(server string, name string, params *DeleteCacheParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCacheRequest generates requests for GetCache
func NewGetCacheRequest(server string, name string, params *GetCacheParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceCacheRequest calls the generic ReplaceCache builder with application/json body
func NewReplaceCacheRequest(server string, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceCacheRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceCacheRequestWithBody generates requests for ReplaceCache with any type of body
func NewReplaceCacheRequestWithBody(server string, name string, params *ReplaceCacheParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/caches/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCaptchasRequest generates requests for GetCaptchas
func NewGetCaptchasRequest(server string, params *GetCaptchasParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/captchas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCaptchaRequest calls the generic CreateCaptcha builder with application/json body
func NewCreateCaptchaRequest(server string, params *CreateCaptchaParams, body CreateCaptchaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCaptchaRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCaptchaRequestWithBody generates requests for CreateCaptcha with any type of body
func NewCreateCaptchaRequestWithBody(server string, params *CreateCaptchaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/captchas")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCaptchaRequest generates requests for DeleteCaptcha
func NewDeleteCaptchaRequest(server string, name string, params *DeleteCaptchaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/captchas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCaptchaRequest generates requests for GetCaptcha
func NewGetCaptchaRequest(server string, name string, params *GetCaptchaParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/captchas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditCaptchaRequest calls the generic EditCaptcha builder with application/json body
func NewEditCaptchaRequest(server string, name string, params *EditCaptchaParams, body EditCaptchaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCaptchaRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditCaptchaRequestWithBody generates requests for EditCaptcha with any type of body
func NewEditCaptchaRequestWithBody(server string, name string, params *EditCaptchaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/captchas/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetClusterConfigurationVersionRequest generates requests for GetClusterConfigurationVersion
func NewGetClusterConfigurationVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/cluster_version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCrtLoadsRequest generates requests for GetCrtLoads
func NewGetCrtLoadsRequest(server string, params *GetCrtLoadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCrtLoadRequest calls the generic CreateCrtLoad builder with application/json body
func NewCreateCrtLoadRequest(server string, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCrtLoadRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCrtLoadRequestWithBody generates requests for CreateCrtLoad with any type of body
func NewCreateCrtLoadRequestWithBody(server string, params *CreateCrtLoadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCrtLoadRequest generates requests for DeleteCrtLoad
func NewDeleteCrtLoadRequest(server string, certificate string, params *DeleteCrtLoadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate", runtime.ParamLocationPath, certificate)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCrtLoadRequest generates requests for GetCrtLoad
func NewGetCrtLoadRequest(server string, certificate string, params *GetCrtLoadParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate", runtime.ParamLocationPath, certificate)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceCrtLoadRequest calls the generic ReplaceCrtLoad builder with application/json body
func NewReplaceCrtLoadRequest(server string, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceCrtLoadRequestWithBody(server, certificate, params, "application/json", bodyReader)
}

// NewReplaceCrtLoadRequestWithBody generates requests for ReplaceCrtLoad with any type of body
func NewReplaceCrtLoadRequestWithBody(server string, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certificate", runtime.ParamLocationPath, certificate)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_loads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "crt_store", runtime.ParamLocationQuery, params.CrtStore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCrtStoresRequest generates requests for GetCrtStores
func NewGetCrtStoresRequest(server string, params *GetCrtStoresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCrtStoreRequest calls the generic CreateCrtStore builder with application/json body
func NewCreateCrtStoreRequest(server string, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCrtStoreRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCrtStoreRequestWithBody generates requests for CreateCrtStore with any type of body
func NewCreateCrtStoreRequestWithBody(server string, params *CreateCrtStoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCrtStoreRequest generates requests for DeleteCrtStore
func NewDeleteCrtStoreRequest(server string, name string, params *DeleteCrtStoreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCrtStoreRequest generates requests for GetCrtStore
func NewGetCrtStoreRequest(server string, name string, params *GetCrtStoreParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditCrtStoreRequest calls the generic EditCrtStore builder with application/json body
func NewEditCrtStoreRequest(server string, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCrtStoreRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditCrtStoreRequestWithBody generates requests for EditCrtStore with any type of body
func NewEditCrtStoreRequestWithBody(server string, name string, params *EditCrtStoreParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/crt_stores/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultsSectionsRequest generates requests for GetDefaultsSections
func NewGetDefaultsSectionsRequest(server string, params *GetDefaultsSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDefaultsSectionRequest calls the generic CreateDefaultsSection builder with application/json body
func NewCreateDefaultsSectionRequest(server string, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDefaultsSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateDefaultsSectionRequestWithBody generates requests for CreateDefaultsSection with any type of body
func NewCreateDefaultsSectionRequestWithBody(server string, params *CreateDefaultsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDefaultsSectionRequest generates requests for DeleteDefaultsSection
func NewDeleteDefaultsSectionRequest(server string, name string, params *DeleteDefaultsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDefaultsSectionRequest generates requests for GetDefaultsSection
func NewGetDefaultsSectionRequest(server string, name string, params *GetDefaultsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDefaultsSectionRequest calls the generic ReplaceDefaultsSection builder with application/json body
func NewReplaceDefaultsSectionRequest(server string, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDefaultsSectionRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceDefaultsSectionRequestWithBody generates requests for ReplaceDefaultsSection with any type of body
func NewReplaceDefaultsSectionRequestWithBody(server string, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPCheckDefaultsRequest generates requests for GetAllHTTPCheckDefaults
func NewGetAllHTTPCheckDefaultsRequest(server string, parentName ParentName, params *GetAllHTTPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPCheckDefaultsRequest calls the generic ReplaceAllHTTPCheckDefaults builder with application/json body
func NewReplaceAllHTTPCheckDefaultsRequest(server string, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPCheckDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPCheckDefaultsRequestWithBody generates requests for ReplaceAllHTTPCheckDefaults with any type of body
func NewReplaceAllHTTPCheckDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPCheckDefaultsRequest generates requests for DeleteHTTPCheckDefaults
func NewDeleteHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPCheckDefaultsRequest generates requests for GetHTTPCheckDefaults
func NewGetHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPCheckDefaultsRequest calls the generic CreateHTTPCheckDefaults builder with application/json body
func NewCreateHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPCheckDefaultsRequestWithBody generates requests for CreateHTTPCheckDefaults with any type of body
func NewCreateHTTPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPCheckDefaultsRequest calls the generic ReplaceHTTPCheckDefaults builder with application/json body
func NewReplaceHTTPCheckDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPCheckDefaultsRequestWithBody generates requests for ReplaceHTTPCheckDefaults with any type of body
func NewReplaceHTTPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPErrorRuleDefaultsRequest generates requests for GetAllHTTPErrorRuleDefaults
func NewGetAllHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPErrorRuleDefaultsRequest calls the generic ReplaceAllHTTPErrorRuleDefaults builder with application/json body
func NewReplaceAllHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody generates requests for ReplaceAllHTTPErrorRuleDefaults with any type of body
func NewReplaceAllHTTPErrorRuleDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorRuleDefaultsRequest generates requests for DeleteHTTPErrorRuleDefaults
func NewDeleteHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorRuleDefaultsRequest generates requests for GetHTTPErrorRuleDefaults
func NewGetHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorRuleDefaultsRequest calls the generic CreateHTTPErrorRuleDefaults builder with application/json body
func NewCreateHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorRuleDefaultsRequestWithBody generates requests for CreateHTTPErrorRuleDefaults with any type of body
func NewCreateHTTPErrorRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPErrorRuleDefaultsRequest calls the generic ReplaceHTTPErrorRuleDefaults builder with application/json body
func NewReplaceHTTPErrorRuleDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorRuleDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorRuleDefaultsRequestWithBody generates requests for ReplaceHTTPErrorRuleDefaults with any type of body
func NewReplaceHTTPErrorRuleDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetDefaultsRequest generates requests for GetAllLogTargetDefaults
func NewGetAllLogTargetDefaultsRequest(server string, parentName ParentName, params *GetAllLogTargetDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetDefaultsRequest calls the generic ReplaceAllLogTargetDefaults builder with application/json body
func NewReplaceAllLogTargetDefaultsRequest(server string, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetDefaultsRequestWithBody generates requests for ReplaceAllLogTargetDefaults with any type of body
func NewReplaceAllLogTargetDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetDefaultsRequest generates requests for DeleteLogTargetDefaults
func NewDeleteLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetDefaultsRequest generates requests for GetLogTargetDefaults
func NewGetLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *GetLogTargetDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetDefaultsRequest calls the generic CreateLogTargetDefaults builder with application/json body
func NewCreateLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetDefaultsRequestWithBody generates requests for CreateLogTargetDefaults with any type of body
func NewCreateLogTargetDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetDefaultsRequest calls the generic ReplaceLogTargetDefaults builder with application/json body
func NewReplaceLogTargetDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetDefaultsRequestWithBody generates requests for ReplaceLogTargetDefaults with any type of body
func NewReplaceLogTargetDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPCheckDefaultsRequest generates requests for GetAllTCPCheckDefaults
func NewGetAllTCPCheckDefaultsRequest(server string, parentName ParentName, params *GetAllTCPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPCheckDefaultsRequest calls the generic ReplaceAllTCPCheckDefaults builder with application/json body
func NewReplaceAllTCPCheckDefaultsRequest(server string, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPCheckDefaultsRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPCheckDefaultsRequestWithBody generates requests for ReplaceAllTCPCheckDefaults with any type of body
func NewReplaceAllTCPCheckDefaultsRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPCheckDefaultsRequest generates requests for DeleteTCPCheckDefaults
func NewDeleteTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPCheckDefaultsRequest generates requests for GetTCPCheckDefaults
func NewGetTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *GetTCPCheckDefaultsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPCheckDefaultsRequest calls the generic CreateTCPCheckDefaults builder with application/json body
func NewCreateTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPCheckDefaultsRequestWithBody generates requests for CreateTCPCheckDefaults with any type of body
func NewCreateTCPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPCheckDefaultsRequest calls the generic ReplaceTCPCheckDefaults builder with application/json body
func NewReplaceTCPCheckDefaultsRequest(server string, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPCheckDefaultsRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPCheckDefaultsRequestWithBody generates requests for ReplaceTCPCheckDefaults with any type of body
func NewReplaceTCPCheckDefaultsRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/defaults/%s/tcp_checks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDynamicUpdateRulesRequest generates requests for GetDynamicUpdateRules
func NewGetDynamicUpdateRulesRequest(server string, params *GetDynamicUpdateRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/dynamic_update_rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDynamicUpdateRulesRequest calls the generic ReplaceDynamicUpdateRules builder with application/json body
func NewReplaceDynamicUpdateRulesRequest(server string, params *ReplaceDynamicUpdateRulesParams, body ReplaceDynamicUpdateRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDynamicUpdateRulesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceDynamicUpdateRulesRequestWithBody generates requests for ReplaceDynamicUpdateRules with any type of body
func NewReplaceDynamicUpdateRulesRequestWithBody(server string, params *ReplaceDynamicUpdateRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/dynamic_update_rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDynamicUpdateRuleRequest generates requests for DeleteDynamicUpdateRule
func NewDeleteDynamicUpdateRuleRequest(server string, index int, params *DeleteDynamicUpdateRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/dynamic_update_rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDynamicUpdateRuleRequest generates requests for GetDynamicUpdateRule
func NewGetDynamicUpdateRuleRequest(server string, index int, params *GetDynamicUpdateRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/dynamic_update_rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDynamicUpdateRuleRequest calls the generic CreateDynamicUpdateRule builder with application/json body
func NewCreateDynamicUpdateRuleRequest(server string, index int, params *CreateDynamicUpdateRuleParams, body CreateDynamicUpdateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDynamicUpdateRuleRequestWithBody(server, index, params, "application/json", bodyReader)
}

// NewCreateDynamicUpdateRuleRequestWithBody generates requests for CreateDynamicUpdateRule with any type of body
func NewCreateDynamicUpdateRuleRequestWithBody(server string, index int, params *CreateDynamicUpdateRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/dynamic_update_rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceDynamicUpdateRuleRequest calls the generic ReplaceDynamicUpdateRule builder with application/json body
func NewReplaceDynamicUpdateRuleRequest(server string, index int, params *ReplaceDynamicUpdateRuleParams, body ReplaceDynamicUpdateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDynamicUpdateRuleRequestWithBody(server, index, params, "application/json", bodyReader)
}

// NewReplaceDynamicUpdateRuleRequestWithBody generates requests for ReplaceDynamicUpdateRule with any type of body
func NewReplaceDynamicUpdateRuleRequestWithBody(server string, index int, params *ReplaceDynamicUpdateRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/dynamic_update_rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDynamicUpdateSectionRequest generates requests for DeleteDynamicUpdateSection
func NewDeleteDynamicUpdateSectionRequest(server string, params *DeleteDynamicUpdateSectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/dynamic_update_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDynamicUpdateSectionRequest generates requests for GetDynamicUpdateSection
func NewGetDynamicUpdateSectionRequest(server string, params *GetDynamicUpdateSectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/dynamic_update_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDynamicUpdateSectionRequest generates requests for CreateDynamicUpdateSection
func NewCreateDynamicUpdateSectionRequest(server string, params *CreateDynamicUpdateSectionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/dynamic_update_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFCGIAppsRequest generates requests for GetFCGIApps
func NewGetFCGIAppsRequest(server string, params *GetFCGIAppsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFCGIAppRequest calls the generic CreateFCGIApp builder with application/json body
func NewCreateFCGIAppRequest(server string, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFCGIAppRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateFCGIAppRequestWithBody generates requests for CreateFCGIApp with any type of body
func NewCreateFCGIAppRequestWithBody(server string, params *CreateFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFCGIAppRequest generates requests for DeleteFCGIApp
func NewDeleteFCGIAppRequest(server string, name string, params *DeleteFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFCGIAppRequest generates requests for GetFCGIApp
func NewGetFCGIAppRequest(server string, name string, params *GetFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceFCGIAppRequest calls the generic ReplaceFCGIApp builder with application/json body
func NewReplaceFCGIAppRequest(server string, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFCGIAppRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceFCGIAppRequestWithBody generates requests for ReplaceFCGIApp with any type of body
func NewReplaceFCGIAppRequestWithBody(server string, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclFCGIAppRequest generates requests for GetAllAclFCGIApp
func NewGetAllAclFCGIAppRequest(server string, parentName ParentName, params *GetAllAclFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclFCGIAppRequest calls the generic ReplaceAllAclFCGIApp builder with application/json body
func NewReplaceAllAclFCGIAppRequest(server string, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclFCGIAppRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclFCGIAppRequestWithBody generates requests for ReplaceAllAclFCGIApp with any type of body
func NewReplaceAllAclFCGIAppRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclFCGIAppRequest generates requests for DeleteAclFCGIApp
func NewDeleteAclFCGIAppRequest(server string, parentName ParentName, index int, params *DeleteAclFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclFCGIAppRequest generates requests for GetAclFCGIApp
func NewGetAclFCGIAppRequest(server string, parentName ParentName, index int, params *GetAclFCGIAppParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclFCGIAppRequest calls the generic CreateAclFCGIApp builder with application/json body
func NewCreateAclFCGIAppRequest(server string, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclFCGIAppRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclFCGIAppRequestWithBody generates requests for CreateAclFCGIApp with any type of body
func NewCreateAclFCGIAppRequestWithBody(server string, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclFCGIAppRequest calls the generic ReplaceAclFCGIApp builder with application/json body
func NewReplaceAclFCGIAppRequest(server string, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclFCGIAppRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclFCGIAppRequestWithBody generates requests for ReplaceAclFCGIApp with any type of body
func NewReplaceAclFCGIAppRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/fcgi_apps/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFrontendsRequest generates requests for GetFrontends
func NewGetFrontendsRequest(server string, params *GetFrontendsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFrontendRequest calls the generic CreateFrontend builder with application/json body
func NewCreateFrontendRequest(server string, params *CreateFrontendParams, body CreateFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFrontendRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateFrontendRequestWithBody generates requests for CreateFrontend with any type of body
func NewCreateFrontendRequestWithBody(server string, params *CreateFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFrontendRequest generates requests for DeleteFrontend
func NewDeleteFrontendRequest(server string, name string, params *DeleteFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFrontendRequest generates requests for GetFrontend
func NewGetFrontendRequest(server string, name string, params *GetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceFrontendRequest calls the generic ReplaceFrontend builder with application/json body
func NewReplaceFrontendRequest(server string, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFrontendRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceFrontendRequestWithBody generates requests for ReplaceFrontend with any type of body
func NewReplaceFrontendRequestWithBody(server string, name string, params *ReplaceFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllAclFrontendRequest generates requests for GetAllAclFrontend
func NewGetAllAclFrontendRequest(server string, parentName ParentName, params *GetAllAclFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AclName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "acl_name", runtime.ParamLocationQuery, *params.AclName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllAclFrontendRequest calls the generic ReplaceAllAclFrontend builder with application/json body
func NewReplaceAllAclFrontendRequest(server string, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllAclFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllAclFrontendRequestWithBody generates requests for ReplaceAllAclFrontend with any type of body
func NewReplaceAllAclFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAclFrontendRequest generates requests for DeleteAclFrontend
func NewDeleteAclFrontendRequest(server string, parentName ParentName, index int, params *DeleteAclFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAclFrontendRequest generates requests for GetAclFrontend
func NewGetAclFrontendRequest(server string, parentName ParentName, index int, params *GetAclFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAclFrontendRequest calls the generic CreateAclFrontend builder with application/json body
func NewCreateAclFrontendRequest(server string, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAclFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateAclFrontendRequestWithBody generates requests for CreateAclFrontend with any type of body
func NewCreateAclFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceAclFrontendRequest calls the generic ReplaceAclFrontend builder with application/json body
func NewReplaceAclFrontendRequest(server string, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAclFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceAclFrontendRequestWithBody generates requests for ReplaceAclFrontend with any type of body
func NewReplaceAclFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/acls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBackendSwitchingRulesRequest generates requests for GetBackendSwitchingRules
func NewGetBackendSwitchingRulesRequest(server string, parentName ParentName, params *GetBackendSwitchingRulesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBackendSwitchingRulesRequest calls the generic ReplaceBackendSwitchingRules builder with application/json body
func NewReplaceBackendSwitchingRulesRequest(server string, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBackendSwitchingRulesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceBackendSwitchingRulesRequestWithBody generates requests for ReplaceBackendSwitchingRules with any type of body
func NewReplaceBackendSwitchingRulesRequestWithBody(server string, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBackendSwitchingRuleRequest generates requests for DeleteBackendSwitchingRule
func NewDeleteBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackendSwitchingRuleRequest generates requests for GetBackendSwitchingRule
func NewGetBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *GetBackendSwitchingRuleParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackendSwitchingRuleRequest calls the generic CreateBackendSwitchingRule builder with application/json body
func NewCreateBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBackendSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateBackendSwitchingRuleRequestWithBody generates requests for CreateBackendSwitchingRule with any type of body
func NewCreateBackendSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceBackendSwitchingRuleRequest calls the generic ReplaceBackendSwitchingRule builder with application/json body
func NewReplaceBackendSwitchingRuleRequest(server string, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBackendSwitchingRuleRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceBackendSwitchingRuleRequestWithBody generates requests for ReplaceBackendSwitchingRule with any type of body
func NewReplaceBackendSwitchingRuleRequestWithBody(server string, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/backend_switching_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllBindFrontendRequest generates requests for GetAllBindFrontend
func NewGetAllBindFrontendRequest(server string, parentName ParentName, params *GetAllBindFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBindFrontendRequest calls the generic CreateBindFrontend builder with application/json body
func NewCreateBindFrontendRequest(server string, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBindFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateBindFrontendRequestWithBody generates requests for CreateBindFrontend with any type of body
func NewCreateBindFrontendRequestWithBody(server string, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBindFrontendRequest generates requests for DeleteBindFrontend
func NewDeleteBindFrontendRequest(server string, parentName ParentName, name string, params *DeleteBindFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBindFrontendRequest generates requests for GetBindFrontend
func NewGetBindFrontendRequest(server string, parentName ParentName, name string, params *GetBindFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBindFrontendRequest calls the generic ReplaceBindFrontend builder with application/json body
func NewReplaceBindFrontendRequest(server string, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBindFrontendRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceBindFrontendRequestWithBody generates requests for ReplaceBindFrontend with any type of body
func NewReplaceBindFrontendRequestWithBody(server string, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDeclareCapturesRequest generates requests for GetDeclareCaptures
func NewGetDeclareCapturesRequest(server string, parentName ParentName, params *GetDeclareCapturesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDeclareCapturesRequest calls the generic ReplaceDeclareCaptures builder with application/json body
func NewReplaceDeclareCapturesRequest(server string, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDeclareCapturesRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceDeclareCapturesRequestWithBody generates requests for ReplaceDeclareCaptures with any type of body
func NewReplaceDeclareCapturesRequestWithBody(server string, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDeclareCaptureRequest generates requests for DeleteDeclareCapture
func NewDeleteDeclareCaptureRequest(server string, parentName ParentName, index int, params *DeleteDeclareCaptureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDeclareCaptureRequest generates requests for GetDeclareCapture
func NewGetDeclareCaptureRequest(server string, parentName ParentName, index int, params *GetDeclareCaptureParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDeclareCaptureRequest calls the generic CreateDeclareCapture builder with application/json body
func NewCreateDeclareCaptureRequest(server string, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDeclareCaptureRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateDeclareCaptureRequestWithBody generates requests for CreateDeclareCapture with any type of body
func NewCreateDeclareCaptureRequestWithBody(server string, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceDeclareCaptureRequest calls the generic ReplaceDeclareCapture builder with application/json body
func NewReplaceDeclareCaptureRequest(server string, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDeclareCaptureRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceDeclareCaptureRequestWithBody generates requests for ReplaceDeclareCapture with any type of body
func NewReplaceDeclareCaptureRequestWithBody(server string, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/captures/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllFilterFrontendRequest generates requests for GetAllFilterFrontend
func NewGetAllFilterFrontendRequest(server string, parentName ParentName, params *GetAllFilterFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllFilterFrontendRequest calls the generic ReplaceAllFilterFrontend builder with application/json body
func NewReplaceAllFilterFrontendRequest(server string, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllFilterFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllFilterFrontendRequestWithBody generates requests for ReplaceAllFilterFrontend with any type of body
func NewReplaceAllFilterFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFilterFrontendRequest generates requests for DeleteFilterFrontend
func NewDeleteFilterFrontendRequest(server string, parentName ParentName, index int, params *DeleteFilterFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFilterFrontendRequest generates requests for GetFilterFrontend
func NewGetFilterFrontendRequest(server string, parentName ParentName, index int, params *GetFilterFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFilterFrontendRequest calls the generic CreateFilterFrontend builder with application/json body
func NewCreateFilterFrontendRequest(server string, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFilterFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateFilterFrontendRequestWithBody generates requests for CreateFilterFrontend with any type of body
func NewCreateFilterFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceFilterFrontendRequest calls the generic ReplaceFilterFrontend builder with application/json body
func NewReplaceFilterFrontendRequest(server string, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceFilterFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceFilterFrontendRequestWithBody generates requests for ReplaceFilterFrontend with any type of body
func NewReplaceFilterFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/filters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPAfterResponseRuleFrontendRequest generates requests for GetAllHTTPAfterResponseRuleFrontend
func NewGetAllHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPAfterResponseRuleFrontendRequest calls the generic ReplaceAllHTTPAfterResponseRuleFrontend builder with application/json body
func NewReplaceAllHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPAfterResponseRuleFrontend with any type of body
func NewReplaceAllHTTPAfterResponseRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPAfterResponseRuleFrontendRequest generates requests for DeleteHTTPAfterResponseRuleFrontend
func NewDeleteHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPAfterResponseRuleFrontendRequest generates requests for GetHTTPAfterResponseRuleFrontend
func NewGetHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPAfterResponseRuleFrontendRequest calls the generic CreateHTTPAfterResponseRuleFrontend builder with application/json body
func NewCreateHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPAfterResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPAfterResponseRuleFrontendRequestWithBody generates requests for CreateHTTPAfterResponseRuleFrontend with any type of body
func NewCreateHTTPAfterResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPAfterResponseRuleFrontendRequest calls the generic ReplaceHTTPAfterResponseRuleFrontend builder with application/json body
func NewReplaceHTTPAfterResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody generates requests for ReplaceHTTPAfterResponseRuleFrontend with any type of body
func NewReplaceHTTPAfterResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_after_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPErrorRuleFrontendRequest generates requests for GetAllHTTPErrorRuleFrontend
func NewGetAllHTTPErrorRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPErrorRuleFrontendRequest calls the generic ReplaceAllHTTPErrorRuleFrontend builder with application/json body
func NewReplaceAllHTTPErrorRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPErrorRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPErrorRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPErrorRuleFrontend with any type of body
func NewReplaceAllHTTPErrorRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorRuleFrontendRequest generates requests for DeleteHTTPErrorRuleFrontend
func NewDeleteHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorRuleFrontendRequest generates requests for GetHTTPErrorRuleFrontend
func NewGetHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorRuleFrontendRequest calls the generic CreateHTTPErrorRuleFrontend builder with application/json body
func NewCreateHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorRuleFrontendRequestWithBody generates requests for CreateHTTPErrorRuleFrontend with any type of body
func NewCreateHTTPErrorRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPErrorRuleFrontendRequest calls the generic ReplaceHTTPErrorRuleFrontend builder with application/json body
func NewReplaceHTTPErrorRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorRuleFrontendRequestWithBody generates requests for ReplaceHTTPErrorRuleFrontend with any type of body
func NewReplaceHTTPErrorRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_error_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPRequestRuleFrontendRequest generates requests for GetAllHTTPRequestRuleFrontend
func NewGetAllHTTPRequestRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPRequestRuleFrontendRequest calls the generic ReplaceAllHTTPRequestRuleFrontend builder with application/json body
func NewReplaceAllHTTPRequestRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPRequestRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPRequestRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPRequestRuleFrontend with any type of body
func NewReplaceAllHTTPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPRequestRuleFrontendRequest generates requests for DeleteHTTPRequestRuleFrontend
func NewDeleteHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPRequestRuleFrontendRequest generates requests for GetHTTPRequestRuleFrontend
func NewGetHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPRequestRuleFrontendRequest calls the generic CreateHTTPRequestRuleFrontend builder with application/json body
func NewCreateHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPRequestRuleFrontendRequestWithBody generates requests for CreateHTTPRequestRuleFrontend with any type of body
func NewCreateHTTPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPRequestRuleFrontendRequest calls the generic ReplaceHTTPRequestRuleFrontend builder with application/json body
func NewReplaceHTTPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPRequestRuleFrontendRequestWithBody generates requests for ReplaceHTTPRequestRuleFrontend with any type of body
func NewReplaceHTTPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllHTTPResponseRuleFrontendRequest generates requests for GetAllHTTPResponseRuleFrontend
func NewGetAllHTTPResponseRuleFrontendRequest(server string, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllHTTPResponseRuleFrontendRequest calls the generic ReplaceAllHTTPResponseRuleFrontend builder with application/json body
func NewReplaceAllHTTPResponseRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllHTTPResponseRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllHTTPResponseRuleFrontendRequestWithBody generates requests for ReplaceAllHTTPResponseRuleFrontend with any type of body
func NewReplaceAllHTTPResponseRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPResponseRuleFrontendRequest generates requests for DeleteHTTPResponseRuleFrontend
func NewDeleteHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPResponseRuleFrontendRequest generates requests for GetHTTPResponseRuleFrontend
func NewGetHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPResponseRuleFrontendRequest calls the generic CreateHTTPResponseRuleFrontend builder with application/json body
func NewCreateHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateHTTPResponseRuleFrontendRequestWithBody generates requests for CreateHTTPResponseRuleFrontend with any type of body
func NewCreateHTTPResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceHTTPResponseRuleFrontendRequest calls the generic ReplaceHTTPResponseRuleFrontend builder with application/json body
func NewReplaceHTTPResponseRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPResponseRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceHTTPResponseRuleFrontendRequestWithBody generates requests for ReplaceHTTPResponseRuleFrontend with any type of body
func NewReplaceHTTPResponseRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/http_response_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetFrontendRequest generates requests for GetAllLogTargetFrontend
func NewGetAllLogTargetFrontendRequest(server string, parentName ParentName, params *GetAllLogTargetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetFrontendRequest calls the generic ReplaceAllLogTargetFrontend builder with application/json body
func NewReplaceAllLogTargetFrontendRequest(server string, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetFrontendRequestWithBody generates requests for ReplaceAllLogTargetFrontend with any type of body
func NewReplaceAllLogTargetFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetFrontendRequest generates requests for DeleteLogTargetFrontend
func NewDeleteLogTargetFrontendRequest(server string, parentName ParentName, index int, params *DeleteLogTargetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetFrontendRequest generates requests for GetLogTargetFrontend
func NewGetLogTargetFrontendRequest(server string, parentName ParentName, index int, params *GetLogTargetFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetFrontendRequest calls the generic CreateLogTargetFrontend builder with application/json body
func NewCreateLogTargetFrontendRequest(server string, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetFrontendRequestWithBody generates requests for CreateLogTargetFrontend with any type of body
func NewCreateLogTargetFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetFrontendRequest calls the generic ReplaceLogTargetFrontend builder with application/json body
func NewReplaceLogTargetFrontendRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetFrontendRequestWithBody generates requests for ReplaceLogTargetFrontend with any type of body
func NewReplaceLogTargetFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllTCPRequestRuleFrontendRequest generates requests for GetAllTCPRequestRuleFrontend
func NewGetAllTCPRequestRuleFrontendRequest(server string, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllTCPRequestRuleFrontendRequest calls the generic ReplaceAllTCPRequestRuleFrontend builder with application/json body
func NewReplaceAllTCPRequestRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllTCPRequestRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllTCPRequestRuleFrontendRequestWithBody generates requests for ReplaceAllTCPRequestRuleFrontend with any type of body
func NewReplaceAllTCPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTCPRequestRuleFrontendRequest generates requests for DeleteTCPRequestRuleFrontend
func NewDeleteTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTCPRequestRuleFrontendRequest generates requests for GetTCPRequestRuleFrontend
func NewGetTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTCPRequestRuleFrontendRequest calls the generic CreateTCPRequestRuleFrontend builder with application/json body
func NewCreateTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTCPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateTCPRequestRuleFrontendRequestWithBody generates requests for CreateTCPRequestRuleFrontend with any type of body
func NewCreateTCPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceTCPRequestRuleFrontendRequest calls the generic ReplaceTCPRequestRuleFrontend builder with application/json body
func NewReplaceTCPRequestRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTCPRequestRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceTCPRequestRuleFrontendRequestWithBody generates requests for ReplaceTCPRequestRuleFrontend with any type of body
func NewReplaceTCPRequestRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/tcp_request_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllWafBodyRuleFrontendRequest generates requests for GetAllWafBodyRuleFrontend
func NewGetAllWafBodyRuleFrontendRequest(server string, parentName ParentName, params *GetAllWafBodyRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/waf_body_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllWafBodyRuleFrontendRequest calls the generic ReplaceAllWafBodyRuleFrontend builder with application/json body
func NewReplaceAllWafBodyRuleFrontendRequest(server string, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, body ReplaceAllWafBodyRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllWafBodyRuleFrontendRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllWafBodyRuleFrontendRequestWithBody generates requests for ReplaceAllWafBodyRuleFrontend with any type of body
func NewReplaceAllWafBodyRuleFrontendRequestWithBody(server string, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/waf_body_rules", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWafBodyRuleFrontendRequest generates requests for DeleteWafBodyRuleFrontend
func NewDeleteWafBodyRuleFrontendRequest(server string, parentName ParentName, index int, params *DeleteWafBodyRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/waf_body_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWafBodyRuleFrontendRequest generates requests for GetWafBodyRuleFrontend
func NewGetWafBodyRuleFrontendRequest(server string, parentName ParentName, index int, params *GetWafBodyRuleFrontendParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/waf_body_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWafBodyRuleFrontendRequest calls the generic CreateWafBodyRuleFrontend builder with application/json body
func NewCreateWafBodyRuleFrontendRequest(server string, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, body CreateWafBodyRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWafBodyRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateWafBodyRuleFrontendRequestWithBody generates requests for CreateWafBodyRuleFrontend with any type of body
func NewCreateWafBodyRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/waf_body_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceWafBodyRuleFrontendRequest calls the generic ReplaceWafBodyRuleFrontend builder with application/json body
func NewReplaceWafBodyRuleFrontendRequest(server string, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, body ReplaceWafBodyRuleFrontendJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceWafBodyRuleFrontendRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceWafBodyRuleFrontendRequestWithBody generates requests for ReplaceWafBodyRuleFrontend with any type of body
func NewReplaceWafBodyRuleFrontendRequestWithBody(server string, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/frontends/%s/waf_body_rules/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGlobalRequest generates requests for GetGlobal
func NewGetGlobalRequest(server string, params *GetGlobalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceGlobalRequest calls the generic ReplaceGlobal builder with application/json body
func NewReplaceGlobalRequest(server string, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceGlobalRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceGlobalRequestWithBody generates requests for ReplaceGlobal with any type of body
func NewReplaceGlobalRequestWithBody(server string, params *ReplaceGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetGlobalRequest generates requests for GetAllLogTargetGlobal
func NewGetAllLogTargetGlobalRequest(server string, params *GetAllLogTargetGlobalParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetGlobalRequest calls the generic ReplaceAllLogTargetGlobal builder with application/json body
func NewReplaceAllLogTargetGlobalRequest(server string, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetGlobalRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetGlobalRequestWithBody generates requests for ReplaceAllLogTargetGlobal with any type of body
func NewReplaceAllLogTargetGlobalRequestWithBody(server string, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetGlobalRequest generates requests for DeleteLogTargetGlobal
func NewDeleteLogTargetGlobalRequest(server string, index int, params *DeleteLogTargetGlobalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetGlobalRequest generates requests for GetLogTargetGlobal
func NewGetLogTargetGlobalRequest(server string, index int, params *GetLogTargetGlobalParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetGlobalRequest calls the generic CreateLogTargetGlobal builder with application/json body
func NewCreateLogTargetGlobalRequest(server string, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetGlobalRequestWithBody(server, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetGlobalRequestWithBody generates requests for CreateLogTargetGlobal with any type of body
func NewCreateLogTargetGlobalRequestWithBody(server string, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetGlobalRequest calls the generic ReplaceLogTargetGlobal builder with application/json body
func NewReplaceLogTargetGlobalRequest(server string, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetGlobalRequestWithBody(server, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetGlobalRequestWithBody generates requests for ReplaceLogTargetGlobal with any type of body
func NewReplaceLogTargetGlobalRequestWithBody(server string, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/global/log_targets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string, params *GetGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupRequest calls the generic CreateGroup builder with application/json body
func NewCreateGroupRequest(server string, params *CreateGroupParams, body CreateGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateGroupRequestWithBody generates requests for CreateGroup with any type of body
func NewCreateGroupRequestWithBody(server string, params *CreateGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupRequest generates requests for DeleteGroup
func NewDeleteGroupRequest(server string, name string, params *DeleteGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupRequest generates requests for GetGroup
func NewGetGroupRequest(server string, name string, params *GetGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceGroupRequest calls the generic ReplaceGroup builder with application/json body
func NewReplaceGroupRequest(server string, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceGroupRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceGroupRequestWithBody generates requests for ReplaceGroup with any type of body
func NewReplaceGroupRequestWithBody(server string, name string, params *ReplaceGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHTTPErrorsSectionsRequest generates requests for GetHTTPErrorsSections
func NewGetHTTPErrorsSectionsRequest(server string, params *GetHTTPErrorsSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateHTTPErrorsSectionRequest calls the generic CreateHTTPErrorsSection builder with application/json body
func NewCreateHTTPErrorsSectionRequest(server string, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateHTTPErrorsSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateHTTPErrorsSectionRequestWithBody generates requests for CreateHTTPErrorsSection with any type of body
func NewCreateHTTPErrorsSectionRequestWithBody(server string, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteHTTPErrorsSectionRequest generates requests for DeleteHTTPErrorsSection
func NewDeleteHTTPErrorsSectionRequest(server string, name string, params *DeleteHTTPErrorsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHTTPErrorsSectionRequest generates requests for GetHTTPErrorsSection
func NewGetHTTPErrorsSectionRequest(server string, name string, params *GetHTTPErrorsSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceHTTPErrorsSectionRequest calls the generic ReplaceHTTPErrorsSection builder with application/json body
func NewReplaceHTTPErrorsSectionRequest(server string, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceHTTPErrorsSectionRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceHTTPErrorsSectionRequestWithBody generates requests for ReplaceHTTPErrorsSection with any type of body
func NewReplaceHTTPErrorsSectionRequestWithBody(server string, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/http_errors_sections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogForwardsRequest generates requests for GetLogForwards
func NewGetLogForwardsRequest(server string, params *GetLogForwardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogForwardRequest calls the generic CreateLogForward builder with application/json body
func NewCreateLogForwardRequest(server string, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogForwardRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateLogForwardRequestWithBody generates requests for CreateLogForward with any type of body
func NewCreateLogForwardRequestWithBody(server string, params *CreateLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogForwardRequest generates requests for DeleteLogForward
func NewDeleteLogForwardRequest(server string, name string, params *DeleteLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogForwardRequest generates requests for GetLogForward
func NewGetLogForwardRequest(server string, name string, params *GetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceLogForwardRequest calls the generic ReplaceLogForward builder with application/json body
func NewReplaceLogForwardRequest(server string, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogForwardRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceLogForwardRequestWithBody generates requests for ReplaceLogForward with any type of body
func NewReplaceLogForwardRequestWithBody(server string, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllBindLogForwardRequest generates requests for GetAllBindLogForward
func NewGetAllBindLogForwardRequest(server string, parentName ParentName, params *GetAllBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBindLogForwardRequest calls the generic CreateBindLogForward builder with application/json body
func NewCreateBindLogForwardRequest(server string, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBindLogForwardRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateBindLogForwardRequestWithBody generates requests for CreateBindLogForward with any type of body
func NewCreateBindLogForwardRequestWithBody(server string, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBindLogForwardRequest generates requests for DeleteBindLogForward
func NewDeleteBindLogForwardRequest(server string, parentName ParentName, name string, params *DeleteBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBindLogForwardRequest generates requests for GetBindLogForward
func NewGetBindLogForwardRequest(server string, parentName ParentName, name string, params *GetBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBindLogForwardRequest calls the generic ReplaceBindLogForward builder with application/json body
func NewReplaceBindLogForwardRequest(server string, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBindLogForwardRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceBindLogForwardRequestWithBody generates requests for ReplaceBindLogForward with any type of body
func NewReplaceBindLogForwardRequestWithBody(server string, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllDgramBindLogForwardRequest generates requests for GetAllDgramBindLogForward
func NewGetAllDgramBindLogForwardRequest(server string, parentName ParentName, params *GetAllDgramBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDgramBindLogForwardRequest calls the generic CreateDgramBindLogForward builder with application/json body
func NewCreateDgramBindLogForwardRequest(server string, parentName ParentName, params *CreateDgramBindLogForwardParams, body CreateDgramBindLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDgramBindLogForwardRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateDgramBindLogForwardRequestWithBody generates requests for CreateDgramBindLogForward with any type of body
func NewCreateDgramBindLogForwardRequestWithBody(server string, parentName ParentName, params *CreateDgramBindLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDgramBindLogForwardRequest generates requests for DeleteDgramBindLogForward
func NewDeleteDgramBindLogForwardRequest(server string, parentName ParentName, name string, params *DeleteDgramBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDgramBindLogForwardRequest generates requests for GetDgramBindLogForward
func NewGetDgramBindLogForwardRequest(server string, parentName ParentName, name string, params *GetDgramBindLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDgramBindLogForwardRequest calls the generic ReplaceDgramBindLogForward builder with application/json body
func NewReplaceDgramBindLogForwardRequest(server string, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, body ReplaceDgramBindLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDgramBindLogForwardRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceDgramBindLogForwardRequestWithBody generates requests for ReplaceDgramBindLogForward with any type of body
func NewReplaceDgramBindLogForwardRequestWithBody(server string, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetLogForwardRequest generates requests for GetAllLogTargetLogForward
func NewGetAllLogTargetLogForwardRequest(server string, parentName ParentName, params *GetAllLogTargetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetLogForwardRequest calls the generic ReplaceAllLogTargetLogForward builder with application/json body
func NewReplaceAllLogTargetLogForwardRequest(server string, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetLogForwardRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetLogForwardRequestWithBody generates requests for ReplaceAllLogTargetLogForward with any type of body
func NewReplaceAllLogTargetLogForwardRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetLogForwardRequest generates requests for DeleteLogTargetLogForward
func NewDeleteLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetLogForwardRequest generates requests for GetLogTargetLogForward
func NewGetLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *GetLogTargetLogForwardParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetLogForwardRequest calls the generic CreateLogTargetLogForward builder with application/json body
func NewCreateLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetLogForwardRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetLogForwardRequestWithBody generates requests for CreateLogTargetLogForward with any type of body
func NewCreateLogTargetLogForwardRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetLogForwardRequest calls the generic ReplaceLogTargetLogForward builder with application/json body
func NewReplaceLogTargetLogForwardRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetLogForwardRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetLogForwardRequestWithBody generates requests for ReplaceLogTargetLogForward with any type of body
func NewReplaceLogTargetLogForwardRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/log_forwards/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMailerEntriesRequest generates requests for GetMailerEntries
func NewGetMailerEntriesRequest(server string, params *GetMailerEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMailerEntryRequest calls the generic CreateMailerEntry builder with application/json body
func NewCreateMailerEntryRequest(server string, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMailerEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateMailerEntryRequestWithBody generates requests for CreateMailerEntry with any type of body
func NewCreateMailerEntryRequestWithBody(server string, params *CreateMailerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMailerEntryRequest generates requests for DeleteMailerEntry
func NewDeleteMailerEntryRequest(server string, name string, params *DeleteMailerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMailerEntryRequest generates requests for GetMailerEntry
func NewGetMailerEntryRequest(server string, name string, params *GetMailerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceMailerEntryRequest calls the generic ReplaceMailerEntry builder with application/json body
func NewReplaceMailerEntryRequest(server string, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceMailerEntryRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceMailerEntryRequestWithBody generates requests for ReplaceMailerEntry with any type of body
func NewReplaceMailerEntryRequestWithBody(server string, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "mailers_section", runtime.ParamLocationQuery, params.MailersSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMailersSectionsRequest generates requests for GetMailersSections
func NewGetMailersSectionsRequest(server string, params *GetMailersSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateMailersSectionRequest calls the generic CreateMailersSection builder with application/json body
func NewCreateMailersSectionRequest(server string, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateMailersSectionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateMailersSectionRequestWithBody generates requests for CreateMailersSection with any type of body
func NewCreateMailersSectionRequestWithBody(server string, params *CreateMailersSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteMailersSectionRequest generates requests for DeleteMailersSection
func NewDeleteMailersSectionRequest(server string, name string, params *DeleteMailersSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMailersSectionRequest generates requests for GetMailersSection
func NewGetMailersSectionRequest(server string, name string, params *GetMailersSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditMailersSectionRequest calls the generic EditMailersSection builder with application/json body
func NewEditMailersSectionRequest(server string, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditMailersSectionRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewEditMailersSectionRequestWithBody generates requests for EditMailersSection with any type of body
func NewEditMailersSectionRequestWithBody(server string, name string, params *EditMailersSectionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/mailers_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNameserversRequest generates requests for GetNameservers
func NewGetNameserversRequest(server string, params *GetNameserversParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNameserverRequest calls the generic CreateNameserver builder with application/json body
func NewCreateNameserverRequest(server string, params *CreateNameserverParams, body CreateNameserverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNameserverRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateNameserverRequestWithBody generates requests for CreateNameserver with any type of body
func NewCreateNameserverRequestWithBody(server string, params *CreateNameserverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNameserverRequest generates requests for DeleteNameserver
func NewDeleteNameserverRequest(server string, name string, params *DeleteNameserverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNameserverRequest generates requests for GetNameserver
func NewGetNameserverRequest(server string, name string, params *GetNameserverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceNameserverRequest calls the generic ReplaceNameserver builder with application/json body
func NewReplaceNameserverRequest(server string, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceNameserverRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceNameserverRequestWithBody generates requests for ReplaceNameserver with any type of body
func NewReplaceNameserverRequestWithBody(server string, name string, params *ReplaceNameserverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/nameservers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolver", runtime.ParamLocationQuery, params.Resolver); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPeerEntriesRequest generates requests for GetPeerEntries
func NewGetPeerEntriesRequest(server string, params *GetPeerEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePeerEntryRequest calls the generic CreatePeerEntry builder with application/json body
func NewCreatePeerEntryRequest(server string, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePeerEntryRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePeerEntryRequestWithBody generates requests for CreatePeerEntry with any type of body
func NewCreatePeerEntryRequestWithBody(server string, params *CreatePeerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePeerEntryRequest generates requests for DeletePeerEntry
func NewDeletePeerEntryRequest(server string, name string, params *DeletePeerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeerEntryRequest generates requests for GetPeerEntry
func NewGetPeerEntryRequest(server string, name string, params *GetPeerEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplacePeerEntryRequest calls the generic ReplacePeerEntry builder with application/json body
func NewReplacePeerEntryRequest(server string, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplacePeerEntryRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplacePeerEntryRequestWithBody generates requests for ReplacePeerEntry with any type of body
func NewReplacePeerEntryRequestWithBody(server string, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "peer_section", runtime.ParamLocationQuery, params.PeerSection); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPeerSectionsRequest generates requests for GetPeerSections
func NewGetPeerSectionsRequest(server string, params *GetPeerSectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePeerRequest calls the generic CreatePeer builder with application/json body
func NewCreatePeerRequest(server string, params *CreatePeerParams, body CreatePeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePeerRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePeerRequestWithBody generates requests for CreatePeer with any type of body
func NewCreatePeerRequestWithBody(server string, params *CreatePeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePeerRequest generates requests for DeletePeer
func NewDeletePeerRequest(server string, name string, params *DeletePeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeerSectionRequest generates requests for GetPeerSection
func NewGetPeerSectionRequest(server string, name string, params *GetPeerSectionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peer_section/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllBindPeerRequest generates requests for GetAllBindPeer
func NewGetAllBindPeerRequest(server string, parentName ParentName, params *GetAllBindPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBindPeerRequest calls the generic CreateBindPeer builder with application/json body
func NewCreateBindPeerRequest(server string, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBindPeerRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateBindPeerRequestWithBody generates requests for CreateBindPeer with any type of body
func NewCreateBindPeerRequestWithBody(server string, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteBindPeerRequest generates requests for DeleteBindPeer
func NewDeleteBindPeerRequest(server string, parentName ParentName, name string, params *DeleteBindPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBindPeerRequest generates requests for GetBindPeer
func NewGetBindPeerRequest(server string, parentName ParentName, name string, params *GetBindPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceBindPeerRequest calls the generic ReplaceBindPeer builder with application/json body
func NewReplaceBindPeerRequest(server string, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceBindPeerRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceBindPeerRequestWithBody generates requests for ReplaceBindPeer with any type of body
func NewReplaceBindPeerRequestWithBody(server string, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetPeerRequest generates requests for GetAllLogTargetPeer
func NewGetAllLogTargetPeerRequest(server string, parentName ParentName, params *GetAllLogTargetPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetPeerRequest calls the generic ReplaceAllLogTargetPeer builder with application/json body
func NewReplaceAllLogTargetPeerRequest(server string, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetPeerRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetPeerRequestWithBody generates requests for ReplaceAllLogTargetPeer with any type of body
func NewReplaceAllLogTargetPeerRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetPeerRequest generates requests for DeleteLogTargetPeer
func NewDeleteLogTargetPeerRequest(server string, parentName ParentName, index int, params *DeleteLogTargetPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetPeerRequest generates requests for GetLogTargetPeer
func NewGetLogTargetPeerRequest(server string, parentName ParentName, index int, params *GetLogTargetPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetPeerRequest calls the generic CreateLogTargetPeer builder with application/json body
func NewCreateLogTargetPeerRequest(server string, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetPeerRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetPeerRequestWithBody generates requests for CreateLogTargetPeer with any type of body
func NewCreateLogTargetPeerRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetPeerRequest calls the generic ReplaceLogTargetPeer builder with application/json body
func NewReplaceLogTargetPeerRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetPeerRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetPeerRequestWithBody generates requests for ReplaceLogTargetPeer with any type of body
func NewReplaceLogTargetPeerRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerPeerRequest generates requests for GetAllServerPeer
func NewGetAllServerPeerRequest(server string, parentName ParentName, params *GetAllServerPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerPeerRequest calls the generic CreateServerPeer builder with application/json body
func NewCreateServerPeerRequest(server string, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerPeerRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerPeerRequestWithBody generates requests for CreateServerPeer with any type of body
func NewCreateServerPeerRequestWithBody(server string, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerPeerRequest generates requests for DeleteServerPeer
func NewDeleteServerPeerRequest(server string, parentName ParentName, name string, params *DeleteServerPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerPeerRequest generates requests for GetServerPeer
func NewGetServerPeerRequest(server string, parentName ParentName, name string, params *GetServerPeerParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerPeerRequest calls the generic ReplaceServerPeer builder with application/json body
func NewReplaceServerPeerRequest(server string, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerPeerRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceServerPeerRequestWithBody generates requests for ReplaceServerPeer with any type of body
func NewReplaceServerPeerRequestWithBody(server string, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTablesRequest generates requests for GetTables
func NewGetTablesRequest(server string, parentName ParentName, params *GetTablesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTableRequest generates requests for DeleteTable
func NewDeleteTableRequest(server string, parentName ParentName, name string, params *DeleteTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, parentName ParentName, name string, params *GetTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceTableRequest calls the generic ReplaceTable builder with application/json body
func NewReplaceTableRequest(server string, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceTableRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceTableRequestWithBody generates requests for ReplaceTable with any type of body
func NewReplaceTableRequestWithBody(server string, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/peers/%s/tables/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetProgramsRequest generates requests for GetPrograms
func NewGetProgramsRequest(server string, params *GetProgramsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateProgramRequest calls the generic CreateProgram builder with application/json body
func NewCreateProgramRequest(server string, params *CreateProgramParams, body CreateProgramJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateProgramRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateProgramRequestWithBody generates requests for CreateProgram with any type of body
func NewCreateProgramRequestWithBody(server string, params *CreateProgramParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteProgramRequest generates requests for DeleteProgram
func NewDeleteProgramRequest(server string, name string, params *DeleteProgramParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProgramRequest generates requests for GetProgram
func NewGetProgramRequest(server string, name string, params *GetProgramParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceProgramRequest calls the generic ReplaceProgram builder with application/json body
func NewReplaceProgramRequest(server string, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceProgramRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceProgramRequestWithBody generates requests for ReplaceProgram with any type of body
func NewReplaceProgramRequestWithBody(server string, name string, params *ReplaceProgramParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/programs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHAProxyConfigurationRequest generates requests for GetHAProxyConfiguration
func NewGetHAProxyConfigurationRequest(server string, params *GetHAProxyConfigurationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostHAProxyConfigurationRequestWithTextBody calls the generic PostHAProxyConfiguration builder with text/plain body
func NewPostHAProxyConfigurationRequestWithTextBody(server string, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewPostHAProxyConfigurationRequestWithBody(server, params, "text/plain", bodyReader)
}

// NewPostHAProxyConfigurationRequestWithBody generates requests for PostHAProxyConfiguration with any type of body
func NewPostHAProxyConfigurationRequestWithBody(server string, params *PostHAProxyConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_version", runtime.ParamLocationQuery, *params.SkipVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyValidate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_validate", runtime.ParamLocationQuery, *params.OnlyValidate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XRuntimeActions != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Runtime-Actions", runtime.ParamLocationHeader, *params.XRuntimeActions)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Runtime-Actions", headerParam0)
		}

	}

	return req, nil
}

// NewGetResolversRequest generates requests for GetResolvers
func NewGetResolversRequest(server string, params *GetResolversParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateResolverRequest calls the generic CreateResolver builder with application/json body
func NewCreateResolverRequest(server string, params *CreateResolverParams, body CreateResolverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateResolverRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateResolverRequestWithBody generates requests for CreateResolver with any type of body
func NewCreateResolverRequestWithBody(server string, params *CreateResolverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteResolverRequest generates requests for DeleteResolver
func NewDeleteResolverRequest(server string, name string, params *DeleteResolverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResolverRequest generates requests for GetResolver
func NewGetResolverRequest(server string, name string, params *GetResolverParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceResolverRequest calls the generic ReplaceResolver builder with application/json body
func NewReplaceResolverRequest(server string, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceResolverRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceResolverRequestWithBody generates requests for ReplaceResolver with any type of body
func NewReplaceResolverRequestWithBody(server string, name string, params *ReplaceResolverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/resolvers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRingsRequest generates requests for GetRings
func NewGetRingsRequest(server string, params *GetRingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRingRequest calls the generic CreateRing builder with application/json body
func NewCreateRingRequest(server string, params *CreateRingParams, body CreateRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRingRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateRingRequestWithBody generates requests for CreateRing with any type of body
func NewCreateRingRequestWithBody(server string, params *CreateRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRingRequest generates requests for DeleteRing
func NewDeleteRingRequest(server string, name string, params *DeleteRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRingRequest generates requests for GetRing
func NewGetRingRequest(server string, name string, params *GetRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceRingRequest calls the generic ReplaceRing builder with application/json body
func NewReplaceRingRequest(server string, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRingRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceRingRequestWithBody generates requests for ReplaceRing with any type of body
func NewReplaceRingRequestWithBody(server string, name string, params *ReplaceRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllServerRingRequest generates requests for GetAllServerRing
func NewGetAllServerRingRequest(server string, parentName ParentName, params *GetAllServerRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServerRingRequest calls the generic CreateServerRing builder with application/json body
func NewCreateServerRingRequest(server string, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServerRingRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateServerRingRequestWithBody generates requests for CreateServerRing with any type of body
func NewCreateServerRingRequestWithBody(server string, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServerRingRequest generates requests for DeleteServerRing
func NewDeleteServerRingRequest(server string, parentName ParentName, name string, params *DeleteServerRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServerRingRequest generates requests for GetServerRing
func NewGetServerRingRequest(server string, parentName ParentName, name string, params *GetServerRingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceServerRingRequest calls the generic ReplaceServerRing builder with application/json body
func NewReplaceServerRingRequest(server string, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceServerRingRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceServerRingRequestWithBody generates requests for ReplaceServerRing with any type of body
func NewReplaceServerRingRequestWithBody(server string, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/rings/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHAProxyConfigurationStructuredRequest generates requests for GetHAProxyConfigurationStructured
func NewGetHAProxyConfigurationStructuredRequest(server string, params *GetHAProxyConfigurationStructuredParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/structured")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStructuredRequest calls the generic ReplaceStructured builder with application/json body
func NewReplaceStructuredRequest(server string, params *ReplaceStructuredParams, body ReplaceStructuredJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceStructuredRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceStructuredRequestWithBody generates requests for ReplaceStructured with any type of body
func NewReplaceStructuredRequestWithBody(server string, params *ReplaceStructuredParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/structured")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_version", runtime.ParamLocationQuery, *params.SkipVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUDPLbsRequest generates requests for GetUDPLbs
func NewGetUDPLbsRequest(server string, params *GetUDPLbsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUDPLbRequest calls the generic CreateUDPLb builder with application/json body
func NewCreateUDPLbRequest(server string, params *CreateUDPLbParams, body CreateUDPLbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUDPLbRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUDPLbRequestWithBody generates requests for CreateUDPLb with any type of body
func NewCreateUDPLbRequestWithBody(server string, params *CreateUDPLbParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUDPLbRequest generates requests for DeleteUDPLb
func NewDeleteUDPLbRequest(server string, name string, params *DeleteUDPLbParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUDPlbRequest generates requests for GetUDPlb
func NewGetUDPlbRequest(server string, name string, params *GetUDPlbParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceUDPLbRequest calls the generic ReplaceUDPLb builder with application/json body
func NewReplaceUDPLbRequest(server string, name string, params *ReplaceUDPLbParams, body ReplaceUDPLbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceUDPLbRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceUDPLbRequestWithBody generates requests for ReplaceUDPLb with any type of body
func NewReplaceUDPLbRequestWithBody(server string, name string, params *ReplaceUDPLbParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllDgramBindUDPLbRequest generates requests for GetAllDgramBindUDPLb
func NewGetAllDgramBindUDPLbRequest(server string, parentName ParentName, params *GetAllDgramBindUDPLbParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/dgram_binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDgramBindUDPLbRequest calls the generic CreateDgramBindUDPLb builder with application/json body
func NewCreateDgramBindUDPLbRequest(server string, parentName ParentName, params *CreateDgramBindUDPLbParams, body CreateDgramBindUDPLbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDgramBindUDPLbRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateDgramBindUDPLbRequestWithBody generates requests for CreateDgramBindUDPLb with any type of body
func NewCreateDgramBindUDPLbRequestWithBody(server string, parentName ParentName, params *CreateDgramBindUDPLbParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/dgram_binds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDgramBindUDPLbRequest generates requests for DeleteDgramBindUDPLb
func NewDeleteDgramBindUDPLbRequest(server string, parentName ParentName, name string, params *DeleteDgramBindUDPLbParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDgramBindUDPLbRequest generates requests for GetDgramBindUDPLb
func NewGetDgramBindUDPLbRequest(server string, parentName ParentName, name string, params *GetDgramBindUDPLbParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceDgramBindUDPLbRequest calls the generic ReplaceDgramBindUDPLb builder with application/json body
func NewReplaceDgramBindUDPLbRequest(server string, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, body ReplaceDgramBindUDPLbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceDgramBindUDPLbRequestWithBody(server, parentName, name, params, "application/json", bodyReader)
}

// NewReplaceDgramBindUDPLbRequestWithBody generates requests for ReplaceDgramBindUDPLb with any type of body
func NewReplaceDgramBindUDPLbRequestWithBody(server string, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/dgram_binds/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllLogTargetUDPLbRequest generates requests for GetAllLogTargetUDPLb
func NewGetAllLogTargetUDPLbRequest(server string, parentName ParentName, params *GetAllLogTargetUDPLbParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceAllLogTargetUDPLbRequest calls the generic ReplaceAllLogTargetUDPLb builder with application/json body
func NewReplaceAllLogTargetUDPLbRequest(server string, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, body ReplaceAllLogTargetUDPLbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceAllLogTargetUDPLbRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceAllLogTargetUDPLbRequestWithBody generates requests for ReplaceAllLogTargetUDPLb with any type of body
func NewReplaceAllLogTargetUDPLbRequestWithBody(server string, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/log_targets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogTargetUDPLbRequest generates requests for DeleteLogTargetUDPLb
func NewDeleteLogTargetUDPLbRequest(server string, parentName ParentName, index int, params *DeleteLogTargetUDPLbParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogTargetUDPLbRequest generates requests for GetLogTargetUDPLb
func NewGetLogTargetUDPLbRequest(server string, parentName ParentName, index int, params *GetLogTargetUDPLbParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogTargetUDPLbRequest calls the generic CreateLogTargetUDPLb builder with application/json body
func NewCreateLogTargetUDPLbRequest(server string, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, body CreateLogTargetUDPLbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogTargetUDPLbRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewCreateLogTargetUDPLbRequestWithBody generates requests for CreateLogTargetUDPLb with any type of body
func NewCreateLogTargetUDPLbRequestWithBody(server string, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReplaceLogTargetUDPLbRequest calls the generic ReplaceLogTargetUDPLb builder with application/json body
func NewReplaceLogTargetUDPLbRequest(server string, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, body ReplaceLogTargetUDPLbJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogTargetUDPLbRequestWithBody(server, parentName, index, params, "application/json", bodyReader)
}

// NewReplaceLogTargetUDPLbRequestWithBody generates requests for ReplaceLogTargetUDPLb with any type of body
func NewReplaceLogTargetUDPLbRequestWithBody(server string, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/udp_lbs/%s/log_targets/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserlistsRequest generates requests for GetUserlists
func NewGetUserlistsRequest(server string, params *GetUserlistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserlistRequest calls the generic CreateUserlist builder with application/json body
func NewCreateUserlistRequest(server string, params *CreateUserlistParams, body CreateUserlistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserlistRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserlistRequestWithBody generates requests for CreateUserlist with any type of body
func NewCreateUserlistRequestWithBody(server string, params *CreateUserlistParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserlistRequest generates requests for DeleteUserlist
func NewDeleteUserlistRequest(server string, name string, params *DeleteUserlistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserlistRequest generates requests for GetUserlist
func NewGetUserlistRequest(server string, name string, params *GetUserlistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/userlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FullSection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full_section", runtime.ParamLocationQuery, *params.FullSection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserRequest calls the generic CreateUser builder with application/json body
func NewCreateUserRequest(server string, params *CreateUserParams, body CreateUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserRequestWithBody generates requests for CreateUser with any type of body
func NewCreateUserRequestWithBody(server string, params *CreateUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRequest generates requests for DeleteUser
func NewDeleteUserRequest(server string, username string, params *DeleteUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, username string, params *GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceUserRequest calls the generic ReplaceUser builder with application/json body
func NewReplaceUserRequest(server string, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceUserRequestWithBody(server, username, params, "application/json", bodyReader)
}

// NewReplaceUserRequestWithBody generates requests for ReplaceUser with any type of body
func NewReplaceUserRequestWithBody(server string, username string, params *ReplaceUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "userlist", runtime.ParamLocationQuery, params.Userlist); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConfigurationVersionRequest generates requests for GetConfigurationVersion
func NewGetConfigurationVersionRequest(server string, params *GetConfigurationVersionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/configuration/version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogConfigRequest generates requests for GetLogConfig
func NewGetLogConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceLogConfigRequest calls the generic ReplaceLogConfig builder with application/json body
func NewReplaceLogConfigRequest(server string, body ReplaceLogConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewReplaceLogConfigRequestWithBody generates requests for ReplaceLogConfig with any type of body
func NewReplaceLogConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogInputsRequest generates requests for GetLogInputs
func NewGetLogInputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/inputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogInputRequest calls the generic CreateLogInput builder with application/json body
func NewCreateLogInputRequest(server string, body CreateLogInputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogInputRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLogInputRequestWithBody generates requests for CreateLogInput with any type of body
func NewCreateLogInputRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/inputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogInputRequest generates requests for DeleteLogInput
func NewDeleteLogInputRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/inputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogInputRequest generates requests for GetLogInput
func NewGetLogInputRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/inputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceLogInputRequest calls the generic ReplaceLogInput builder with application/json body
func NewReplaceLogInputRequest(server string, id string, body ReplaceLogInputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogInputRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceLogInputRequestWithBody generates requests for ReplaceLogInput with any type of body
func NewReplaceLogInputRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/inputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetLogOutputsRequest generates requests for GetLogOutputs
func NewGetLogOutputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLogOutputRequest calls the generic CreateLogOutput builder with application/json body
func NewCreateLogOutputRequest(server string, body CreateLogOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateLogOutputRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateLogOutputRequestWithBody generates requests for CreateLogOutput with any type of body
func NewCreateLogOutputRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteLogOutputRequest generates requests for DeleteLogOutput
func NewDeleteLogOutputRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLogOutputRequest generates requests for GetLogOutput
func NewGetLogOutputRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceLogOutputRequest calls the generic ReplaceLogOutput builder with application/json body
func NewReplaceLogOutputRequest(server string, id string, body ReplaceLogOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceLogOutputRequestWithBody(server, id, "application/json", bodyReader)
}

// NewReplaceLogOutputRequestWithBody generates requests for ReplaceLogOutput with any type of body
func NewReplaceLogOutputRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/logs/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReloadsRequest generates requests for GetReloads
func NewGetReloadsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/reloads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReloadRequest generates requests for GetReload
func NewGetReloadRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/reloads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeEndpointsRequest generates requests for GetRuntimeEndpoints
func NewGetRuntimeEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsRequest generates requests for GetServicesHaproxyRuntimeAcls
func NewGetServicesHaproxyRuntimeAclsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsIdRequest generates requests for GetServicesHaproxyRuntimeAclsId
func NewGetServicesHaproxyRuntimeAclsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsParentNameEntriesRequest generates requests for GetServicesHaproxyRuntimeAclsParentNameEntries
func NewGetServicesHaproxyRuntimeAclsParentNameEntriesRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequest calls the generic PostServicesHaproxyRuntimeAclsParentNameEntries builder with application/json body
func NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequest(server string, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody generates requests for PostServicesHaproxyRuntimeAclsParentNameEntries with any type of body
func NewPostServicesHaproxyRuntimeAclsParentNameEntriesRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddPayloadRuntimeACLRequest calls the generic AddPayloadRuntimeACL builder with application/json body
func NewAddPayloadRuntimeACLRequest(server string, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPayloadRuntimeACLRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewAddPayloadRuntimeACLRequestWithBody generates requests for AddPayloadRuntimeACL with any type of body
func NewAddPayloadRuntimeACLRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdRequest generates requests for DeleteServicesHaproxyRuntimeAclsParentNameEntriesId
func NewDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServicesHaproxyRuntimeAclsParentNameEntriesIdRequest generates requests for GetServicesHaproxyRuntimeAclsParentNameEntriesId
func NewGetServicesHaproxyRuntimeAclsParentNameEntriesIdRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/acls/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllRuntimeServerRequest generates requests for GetAllRuntimeServer
func NewGetAllRuntimeServerRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddRuntimeServerRequest calls the generic AddRuntimeServer builder with application/json body
func NewAddRuntimeServerRequest(server string, parentName ParentName, body AddRuntimeServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRuntimeServerRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewAddRuntimeServerRequestWithBody generates requests for AddRuntimeServer with any type of body
func NewAddRuntimeServerRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuntimeServerRequest generates requests for DeleteRuntimeServer
func NewDeleteRuntimeServerRequest(server string, parentName ParentName, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeServerRequest generates requests for GetRuntimeServer
func NewGetRuntimeServerRequest(server string, parentName ParentName, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceRuntimeServerRequest calls the generic ReplaceRuntimeServer builder with application/json body
func NewReplaceRuntimeServerRequest(server string, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRuntimeServerRequestWithBody(server, parentName, name, "application/json", bodyReader)
}

// NewReplaceRuntimeServerRequestWithBody generates requests for ReplaceRuntimeServer with any type of body
func NewReplaceRuntimeServerRequestWithBody(server string, parentName ParentName, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/backends/%s/servers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetHaproxyProcessInfoRequest generates requests for GetHaproxyProcessInfo
func NewGetHaproxyProcessInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/info")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllRuntimeMapFilesRequest generates requests for GetAllRuntimeMapFiles
func NewGetAllRuntimeMapFilesRequest(server string, params *GetAllRuntimeMapFilesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeUnmanaged != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_unmanaged", runtime.ParamLocationQuery, *params.IncludeUnmanaged); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearRuntimeMapRequest generates requests for ClearRuntimeMap
func NewClearRuntimeMapRequest(server string, name string, params *ClearRuntimeMapParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceDelete != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "forceDelete", runtime.ParamLocationQuery, *params.ForceDelete); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneRuntimeMapRequest generates requests for GetOneRuntimeMap
func NewGetOneRuntimeMapRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPayloadRuntimeMapRequest calls the generic AddPayloadRuntimeMap builder with application/json body
func NewAddPayloadRuntimeMapRequest(server string, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPayloadRuntimeMapRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewAddPayloadRuntimeMapRequestWithBody generates requests for AddPayloadRuntimeMap with any type of body
func NewAddPayloadRuntimeMapRequestWithBody(server string, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewShowRuntimeMapRequest generates requests for ShowRuntimeMap
func NewShowRuntimeMapRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddMapEntryRequest calls the generic AddMapEntry builder with application/json body
func NewAddMapEntryRequest(server string, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMapEntryRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewAddMapEntryRequestWithBody generates requests for AddMapEntry with any type of body
func NewAddMapEntryRequestWithBody(server string, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRuntimeMapEntryRequest generates requests for DeleteRuntimeMapEntry
func NewDeleteRuntimeMapEntryRequest(server string, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRuntimeMapEntryRequest generates requests for GetRuntimeMapEntry
func NewGetRuntimeMapEntryRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceRuntimeMapEntryRequest calls the generic ReplaceRuntimeMapEntry builder with application/json body
func NewReplaceRuntimeMapEntryRequest(server string, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceRuntimeMapEntryRequestWithBody(server, parentName, id, params, "application/json", bodyReader)
}

// NewReplaceRuntimeMapEntryRequestWithBody generates requests for ReplaceRuntimeMapEntry with any type of body
func NewReplaceRuntimeMapEntryRequestWithBody(server string, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/maps/%s/entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceSync != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_sync", runtime.ParamLocationQuery, *params.ForceSync); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStickTablesRequest generates requests for GetStickTables
func NewGetStickTablesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStickTableRequest generates requests for GetStickTable
func NewGetStickTableRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStickTableEntriesRequest generates requests for GetStickTableEntries
func NewGetStickTableEntriesRequest(server string, parentName ParentName, params *GetStickTableEntriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Key != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key", runtime.ParamLocationQuery, *params.Key); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetStickTableEntriesRequest calls the generic SetStickTableEntries builder with application/json body
func NewSetStickTableEntriesRequest(server string, parentName ParentName, body SetStickTableEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetStickTableEntriesRequestWithBody(server, parentName, "application/json", bodyReader)
}

// NewSetStickTableEntriesRequestWithBody generates requests for SetStickTableEntries with any type of body
func NewSetStickTableEntriesRequestWithBody(server string, parentName ParentName, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/runtime/stick_tables/%s/entries", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSitesRequest generates requests for GetSites
func NewGetSitesRequest(server string, params *GetSitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSiteRequest calls the generic CreateSite builder with application/json body
func NewCreateSiteRequest(server string, params *CreateSiteParams, body CreateSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSiteRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSiteRequestWithBody generates requests for CreateSite with any type of body
func NewCreateSiteRequestWithBody(server string, params *CreateSiteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSiteRequest generates requests for DeleteSite
func NewDeleteSiteRequest(server string, name string, params *DeleteSiteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSiteRequest generates requests for GetSite
func NewGetSiteRequest(server string, name string, params *GetSiteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSiteRequest calls the generic ReplaceSite builder with application/json body
func NewReplaceSiteRequest(server string, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSiteRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewReplaceSiteRequestWithBody generates requests for ReplaceSite with any type of body
func NewReplaceSiteRequestWithBody(server string, name string, params *ReplaceSiteParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/sites/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSpoeEndpointsRequest generates requests for GetSpoeEndpoints
func NewGetSpoeEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSpoeFilesRequest generates requests for GetAllSpoeFiles
func NewGetAllSpoeFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeRequestWithBody generates requests for CreateSpoe with any type of body
func NewCreateSpoeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeFileRequest generates requests for DeleteSpoeFile
func NewDeleteSpoeFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneSpoeFileRequest generates requests for GetOneSpoeFile
func NewGetOneSpoeFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSpoeScopeRequest generates requests for GetAllSpoeScope
func NewGetAllSpoeScopeRequest(server string, parentName ParentName, params *GetAllSpoeScopeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeScopeRequest calls the generic CreateSpoeScope builder with application/json body
func NewCreateSpoeScopeRequest(server string, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeScopeRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewCreateSpoeScopeRequestWithBody generates requests for CreateSpoeScope with any type of body
func NewCreateSpoeScopeRequestWithBody(server string, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeScopeRequest generates requests for DeleteSpoeScope
func NewDeleteSpoeScopeRequest(server string, parentName ParentName, name string, params *DeleteSpoeScopeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeScopeRequest generates requests for GetSpoeScope
func NewGetSpoeScopeRequest(server string, parentName ParentName, name string, params *GetSpoeScopeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllSpoeAgentRequest generates requests for GetAllSpoeAgent
func NewGetAllSpoeAgentRequest(server string, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeAgentRequest calls the generic CreateSpoeAgent builder with application/json body
func NewCreateSpoeAgentRequest(server string, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeAgentRequestWithBody(server, parentName, scopeName, params, "application/json", bodyReader)
}

// NewCreateSpoeAgentRequestWithBody generates requests for CreateSpoeAgent with any type of body
func NewCreateSpoeAgentRequestWithBody(server string, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeAgentRequest generates requests for DeleteSpoeAgent
func NewDeleteSpoeAgentRequest(server string, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeAgentRequest generates requests for GetSpoeAgent
func NewGetSpoeAgentRequest(server string, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSpoeAgentRequest calls the generic ReplaceSpoeAgent builder with application/json body
func NewReplaceSpoeAgentRequest(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSpoeAgentRequestWithBody(server, parentName, scopeName, name, params, "application/json", bodyReader)
}

// NewReplaceSpoeAgentRequestWithBody generates requests for ReplaceSpoeAgent with any type of body
func NewReplaceSpoeAgentRequestWithBody(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/agents/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSpoeGroupRequest generates requests for GetAllSpoeGroup
func NewGetAllSpoeGroupRequest(server string, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeGroupRequest calls the generic CreateSpoeGroup builder with application/json body
func NewCreateSpoeGroupRequest(server string, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeGroupRequestWithBody(server, parentName, scopeName, params, "application/json", bodyReader)
}

// NewCreateSpoeGroupRequestWithBody generates requests for CreateSpoeGroup with any type of body
func NewCreateSpoeGroupRequestWithBody(server string, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeGroupRequest generates requests for DeleteSpoeGroup
func NewDeleteSpoeGroupRequest(server string, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeGroupRequest generates requests for GetSpoeGroup
func NewGetSpoeGroupRequest(server string, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSpoeGroupRequest calls the generic ReplaceSpoeGroup builder with application/json body
func NewReplaceSpoeGroupRequest(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSpoeGroupRequestWithBody(server, parentName, scopeName, name, params, "application/json", bodyReader)
}

// NewReplaceSpoeGroupRequestWithBody generates requests for ReplaceSpoeGroup with any type of body
func NewReplaceSpoeGroupRequestWithBody(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/groups/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSpoeMessageRequest generates requests for GetAllSpoeMessage
func NewGetAllSpoeMessageRequest(server string, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpoeMessageRequest calls the generic CreateSpoeMessage builder with application/json body
func NewCreateSpoeMessageRequest(server string, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpoeMessageRequestWithBody(server, parentName, scopeName, params, "application/json", bodyReader)
}

// NewCreateSpoeMessageRequestWithBody generates requests for CreateSpoeMessage with any type of body
func NewCreateSpoeMessageRequestWithBody(server string, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpoeMessageRequest generates requests for DeleteSpoeMessage
func NewDeleteSpoeMessageRequest(server string, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeMessageRequest generates requests for GetSpoeMessage
func NewGetSpoeMessageRequest(server string, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceSpoeMessageRequest calls the generic ReplaceSpoeMessage builder with application/json body
func NewReplaceSpoeMessageRequest(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceSpoeMessageRequestWithBody(server, parentName, scopeName, name, params, "application/json", bodyReader)
}

// NewReplaceSpoeMessageRequestWithBody generates requests for ReplaceSpoeMessage with any type of body
func NewReplaceSpoeMessageRequestWithBody(server string, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scope_name", runtime.ParamLocationPath, scopeName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/scopes/%s/messages/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllSpoeTransactionRequest generates requests for GetAllSpoeTransaction
func NewGetAllSpoeTransactionRequest(server string, parentName ParentName, params *GetAllSpoeTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartSpoeTransactionRequest generates requests for StartSpoeTransaction
func NewStartSpoeTransactionRequest(server string, parentName ParentName, params *StartSpoeTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteSpoeTransactionRequest generates requests for DeleteSpoeTransaction
func NewDeleteSpoeTransactionRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeTransactionRequest generates requests for GetSpoeTransaction
func NewGetSpoeTransactionRequest(server string, parentName ParentName, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitSpoeTransactionRequest generates requests for CommitSpoeTransaction
func NewCommitSpoeTransactionRequest(server string, parentName ParentName, id string, params *CommitSpoeTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/spoe_files/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpoeConfigurationVersionRequest generates requests for GetSpoeConfigurationVersion
func NewGetSpoeConfigurationVersionRequest(server string, parentName ParentName, params *GetSpoeConfigurationVersionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/spoe/%s/version", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsEndpointsRequest generates requests for GetStatsEndpoints
func NewGetStatsEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, params *GetStatsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/stats/native")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Parent != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "parent", runtime.ParamLocationQuery, *params.Parent); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStorageEndpointsRequest generates requests for GetStorageEndpoints
func NewGetStorageEndpointsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllStorageGeneralFilesRequest generates requests for GetAllStorageGeneralFiles
func NewGetAllStorageGeneralFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageGeneralFileRequestWithBody generates requests for CreateStorageGeneralFile with any type of body
func NewCreateStorageGeneralFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageGeneralFileRequest generates requests for DeleteStorageGeneralFile
func NewDeleteStorageGeneralFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageGeneralFileRequest generates requests for GetOneStorageGeneralFile
func NewGetOneStorageGeneralFileRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageGeneralFileRequestWithBody generates requests for ReplaceStorageGeneralFile with any type of body
func NewReplaceStorageGeneralFileRequestWithBody(server string, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/general/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllStorageMapFilesRequest generates requests for GetAllStorageMapFiles
func NewGetAllStorageMapFilesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageMapFileRequestWithBody generates requests for CreateStorageMapFile with any type of body
func NewCreateStorageMapFileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageMapRequest generates requests for DeleteStorageMap
func NewDeleteStorageMapRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageMapRequest generates requests for GetOneStorageMap
func NewGetOneStorageMapRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageMapFileRequestWithTextBody calls the generic ReplaceStorageMapFile builder with text/plain body
func NewReplaceStorageMapFileRequestWithTextBody(server string, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewReplaceStorageMapFileRequestWithBody(server, name, params, "text/plain", bodyReader)
}

// NewReplaceStorageMapFileRequestWithBody generates requests for ReplaceStorageMapFile with any type of body
func NewReplaceStorageMapFileRequestWithBody(server string, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/maps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllStorageSSLCertificatesRequest generates requests for GetAllStorageSSLCertificates
func NewGetAllStorageSSLCertificatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStorageSSLCertificateRequestWithBody generates requests for CreateStorageSSLCertificate with any type of body
func NewCreateStorageSSLCertificateRequestWithBody(server string, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStorageSSLCertificateRequest generates requests for DeleteStorageSSLCertificate
func NewDeleteStorageSSLCertificateRequest(server string, name string, params *DeleteStorageSSLCertificateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOneStorageSSLCertificateRequest generates requests for GetOneStorageSSLCertificate
func NewGetOneStorageSSLCertificateRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceStorageSSLCertificateRequestWithTextBody calls the generic ReplaceStorageSSLCertificate builder with text/plain body
func NewReplaceStorageSSLCertificateRequestWithTextBody(server string, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewReplaceStorageSSLCertificateRequestWithBody(server, name, params, "text/plain", bodyReader)
}

// NewReplaceStorageSSLCertificateRequestWithBody generates requests for ReplaceStorageSSLCertificate with any type of body
func NewReplaceStorageSSLCertificateRequestWithBody(server string, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/storage/ssl_certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTransactionsRequest generates requests for GetTransactions
func NewGetTransactionsRequest(server string, params *GetTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartTransactionRequest generates requests for StartTransaction
func NewStartTransactionRequest(server string, params *StartTransactionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTransactionRequest generates requests for DeleteTransaction
func NewDeleteTransactionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionRequest generates requests for GetTransaction
func NewGetTransactionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitTransactionRequest generates requests for CommitTransaction
func NewCommitTransactionRequest(server string, id string, params *CommitTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWafRulesetsRequest generates requests for GetWafRulesets
func NewGetWafRulesetsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWafRulesetRequestWithBody generates requests for CreateWafRuleset with any type of body
func NewCreateWafRulesetRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWafRulesetRequest generates requests for DeleteWafRuleset
func NewDeleteWafRulesetRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWafRulesetRequest generates requests for GetWafRuleset
func NewGetWafRulesetRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceWafRulesetRequestWithBody generates requests for ReplaceWafRuleset with any type of body
func NewReplaceWafRulesetRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWafFilesRequest generates requests for GetWafFiles
func NewGetWafFilesRequest(server string, rulesetName RulesetName, params *GetWafFilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset_name", runtime.ParamLocationPath, rulesetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SubDir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sub_dir", runtime.ParamLocationQuery, *params.SubDir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateWafFileRequestWithBody generates requests for CreateWafFile with any type of body
func NewCreateWafFileRequestWithBody(server string, rulesetName RulesetName, params *CreateWafFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset_name", runtime.ParamLocationPath, rulesetName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets/%s/files", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SubDir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sub_dir", runtime.ParamLocationQuery, *params.SubDir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWafFileRequest generates requests for DeleteWafFile
func NewDeleteWafFileRequest(server string, rulesetName RulesetName, name string, params *DeleteWafFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset_name", runtime.ParamLocationPath, rulesetName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets/%s/files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SubDir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sub_dir", runtime.ParamLocationQuery, *params.SubDir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWafFileRequest generates requests for GetWafFile
func NewGetWafFileRequest(server string, rulesetName RulesetName, name string, params *GetWafFileParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset_name", runtime.ParamLocationPath, rulesetName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets/%s/files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SubDir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sub_dir", runtime.ParamLocationQuery, *params.SubDir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceWafFileRequestWithTextBody calls the generic ReplaceWafFile builder with text/plain body
func NewReplaceWafFileRequestWithTextBody(server string, rulesetName RulesetName, name string, params *ReplaceWafFileParams, body ReplaceWafFileTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewReplaceWafFileRequestWithBody(server, rulesetName, name, params, "text/plain", bodyReader)
}

// NewReplaceWafFileRequestWithBody generates requests for ReplaceWafFile with any type of body
func NewReplaceWafFileRequestWithBody(server string, rulesetName RulesetName, name string, params *ReplaceWafFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ruleset_name", runtime.ParamLocationPath, rulesetName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/haproxy/waf/rulesets/%s/files/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SubDir != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sub_dir", runtime.ParamLocationQuery, *params.SubDir); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeepalivedClusterConfigurationVersionRequest generates requests for GetKeepalivedClusterConfigurationVersion
func NewGetKeepalivedClusterConfigurationVersionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/cluster_version")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalDefsRequest generates requests for GetGlobalDefs
func NewGetGlobalDefsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/global_defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceGlobalDefsRequest calls the generic ReplaceGlobalDefs builder with application/json body
func NewReplaceGlobalDefsRequest(server string, params *ReplaceGlobalDefsParams, body ReplaceGlobalDefsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceGlobalDefsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewReplaceGlobalDefsRequestWithBody generates requests for ReplaceGlobalDefs with any type of body
func NewReplaceGlobalDefsRequestWithBody(server string, params *ReplaceGlobalDefsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/global_defaults")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetKeepalivedConfigurationRequest generates requests for GetKeepalivedConfiguration
func NewGetKeepalivedConfigurationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceKeepalivedConfigurationRequestWithTextBody calls the generic ReplaceKeepalivedConfiguration builder with text/plain body
func NewReplaceKeepalivedConfigurationRequestWithTextBody(server string, params *ReplaceKeepalivedConfigurationParams, body ReplaceKeepalivedConfigurationTextRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyReader = strings.NewReader(string(body))
	return NewReplaceKeepalivedConfigurationRequestWithBody(server, params, "text/plain", bodyReader)
}

// NewReplaceKeepalivedConfigurationRequestWithBody generates requests for ReplaceKeepalivedConfiguration with any type of body
func NewReplaceKeepalivedConfigurationRequestWithBody(server string, params *ReplaceKeepalivedConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/raw")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SkipVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_version", runtime.ParamLocationQuery, *params.SkipVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip_reload", runtime.ParamLocationQuery, *params.SkipReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyValidate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_validate", runtime.ParamLocationQuery, *params.OnlyValidate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllVRRPInstanceRequest generates requests for GetAllVRRPInstance
func NewGetAllVRRPInstanceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVRRPInstanceRequest calls the generic CreateVRRPInstance builder with application/json body
func NewCreateVRRPInstanceRequest(server string, params *CreateVRRPInstanceParams, body CreateVRRPInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVRRPInstanceRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateVRRPInstanceRequestWithBody generates requests for CreateVRRPInstance with any type of body
func NewCreateVRRPInstanceRequestWithBody(server string, params *CreateVRRPInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_instances")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVRRPInstanceRequest generates requests for DeleteVRRPInstance
func NewDeleteVRRPInstanceRequest(server string, parentName ParentName, params *DeleteVRRPInstanceParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVRRPInstanceRequest generates requests for GetVRRPInstance
func NewGetVRRPInstanceRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceVRRPInstanceRequest calls the generic ReplaceVRRPInstance builder with application/json body
func NewReplaceVRRPInstanceRequest(server string, parentName ParentName, params *ReplaceVRRPInstanceParams, body ReplaceVRRPInstanceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceVRRPInstanceRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceVRRPInstanceRequestWithBody generates requests for ReplaceVRRPInstance with any type of body
func NewReplaceVRRPInstanceRequestWithBody(server string, parentName ParentName, params *ReplaceVRRPInstanceParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_instances/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllVRRPSyncGroupRequest generates requests for GetAllVRRPSyncGroup
func NewGetAllVRRPSyncGroupRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_sync_groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVRRPSyncGroupRequest calls the generic CreateVRRPSyncGroup builder with application/json body
func NewCreateVRRPSyncGroupRequest(server string, params *CreateVRRPSyncGroupParams, body CreateVRRPSyncGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVRRPSyncGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateVRRPSyncGroupRequestWithBody generates requests for CreateVRRPSyncGroup with any type of body
func NewCreateVRRPSyncGroupRequestWithBody(server string, params *CreateVRRPSyncGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_sync_groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVRRPSyncGroupRequest generates requests for DeleteVRRPSyncGroup
func NewDeleteVRRPSyncGroupRequest(server string, parentName ParentName, params *DeleteVRRPSyncGroupParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_sync_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVRRPSyncGroupRequest generates requests for GetVRRPSyncGroup
func NewGetVRRPSyncGroupRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_sync_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceVRRPSyncGroupRequest calls the generic ReplaceVRRPSyncGroup builder with application/json body
func NewReplaceVRRPSyncGroupRequest(server string, parentName ParentName, params *ReplaceVRRPSyncGroupParams, body ReplaceVRRPSyncGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceVRRPSyncGroupRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceVRRPSyncGroupRequestWithBody generates requests for ReplaceVRRPSyncGroup with any type of body
func NewReplaceVRRPSyncGroupRequestWithBody(server string, parentName ParentName, params *ReplaceVRRPSyncGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_sync_groups/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllVRRPScriptRequest generates requests for GetAllVRRPScript
func NewGetAllVRRPScriptRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_track_scripts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateVRRPScriptRequest calls the generic CreateVRRPScript builder with application/json body
func NewCreateVRRPScriptRequest(server string, params *CreateVRRPScriptParams, body CreateVRRPScriptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateVRRPScriptRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateVRRPScriptRequestWithBody generates requests for CreateVRRPScript with any type of body
func NewCreateVRRPScriptRequestWithBody(server string, params *CreateVRRPScriptParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_track_scripts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteVRRPScriptRequest generates requests for DeleteVRRPScript
func NewDeleteVRRPScriptRequest(server string, parentName ParentName, params *DeleteVRRPScriptParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_track_scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVRRPScriptRequest generates requests for GetVRRPScript
func NewGetVRRPScriptRequest(server string, parentName ParentName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_track_scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReplaceVRRPScriptRequest calls the generic ReplaceVRRPScript builder with application/json body
func NewReplaceVRRPScriptRequest(server string, parentName ParentName, params *ReplaceVRRPScriptParams, body ReplaceVRRPScriptJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReplaceVRRPScriptRequestWithBody(server, parentName, params, "application/json", bodyReader)
}

// NewReplaceVRRPScriptRequestWithBody generates requests for ReplaceVRRPScript with any type of body
func NewReplaceVRRPScriptRequestWithBody(server string, parentName ParentName, params *ReplaceVRRPScriptParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "parent_name", runtime.ParamLocationPath, parentName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/configuration/vrrp_track_scripts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TransactionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transaction_id", runtime.ParamLocationQuery, *params.TransactionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllKeepalivedReloadRequest generates requests for GetAllKeepalivedReload
func NewGetAllKeepalivedReloadRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/reloads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeepalivedReloadRequest generates requests for GetKeepalivedReload
func NewGetKeepalivedReloadRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/reloads/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllKeepalivedTransactionRequest generates requests for GetAllKeepalivedTransaction
func NewGetAllKeepalivedTransactionRequest(server string, params *GetAllKeepalivedTransactionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartKeepalivedTransactionRequest generates requests for StartKeepalivedTransaction
func NewStartKeepalivedTransactionRequest(server string, params *StartKeepalivedTransactionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteKeepalivedTransactionRequest generates requests for DeleteKeepalivedTransaction
func NewDeleteKeepalivedTransactionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeepalivedTransactionRequest generates requests for GetKeepalivedTransaction
func NewGetKeepalivedTransactionRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitKeepalivedTransactionRequest generates requests for CommitKeepalivedTransaction
func NewCommitKeepalivedTransactionRequest(server string, id string, params *CommitKeepalivedTransactionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/services/keepalived/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForceReload != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force_reload", runtime.ParamLocationQuery, *params.ForceReload); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpecificationRequest generates requests for GetSpecification
func NewGetSpecificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/specification")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOpenapiv3SpecificationRequest generates requests for GetOpenapiv3Specification
func NewGetOpenapiv3SpecificationRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/specification_openapiv3")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSummaryRequest generates requests for GetSummary
func NewGetSummaryRequest(server string, params *GetSummaryParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Refresh != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "refresh", runtime.ParamLocationQuery, *params.Refresh); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAPIEndpointsWithResponse request
	GetAPIEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAPIEndpointsResponse, error)

	// GetAlohaEndpointsWithResponse request
	GetAlohaEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAlohaEndpointsResponse, error)

	// GetAlohaActionsWithResponse request
	GetAlohaActionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAlohaActionsResponse, error)

	// ExecuteAlohaActionWithBodyWithResponse request with any body
	ExecuteAlohaActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteAlohaActionResponse, error)

	ExecuteAlohaActionWithResponse(ctx context.Context, body ExecuteAlohaActionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteAlohaActionResponse, error)

	// GetAlohaActionWithResponse request
	GetAlohaActionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAlohaActionResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// PostClusterWithBodyWithResponse request with any body
	PostClusterWithBodyWithResponse(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterResponse, error)

	PostClusterWithResponse(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterResponse, error)

	// EditClusterWithBodyWithResponse request with any body
	EditClusterWithBodyWithResponse(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditClusterResponse, error)

	EditClusterWithResponse(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*EditClusterResponse, error)

	// InitiateCertificateRefreshWithResponse request
	InitiateCertificateRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitiateCertificateRefreshResponse, error)

	// GetFactsWithResponse request
	GetFactsWithResponse(ctx context.Context, params *GetFactsParams, reqEditors ...RequestEditorFn) (*GetFactsResponse, error)

	// GetHealthWithResponse request
	GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error)

	// GetInfoWithResponse request
	GetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfoResponse, error)

	// GetAWSRegionsWithResponse request
	GetAWSRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAWSRegionsResponse, error)

	// CreateAWSRegionWithBodyWithResponse request with any body
	CreateAWSRegionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error)

	CreateAWSRegionWithResponse(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error)

	// DeleteAWSRegionWithResponse request
	DeleteAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAWSRegionResponse, error)

	// GetAWSRegionWithResponse request
	GetAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAWSRegionResponse, error)

	// ReplaceAWSRegionWithBodyWithResponse request with any body
	ReplaceAWSRegionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error)

	ReplaceAWSRegionWithResponse(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error)

	// GetConsulsWithResponse request
	GetConsulsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConsulsResponse, error)

	// CreateConsulWithBodyWithResponse request with any body
	CreateConsulWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error)

	CreateConsulWithResponse(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error)

	// DeleteConsulWithResponse request
	DeleteConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteConsulResponse, error)

	// GetConsulWithResponse request
	GetConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConsulResponse, error)

	// ReplaceConsulWithBodyWithResponse request with any body
	ReplaceConsulWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error)

	ReplaceConsulWithResponse(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error)

	// GetServicesEndpointsWithResponse request
	GetServicesEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesEndpointsResponse, error)

	// RunActionsWithBodyWithResponse request with any body
	RunActionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunActionsResponse, error)

	RunActionsWithResponse(ctx context.Context, body RunActionsJSONRequestBody, reqEditors ...RequestEditorFn) (*RunActionsResponse, error)

	// GetGitEndpointsWithResponse request
	GetGitEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGitEndpointsResponse, error)

	// GetGitActionsWithResponse request
	GetGitActionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGitActionsResponse, error)

	// ExecuteGitActionWithBodyWithResponse request with any body
	ExecuteGitActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteGitActionResponse, error)

	ExecuteGitActionWithResponse(ctx context.Context, body ExecuteGitActionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteGitActionResponse, error)

	// GetGitActionWithResponse request
	GetGitActionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGitActionResponse, error)

	// GetGitSettingsWithResponse request
	GetGitSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGitSettingsResponse, error)

	// ReplaceGitSettingsWithBodyWithResponse request with any body
	ReplaceGitSettingsWithBodyWithResponse(ctx context.Context, params *ReplaceGitSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGitSettingsResponse, error)

	ReplaceGitSettingsWithResponse(ctx context.Context, params *ReplaceGitSettingsParams, body ReplaceGitSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGitSettingsResponse, error)

	// GetHaproxyEndpointsWithResponse request
	GetHaproxyEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyEndpointsResponse, error)

	// GetConfigurationEndpointsWithResponse request
	GetConfigurationEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationEndpointsResponse, error)

	// GetBackendsWithResponse request
	GetBackendsWithResponse(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*GetBackendsResponse, error)

	// CreateBackendWithBodyWithResponse request with any body
	CreateBackendWithBodyWithResponse(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error)

	CreateBackendWithResponse(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error)

	// DeleteBackendWithResponse request
	DeleteBackendWithResponse(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*DeleteBackendResponse, error)

	// GetBackendWithResponse request
	GetBackendWithResponse(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*GetBackendResponse, error)

	// ReplaceBackendWithBodyWithResponse request with any body
	ReplaceBackendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error)

	ReplaceBackendWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error)

	// GetAllAclBackendWithResponse request
	GetAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*GetAllAclBackendResponse, error)

	// ReplaceAllAclBackendWithBodyWithResponse request with any body
	ReplaceAllAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error)

	ReplaceAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error)

	// DeleteAclBackendWithResponse request
	DeleteAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*DeleteAclBackendResponse, error)

	// GetAclBackendWithResponse request
	GetAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*GetAclBackendResponse, error)

	// CreateAclBackendWithBodyWithResponse request with any body
	CreateAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error)

	CreateAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error)

	// ReplaceAclBackendWithBodyWithResponse request with any body
	ReplaceAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error)

	ReplaceAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error)

	// GetAllFilterBackendWithResponse request
	GetAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*GetAllFilterBackendResponse, error)

	// ReplaceAllFilterBackendWithBodyWithResponse request with any body
	ReplaceAllFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error)

	ReplaceAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error)

	// DeleteFilterBackendWithResponse request
	DeleteFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*DeleteFilterBackendResponse, error)

	// GetFilterBackendWithResponse request
	GetFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*GetFilterBackendResponse, error)

	// CreateFilterBackendWithBodyWithResponse request with any body
	CreateFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error)

	CreateFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error)

	// ReplaceFilterBackendWithBodyWithResponse request with any body
	ReplaceFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error)

	ReplaceFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error)

	// GetAllHTTPAfterResponseRuleBackendWithResponse request
	GetAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleBackendResponse, error)

	// ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error)

	ReplaceAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error)

	// DeleteHTTPAfterResponseRuleBackendWithResponse request
	DeleteHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleBackendResponse, error)

	// GetHTTPAfterResponseRuleBackendWithResponse request
	GetHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleBackendResponse, error)

	// CreateHTTPAfterResponseRuleBackendWithBodyWithResponse request with any body
	CreateHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error)

	CreateHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error)

	// ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error)

	ReplaceHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error)

	// GetAllHTTPCheckBackendWithResponse request
	GetAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckBackendResponse, error)

	// ReplaceAllHTTPCheckBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error)

	ReplaceAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error)

	// DeleteHTTPCheckBackendWithResponse request
	DeleteHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckBackendResponse, error)

	// GetHTTPCheckBackendWithResponse request
	GetHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckBackendResponse, error)

	// CreateHTTPCheckBackendWithBodyWithResponse request with any body
	CreateHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error)

	CreateHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error)

	// ReplaceHTTPCheckBackendWithBodyWithResponse request with any body
	ReplaceHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error)

	ReplaceHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error)

	// GetAllHTTPErrorRuleBackendWithResponse request
	GetAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleBackendResponse, error)

	// ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error)

	ReplaceAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error)

	// DeleteHTTPErrorRuleBackendWithResponse request
	DeleteHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleBackendResponse, error)

	// GetHTTPErrorRuleBackendWithResponse request
	GetHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleBackendResponse, error)

	// CreateHTTPErrorRuleBackendWithBodyWithResponse request with any body
	CreateHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error)

	CreateHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error)

	// ReplaceHTTPErrorRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error)

	ReplaceHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error)

	// GetAllHTTPRequestRuleBackendWithResponse request
	GetAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleBackendResponse, error)

	// ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error)

	ReplaceAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error)

	// DeleteHTTPRequestRuleBackendWithResponse request
	DeleteHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleBackendResponse, error)

	// GetHTTPRequestRuleBackendWithResponse request
	GetHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleBackendResponse, error)

	// CreateHTTPRequestRuleBackendWithBodyWithResponse request with any body
	CreateHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error)

	CreateHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error)

	// ReplaceHTTPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error)

	ReplaceHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error)

	// GetAllHTTPResponseRuleBackendWithResponse request
	GetAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleBackendResponse, error)

	// ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error)

	ReplaceAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error)

	// DeleteHTTPResponseRuleBackendWithResponse request
	DeleteHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleBackendResponse, error)

	// GetHTTPResponseRuleBackendWithResponse request
	GetHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleBackendResponse, error)

	// CreateHTTPResponseRuleBackendWithBodyWithResponse request with any body
	CreateHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error)

	CreateHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error)

	// ReplaceHTTPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error)

	ReplaceHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error)

	// GetAllLogTargetBackendWithResponse request
	GetAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetBackendResponse, error)

	// ReplaceAllLogTargetBackendWithBodyWithResponse request with any body
	ReplaceAllLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error)

	ReplaceAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error)

	// DeleteLogTargetBackendWithResponse request
	DeleteLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetBackendResponse, error)

	// GetLogTargetBackendWithResponse request
	GetLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetLogTargetBackendResponse, error)

	// CreateLogTargetBackendWithBodyWithResponse request with any body
	CreateLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error)

	CreateLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error)

	// ReplaceLogTargetBackendWithBodyWithResponse request with any body
	ReplaceLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error)

	ReplaceLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error)

	// GetServerSwitchingRulesWithResponse request
	GetServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRulesResponse, error)

	// ReplaceServerSwitchingRulesWithBodyWithResponse request with any body
	ReplaceServerSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error)

	ReplaceServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error)

	// DeleteServerSwitchingRuleWithResponse request
	DeleteServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteServerSwitchingRuleResponse, error)

	// GetServerSwitchingRuleWithResponse request
	GetServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRuleResponse, error)

	// CreateServerSwitchingRuleWithBodyWithResponse request with any body
	CreateServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error)

	CreateServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error)

	// ReplaceServerSwitchingRuleWithBodyWithResponse request with any body
	ReplaceServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error)

	ReplaceServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error)

	// GetServerTemplatesWithResponse request
	GetServerTemplatesWithResponse(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*GetServerTemplatesResponse, error)

	// CreateServerTemplateWithBodyWithResponse request with any body
	CreateServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error)

	CreateServerTemplateWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error)

	// DeleteServerTemplateWithResponse request
	DeleteServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*DeleteServerTemplateResponse, error)

	// GetServerTemplateWithResponse request
	GetServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*GetServerTemplateResponse, error)

	// ReplaceServerTemplateWithBodyWithResponse request with any body
	ReplaceServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error)

	ReplaceServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error)

	// GetAllServerBackendWithResponse request
	GetAllServerBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*GetAllServerBackendResponse, error)

	// CreateServerBackendWithBodyWithResponse request with any body
	CreateServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error)

	CreateServerBackendWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error)

	// DeleteServerBackendWithResponse request
	DeleteServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*DeleteServerBackendResponse, error)

	// GetServerBackendWithResponse request
	GetServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*GetServerBackendResponse, error)

	// ReplaceServerBackendWithBodyWithResponse request with any body
	ReplaceServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error)

	ReplaceServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error)

	// GetStickRulesWithResponse request
	GetStickRulesWithResponse(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*GetStickRulesResponse, error)

	// ReplaceStickRulesWithBodyWithResponse request with any body
	ReplaceStickRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error)

	ReplaceStickRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error)

	// DeleteStickRuleWithResponse request
	DeleteStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*DeleteStickRuleResponse, error)

	// GetStickRuleWithResponse request
	GetStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*GetStickRuleResponse, error)

	// CreateStickRuleWithBodyWithResponse request with any body
	CreateStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error)

	CreateStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error)

	// ReplaceStickRuleWithBodyWithResponse request with any body
	ReplaceStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error)

	ReplaceStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error)

	// GetAllTCPCheckBackendWithResponse request
	GetAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckBackendResponse, error)

	// ReplaceAllTCPCheckBackendWithBodyWithResponse request with any body
	ReplaceAllTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error)

	ReplaceAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error)

	// DeleteTCPCheckBackendWithResponse request
	DeleteTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckBackendResponse, error)

	// GetTCPCheckBackendWithResponse request
	GetTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetTCPCheckBackendResponse, error)

	// CreateTCPCheckBackendWithBodyWithResponse request with any body
	CreateTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error)

	CreateTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error)

	// ReplaceTCPCheckBackendWithBodyWithResponse request with any body
	ReplaceTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error)

	ReplaceTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error)

	// GetAllTCPRequestRuleBackendWithResponse request
	GetAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleBackendResponse, error)

	// ReplaceAllTCPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceAllTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error)

	ReplaceAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error)

	// DeleteTCPRequestRuleBackendWithResponse request
	DeleteTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleBackendResponse, error)

	// GetTCPRequestRuleBackendWithResponse request
	GetTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleBackendResponse, error)

	// CreateTCPRequestRuleBackendWithBodyWithResponse request with any body
	CreateTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error)

	CreateTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error)

	// ReplaceTCPRequestRuleBackendWithBodyWithResponse request with any body
	ReplaceTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error)

	ReplaceTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error)

	// GetAllTCPResponseRuleBackendWithResponse request
	GetAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPResponseRuleBackendResponse, error)

	// ReplaceAllTCPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceAllTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error)

	ReplaceAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error)

	// DeleteTCPResponseRuleBackendWithResponse request
	DeleteTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPResponseRuleBackendResponse, error)

	// GetTCPResponseRuleBackendWithResponse request
	GetTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPResponseRuleBackendResponse, error)

	// CreateTCPResponseRuleBackendWithBodyWithResponse request with any body
	CreateTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error)

	CreateTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error)

	// ReplaceTCPResponseRuleBackendWithBodyWithResponse request with any body
	ReplaceTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error)

	ReplaceTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error)

	// GetAllWafBodyRuleBackendWithResponse request
	GetAllWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllWafBodyRuleBackendResponse, error)

	// ReplaceAllWafBodyRuleBackendWithBodyWithResponse request with any body
	ReplaceAllWafBodyRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllWafBodyRuleBackendResponse, error)

	ReplaceAllWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, body ReplaceAllWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllWafBodyRuleBackendResponse, error)

	// DeleteWafBodyRuleBackendWithResponse request
	DeleteWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteWafBodyRuleBackendResponse, error)

	// GetWafBodyRuleBackendWithResponse request
	GetWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*GetWafBodyRuleBackendResponse, error)

	// CreateWafBodyRuleBackendWithBodyWithResponse request with any body
	CreateWafBodyRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWafBodyRuleBackendResponse, error)

	CreateWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, body CreateWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWafBodyRuleBackendResponse, error)

	// ReplaceWafBodyRuleBackendWithBodyWithResponse request with any body
	ReplaceWafBodyRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceWafBodyRuleBackendResponse, error)

	ReplaceWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, body ReplaceWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceWafBodyRuleBackendResponse, error)

	// GetBotmgmtProfilesWithResponse request
	GetBotmgmtProfilesWithResponse(ctx context.Context, params *GetBotmgmtProfilesParams, reqEditors ...RequestEditorFn) (*GetBotmgmtProfilesResponse, error)

	// CreateBotmgmtProfileWithBodyWithResponse request with any body
	CreateBotmgmtProfileWithBodyWithResponse(ctx context.Context, params *CreateBotmgmtProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBotmgmtProfileResponse, error)

	CreateBotmgmtProfileWithResponse(ctx context.Context, params *CreateBotmgmtProfileParams, body CreateBotmgmtProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBotmgmtProfileResponse, error)

	// DeleteBotmgmtProfileWithResponse request
	DeleteBotmgmtProfileWithResponse(ctx context.Context, name string, params *DeleteBotmgmtProfileParams, reqEditors ...RequestEditorFn) (*DeleteBotmgmtProfileResponse, error)

	// GetBotmgmtProfileWithResponse request
	GetBotmgmtProfileWithResponse(ctx context.Context, name string, params *GetBotmgmtProfileParams, reqEditors ...RequestEditorFn) (*GetBotmgmtProfileResponse, error)

	// EditBotmgmtProfileWithBodyWithResponse request with any body
	EditBotmgmtProfileWithBodyWithResponse(ctx context.Context, name string, params *EditBotmgmtProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditBotmgmtProfileResponse, error)

	EditBotmgmtProfileWithResponse(ctx context.Context, name string, params *EditBotmgmtProfileParams, body EditBotmgmtProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*EditBotmgmtProfileResponse, error)

	// GetCachesWithResponse request
	GetCachesWithResponse(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*GetCachesResponse, error)

	// CreateCacheWithBodyWithResponse request with any body
	CreateCacheWithBodyWithResponse(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error)

	CreateCacheWithResponse(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error)

	// DeleteCacheWithResponse request
	DeleteCacheWithResponse(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*DeleteCacheResponse, error)

	// GetCacheWithResponse request
	GetCacheWithResponse(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*GetCacheResponse, error)

	// ReplaceCacheWithBodyWithResponse request with any body
	ReplaceCacheWithBodyWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error)

	ReplaceCacheWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error)

	// GetCaptchasWithResponse request
	GetCaptchasWithResponse(ctx context.Context, params *GetCaptchasParams, reqEditors ...RequestEditorFn) (*GetCaptchasResponse, error)

	// CreateCaptchaWithBodyWithResponse request with any body
	CreateCaptchaWithBodyWithResponse(ctx context.Context, params *CreateCaptchaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCaptchaResponse, error)

	CreateCaptchaWithResponse(ctx context.Context, params *CreateCaptchaParams, body CreateCaptchaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCaptchaResponse, error)

	// DeleteCaptchaWithResponse request
	DeleteCaptchaWithResponse(ctx context.Context, name string, params *DeleteCaptchaParams, reqEditors ...RequestEditorFn) (*DeleteCaptchaResponse, error)

	// GetCaptchaWithResponse request
	GetCaptchaWithResponse(ctx context.Context, name string, params *GetCaptchaParams, reqEditors ...RequestEditorFn) (*GetCaptchaResponse, error)

	// EditCaptchaWithBodyWithResponse request with any body
	EditCaptchaWithBodyWithResponse(ctx context.Context, name string, params *EditCaptchaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCaptchaResponse, error)

	EditCaptchaWithResponse(ctx context.Context, name string, params *EditCaptchaParams, body EditCaptchaJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCaptchaResponse, error)

	// GetClusterConfigurationVersionWithResponse request
	GetClusterConfigurationVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterConfigurationVersionResponse, error)

	// GetCrtLoadsWithResponse request
	GetCrtLoadsWithResponse(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*GetCrtLoadsResponse, error)

	// CreateCrtLoadWithBodyWithResponse request with any body
	CreateCrtLoadWithBodyWithResponse(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error)

	CreateCrtLoadWithResponse(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error)

	// DeleteCrtLoadWithResponse request
	DeleteCrtLoadWithResponse(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*DeleteCrtLoadResponse, error)

	// GetCrtLoadWithResponse request
	GetCrtLoadWithResponse(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*GetCrtLoadResponse, error)

	// ReplaceCrtLoadWithBodyWithResponse request with any body
	ReplaceCrtLoadWithBodyWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error)

	ReplaceCrtLoadWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error)

	// GetCrtStoresWithResponse request
	GetCrtStoresWithResponse(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*GetCrtStoresResponse, error)

	// CreateCrtStoreWithBodyWithResponse request with any body
	CreateCrtStoreWithBodyWithResponse(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error)

	CreateCrtStoreWithResponse(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error)

	// DeleteCrtStoreWithResponse request
	DeleteCrtStoreWithResponse(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*DeleteCrtStoreResponse, error)

	// GetCrtStoreWithResponse request
	GetCrtStoreWithResponse(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*GetCrtStoreResponse, error)

	// EditCrtStoreWithBodyWithResponse request with any body
	EditCrtStoreWithBodyWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error)

	EditCrtStoreWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error)

	// GetDefaultsSectionsWithResponse request
	GetDefaultsSectionsWithResponse(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionsResponse, error)

	// CreateDefaultsSectionWithBodyWithResponse request with any body
	CreateDefaultsSectionWithBodyWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error)

	CreateDefaultsSectionWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error)

	// DeleteDefaultsSectionWithResponse request
	DeleteDefaultsSectionWithResponse(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*DeleteDefaultsSectionResponse, error)

	// GetDefaultsSectionWithResponse request
	GetDefaultsSectionWithResponse(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionResponse, error)

	// ReplaceDefaultsSectionWithBodyWithResponse request with any body
	ReplaceDefaultsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error)

	ReplaceDefaultsSectionWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error)

	// GetAllHTTPCheckDefaultsWithResponse request
	GetAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckDefaultsResponse, error)

	// ReplaceAllHTTPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceAllHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error)

	ReplaceAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error)

	// DeleteHTTPCheckDefaultsWithResponse request
	DeleteHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckDefaultsResponse, error)

	// GetHTTPCheckDefaultsWithResponse request
	GetHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckDefaultsResponse, error)

	// CreateHTTPCheckDefaultsWithBodyWithResponse request with any body
	CreateHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error)

	CreateHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error)

	// ReplaceHTTPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error)

	ReplaceHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error)

	// GetAllHTTPErrorRuleDefaultsWithResponse request
	GetAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleDefaultsResponse, error)

	// ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse request with any body
	ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error)

	ReplaceAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error)

	// DeleteHTTPErrorRuleDefaultsWithResponse request
	DeleteHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleDefaultsResponse, error)

	// GetHTTPErrorRuleDefaultsWithResponse request
	GetHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleDefaultsResponse, error)

	// CreateHTTPErrorRuleDefaultsWithBodyWithResponse request with any body
	CreateHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error)

	CreateHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error)

	// ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse request with any body
	ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error)

	ReplaceHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error)

	// GetAllLogTargetDefaultsWithResponse request
	GetAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetDefaultsResponse, error)

	// ReplaceAllLogTargetDefaultsWithBodyWithResponse request with any body
	ReplaceAllLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error)

	ReplaceAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error)

	// DeleteLogTargetDefaultsWithResponse request
	DeleteLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetDefaultsResponse, error)

	// GetLogTargetDefaultsWithResponse request
	GetLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetLogTargetDefaultsResponse, error)

	// CreateLogTargetDefaultsWithBodyWithResponse request with any body
	CreateLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error)

	CreateLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error)

	// ReplaceLogTargetDefaultsWithBodyWithResponse request with any body
	ReplaceLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error)

	ReplaceLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error)

	// GetAllTCPCheckDefaultsWithResponse request
	GetAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckDefaultsResponse, error)

	// ReplaceAllTCPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceAllTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error)

	ReplaceAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error)

	// DeleteTCPCheckDefaultsWithResponse request
	DeleteTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckDefaultsResponse, error)

	// GetTCPCheckDefaultsWithResponse request
	GetTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPCheckDefaultsResponse, error)

	// CreateTCPCheckDefaultsWithBodyWithResponse request with any body
	CreateTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error)

	CreateTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error)

	// ReplaceTCPCheckDefaultsWithBodyWithResponse request with any body
	ReplaceTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error)

	ReplaceTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error)

	// GetDynamicUpdateRulesWithResponse request
	GetDynamicUpdateRulesWithResponse(ctx context.Context, params *GetDynamicUpdateRulesParams, reqEditors ...RequestEditorFn) (*GetDynamicUpdateRulesResponse, error)

	// ReplaceDynamicUpdateRulesWithBodyWithResponse request with any body
	ReplaceDynamicUpdateRulesWithBodyWithResponse(ctx context.Context, params *ReplaceDynamicUpdateRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDynamicUpdateRulesResponse, error)

	ReplaceDynamicUpdateRulesWithResponse(ctx context.Context, params *ReplaceDynamicUpdateRulesParams, body ReplaceDynamicUpdateRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDynamicUpdateRulesResponse, error)

	// DeleteDynamicUpdateRuleWithResponse request
	DeleteDynamicUpdateRuleWithResponse(ctx context.Context, index int, params *DeleteDynamicUpdateRuleParams, reqEditors ...RequestEditorFn) (*DeleteDynamicUpdateRuleResponse, error)

	// GetDynamicUpdateRuleWithResponse request
	GetDynamicUpdateRuleWithResponse(ctx context.Context, index int, params *GetDynamicUpdateRuleParams, reqEditors ...RequestEditorFn) (*GetDynamicUpdateRuleResponse, error)

	// CreateDynamicUpdateRuleWithBodyWithResponse request with any body
	CreateDynamicUpdateRuleWithBodyWithResponse(ctx context.Context, index int, params *CreateDynamicUpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDynamicUpdateRuleResponse, error)

	CreateDynamicUpdateRuleWithResponse(ctx context.Context, index int, params *CreateDynamicUpdateRuleParams, body CreateDynamicUpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDynamicUpdateRuleResponse, error)

	// ReplaceDynamicUpdateRuleWithBodyWithResponse request with any body
	ReplaceDynamicUpdateRuleWithBodyWithResponse(ctx context.Context, index int, params *ReplaceDynamicUpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDynamicUpdateRuleResponse, error)

	ReplaceDynamicUpdateRuleWithResponse(ctx context.Context, index int, params *ReplaceDynamicUpdateRuleParams, body ReplaceDynamicUpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDynamicUpdateRuleResponse, error)

	// DeleteDynamicUpdateSectionWithResponse request
	DeleteDynamicUpdateSectionWithResponse(ctx context.Context, params *DeleteDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*DeleteDynamicUpdateSectionResponse, error)

	// GetDynamicUpdateSectionWithResponse request
	GetDynamicUpdateSectionWithResponse(ctx context.Context, params *GetDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*GetDynamicUpdateSectionResponse, error)

	// CreateDynamicUpdateSectionWithResponse request
	CreateDynamicUpdateSectionWithResponse(ctx context.Context, params *CreateDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*CreateDynamicUpdateSectionResponse, error)

	// GetFCGIAppsWithResponse request
	GetFCGIAppsWithResponse(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*GetFCGIAppsResponse, error)

	// CreateFCGIAppWithBodyWithResponse request with any body
	CreateFCGIAppWithBodyWithResponse(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error)

	CreateFCGIAppWithResponse(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error)

	// DeleteFCGIAppWithResponse request
	DeleteFCGIAppWithResponse(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteFCGIAppResponse, error)

	// GetFCGIAppWithResponse request
	GetFCGIAppWithResponse(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*GetFCGIAppResponse, error)

	// ReplaceFCGIAppWithBodyWithResponse request with any body
	ReplaceFCGIAppWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error)

	ReplaceFCGIAppWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error)

	// GetAllAclFCGIAppWithResponse request
	GetAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAllAclFCGIAppResponse, error)

	// ReplaceAllAclFCGIAppWithBodyWithResponse request with any body
	ReplaceAllAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error)

	ReplaceAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error)

	// DeleteAclFCGIAppWithResponse request
	DeleteAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteAclFCGIAppResponse, error)

	// GetAclFCGIAppWithResponse request
	GetAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAclFCGIAppResponse, error)

	// CreateAclFCGIAppWithBodyWithResponse request with any body
	CreateAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error)

	CreateAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error)

	// ReplaceAclFCGIAppWithBodyWithResponse request with any body
	ReplaceAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error)

	ReplaceAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error)

	// GetFrontendsWithResponse request
	GetFrontendsWithResponse(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*GetFrontendsResponse, error)

	// CreateFrontendWithBodyWithResponse request with any body
	CreateFrontendWithBodyWithResponse(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error)

	CreateFrontendWithResponse(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error)

	// DeleteFrontendWithResponse request
	DeleteFrontendWithResponse(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFrontendResponse, error)

	// GetFrontendWithResponse request
	GetFrontendWithResponse(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*GetFrontendResponse, error)

	// ReplaceFrontendWithBodyWithResponse request with any body
	ReplaceFrontendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error)

	ReplaceFrontendWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error)

	// GetAllAclFrontendWithResponse request
	GetAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAllAclFrontendResponse, error)

	// ReplaceAllAclFrontendWithBodyWithResponse request with any body
	ReplaceAllAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error)

	ReplaceAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error)

	// DeleteAclFrontendWithResponse request
	DeleteAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*DeleteAclFrontendResponse, error)

	// GetAclFrontendWithResponse request
	GetAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAclFrontendResponse, error)

	// CreateAclFrontendWithBodyWithResponse request with any body
	CreateAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error)

	CreateAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error)

	// ReplaceAclFrontendWithBodyWithResponse request with any body
	ReplaceAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error)

	ReplaceAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error)

	// GetBackendSwitchingRulesWithResponse request
	GetBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRulesResponse, error)

	// ReplaceBackendSwitchingRulesWithBodyWithResponse request with any body
	ReplaceBackendSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error)

	ReplaceBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error)

	// DeleteBackendSwitchingRuleWithResponse request
	DeleteBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteBackendSwitchingRuleResponse, error)

	// GetBackendSwitchingRuleWithResponse request
	GetBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRuleResponse, error)

	// CreateBackendSwitchingRuleWithBodyWithResponse request with any body
	CreateBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error)

	CreateBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error)

	// ReplaceBackendSwitchingRuleWithBodyWithResponse request with any body
	ReplaceBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error)

	ReplaceBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error)

	// GetAllBindFrontendWithResponse request
	GetAllBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*GetAllBindFrontendResponse, error)

	// CreateBindFrontendWithBodyWithResponse request with any body
	CreateBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error)

	CreateBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error)

	// DeleteBindFrontendWithResponse request
	DeleteBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*DeleteBindFrontendResponse, error)

	// GetBindFrontendWithResponse request
	GetBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*GetBindFrontendResponse, error)

	// ReplaceBindFrontendWithBodyWithResponse request with any body
	ReplaceBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error)

	ReplaceBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error)

	// GetDeclareCapturesWithResponse request
	GetDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*GetDeclareCapturesResponse, error)

	// ReplaceDeclareCapturesWithBodyWithResponse request with any body
	ReplaceDeclareCapturesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error)

	ReplaceDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error)

	// DeleteDeclareCaptureWithResponse request
	DeleteDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*DeleteDeclareCaptureResponse, error)

	// GetDeclareCaptureWithResponse request
	GetDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*GetDeclareCaptureResponse, error)

	// CreateDeclareCaptureWithBodyWithResponse request with any body
	CreateDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error)

	CreateDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error)

	// ReplaceDeclareCaptureWithBodyWithResponse request with any body
	ReplaceDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error)

	ReplaceDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error)

	// GetAllFilterFrontendWithResponse request
	GetAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetAllFilterFrontendResponse, error)

	// ReplaceAllFilterFrontendWithBodyWithResponse request with any body
	ReplaceAllFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error)

	ReplaceAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error)

	// DeleteFilterFrontendWithResponse request
	DeleteFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFilterFrontendResponse, error)

	// GetFilterFrontendWithResponse request
	GetFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetFilterFrontendResponse, error)

	// CreateFilterFrontendWithBodyWithResponse request with any body
	CreateFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error)

	CreateFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error)

	// ReplaceFilterFrontendWithBodyWithResponse request with any body
	ReplaceFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error)

	ReplaceFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error)

	// GetAllHTTPAfterResponseRuleFrontendWithResponse request
	GetAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleFrontendResponse, error)

	// ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error)

	ReplaceAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error)

	// DeleteHTTPAfterResponseRuleFrontendWithResponse request
	DeleteHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleFrontendResponse, error)

	// GetHTTPAfterResponseRuleFrontendWithResponse request
	GetHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleFrontendResponse, error)

	// CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error)

	CreateHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error)

	// ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error)

	ReplaceHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error)

	// GetAllHTTPErrorRuleFrontendWithResponse request
	GetAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleFrontendResponse, error)

	// ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error)

	ReplaceAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error)

	// DeleteHTTPErrorRuleFrontendWithResponse request
	DeleteHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleFrontendResponse, error)

	// GetHTTPErrorRuleFrontendWithResponse request
	GetHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleFrontendResponse, error)

	// CreateHTTPErrorRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error)

	CreateHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error)

	// ReplaceHTTPErrorRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error)

	ReplaceHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error)

	// GetAllHTTPRequestRuleFrontendWithResponse request
	GetAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleFrontendResponse, error)

	// ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error)

	ReplaceAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error)

	// DeleteHTTPRequestRuleFrontendWithResponse request
	DeleteHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleFrontendResponse, error)

	// GetHTTPRequestRuleFrontendWithResponse request
	GetHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleFrontendResponse, error)

	// CreateHTTPRequestRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error)

	CreateHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error)

	// ReplaceHTTPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error)

	ReplaceHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error)

	// GetAllHTTPResponseRuleFrontendWithResponse request
	GetAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleFrontendResponse, error)

	// ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error)

	ReplaceAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error)

	// DeleteHTTPResponseRuleFrontendWithResponse request
	DeleteHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleFrontendResponse, error)

	// GetHTTPResponseRuleFrontendWithResponse request
	GetHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleFrontendResponse, error)

	// CreateHTTPResponseRuleFrontendWithBodyWithResponse request with any body
	CreateHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error)

	CreateHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error)

	// ReplaceHTTPResponseRuleFrontendWithBodyWithResponse request with any body
	ReplaceHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error)

	ReplaceHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error)

	// GetAllLogTargetFrontendWithResponse request
	GetAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetFrontendResponse, error)

	// ReplaceAllLogTargetFrontendWithBodyWithResponse request with any body
	ReplaceAllLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error)

	ReplaceAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error)

	// DeleteLogTargetFrontendWithResponse request
	DeleteLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetFrontendResponse, error)

	// GetLogTargetFrontendWithResponse request
	GetLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetLogTargetFrontendResponse, error)

	// CreateLogTargetFrontendWithBodyWithResponse request with any body
	CreateLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error)

	CreateLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error)

	// ReplaceLogTargetFrontendWithBodyWithResponse request with any body
	ReplaceLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error)

	ReplaceLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error)

	// GetAllTCPRequestRuleFrontendWithResponse request
	GetAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleFrontendResponse, error)

	// ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error)

	ReplaceAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error)

	// DeleteTCPRequestRuleFrontendWithResponse request
	DeleteTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleFrontendResponse, error)

	// GetTCPRequestRuleFrontendWithResponse request
	GetTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleFrontendResponse, error)

	// CreateTCPRequestRuleFrontendWithBodyWithResponse request with any body
	CreateTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error)

	CreateTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error)

	// ReplaceTCPRequestRuleFrontendWithBodyWithResponse request with any body
	ReplaceTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error)

	ReplaceTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error)

	// GetAllWafBodyRuleFrontendWithResponse request
	GetAllWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllWafBodyRuleFrontendResponse, error)

	// ReplaceAllWafBodyRuleFrontendWithBodyWithResponse request with any body
	ReplaceAllWafBodyRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllWafBodyRuleFrontendResponse, error)

	ReplaceAllWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, body ReplaceAllWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllWafBodyRuleFrontendResponse, error)

	// DeleteWafBodyRuleFrontendWithResponse request
	DeleteWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteWafBodyRuleFrontendResponse, error)

	// GetWafBodyRuleFrontendWithResponse request
	GetWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetWafBodyRuleFrontendResponse, error)

	// CreateWafBodyRuleFrontendWithBodyWithResponse request with any body
	CreateWafBodyRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWafBodyRuleFrontendResponse, error)

	CreateWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, body CreateWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWafBodyRuleFrontendResponse, error)

	// ReplaceWafBodyRuleFrontendWithBodyWithResponse request with any body
	ReplaceWafBodyRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceWafBodyRuleFrontendResponse, error)

	ReplaceWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, body ReplaceWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceWafBodyRuleFrontendResponse, error)

	// GetGlobalWithResponse request
	GetGlobalWithResponse(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error)

	// ReplaceGlobalWithBodyWithResponse request with any body
	ReplaceGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error)

	ReplaceGlobalWithResponse(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error)

	// GetAllLogTargetGlobalWithResponse request
	GetAllLogTargetGlobalWithResponse(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetGlobalResponse, error)

	// ReplaceAllLogTargetGlobalWithBodyWithResponse request with any body
	ReplaceAllLogTargetGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error)

	ReplaceAllLogTargetGlobalWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error)

	// DeleteLogTargetGlobalWithResponse request
	DeleteLogTargetGlobalWithResponse(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetGlobalResponse, error)

	// GetLogTargetGlobalWithResponse request
	GetLogTargetGlobalWithResponse(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetLogTargetGlobalResponse, error)

	// CreateLogTargetGlobalWithBodyWithResponse request with any body
	CreateLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error)

	CreateLogTargetGlobalWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error)

	// ReplaceLogTargetGlobalWithBodyWithResponse request with any body
	ReplaceLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error)

	ReplaceLogTargetGlobalWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error)

	// GetGroupsWithResponse request
	GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error)

	// CreateGroupWithBodyWithResponse request with any body
	CreateGroupWithBodyWithResponse(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	CreateGroupWithResponse(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error)

	// DeleteGroupWithResponse request
	DeleteGroupWithResponse(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error)

	// GetGroupWithResponse request
	GetGroupWithResponse(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupResponse, error)

	// ReplaceGroupWithBodyWithResponse request with any body
	ReplaceGroupWithBodyWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error)

	ReplaceGroupWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error)

	// GetHTTPErrorsSectionsWithResponse request
	GetHTTPErrorsSectionsWithResponse(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionsResponse, error)

	// CreateHTTPErrorsSectionWithBodyWithResponse request with any body
	CreateHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error)

	CreateHTTPErrorsSectionWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error)

	// DeleteHTTPErrorsSectionWithResponse request
	DeleteHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorsSectionResponse, error)

	// GetHTTPErrorsSectionWithResponse request
	GetHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionResponse, error)

	// ReplaceHTTPErrorsSectionWithBodyWithResponse request with any body
	ReplaceHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error)

	ReplaceHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error)

	// GetLogForwardsWithResponse request
	GetLogForwardsWithResponse(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*GetLogForwardsResponse, error)

	// CreateLogForwardWithBodyWithResponse request with any body
	CreateLogForwardWithBodyWithResponse(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error)

	CreateLogForwardWithResponse(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error)

	// DeleteLogForwardWithResponse request
	DeleteLogForwardWithResponse(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogForwardResponse, error)

	// GetLogForwardWithResponse request
	GetLogForwardWithResponse(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogForwardResponse, error)

	// ReplaceLogForwardWithBodyWithResponse request with any body
	ReplaceLogForwardWithBodyWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error)

	ReplaceLogForwardWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error)

	// GetAllBindLogForwardWithResponse request
	GetAllBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllBindLogForwardResponse, error)

	// CreateBindLogForwardWithBodyWithResponse request with any body
	CreateBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error)

	CreateBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error)

	// DeleteBindLogForwardWithResponse request
	DeleteBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteBindLogForwardResponse, error)

	// GetBindLogForwardWithResponse request
	GetBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetBindLogForwardResponse, error)

	// ReplaceBindLogForwardWithBodyWithResponse request with any body
	ReplaceBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error)

	ReplaceBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error)

	// GetAllDgramBindLogForwardWithResponse request
	GetAllDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllDgramBindLogForwardResponse, error)

	// CreateDgramBindLogForwardWithBodyWithResponse request with any body
	CreateDgramBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDgramBindLogForwardResponse, error)

	CreateDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindLogForwardParams, body CreateDgramBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDgramBindLogForwardResponse, error)

	// DeleteDgramBindLogForwardWithResponse request
	DeleteDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteDgramBindLogForwardResponse, error)

	// GetDgramBindLogForwardWithResponse request
	GetDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *GetDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetDgramBindLogForwardResponse, error)

	// ReplaceDgramBindLogForwardWithBodyWithResponse request with any body
	ReplaceDgramBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDgramBindLogForwardResponse, error)

	ReplaceDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, body ReplaceDgramBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDgramBindLogForwardResponse, error)

	// GetAllLogTargetLogForwardWithResponse request
	GetAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetLogForwardResponse, error)

	// ReplaceAllLogTargetLogForwardWithBodyWithResponse request with any body
	ReplaceAllLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error)

	ReplaceAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error)

	// DeleteLogTargetLogForwardWithResponse request
	DeleteLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetLogForwardResponse, error)

	// GetLogTargetLogForwardWithResponse request
	GetLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogTargetLogForwardResponse, error)

	// CreateLogTargetLogForwardWithBodyWithResponse request with any body
	CreateLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error)

	CreateLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error)

	// ReplaceLogTargetLogForwardWithBodyWithResponse request with any body
	ReplaceLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error)

	ReplaceLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error)

	// GetMailerEntriesWithResponse request
	GetMailerEntriesWithResponse(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*GetMailerEntriesResponse, error)

	// CreateMailerEntryWithBodyWithResponse request with any body
	CreateMailerEntryWithBodyWithResponse(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error)

	CreateMailerEntryWithResponse(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error)

	// DeleteMailerEntryWithResponse request
	DeleteMailerEntryWithResponse(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*DeleteMailerEntryResponse, error)

	// GetMailerEntryWithResponse request
	GetMailerEntryWithResponse(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*GetMailerEntryResponse, error)

	// ReplaceMailerEntryWithBodyWithResponse request with any body
	ReplaceMailerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error)

	ReplaceMailerEntryWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error)

	// GetMailersSectionsWithResponse request
	GetMailersSectionsWithResponse(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*GetMailersSectionsResponse, error)

	// CreateMailersSectionWithBodyWithResponse request with any body
	CreateMailersSectionWithBodyWithResponse(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error)

	CreateMailersSectionWithResponse(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error)

	// DeleteMailersSectionWithResponse request
	DeleteMailersSectionWithResponse(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*DeleteMailersSectionResponse, error)

	// GetMailersSectionWithResponse request
	GetMailersSectionWithResponse(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*GetMailersSectionResponse, error)

	// EditMailersSectionWithBodyWithResponse request with any body
	EditMailersSectionWithBodyWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error)

	EditMailersSectionWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error)

	// GetNameserversWithResponse request
	GetNameserversWithResponse(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*GetNameserversResponse, error)

	// CreateNameserverWithBodyWithResponse request with any body
	CreateNameserverWithBodyWithResponse(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error)

	CreateNameserverWithResponse(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error)

	// DeleteNameserverWithResponse request
	DeleteNameserverWithResponse(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*DeleteNameserverResponse, error)

	// GetNameserverWithResponse request
	GetNameserverWithResponse(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*GetNameserverResponse, error)

	// ReplaceNameserverWithBodyWithResponse request with any body
	ReplaceNameserverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error)

	ReplaceNameserverWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error)

	// GetPeerEntriesWithResponse request
	GetPeerEntriesWithResponse(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*GetPeerEntriesResponse, error)

	// CreatePeerEntryWithBodyWithResponse request with any body
	CreatePeerEntryWithBodyWithResponse(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error)

	CreatePeerEntryWithResponse(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error)

	// DeletePeerEntryWithResponse request
	DeletePeerEntryWithResponse(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*DeletePeerEntryResponse, error)

	// GetPeerEntryWithResponse request
	GetPeerEntryWithResponse(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*GetPeerEntryResponse, error)

	// ReplacePeerEntryWithBodyWithResponse request with any body
	ReplacePeerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error)

	ReplacePeerEntryWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error)

	// GetPeerSectionsWithResponse request
	GetPeerSectionsWithResponse(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*GetPeerSectionsResponse, error)

	// CreatePeerWithBodyWithResponse request with any body
	CreatePeerWithBodyWithResponse(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error)

	CreatePeerWithResponse(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error)

	// DeletePeerWithResponse request
	DeletePeerWithResponse(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*DeletePeerResponse, error)

	// GetPeerSectionWithResponse request
	GetPeerSectionWithResponse(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*GetPeerSectionResponse, error)

	// GetAllBindPeerWithResponse request
	GetAllBindPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*GetAllBindPeerResponse, error)

	// CreateBindPeerWithBodyWithResponse request with any body
	CreateBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error)

	CreateBindPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error)

	// DeleteBindPeerWithResponse request
	DeleteBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*DeleteBindPeerResponse, error)

	// GetBindPeerWithResponse request
	GetBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*GetBindPeerResponse, error)

	// ReplaceBindPeerWithBodyWithResponse request with any body
	ReplaceBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error)

	ReplaceBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error)

	// GetAllLogTargetPeerWithResponse request
	GetAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetPeerResponse, error)

	// ReplaceAllLogTargetPeerWithBodyWithResponse request with any body
	ReplaceAllLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error)

	ReplaceAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error)

	// DeleteLogTargetPeerWithResponse request
	DeleteLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetPeerResponse, error)

	// GetLogTargetPeerWithResponse request
	GetLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetLogTargetPeerResponse, error)

	// CreateLogTargetPeerWithBodyWithResponse request with any body
	CreateLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error)

	CreateLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error)

	// ReplaceLogTargetPeerWithBodyWithResponse request with any body
	ReplaceLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error)

	ReplaceLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error)

	// GetAllServerPeerWithResponse request
	GetAllServerPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*GetAllServerPeerResponse, error)

	// CreateServerPeerWithBodyWithResponse request with any body
	CreateServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error)

	CreateServerPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error)

	// DeleteServerPeerWithResponse request
	DeleteServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*DeleteServerPeerResponse, error)

	// GetServerPeerWithResponse request
	GetServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*GetServerPeerResponse, error)

	// ReplaceServerPeerWithBodyWithResponse request with any body
	ReplaceServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error)

	ReplaceServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error)

	// GetTablesWithResponse request
	GetTablesWithResponse(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	CreateTableWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	// DeleteTableWithResponse request
	DeleteTableWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error)

	// GetTableWithResponse request
	GetTableWithResponse(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error)

	// ReplaceTableWithBodyWithResponse request with any body
	ReplaceTableWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error)

	ReplaceTableWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error)

	// GetProgramsWithResponse request
	GetProgramsWithResponse(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error)

	// CreateProgramWithBodyWithResponse request with any body
	CreateProgramWithBodyWithResponse(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error)

	CreateProgramWithResponse(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error)

	// DeleteProgramWithResponse request
	DeleteProgramWithResponse(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*DeleteProgramResponse, error)

	// GetProgramWithResponse request
	GetProgramWithResponse(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error)

	// ReplaceProgramWithBodyWithResponse request with any body
	ReplaceProgramWithBodyWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error)

	ReplaceProgramWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error)

	// GetHAProxyConfigurationWithResponse request
	GetHAProxyConfigurationWithResponse(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*GetHAProxyConfigurationResponse, error)

	// PostHAProxyConfigurationWithBodyWithResponse request with any body
	PostHAProxyConfigurationWithBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error)

	PostHAProxyConfigurationWithTextBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error)

	// GetResolversWithResponse request
	GetResolversWithResponse(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*GetResolversResponse, error)

	// CreateResolverWithBodyWithResponse request with any body
	CreateResolverWithBodyWithResponse(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error)

	CreateResolverWithResponse(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error)

	// DeleteResolverWithResponse request
	DeleteResolverWithResponse(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*DeleteResolverResponse, error)

	// GetResolverWithResponse request
	GetResolverWithResponse(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*GetResolverResponse, error)

	// ReplaceResolverWithBodyWithResponse request with any body
	ReplaceResolverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error)

	ReplaceResolverWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error)

	// GetRingsWithResponse request
	GetRingsWithResponse(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*GetRingsResponse, error)

	// CreateRingWithBodyWithResponse request with any body
	CreateRingWithBodyWithResponse(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRingResponse, error)

	CreateRingWithResponse(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRingResponse, error)

	// DeleteRingWithResponse request
	DeleteRingWithResponse(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*DeleteRingResponse, error)

	// GetRingWithResponse request
	GetRingWithResponse(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*GetRingResponse, error)

	// ReplaceRingWithBodyWithResponse request with any body
	ReplaceRingWithBodyWithResponse(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error)

	ReplaceRingWithResponse(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error)

	// GetAllServerRingWithResponse request
	GetAllServerRingWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*GetAllServerRingResponse, error)

	// CreateServerRingWithBodyWithResponse request with any body
	CreateServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error)

	CreateServerRingWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error)

	// DeleteServerRingWithResponse request
	DeleteServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*DeleteServerRingResponse, error)

	// GetServerRingWithResponse request
	GetServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*GetServerRingResponse, error)

	// ReplaceServerRingWithBodyWithResponse request with any body
	ReplaceServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error)

	ReplaceServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error)

	// GetHAProxyConfigurationStructuredWithResponse request
	GetHAProxyConfigurationStructuredWithResponse(ctx context.Context, params *GetHAProxyConfigurationStructuredParams, reqEditors ...RequestEditorFn) (*GetHAProxyConfigurationStructuredResponse, error)

	// ReplaceStructuredWithBodyWithResponse request with any body
	ReplaceStructuredWithBodyWithResponse(ctx context.Context, params *ReplaceStructuredParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStructuredResponse, error)

	ReplaceStructuredWithResponse(ctx context.Context, params *ReplaceStructuredParams, body ReplaceStructuredJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStructuredResponse, error)

	// GetUDPLbsWithResponse request
	GetUDPLbsWithResponse(ctx context.Context, params *GetUDPLbsParams, reqEditors ...RequestEditorFn) (*GetUDPLbsResponse, error)

	// CreateUDPLbWithBodyWithResponse request with any body
	CreateUDPLbWithBodyWithResponse(ctx context.Context, params *CreateUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUDPLbResponse, error)

	CreateUDPLbWithResponse(ctx context.Context, params *CreateUDPLbParams, body CreateUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUDPLbResponse, error)

	// DeleteUDPLbWithResponse request
	DeleteUDPLbWithResponse(ctx context.Context, name string, params *DeleteUDPLbParams, reqEditors ...RequestEditorFn) (*DeleteUDPLbResponse, error)

	// GetUDPlbWithResponse request
	GetUDPlbWithResponse(ctx context.Context, name string, params *GetUDPlbParams, reqEditors ...RequestEditorFn) (*GetUDPlbResponse, error)

	// ReplaceUDPLbWithBodyWithResponse request with any body
	ReplaceUDPLbWithBodyWithResponse(ctx context.Context, name string, params *ReplaceUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceUDPLbResponse, error)

	ReplaceUDPLbWithResponse(ctx context.Context, name string, params *ReplaceUDPLbParams, body ReplaceUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceUDPLbResponse, error)

	// GetAllDgramBindUDPLbWithResponse request
	GetAllDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, params *GetAllDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*GetAllDgramBindUDPLbResponse, error)

	// CreateDgramBindUDPLbWithBodyWithResponse request with any body
	CreateDgramBindUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDgramBindUDPLbResponse, error)

	CreateDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindUDPLbParams, body CreateDgramBindUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDgramBindUDPLbResponse, error)

	// DeleteDgramBindUDPLbWithResponse request
	DeleteDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*DeleteDgramBindUDPLbResponse, error)

	// GetDgramBindUDPLbWithResponse request
	GetDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, name string, params *GetDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*GetDgramBindUDPLbResponse, error)

	// ReplaceDgramBindUDPLbWithBodyWithResponse request with any body
	ReplaceDgramBindUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDgramBindUDPLbResponse, error)

	ReplaceDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, body ReplaceDgramBindUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDgramBindUDPLbResponse, error)

	// GetAllLogTargetUDPLbWithResponse request
	GetAllLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetUDPLbResponse, error)

	// ReplaceAllLogTargetUDPLbWithBodyWithResponse request with any body
	ReplaceAllLogTargetUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetUDPLbResponse, error)

	ReplaceAllLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, body ReplaceAllLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetUDPLbResponse, error)

	// DeleteLogTargetUDPLbWithResponse request
	DeleteLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetUDPLbResponse, error)

	// GetLogTargetUDPLbWithResponse request
	GetLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*GetLogTargetUDPLbResponse, error)

	// CreateLogTargetUDPLbWithBodyWithResponse request with any body
	CreateLogTargetUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetUDPLbResponse, error)

	CreateLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, body CreateLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetUDPLbResponse, error)

	// ReplaceLogTargetUDPLbWithBodyWithResponse request with any body
	ReplaceLogTargetUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetUDPLbResponse, error)

	ReplaceLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, body ReplaceLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetUDPLbResponse, error)

	// GetUserlistsWithResponse request
	GetUserlistsWithResponse(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*GetUserlistsResponse, error)

	// CreateUserlistWithBodyWithResponse request with any body
	CreateUserlistWithBodyWithResponse(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error)

	CreateUserlistWithResponse(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error)

	// DeleteUserlistWithResponse request
	DeleteUserlistWithResponse(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*DeleteUserlistResponse, error)

	// GetUserlistWithResponse request
	GetUserlistWithResponse(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*GetUserlistResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// CreateUserWithBodyWithResponse request with any body
	CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error)

	// DeleteUserWithResponse request
	DeleteUserWithResponse(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// ReplaceUserWithBodyWithResponse request with any body
	ReplaceUserWithBodyWithResponse(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error)

	ReplaceUserWithResponse(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error)

	// GetConfigurationVersionWithResponse request
	GetConfigurationVersionWithResponse(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetConfigurationVersionResponse, error)

	// GetLogConfigWithResponse request
	GetLogConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogConfigResponse, error)

	// ReplaceLogConfigWithBodyWithResponse request with any body
	ReplaceLogConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogConfigResponse, error)

	ReplaceLogConfigWithResponse(ctx context.Context, body ReplaceLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogConfigResponse, error)

	// GetLogInputsWithResponse request
	GetLogInputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogInputsResponse, error)

	// CreateLogInputWithBodyWithResponse request with any body
	CreateLogInputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogInputResponse, error)

	CreateLogInputWithResponse(ctx context.Context, body CreateLogInputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogInputResponse, error)

	// DeleteLogInputWithResponse request
	DeleteLogInputWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLogInputResponse, error)

	// GetLogInputWithResponse request
	GetLogInputWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLogInputResponse, error)

	// ReplaceLogInputWithBodyWithResponse request with any body
	ReplaceLogInputWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogInputResponse, error)

	ReplaceLogInputWithResponse(ctx context.Context, id string, body ReplaceLogInputJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogInputResponse, error)

	// GetLogOutputsWithResponse request
	GetLogOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogOutputsResponse, error)

	// CreateLogOutputWithBodyWithResponse request with any body
	CreateLogOutputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogOutputResponse, error)

	CreateLogOutputWithResponse(ctx context.Context, body CreateLogOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogOutputResponse, error)

	// DeleteLogOutputWithResponse request
	DeleteLogOutputWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLogOutputResponse, error)

	// GetLogOutputWithResponse request
	GetLogOutputWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLogOutputResponse, error)

	// ReplaceLogOutputWithBodyWithResponse request with any body
	ReplaceLogOutputWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogOutputResponse, error)

	ReplaceLogOutputWithResponse(ctx context.Context, id string, body ReplaceLogOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogOutputResponse, error)

	// GetReloadsWithResponse request
	GetReloadsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReloadsResponse, error)

	// GetReloadWithResponse request
	GetReloadWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReloadResponse, error)

	// GetRuntimeEndpointsWithResponse request
	GetRuntimeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeEndpointsResponse, error)

	// GetServicesHaproxyRuntimeAclsWithResponse request
	GetServicesHaproxyRuntimeAclsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsResponse, error)

	// GetServicesHaproxyRuntimeAclsIdWithResponse request
	GetServicesHaproxyRuntimeAclsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsIdResponse, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse request
	GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesResponse, error)

	// PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse request with any body
	PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error)

	PostServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error)

	// AddPayloadRuntimeACLWithBodyWithResponse request with any body
	AddPayloadRuntimeACLWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error)

	AddPayloadRuntimeACLWithResponse(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error)

	// DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request
	DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error)

	// GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request
	GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error)

	// GetAllRuntimeServerWithResponse request
	GetAllRuntimeServerWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetAllRuntimeServerResponse, error)

	// AddRuntimeServerWithBodyWithResponse request with any body
	AddRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error)

	AddRuntimeServerWithResponse(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error)

	// DeleteRuntimeServerWithResponse request
	DeleteRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*DeleteRuntimeServerResponse, error)

	// GetRuntimeServerWithResponse request
	GetRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*GetRuntimeServerResponse, error)

	// ReplaceRuntimeServerWithBodyWithResponse request with any body
	ReplaceRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error)

	ReplaceRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error)

	// GetHaproxyProcessInfoWithResponse request
	GetHaproxyProcessInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyProcessInfoResponse, error)

	// GetAllRuntimeMapFilesWithResponse request
	GetAllRuntimeMapFilesWithResponse(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*GetAllRuntimeMapFilesResponse, error)

	// ClearRuntimeMapWithResponse request
	ClearRuntimeMapWithResponse(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*ClearRuntimeMapResponse, error)

	// GetOneRuntimeMapWithResponse request
	GetOneRuntimeMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneRuntimeMapResponse, error)

	// AddPayloadRuntimeMapWithBodyWithResponse request with any body
	AddPayloadRuntimeMapWithBodyWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error)

	AddPayloadRuntimeMapWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error)

	// ShowRuntimeMapWithResponse request
	ShowRuntimeMapWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*ShowRuntimeMapResponse, error)

	// AddMapEntryWithBodyWithResponse request with any body
	AddMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error)

	AddMapEntryWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error)

	// DeleteRuntimeMapEntryWithResponse request
	DeleteRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*DeleteRuntimeMapEntryResponse, error)

	// GetRuntimeMapEntryWithResponse request
	GetRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetRuntimeMapEntryResponse, error)

	// ReplaceRuntimeMapEntryWithBodyWithResponse request with any body
	ReplaceRuntimeMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error)

	ReplaceRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error)

	// GetStickTablesWithResponse request
	GetStickTablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStickTablesResponse, error)

	// GetStickTableWithResponse request
	GetStickTableWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetStickTableResponse, error)

	// GetStickTableEntriesWithResponse request
	GetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*GetStickTableEntriesResponse, error)

	// SetStickTableEntriesWithBodyWithResponse request with any body
	SetStickTableEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error)

	SetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error)

	// GetSitesWithResponse request
	GetSitesWithResponse(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*GetSitesResponse, error)

	// CreateSiteWithBodyWithResponse request with any body
	CreateSiteWithBodyWithResponse(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	CreateSiteWithResponse(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error)

	// DeleteSiteWithResponse request
	DeleteSiteWithResponse(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error)

	// GetSiteWithResponse request
	GetSiteWithResponse(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*GetSiteResponse, error)

	// ReplaceSiteWithBodyWithResponse request with any body
	ReplaceSiteWithBodyWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error)

	ReplaceSiteWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error)

	// GetSpoeEndpointsWithResponse request
	GetSpoeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpoeEndpointsResponse, error)

	// GetAllSpoeFilesWithResponse request
	GetAllSpoeFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSpoeFilesResponse, error)

	// CreateSpoeWithBodyWithResponse request with any body
	CreateSpoeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeResponse, error)

	// DeleteSpoeFileWithResponse request
	DeleteSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteSpoeFileResponse, error)

	// GetOneSpoeFileWithResponse request
	GetOneSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneSpoeFileResponse, error)

	// GetAllSpoeScopeWithResponse request
	GetAllSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetAllSpoeScopeResponse, error)

	// CreateSpoeScopeWithBodyWithResponse request with any body
	CreateSpoeScopeWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error)

	CreateSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error)

	// DeleteSpoeScopeWithResponse request
	DeleteSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*DeleteSpoeScopeResponse, error)

	// GetSpoeScopeWithResponse request
	GetSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetSpoeScopeResponse, error)

	// GetAllSpoeAgentWithResponse request
	GetAllSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetAllSpoeAgentResponse, error)

	// CreateSpoeAgentWithBodyWithResponse request with any body
	CreateSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error)

	CreateSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error)

	// DeleteSpoeAgentWithResponse request
	DeleteSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*DeleteSpoeAgentResponse, error)

	// GetSpoeAgentWithResponse request
	GetSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetSpoeAgentResponse, error)

	// ReplaceSpoeAgentWithBodyWithResponse request with any body
	ReplaceSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error)

	ReplaceSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error)

	// GetAllSpoeGroupWithResponse request
	GetAllSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetAllSpoeGroupResponse, error)

	// CreateSpoeGroupWithBodyWithResponse request with any body
	CreateSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error)

	CreateSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error)

	// DeleteSpoeGroupWithResponse request
	DeleteSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*DeleteSpoeGroupResponse, error)

	// GetSpoeGroupWithResponse request
	GetSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetSpoeGroupResponse, error)

	// ReplaceSpoeGroupWithBodyWithResponse request with any body
	ReplaceSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error)

	ReplaceSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error)

	// GetAllSpoeMessageWithResponse request
	GetAllSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetAllSpoeMessageResponse, error)

	// CreateSpoeMessageWithBodyWithResponse request with any body
	CreateSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error)

	CreateSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error)

	// DeleteSpoeMessageWithResponse request
	DeleteSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*DeleteSpoeMessageResponse, error)

	// GetSpoeMessageWithResponse request
	GetSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetSpoeMessageResponse, error)

	// ReplaceSpoeMessageWithBodyWithResponse request with any body
	ReplaceSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error)

	ReplaceSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error)

	// GetAllSpoeTransactionWithResponse request
	GetAllSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*GetAllSpoeTransactionResponse, error)

	// StartSpoeTransactionWithResponse request
	StartSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*StartSpoeTransactionResponse, error)

	// DeleteSpoeTransactionWithResponse request
	DeleteSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteSpoeTransactionResponse, error)

	// GetSpoeTransactionWithResponse request
	GetSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetSpoeTransactionResponse, error)

	// CommitSpoeTransactionWithResponse request
	CommitSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*CommitSpoeTransactionResponse, error)

	// GetSpoeConfigurationVersionWithResponse request
	GetSpoeConfigurationVersionWithResponse(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetSpoeConfigurationVersionResponse, error)

	// GetStatsEndpointsWithResponse request
	GetStatsEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsEndpointsResponse, error)

	// GetStatsWithResponse request
	GetStatsWithResponse(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// GetStorageEndpointsWithResponse request
	GetStorageEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageEndpointsResponse, error)

	// GetAllStorageGeneralFilesWithResponse request
	GetAllStorageGeneralFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageGeneralFilesResponse, error)

	// CreateStorageGeneralFileWithBodyWithResponse request with any body
	CreateStorageGeneralFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageGeneralFileResponse, error)

	// DeleteStorageGeneralFileWithResponse request
	DeleteStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageGeneralFileResponse, error)

	// GetOneStorageGeneralFileWithResponse request
	GetOneStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageGeneralFileResponse, error)

	// ReplaceStorageGeneralFileWithBodyWithResponse request with any body
	ReplaceStorageGeneralFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageGeneralFileResponse, error)

	// GetAllStorageMapFilesWithResponse request
	GetAllStorageMapFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageMapFilesResponse, error)

	// CreateStorageMapFileWithBodyWithResponse request with any body
	CreateStorageMapFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageMapFileResponse, error)

	// DeleteStorageMapWithResponse request
	DeleteStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageMapResponse, error)

	// GetOneStorageMapWithResponse request
	GetOneStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageMapResponse, error)

	// ReplaceStorageMapFileWithBodyWithResponse request with any body
	ReplaceStorageMapFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error)

	ReplaceStorageMapFileWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error)

	// GetAllStorageSSLCertificatesWithResponse request
	GetAllStorageSSLCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageSSLCertificatesResponse, error)

	// CreateStorageSSLCertificateWithBodyWithResponse request with any body
	CreateStorageSSLCertificateWithBodyWithResponse(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCertificateResponse, error)

	// DeleteStorageSSLCertificateWithResponse request
	DeleteStorageSSLCertificateWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCertificateResponse, error)

	// GetOneStorageSSLCertificateWithResponse request
	GetOneStorageSSLCertificateWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageSSLCertificateResponse, error)

	// ReplaceStorageSSLCertificateWithBodyWithResponse request with any body
	ReplaceStorageSSLCertificateWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error)

	ReplaceStorageSSLCertificateWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error)

	// GetTransactionsWithResponse request
	GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error)

	// StartTransactionWithResponse request
	StartTransactionWithResponse(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*StartTransactionResponse, error)

	// DeleteTransactionWithResponse request
	DeleteTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error)

	// GetTransactionWithResponse request
	GetTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error)

	// CommitTransactionWithResponse request
	CommitTransactionWithResponse(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error)

	// GetWafRulesetsWithResponse request
	GetWafRulesetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWafRulesetsResponse, error)

	// CreateWafRulesetWithBodyWithResponse request with any body
	CreateWafRulesetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWafRulesetResponse, error)

	// DeleteWafRulesetWithResponse request
	DeleteWafRulesetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteWafRulesetResponse, error)

	// GetWafRulesetWithResponse request
	GetWafRulesetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetWafRulesetResponse, error)

	// ReplaceWafRulesetWithBodyWithResponse request with any body
	ReplaceWafRulesetWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceWafRulesetResponse, error)

	// GetWafFilesWithResponse request
	GetWafFilesWithResponse(ctx context.Context, rulesetName RulesetName, params *GetWafFilesParams, reqEditors ...RequestEditorFn) (*GetWafFilesResponse, error)

	// CreateWafFileWithBodyWithResponse request with any body
	CreateWafFileWithBodyWithResponse(ctx context.Context, rulesetName RulesetName, params *CreateWafFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWafFileResponse, error)

	// DeleteWafFileWithResponse request
	DeleteWafFileWithResponse(ctx context.Context, rulesetName RulesetName, name string, params *DeleteWafFileParams, reqEditors ...RequestEditorFn) (*DeleteWafFileResponse, error)

	// GetWafFileWithResponse request
	GetWafFileWithResponse(ctx context.Context, rulesetName RulesetName, name string, params *GetWafFileParams, reqEditors ...RequestEditorFn) (*GetWafFileResponse, error)

	// ReplaceWafFileWithBodyWithResponse request with any body
	ReplaceWafFileWithBodyWithResponse(ctx context.Context, rulesetName RulesetName, name string, params *ReplaceWafFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceWafFileResponse, error)

	ReplaceWafFileWithTextBodyWithResponse(ctx context.Context, rulesetName RulesetName, name string, params *ReplaceWafFileParams, body ReplaceWafFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceWafFileResponse, error)

	// GetKeepalivedClusterConfigurationVersionWithResponse request
	GetKeepalivedClusterConfigurationVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeepalivedClusterConfigurationVersionResponse, error)

	// GetGlobalDefsWithResponse request
	GetGlobalDefsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalDefsResponse, error)

	// ReplaceGlobalDefsWithBodyWithResponse request with any body
	ReplaceGlobalDefsWithBodyWithResponse(ctx context.Context, params *ReplaceGlobalDefsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGlobalDefsResponse, error)

	ReplaceGlobalDefsWithResponse(ctx context.Context, params *ReplaceGlobalDefsParams, body ReplaceGlobalDefsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGlobalDefsResponse, error)

	// GetKeepalivedConfigurationWithResponse request
	GetKeepalivedConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeepalivedConfigurationResponse, error)

	// ReplaceKeepalivedConfigurationWithBodyWithResponse request with any body
	ReplaceKeepalivedConfigurationWithBodyWithResponse(ctx context.Context, params *ReplaceKeepalivedConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceKeepalivedConfigurationResponse, error)

	ReplaceKeepalivedConfigurationWithTextBodyWithResponse(ctx context.Context, params *ReplaceKeepalivedConfigurationParams, body ReplaceKeepalivedConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceKeepalivedConfigurationResponse, error)

	// GetAllVRRPInstanceWithResponse request
	GetAllVRRPInstanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVRRPInstanceResponse, error)

	// CreateVRRPInstanceWithBodyWithResponse request with any body
	CreateVRRPInstanceWithBodyWithResponse(ctx context.Context, params *CreateVRRPInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVRRPInstanceResponse, error)

	CreateVRRPInstanceWithResponse(ctx context.Context, params *CreateVRRPInstanceParams, body CreateVRRPInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVRRPInstanceResponse, error)

	// DeleteVRRPInstanceWithResponse request
	DeleteVRRPInstanceWithResponse(ctx context.Context, parentName ParentName, params *DeleteVRRPInstanceParams, reqEditors ...RequestEditorFn) (*DeleteVRRPInstanceResponse, error)

	// GetVRRPInstanceWithResponse request
	GetVRRPInstanceWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetVRRPInstanceResponse, error)

	// ReplaceVRRPInstanceWithBodyWithResponse request with any body
	ReplaceVRRPInstanceWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceVRRPInstanceResponse, error)

	ReplaceVRRPInstanceWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPInstanceParams, body ReplaceVRRPInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceVRRPInstanceResponse, error)

	// GetAllVRRPSyncGroupWithResponse request
	GetAllVRRPSyncGroupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVRRPSyncGroupResponse, error)

	// CreateVRRPSyncGroupWithBodyWithResponse request with any body
	CreateVRRPSyncGroupWithBodyWithResponse(ctx context.Context, params *CreateVRRPSyncGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVRRPSyncGroupResponse, error)

	CreateVRRPSyncGroupWithResponse(ctx context.Context, params *CreateVRRPSyncGroupParams, body CreateVRRPSyncGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVRRPSyncGroupResponse, error)

	// DeleteVRRPSyncGroupWithResponse request
	DeleteVRRPSyncGroupWithResponse(ctx context.Context, parentName ParentName, params *DeleteVRRPSyncGroupParams, reqEditors ...RequestEditorFn) (*DeleteVRRPSyncGroupResponse, error)

	// GetVRRPSyncGroupWithResponse request
	GetVRRPSyncGroupWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetVRRPSyncGroupResponse, error)

	// ReplaceVRRPSyncGroupWithBodyWithResponse request with any body
	ReplaceVRRPSyncGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPSyncGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceVRRPSyncGroupResponse, error)

	ReplaceVRRPSyncGroupWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPSyncGroupParams, body ReplaceVRRPSyncGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceVRRPSyncGroupResponse, error)

	// GetAllVRRPScriptWithResponse request
	GetAllVRRPScriptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVRRPScriptResponse, error)

	// CreateVRRPScriptWithBodyWithResponse request with any body
	CreateVRRPScriptWithBodyWithResponse(ctx context.Context, params *CreateVRRPScriptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVRRPScriptResponse, error)

	CreateVRRPScriptWithResponse(ctx context.Context, params *CreateVRRPScriptParams, body CreateVRRPScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVRRPScriptResponse, error)

	// DeleteVRRPScriptWithResponse request
	DeleteVRRPScriptWithResponse(ctx context.Context, parentName ParentName, params *DeleteVRRPScriptParams, reqEditors ...RequestEditorFn) (*DeleteVRRPScriptResponse, error)

	// GetVRRPScriptWithResponse request
	GetVRRPScriptWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetVRRPScriptResponse, error)

	// ReplaceVRRPScriptWithBodyWithResponse request with any body
	ReplaceVRRPScriptWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPScriptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceVRRPScriptResponse, error)

	ReplaceVRRPScriptWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPScriptParams, body ReplaceVRRPScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceVRRPScriptResponse, error)

	// GetAllKeepalivedReloadWithResponse request
	GetAllKeepalivedReloadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllKeepalivedReloadResponse, error)

	// GetKeepalivedReloadWithResponse request
	GetKeepalivedReloadWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeepalivedReloadResponse, error)

	// GetAllKeepalivedTransactionWithResponse request
	GetAllKeepalivedTransactionWithResponse(ctx context.Context, params *GetAllKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*GetAllKeepalivedTransactionResponse, error)

	// StartKeepalivedTransactionWithResponse request
	StartKeepalivedTransactionWithResponse(ctx context.Context, params *StartKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*StartKeepalivedTransactionResponse, error)

	// DeleteKeepalivedTransactionWithResponse request
	DeleteKeepalivedTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeepalivedTransactionResponse, error)

	// GetKeepalivedTransactionWithResponse request
	GetKeepalivedTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeepalivedTransactionResponse, error)

	// CommitKeepalivedTransactionWithResponse request
	CommitKeepalivedTransactionWithResponse(ctx context.Context, id string, params *CommitKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*CommitKeepalivedTransactionResponse, error)

	// GetSpecificationWithResponse request
	GetSpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpecificationResponse, error)

	// GetOpenapiv3SpecificationWithResponse request
	GetOpenapiv3SpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiv3SpecificationResponse, error)

	// GetSummaryWithResponse request
	GetSummaryWithResponse(ctx context.Context, params *GetSummaryParams, reqEditors ...RequestEditorFn) (*GetSummaryResponse, error)
}

type GetAPIEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAPIEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAPIEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlohaEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAlohaEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlohaEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlohaActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AlohaActions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAlohaActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlohaActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteAlohaActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AlohaAction
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ExecuteAlohaActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteAlohaActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAlohaActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AlohaAction
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAlohaActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAlohaActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r PostClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSettings
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InitiateCertificateRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r InitiateCertificateRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InitiateCertificateRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFactsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Facts
	JSON500      *Facts
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFactsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFactsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHealthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Health
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHealthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHealthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Info
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAWSRegionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AwsRegions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAWSRegionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAWSRegionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AwsRegion
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AwsRegion
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAWSRegionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AwsRegion
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAWSRegionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAWSRegionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsulsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consuls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConsulsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsulsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Consul
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consul
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceConsulResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Consul
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceConsulResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceConsulResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Actions
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r RunActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGitEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGitEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGitEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGitActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitActions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGitActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGitActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExecuteGitActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitResponse
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ExecuteGitActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExecuteGitActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGitActionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitAction
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGitActionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGitActionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGitSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitSettings
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGitSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGitSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceGitSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitSettings
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceGitSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceGitSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHaproxyEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHaproxyEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHaproxyEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConfigurationEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backends
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Backend
	JSON202      *Backend
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backend
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Backend
	JSON202      *Backend
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSON202      *Filters
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFilterBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFilterBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFilterBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSON202      *HttpAfterResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPAfterResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPAfterResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPAfterResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSON202      *HttpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSON202      *HttpErrorRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSON202      *HttpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSON202      *HttpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRules
	JSON202      *ServerSwitchingRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServerSwitchingRule
	JSON202      *ServerSwitchingRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerSwitchingRule
	JSON202      *ServerSwitchingRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTemplates
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServerTemplate
	JSON202      *ServerTemplate
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTemplate
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServerTemplate
	JSON202      *ServerTemplate
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Servers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStickRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRules
	JSON202      *StickRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStickRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStickRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *StickRule
	JSON202      *StickRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStickRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickRule
	JSON202      *StickRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStickRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStickRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSON202      *TcpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPCheckBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPCheckBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPCheckBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSON202      *TcpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPRequestRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPRequestRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPRequestRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRules
	JSON202      *TcpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpResponseRule
	JSON202      *TcpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPResponseRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpResponseRule
	JSON202      *TcpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPResponseRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPResponseRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllWafBodyRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafBodyRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllWafBodyRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllWafBodyRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllWafBodyRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafBodyRules
	JSON202      *WafBodyRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllWafBodyRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllWafBodyRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWafBodyRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteWafBodyRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWafBodyRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWafBodyRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafBodyRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetWafBodyRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWafBodyRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWafBodyRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WafBodyRule
	JSON202      *WafBodyRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateWafBodyRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWafBodyRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceWafBodyRuleBackendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafBodyRule
	JSON202      *WafBodyRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceWafBodyRuleBackendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceWafBodyRuleBackendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBotmgmtProfilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotmgmtProfiles
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBotmgmtProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBotmgmtProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBotmgmtProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BotmgmtProfile
	JSON202      *BotmgmtProfile
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBotmgmtProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBotmgmtProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBotmgmtProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBotmgmtProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBotmgmtProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBotmgmtProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotmgmtProfile
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBotmgmtProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBotmgmtProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditBotmgmtProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BotmgmtProfile
	JSON202      *BotmgmtProfile
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditBotmgmtProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditBotmgmtProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCachesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Caches
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCachesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCachesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Cache
	JSON202      *Cache
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cache
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceCacheResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Cache
	JSON202      *Cache
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceCacheResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceCacheResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptchasResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Captchas
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCaptchasResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptchasResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCaptchaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Captcha
	JSON202      *Captcha
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCaptchaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCaptchaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCaptchaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCaptchaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCaptchaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptchaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Captcha
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCaptchaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptchaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCaptchaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Captcha
	JSON202      *Captcha
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditCaptchaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCaptchaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterConfigurationVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterVersion
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetClusterConfigurationVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterConfigurationVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtLoadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtLoads
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtLoadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtLoadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CrtLoad
	JSON202      *CrtLoad
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtLoad
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceCrtLoadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtLoad
	JSON202      *CrtLoad
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceCrtLoadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceCrtLoadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtStoresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtStores
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtStoresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtStoresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CrtStore
	JSON202      *CrtStore
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtStore
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCrtStoreResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CrtStore
	JSON202      *CrtStore
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditCrtStoreResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCrtStoreResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultsSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DefaultsSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDefaultsSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultsSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Defaults
	JSON202      *Defaults
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Defaults
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDefaultsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Defaults
	JSON202      *Defaults
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDefaultsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDefaultsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpChecks
	JSON202      *HttpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpCheck
	JSON202      *HttpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSON202      *HttpErrorRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorRuleDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorRuleDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorRuleDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpChecks
	JSON202      *TcpChecks
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPCheckDefaultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpCheck
	JSON202      *TcpCheck
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPCheckDefaultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPCheckDefaultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDynamicUpdateRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DynamicUpdateRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDynamicUpdateRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDynamicUpdateRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDynamicUpdateRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DynamicUpdateRules
	JSON202      *DynamicUpdateRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDynamicUpdateRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDynamicUpdateRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDynamicUpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDynamicUpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDynamicUpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDynamicUpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DynamicUpdateRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDynamicUpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDynamicUpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDynamicUpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DynamicUpdateRule
	JSON202      *DynamicUpdateRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDynamicUpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDynamicUpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDynamicUpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DynamicUpdateRule
	JSON202      *DynamicUpdateRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDynamicUpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDynamicUpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDynamicUpdateSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDynamicUpdateSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDynamicUpdateSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDynamicUpdateSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDynamicUpdateSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDynamicUpdateSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDynamicUpdateSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDynamicUpdateSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDynamicUpdateSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFCGIAppsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FcgiApps
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFCGIAppsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFCGIAppsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *FCGIApp
	JSON202      *FCGIApp
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FCGIApp
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FCGIApp
	JSON202      *FCGIApp
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclFCGIAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclFCGIAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclFCGIAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFrontendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Frontends
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFrontendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFrontendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Frontend
	JSON202      *Frontend
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Frontend
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Frontend
	JSON202      *Frontend
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acls
	JSON202      *Acls
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAclFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Acl
	JSON202      *Acl
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAclFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAclFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBackendSwitchingRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRules
	JSON202      *BackendSwitchingRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBackendSwitchingRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBackendSwitchingRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *BackendSwitchingRule
	JSON202      *BackendSwitchingRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBackendSwitchingRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackendSwitchingRule
	JSON202      *BackendSwitchingRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBackendSwitchingRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBackendSwitchingRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBindFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBindFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBindFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeclareCapturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Captures
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDeclareCapturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeclareCapturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDeclareCapturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Captures
	JSON202      *Captures
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDeclareCapturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDeclareCapturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Capture
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Capture
	JSON202      *Capture
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDeclareCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Capture
	JSON202      *Capture
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDeclareCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDeclareCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filters
	JSON202      *Filters
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceFilterFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Filter
	JSON202      *Filter
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceFilterFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceFilterFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRules
	JSON202      *HttpAfterResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPAfterResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpAfterResponseRule
	JSON202      *HttpAfterResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPAfterResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPAfterResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRules
	JSON202      *HttpErrorRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorRule
	JSON202      *HttpErrorRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRules
	JSON202      *HttpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpRequestRule
	JSON202      *HttpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRules
	JSON202      *HttpResponseRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPResponseRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpResponseRule
	JSON202      *HttpResponseRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPResponseRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPResponseRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRules
	JSON202      *TcpRequestRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTCPRequestRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TcpRequestRule
	JSON202      *TcpRequestRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTCPRequestRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTCPRequestRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllWafBodyRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafBodyRules
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllWafBodyRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllWafBodyRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllWafBodyRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafBodyRules
	JSON202      *WafBodyRules
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllWafBodyRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllWafBodyRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWafBodyRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteWafBodyRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWafBodyRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWafBodyRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafBodyRule
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetWafBodyRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWafBodyRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWafBodyRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WafBodyRule
	JSON202      *WafBodyRule
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateWafBodyRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWafBodyRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceWafBodyRuleFrontendResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafBodyRule
	JSON202      *WafBodyRule
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceWafBodyRuleFrontendResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceWafBodyRuleFrontendResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Global
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Global
	JSON202      *Global
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetGlobalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetGlobalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetGlobalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Groups
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Group
	JSON202      *Group
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Group
	JSON202      *Group
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorsSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorsSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorsSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorsSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *HttpErrorsSection
	JSON202      *HttpErrorsSection
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorsSection
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceHTTPErrorsSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HttpErrorsSection
	JSON202      *HttpErrorsSection
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceHTTPErrorsSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceHTTPErrorsSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogForwardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogForwards
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogForwardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogForwardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogForward
	JSON202      *LogForward
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogForward
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogForward
	JSON202      *LogForward
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDgramBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBinds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllDgramBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDgramBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDgramBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DgramBind
	JSON202      *DgramBind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDgramBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDgramBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDgramBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDgramBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDgramBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDgramBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDgramBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDgramBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDgramBindLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBind
	JSON202      *DgramBind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDgramBindLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDgramBindLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetLogForwardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetLogForwardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetLogForwardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailerEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailerEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailerEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailerEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MailerEntry
	JSON202      *MailerEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailerEntry
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceMailerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailerEntry
	JSON202      *MailerEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceMailerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceMailerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailersSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailersSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailersSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailersSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MailersSection
	JSON202      *MailersSection
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailersSection
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditMailersSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MailersSection
	JSON202      *MailersSection
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r EditMailersSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditMailersSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNameserversResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nameservers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetNameserversResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNameserversResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Nameserver
	JSON202      *Nameserver
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nameserver
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceNameserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Nameserver
	JSON202      *Nameserver
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceNameserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceNameserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PeerEntry
	JSON202      *PeerEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreatePeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeletePeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerEntry
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplacePeerEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerEntry
	JSON202      *PeerEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplacePeerEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplacePeerEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerSectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerSections
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerSectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerSectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PeerSection
	JSON202      *PeerSection
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreatePeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeletePeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeerSectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeerSection
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetPeerSectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeerSectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Binds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceBindPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Bind
	JSON202      *Bind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceBindPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceBindPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Servers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerPeerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerPeerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerPeerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Tables
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Table
	JSON202      *Table
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Table
	JSON202      *Table
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Programs
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetProgramsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Program
	JSON202      *Program
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Program
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceProgramResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Program
	JSON202      *Program
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceProgramResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceProgramResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHAProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetHAProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHAProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostHAProxyConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostHAProxyConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostHAProxyConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResolversResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resolvers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetResolversResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResolversResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Resolver
	JSON202      *Resolver
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resolver
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceResolverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Resolver
	JSON202      *Resolver
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceResolverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceResolverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Rings
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Ring
	JSON202      *Ring
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ring
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Ring
	JSON202      *Ring
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Servers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceServerRingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Server
	JSON202      *Server
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceServerRingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceServerRingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHAProxyConfigurationStructuredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Structured
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHAProxyConfigurationStructuredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHAProxyConfigurationStructuredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStructuredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Structured
	JSON202      *Structured
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStructuredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStructuredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUDPLbsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UdpLbs
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUDPLbsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUDPLbsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UDPLb
	JSON202      *UDPLb
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUDPlbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UDPLb
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUDPlbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUDPlbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UDPLb
	JSON202      *UDPLb
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDgramBindUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBinds
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllDgramBindUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDgramBindUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDgramBindUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *DgramBind
	JSON202      *DgramBind
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateDgramBindUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDgramBindUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDgramBindUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteDgramBindUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDgramBindUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDgramBindUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBind
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetDgramBindUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDgramBindUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceDgramBindUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DgramBind
	JSON202      *DgramBind
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceDgramBindUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceDgramBindUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllLogTargetUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllLogTargetUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllLogTargetUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceAllLogTargetUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTargets
	JSON202      *LogTargets
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceAllLogTargetUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceAllLogTargetUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogTargetUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogTargetUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogTargetUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogTargetUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogTargetUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogTargetUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogTargetUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogTargetUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogTargetUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogTargetUDPLbResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogTarget
	JSON202      *LogTarget
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogTargetUDPLbResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogTargetUDPLbResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserlistsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Userlists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserlistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserlistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Userlist
	JSON202      *Userlist
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateUserlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteUserlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserlistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Userlist
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserlistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserlistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Users
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *User
	JSON202      *User
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON404      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON202      *User
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigurationVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetConfigurationVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigurationVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogConfiguration
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogConfiguration
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogInputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogInputs
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogInputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogInputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogInput
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogInput
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogInputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogInput
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogInputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogInputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogOutputs
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLogOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *LogOutput
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateLogOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLogOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLogOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteLogOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLogOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLogOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogOutput
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetLogOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLogOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceLogOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogOutput
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceLogOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceLogOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReloadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reloads
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetReloadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReloadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reload
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetReloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRuntimeEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFiles
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFile
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsParentNameEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFilesEntries
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostServicesHaproxyRuntimeAclsParentNameEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AclFileEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r PostServicesHaproxyRuntimeAclsParentNameEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostServicesHaproxyRuntimeAclsParentNameEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPayloadRuntimeACLResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AclFilesEntries
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddPayloadRuntimeACLResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPayloadRuntimeACLResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AclFileEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeServers
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RuntimeAddServer
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeServer
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRuntimeServerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeServer
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceRuntimeServerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRuntimeServerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHaproxyProcessInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProcessInfo
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetHaproxyProcessInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHaproxyProcessInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllRuntimeMapFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Maps
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllRuntimeMapFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllRuntimeMapFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ClearRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Map
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPayloadRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MapEntries
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddPayloadRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPayloadRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowRuntimeMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MapEntries
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ShowRuntimeMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowRuntimeMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MapEntry
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r AddMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuntimeMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteRuntimeMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuntimeMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRuntimeMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MapEntry
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetRuntimeMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRuntimeMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceRuntimeMapEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MapEntry
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceRuntimeMapEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceRuntimeMapEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickTables
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickTable
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStickTableEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StickTableEntries
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStickTableEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStickTableEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetStickTableEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r SetStickTableEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetStickTableEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Sites
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Site
	JSON202      *Site
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Site
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSiteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Site
	JSON202      *Site
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSiteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSiteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeFiles
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *string
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneSpoeFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *string `json:"data,omitempty"`
	}
	JSON404     *NotFound
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneSpoeFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneSpoeFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeScopes
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeScope
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeScopeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeScope
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeScopeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeScopeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeAgents
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeAgent
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeAgent
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSpoeAgentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeAgent
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSpoeAgentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSpoeAgentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeGroups
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeGroup
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeGroup
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSpoeGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeGroup
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSpoeGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSpoeGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeMessages
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeMessage
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeMessage
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceSpoeMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeMessage
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceSpoeMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceSpoeMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeTransactions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SpoeTransaction
	JSON429      *struct {
		Code    *int    `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r StartSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeTransaction
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitSpoeTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SpoeTransaction
	JSON202      *SpoeTransaction
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CommitSpoeTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitSpoeTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpoeConfigurationVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *int
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpoeConfigurationVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpoeConfigurationVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStatsEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NativeStats
	JSON500      *NativeStats
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStorageEndpointsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Endpoints
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetStorageEndpointsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStorageEndpointsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageGeneralFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GeneralFiles
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageGeneralFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageGeneralFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GeneralFile
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageGeneralFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageGeneralFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageGeneralFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageMapFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Maps
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageMapFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageMapFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageMapFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Map
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageMapFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageMapFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageMapResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageMapResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageMapResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageMapFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageMapFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageMapFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStorageSSLCertificatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificates
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllStorageSSLCertificatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStorageSSLCertificatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SslCertificate
	JSON202      *SslCertificate
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOneStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificate
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOneStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOneStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceStorageSSLCertificateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SslCertificate
	JSON202      *SslCertificate
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceStorageSSLCertificateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceStorageSSLCertificateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transactions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Transaction
	JSON429      *struct {
		Code    *int    `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r StartTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Transaction
	JSON202      *Transaction
	JSON400      *BadRequest
	JSON404      *NotFound
	JSON406      *NotAcceptable
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CommitTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWafRulesetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafRulesets
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetWafRulesetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWafRulesetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWafRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WafRuleset
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateWafRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWafRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWafRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteWafRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWafRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWafRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafRuleset
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetWafRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWafRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceWafRulesetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceWafRulesetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceWafRulesetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWafFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WafFiles
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetWafFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWafFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWafFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WafFile
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateWafFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWafFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWafFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteWafFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWafFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWafFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetWafFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWafFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceWafFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceWafFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceWafFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeepalivedClusterConfigurationVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterVersion
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetKeepalivedClusterConfigurationVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeepalivedClusterConfigurationVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalDefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpGlobalDefs
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetGlobalDefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalDefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceGlobalDefsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpGlobalDefs
	JSON202      *VrrpGlobalDefs
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceGlobalDefsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceGlobalDefsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeepalivedConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data string `json:"data"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetKeepalivedConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeepalivedConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceKeepalivedConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Data string `json:"data"`
	}
	JSON202 *struct {
		Data string `json:"data"`
	}
	JSON400     *BadRequest
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceKeepalivedConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceKeepalivedConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllVRRPInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpInstances
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllVRRPInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllVRRPInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVRRPInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VrrpInstance
	JSON202      *VrrpInstance
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVRRPInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVRRPInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVRRPInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteVRRPInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVRRPInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVRRPInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpInstance
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVRRPInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVRRPInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceVRRPInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpInstance
	JSON202      *VrrpInstance
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceVRRPInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceVRRPInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllVRRPSyncGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpSyncGroups
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllVRRPSyncGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllVRRPSyncGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVRRPSyncGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VrrpSyncGroup
	JSON202      *VrrpSyncGroup
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVRRPSyncGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVRRPSyncGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVRRPSyncGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteVRRPSyncGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVRRPSyncGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVRRPSyncGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpSyncGroup
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVRRPSyncGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVRRPSyncGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceVRRPSyncGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpSyncGroup
	JSON202      *VrrpSyncGroup
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceVRRPSyncGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceVRRPSyncGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllVRRPScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpTrackScripts
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllVRRPScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllVRRPScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateVRRPScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *VrrpTrackScript
	JSON202      *VrrpTrackScript
	JSON400      *BadRequest
	JSON409      *AlreadyExists
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CreateVRRPScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateVRRPScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVRRPScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteVRRPScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVRRPScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVRRPScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpTrackScript
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetVRRPScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVRRPScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReplaceVRRPScriptResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VrrpTrackScript
	JSON202      *VrrpTrackScript
	JSON400      *BadRequest
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r ReplaceVRRPScriptResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReplaceVRRPScriptResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllKeepalivedReloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeepalivedReloads
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllKeepalivedReloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllKeepalivedReloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeepalivedReloadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeepalivedReload
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetKeepalivedReloadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeepalivedReloadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllKeepalivedTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeepalivedTransactions
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetAllKeepalivedTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllKeepalivedTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartKeepalivedTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *KeepalivedTransaction
	JSON429      *struct {
		Code    *int    `json:"code,omitempty"`
		Message *string `json:"message,omitempty"`
	}
	JSONDefault *DefaultError
}

// Status returns HTTPResponse.Status
func (r StartKeepalivedTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartKeepalivedTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteKeepalivedTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r DeleteKeepalivedTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteKeepalivedTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeepalivedTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeepalivedTransaction
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetKeepalivedTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeepalivedTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitKeepalivedTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeepalivedTransaction
	JSON202      *KeepalivedTransaction
	JSON400      *BadRequest
	JSON404      *NotFound
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r CommitKeepalivedTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitKeepalivedTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpecificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSpecificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpecificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOpenapiv3SpecificationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetOpenapiv3SpecificationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOpenapiv3SpecificationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Summary
	JSONDefault  *DefaultError
}

// Status returns HTTPResponse.Status
func (r GetSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAPIEndpointsWithResponse request returning *GetAPIEndpointsResponse
func (c *ClientWithResponses) GetAPIEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAPIEndpointsResponse, error) {
	rsp, err := c.GetAPIEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAPIEndpointsResponse(rsp)
}

// GetAlohaEndpointsWithResponse request returning *GetAlohaEndpointsResponse
func (c *ClientWithResponses) GetAlohaEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAlohaEndpointsResponse, error) {
	rsp, err := c.GetAlohaEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlohaEndpointsResponse(rsp)
}

// GetAlohaActionsWithResponse request returning *GetAlohaActionsResponse
func (c *ClientWithResponses) GetAlohaActionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAlohaActionsResponse, error) {
	rsp, err := c.GetAlohaActions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlohaActionsResponse(rsp)
}

// ExecuteAlohaActionWithBodyWithResponse request with arbitrary body returning *ExecuteAlohaActionResponse
func (c *ClientWithResponses) ExecuteAlohaActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteAlohaActionResponse, error) {
	rsp, err := c.ExecuteAlohaActionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteAlohaActionResponse(rsp)
}

func (c *ClientWithResponses) ExecuteAlohaActionWithResponse(ctx context.Context, body ExecuteAlohaActionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteAlohaActionResponse, error) {
	rsp, err := c.ExecuteAlohaAction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteAlohaActionResponse(rsp)
}

// GetAlohaActionWithResponse request returning *GetAlohaActionResponse
func (c *ClientWithResponses) GetAlohaActionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAlohaActionResponse, error) {
	rsp, err := c.GetAlohaAction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAlohaActionResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// PostClusterWithBodyWithResponse request with arbitrary body returning *PostClusterResponse
func (c *ClientWithResponses) PostClusterWithBodyWithResponse(ctx context.Context, params *PostClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostClusterResponse, error) {
	rsp, err := c.PostClusterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterResponse(rsp)
}

func (c *ClientWithResponses) PostClusterWithResponse(ctx context.Context, params *PostClusterParams, body PostClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*PostClusterResponse, error) {
	rsp, err := c.PostCluster(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostClusterResponse(rsp)
}

// EditClusterWithBodyWithResponse request with arbitrary body returning *EditClusterResponse
func (c *ClientWithResponses) EditClusterWithBodyWithResponse(ctx context.Context, params *EditClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditClusterResponse, error) {
	rsp, err := c.EditClusterWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditClusterResponse(rsp)
}

func (c *ClientWithResponses) EditClusterWithResponse(ctx context.Context, params *EditClusterParams, body EditClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*EditClusterResponse, error) {
	rsp, err := c.EditCluster(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditClusterResponse(rsp)
}

// InitiateCertificateRefreshWithResponse request returning *InitiateCertificateRefreshResponse
func (c *ClientWithResponses) InitiateCertificateRefreshWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*InitiateCertificateRefreshResponse, error) {
	rsp, err := c.InitiateCertificateRefresh(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInitiateCertificateRefreshResponse(rsp)
}

// GetFactsWithResponse request returning *GetFactsResponse
func (c *ClientWithResponses) GetFactsWithResponse(ctx context.Context, params *GetFactsParams, reqEditors ...RequestEditorFn) (*GetFactsResponse, error) {
	rsp, err := c.GetFacts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFactsResponse(rsp)
}

// GetHealthWithResponse request returning *GetHealthResponse
func (c *ClientWithResponses) GetHealthWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHealthResponse, error) {
	rsp, err := c.GetHealth(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHealthResponse(rsp)
}

// GetInfoWithResponse request returning *GetInfoResponse
func (c *ClientWithResponses) GetInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetInfoResponse, error) {
	rsp, err := c.GetInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInfoResponse(rsp)
}

// GetAWSRegionsWithResponse request returning *GetAWSRegionsResponse
func (c *ClientWithResponses) GetAWSRegionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAWSRegionsResponse, error) {
	rsp, err := c.GetAWSRegions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAWSRegionsResponse(rsp)
}

// CreateAWSRegionWithBodyWithResponse request with arbitrary body returning *CreateAWSRegionResponse
func (c *ClientWithResponses) CreateAWSRegionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error) {
	rsp, err := c.CreateAWSRegionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAWSRegionResponse(rsp)
}

func (c *ClientWithResponses) CreateAWSRegionWithResponse(ctx context.Context, body CreateAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAWSRegionResponse, error) {
	rsp, err := c.CreateAWSRegion(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAWSRegionResponse(rsp)
}

// DeleteAWSRegionWithResponse request returning *DeleteAWSRegionResponse
func (c *ClientWithResponses) DeleteAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteAWSRegionResponse, error) {
	rsp, err := c.DeleteAWSRegion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAWSRegionResponse(rsp)
}

// GetAWSRegionWithResponse request returning *GetAWSRegionResponse
func (c *ClientWithResponses) GetAWSRegionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAWSRegionResponse, error) {
	rsp, err := c.GetAWSRegion(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAWSRegionResponse(rsp)
}

// ReplaceAWSRegionWithBodyWithResponse request with arbitrary body returning *ReplaceAWSRegionResponse
func (c *ClientWithResponses) ReplaceAWSRegionWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error) {
	rsp, err := c.ReplaceAWSRegionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAWSRegionResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAWSRegionWithResponse(ctx context.Context, id string, body ReplaceAWSRegionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAWSRegionResponse, error) {
	rsp, err := c.ReplaceAWSRegion(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAWSRegionResponse(rsp)
}

// GetConsulsWithResponse request returning *GetConsulsResponse
func (c *ClientWithResponses) GetConsulsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConsulsResponse, error) {
	rsp, err := c.GetConsuls(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsulsResponse(rsp)
}

// CreateConsulWithBodyWithResponse request with arbitrary body returning *CreateConsulResponse
func (c *ClientWithResponses) CreateConsulWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error) {
	rsp, err := c.CreateConsulWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsulResponse(rsp)
}

func (c *ClientWithResponses) CreateConsulWithResponse(ctx context.Context, body CreateConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConsulResponse, error) {
	rsp, err := c.CreateConsul(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConsulResponse(rsp)
}

// DeleteConsulWithResponse request returning *DeleteConsulResponse
func (c *ClientWithResponses) DeleteConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteConsulResponse, error) {
	rsp, err := c.DeleteConsul(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConsulResponse(rsp)
}

// GetConsulWithResponse request returning *GetConsulResponse
func (c *ClientWithResponses) GetConsulWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetConsulResponse, error) {
	rsp, err := c.GetConsul(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConsulResponse(rsp)
}

// ReplaceConsulWithBodyWithResponse request with arbitrary body returning *ReplaceConsulResponse
func (c *ClientWithResponses) ReplaceConsulWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error) {
	rsp, err := c.ReplaceConsulWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceConsulResponse(rsp)
}

func (c *ClientWithResponses) ReplaceConsulWithResponse(ctx context.Context, id string, body ReplaceConsulJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceConsulResponse, error) {
	rsp, err := c.ReplaceConsul(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceConsulResponse(rsp)
}

// GetServicesEndpointsWithResponse request returning *GetServicesEndpointsResponse
func (c *ClientWithResponses) GetServicesEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesEndpointsResponse, error) {
	rsp, err := c.GetServicesEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesEndpointsResponse(rsp)
}

// RunActionsWithBodyWithResponse request with arbitrary body returning *RunActionsResponse
func (c *ClientWithResponses) RunActionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunActionsResponse, error) {
	rsp, err := c.RunActionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunActionsResponse(rsp)
}

func (c *ClientWithResponses) RunActionsWithResponse(ctx context.Context, body RunActionsJSONRequestBody, reqEditors ...RequestEditorFn) (*RunActionsResponse, error) {
	rsp, err := c.RunActions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunActionsResponse(rsp)
}

// GetGitEndpointsWithResponse request returning *GetGitEndpointsResponse
func (c *ClientWithResponses) GetGitEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGitEndpointsResponse, error) {
	rsp, err := c.GetGitEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGitEndpointsResponse(rsp)
}

// GetGitActionsWithResponse request returning *GetGitActionsResponse
func (c *ClientWithResponses) GetGitActionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGitActionsResponse, error) {
	rsp, err := c.GetGitActions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGitActionsResponse(rsp)
}

// ExecuteGitActionWithBodyWithResponse request with arbitrary body returning *ExecuteGitActionResponse
func (c *ClientWithResponses) ExecuteGitActionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExecuteGitActionResponse, error) {
	rsp, err := c.ExecuteGitActionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteGitActionResponse(rsp)
}

func (c *ClientWithResponses) ExecuteGitActionWithResponse(ctx context.Context, body ExecuteGitActionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExecuteGitActionResponse, error) {
	rsp, err := c.ExecuteGitAction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExecuteGitActionResponse(rsp)
}

// GetGitActionWithResponse request returning *GetGitActionResponse
func (c *ClientWithResponses) GetGitActionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGitActionResponse, error) {
	rsp, err := c.GetGitAction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGitActionResponse(rsp)
}

// GetGitSettingsWithResponse request returning *GetGitSettingsResponse
func (c *ClientWithResponses) GetGitSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGitSettingsResponse, error) {
	rsp, err := c.GetGitSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGitSettingsResponse(rsp)
}

// ReplaceGitSettingsWithBodyWithResponse request with arbitrary body returning *ReplaceGitSettingsResponse
func (c *ClientWithResponses) ReplaceGitSettingsWithBodyWithResponse(ctx context.Context, params *ReplaceGitSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGitSettingsResponse, error) {
	rsp, err := c.ReplaceGitSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGitSettingsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceGitSettingsWithResponse(ctx context.Context, params *ReplaceGitSettingsParams, body ReplaceGitSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGitSettingsResponse, error) {
	rsp, err := c.ReplaceGitSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGitSettingsResponse(rsp)
}

// GetHaproxyEndpointsWithResponse request returning *GetHaproxyEndpointsResponse
func (c *ClientWithResponses) GetHaproxyEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyEndpointsResponse, error) {
	rsp, err := c.GetHaproxyEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHaproxyEndpointsResponse(rsp)
}

// GetConfigurationEndpointsWithResponse request returning *GetConfigurationEndpointsResponse
func (c *ClientWithResponses) GetConfigurationEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigurationEndpointsResponse, error) {
	rsp, err := c.GetConfigurationEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationEndpointsResponse(rsp)
}

// GetBackendsWithResponse request returning *GetBackendsResponse
func (c *ClientWithResponses) GetBackendsWithResponse(ctx context.Context, params *GetBackendsParams, reqEditors ...RequestEditorFn) (*GetBackendsResponse, error) {
	rsp, err := c.GetBackends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendsResponse(rsp)
}

// CreateBackendWithBodyWithResponse request with arbitrary body returning *CreateBackendResponse
func (c *ClientWithResponses) CreateBackendWithBodyWithResponse(ctx context.Context, params *CreateBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error) {
	rsp, err := c.CreateBackendWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateBackendWithResponse(ctx context.Context, params *CreateBackendParams, body CreateBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendResponse, error) {
	rsp, err := c.CreateBackend(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendResponse(rsp)
}

// DeleteBackendWithResponse request returning *DeleteBackendResponse
func (c *ClientWithResponses) DeleteBackendWithResponse(ctx context.Context, name string, params *DeleteBackendParams, reqEditors ...RequestEditorFn) (*DeleteBackendResponse, error) {
	rsp, err := c.DeleteBackend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackendResponse(rsp)
}

// GetBackendWithResponse request returning *GetBackendResponse
func (c *ClientWithResponses) GetBackendWithResponse(ctx context.Context, name string, params *GetBackendParams, reqEditors ...RequestEditorFn) (*GetBackendResponse, error) {
	rsp, err := c.GetBackend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendResponse(rsp)
}

// ReplaceBackendWithBodyWithResponse request with arbitrary body returning *ReplaceBackendResponse
func (c *ClientWithResponses) ReplaceBackendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error) {
	rsp, err := c.ReplaceBackendWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBackendWithResponse(ctx context.Context, name string, params *ReplaceBackendParams, body ReplaceBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendResponse, error) {
	rsp, err := c.ReplaceBackend(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendResponse(rsp)
}

// GetAllAclBackendWithResponse request returning *GetAllAclBackendResponse
func (c *ClientWithResponses) GetAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclBackendParams, reqEditors ...RequestEditorFn) (*GetAllAclBackendResponse, error) {
	rsp, err := c.GetAllAclBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclBackendResponse(rsp)
}

// ReplaceAllAclBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclBackendResponse
func (c *ClientWithResponses) ReplaceAllAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error) {
	rsp, err := c.ReplaceAllAclBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclBackendParams, body ReplaceAllAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclBackendResponse, error) {
	rsp, err := c.ReplaceAllAclBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclBackendResponse(rsp)
}

// DeleteAclBackendWithResponse request returning *DeleteAclBackendResponse
func (c *ClientWithResponses) DeleteAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclBackendParams, reqEditors ...RequestEditorFn) (*DeleteAclBackendResponse, error) {
	rsp, err := c.DeleteAclBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclBackendResponse(rsp)
}

// GetAclBackendWithResponse request returning *GetAclBackendResponse
func (c *ClientWithResponses) GetAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclBackendParams, reqEditors ...RequestEditorFn) (*GetAclBackendResponse, error) {
	rsp, err := c.GetAclBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclBackendResponse(rsp)
}

// CreateAclBackendWithBodyWithResponse request with arbitrary body returning *CreateAclBackendResponse
func (c *ClientWithResponses) CreateAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error) {
	rsp, err := c.CreateAclBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclBackendParams, body CreateAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclBackendResponse, error) {
	rsp, err := c.CreateAclBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclBackendResponse(rsp)
}

// ReplaceAclBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAclBackendResponse
func (c *ClientWithResponses) ReplaceAclBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error) {
	rsp, err := c.ReplaceAclBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclBackendParams, body ReplaceAclBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclBackendResponse, error) {
	rsp, err := c.ReplaceAclBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclBackendResponse(rsp)
}

// GetAllFilterBackendWithResponse request returning *GetAllFilterBackendResponse
func (c *ClientWithResponses) GetAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterBackendParams, reqEditors ...RequestEditorFn) (*GetAllFilterBackendResponse, error) {
	rsp, err := c.GetAllFilterBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllFilterBackendResponse(rsp)
}

// ReplaceAllFilterBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllFilterBackendResponse
func (c *ClientWithResponses) ReplaceAllFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error) {
	rsp, err := c.ReplaceAllFilterBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllFilterBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterBackendParams, body ReplaceAllFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterBackendResponse, error) {
	rsp, err := c.ReplaceAllFilterBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterBackendResponse(rsp)
}

// DeleteFilterBackendWithResponse request returning *DeleteFilterBackendResponse
func (c *ClientWithResponses) DeleteFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterBackendParams, reqEditors ...RequestEditorFn) (*DeleteFilterBackendResponse, error) {
	rsp, err := c.DeleteFilterBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFilterBackendResponse(rsp)
}

// GetFilterBackendWithResponse request returning *GetFilterBackendResponse
func (c *ClientWithResponses) GetFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterBackendParams, reqEditors ...RequestEditorFn) (*GetFilterBackendResponse, error) {
	rsp, err := c.GetFilterBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterBackendResponse(rsp)
}

// CreateFilterBackendWithBodyWithResponse request with arbitrary body returning *CreateFilterBackendResponse
func (c *ClientWithResponses) CreateFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error) {
	rsp, err := c.CreateFilterBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterBackendParams, body CreateFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterBackendResponse, error) {
	rsp, err := c.CreateFilterBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterBackendResponse(rsp)
}

// ReplaceFilterBackendWithBodyWithResponse request with arbitrary body returning *ReplaceFilterBackendResponse
func (c *ClientWithResponses) ReplaceFilterBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error) {
	rsp, err := c.ReplaceFilterBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFilterBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterBackendParams, body ReplaceFilterBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterBackendResponse, error) {
	rsp, err := c.ReplaceFilterBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterBackendResponse(rsp)
}

// GetAllHTTPAfterResponseRuleBackendWithResponse request returning *GetAllHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPAfterResponseRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPAfterResponseRuleBackendResponse(rsp)
}

// ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleBackendParams, body ReplaceAllHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleBackendResponse(rsp)
}

// DeleteHTTPAfterResponseRuleBackendWithResponse request returning *DeleteHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPAfterResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPAfterResponseRuleBackendResponse(rsp)
}

// GetHTTPAfterResponseRuleBackendWithResponse request returning *GetHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) GetHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.GetHTTPAfterResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPAfterResponseRuleBackendResponse(rsp)
}

// CreateHTTPAfterResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleBackendParams, body CreateHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleBackendResponse(rsp)
}

// ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPAfterResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleBackendParams, body ReplaceHTTPAfterResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleBackendResponse(rsp)
}

// GetAllHTTPCheckBackendWithResponse request returning *GetAllHTTPCheckBackendResponse
func (c *ClientWithResponses) GetAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckBackendResponse, error) {
	rsp, err := c.GetAllHTTPCheckBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPCheckBackendResponse(rsp)
}

// ReplaceAllHTTPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPCheckBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckBackendParams, body ReplaceAllHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckBackendResponse(rsp)
}

// DeleteHTTPCheckBackendWithResponse request returning *DeleteHTTPCheckBackendResponse
func (c *ClientWithResponses) DeleteHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckBackendResponse, error) {
	rsp, err := c.DeleteHTTPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPCheckBackendResponse(rsp)
}

// GetHTTPCheckBackendWithResponse request returning *GetHTTPCheckBackendResponse
func (c *ClientWithResponses) GetHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckBackendResponse, error) {
	rsp, err := c.GetHTTPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPCheckBackendResponse(rsp)
}

// CreateHTTPCheckBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPCheckBackendResponse
func (c *ClientWithResponses) CreateHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error) {
	rsp, err := c.CreateHTTPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckBackendParams, body CreateHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckBackendResponse, error) {
	rsp, err := c.CreateHTTPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckBackendResponse(rsp)
}

// ReplaceHTTPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPCheckBackendResponse
func (c *ClientWithResponses) ReplaceHTTPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceHTTPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckBackendParams, body ReplaceHTTPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckBackendResponse, error) {
	rsp, err := c.ReplaceHTTPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckBackendResponse(rsp)
}

// GetAllHTTPErrorRuleBackendWithResponse request returning *GetAllHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPErrorRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPErrorRuleBackendResponse(rsp)
}

// ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleBackendParams, body ReplaceAllHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleBackendResponse(rsp)
}

// DeleteHTTPErrorRuleBackendWithResponse request returning *DeleteHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPErrorRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorRuleBackendResponse(rsp)
}

// GetHTTPErrorRuleBackendWithResponse request returning *GetHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) GetHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.GetHTTPErrorRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorRuleBackendResponse(rsp)
}

// CreateHTTPErrorRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleBackendParams, body CreateHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleBackendResponse(rsp)
}

// ReplaceHTTPErrorRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPErrorRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleBackendParams, body ReplaceHTTPErrorRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleBackendResponse(rsp)
}

// GetAllHTTPRequestRuleBackendWithResponse request returning *GetAllHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPRequestRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPRequestRuleBackendResponse(rsp)
}

// ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleBackendParams, body ReplaceAllHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleBackendResponse(rsp)
}

// DeleteHTTPRequestRuleBackendWithResponse request returning *DeleteHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPRequestRuleBackendResponse(rsp)
}

// GetHTTPRequestRuleBackendWithResponse request returning *GetHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) GetHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.GetHTTPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPRequestRuleBackendResponse(rsp)
}

// CreateHTTPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleBackendParams, body CreateHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleBackendResponse(rsp)
}

// ReplaceHTTPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleBackendParams, body ReplaceHTTPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleBackendResponse(rsp)
}

// GetAllHTTPResponseRuleBackendWithResponse request returning *GetAllHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) GetAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.GetAllHTTPResponseRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPResponseRuleBackendResponse(rsp)
}

// ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleBackendParams, body ReplaceAllHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleBackendResponse(rsp)
}

// DeleteHTTPResponseRuleBackendWithResponse request returning *DeleteHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) DeleteHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.DeleteHTTPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPResponseRuleBackendResponse(rsp)
}

// GetHTTPResponseRuleBackendWithResponse request returning *GetHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) GetHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.GetHTTPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPResponseRuleBackendResponse(rsp)
}

// CreateHTTPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) CreateHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleBackendParams, body CreateHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleBackendResponse(rsp)
}

// ReplaceHTTPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceHTTPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleBackendParams, body ReplaceHTTPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleBackendResponse(rsp)
}

// GetAllLogTargetBackendWithResponse request returning *GetAllLogTargetBackendResponse
func (c *ClientWithResponses) GetAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetBackendResponse, error) {
	rsp, err := c.GetAllLogTargetBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetBackendResponse(rsp)
}

// ReplaceAllLogTargetBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetBackendResponse
func (c *ClientWithResponses) ReplaceAllLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetBackendParams, body ReplaceAllLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetBackendResponse(rsp)
}

// DeleteLogTargetBackendWithResponse request returning *DeleteLogTargetBackendResponse
func (c *ClientWithResponses) DeleteLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetBackendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetBackendResponse, error) {
	rsp, err := c.DeleteLogTargetBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetBackendResponse(rsp)
}

// GetLogTargetBackendWithResponse request returning *GetLogTargetBackendResponse
func (c *ClientWithResponses) GetLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetBackendParams, reqEditors ...RequestEditorFn) (*GetLogTargetBackendResponse, error) {
	rsp, err := c.GetLogTargetBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetBackendResponse(rsp)
}

// CreateLogTargetBackendWithBodyWithResponse request with arbitrary body returning *CreateLogTargetBackendResponse
func (c *ClientWithResponses) CreateLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error) {
	rsp, err := c.CreateLogTargetBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetBackendParams, body CreateLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetBackendResponse, error) {
	rsp, err := c.CreateLogTargetBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetBackendResponse(rsp)
}

// ReplaceLogTargetBackendWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetBackendResponse
func (c *ClientWithResponses) ReplaceLogTargetBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceLogTargetBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetBackendParams, body ReplaceLogTargetBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetBackendResponse, error) {
	rsp, err := c.ReplaceLogTargetBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetBackendResponse(rsp)
}

// GetServerSwitchingRulesWithResponse request returning *GetServerSwitchingRulesResponse
func (c *ClientWithResponses) GetServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetServerSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRulesResponse, error) {
	rsp, err := c.GetServerSwitchingRules(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerSwitchingRulesResponse(rsp)
}

// ReplaceServerSwitchingRulesWithBodyWithResponse request with arbitrary body returning *ReplaceServerSwitchingRulesResponse
func (c *ClientWithResponses) ReplaceServerSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRulesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceServerSwitchingRulesParams, body ReplaceServerSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRules(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRulesResponse(rsp)
}

// DeleteServerSwitchingRuleWithResponse request returning *DeleteServerSwitchingRuleResponse
func (c *ClientWithResponses) DeleteServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteServerSwitchingRuleResponse, error) {
	rsp, err := c.DeleteServerSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerSwitchingRuleResponse(rsp)
}

// GetServerSwitchingRuleWithResponse request returning *GetServerSwitchingRuleResponse
func (c *ClientWithResponses) GetServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetServerSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetServerSwitchingRuleResponse, error) {
	rsp, err := c.GetServerSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerSwitchingRuleResponse(rsp)
}

// CreateServerSwitchingRuleWithBodyWithResponse request with arbitrary body returning *CreateServerSwitchingRuleResponse
func (c *ClientWithResponses) CreateServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error) {
	rsp, err := c.CreateServerSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateServerSwitchingRuleParams, body CreateServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerSwitchingRuleResponse, error) {
	rsp, err := c.CreateServerSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerSwitchingRuleResponse(rsp)
}

// ReplaceServerSwitchingRuleWithBodyWithResponse request with arbitrary body returning *ReplaceServerSwitchingRuleResponse
func (c *ClientWithResponses) ReplaceServerSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceServerSwitchingRuleParams, body ReplaceServerSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceServerSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerSwitchingRuleResponse(rsp)
}

// GetServerTemplatesWithResponse request returning *GetServerTemplatesResponse
func (c *ClientWithResponses) GetServerTemplatesWithResponse(ctx context.Context, parentName ParentName, params *GetServerTemplatesParams, reqEditors ...RequestEditorFn) (*GetServerTemplatesResponse, error) {
	rsp, err := c.GetServerTemplates(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerTemplatesResponse(rsp)
}

// CreateServerTemplateWithBodyWithResponse request with arbitrary body returning *CreateServerTemplateResponse
func (c *ClientWithResponses) CreateServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error) {
	rsp, err := c.CreateServerTemplateWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerTemplateResponse(rsp)
}

func (c *ClientWithResponses) CreateServerTemplateWithResponse(ctx context.Context, parentName ParentName, params *CreateServerTemplateParams, body CreateServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerTemplateResponse, error) {
	rsp, err := c.CreateServerTemplate(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerTemplateResponse(rsp)
}

// DeleteServerTemplateWithResponse request returning *DeleteServerTemplateResponse
func (c *ClientWithResponses) DeleteServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *DeleteServerTemplateParams, reqEditors ...RequestEditorFn) (*DeleteServerTemplateResponse, error) {
	rsp, err := c.DeleteServerTemplate(ctx, parentName, prefix, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerTemplateResponse(rsp)
}

// GetServerTemplateWithResponse request returning *GetServerTemplateResponse
func (c *ClientWithResponses) GetServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *GetServerTemplateParams, reqEditors ...RequestEditorFn) (*GetServerTemplateResponse, error) {
	rsp, err := c.GetServerTemplate(ctx, parentName, prefix, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerTemplateResponse(rsp)
}

// ReplaceServerTemplateWithBodyWithResponse request with arbitrary body returning *ReplaceServerTemplateResponse
func (c *ClientWithResponses) ReplaceServerTemplateWithBodyWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error) {
	rsp, err := c.ReplaceServerTemplateWithBody(ctx, parentName, prefix, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerTemplateResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerTemplateWithResponse(ctx context.Context, parentName ParentName, prefix string, params *ReplaceServerTemplateParams, body ReplaceServerTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerTemplateResponse, error) {
	rsp, err := c.ReplaceServerTemplate(ctx, parentName, prefix, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerTemplateResponse(rsp)
}

// GetAllServerBackendWithResponse request returning *GetAllServerBackendResponse
func (c *ClientWithResponses) GetAllServerBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerBackendParams, reqEditors ...RequestEditorFn) (*GetAllServerBackendResponse, error) {
	rsp, err := c.GetAllServerBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerBackendResponse(rsp)
}

// CreateServerBackendWithBodyWithResponse request with arbitrary body returning *CreateServerBackendResponse
func (c *ClientWithResponses) CreateServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error) {
	rsp, err := c.CreateServerBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateServerBackendWithResponse(ctx context.Context, parentName ParentName, params *CreateServerBackendParams, body CreateServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerBackendResponse, error) {
	rsp, err := c.CreateServerBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerBackendResponse(rsp)
}

// DeleteServerBackendWithResponse request returning *DeleteServerBackendResponse
func (c *ClientWithResponses) DeleteServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerBackendParams, reqEditors ...RequestEditorFn) (*DeleteServerBackendResponse, error) {
	rsp, err := c.DeleteServerBackend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerBackendResponse(rsp)
}

// GetServerBackendWithResponse request returning *GetServerBackendResponse
func (c *ClientWithResponses) GetServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerBackendParams, reqEditors ...RequestEditorFn) (*GetServerBackendResponse, error) {
	rsp, err := c.GetServerBackend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerBackendResponse(rsp)
}

// ReplaceServerBackendWithBodyWithResponse request with arbitrary body returning *ReplaceServerBackendResponse
func (c *ClientWithResponses) ReplaceServerBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error) {
	rsp, err := c.ReplaceServerBackendWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerBackendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerBackendParams, body ReplaceServerBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerBackendResponse, error) {
	rsp, err := c.ReplaceServerBackend(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerBackendResponse(rsp)
}

// GetStickRulesWithResponse request returning *GetStickRulesResponse
func (c *ClientWithResponses) GetStickRulesWithResponse(ctx context.Context, parentName ParentName, params *GetStickRulesParams, reqEditors ...RequestEditorFn) (*GetStickRulesResponse, error) {
	rsp, err := c.GetStickRules(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickRulesResponse(rsp)
}

// ReplaceStickRulesWithBodyWithResponse request with arbitrary body returning *ReplaceStickRulesResponse
func (c *ClientWithResponses) ReplaceStickRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error) {
	rsp, err := c.ReplaceStickRulesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStickRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceStickRulesParams, body ReplaceStickRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRulesResponse, error) {
	rsp, err := c.ReplaceStickRules(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRulesResponse(rsp)
}

// DeleteStickRuleWithResponse request returning *DeleteStickRuleResponse
func (c *ClientWithResponses) DeleteStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteStickRuleParams, reqEditors ...RequestEditorFn) (*DeleteStickRuleResponse, error) {
	rsp, err := c.DeleteStickRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStickRuleResponse(rsp)
}

// GetStickRuleWithResponse request returning *GetStickRuleResponse
func (c *ClientWithResponses) GetStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetStickRuleParams, reqEditors ...RequestEditorFn) (*GetStickRuleResponse, error) {
	rsp, err := c.GetStickRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickRuleResponse(rsp)
}

// CreateStickRuleWithBodyWithResponse request with arbitrary body returning *CreateStickRuleResponse
func (c *ClientWithResponses) CreateStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error) {
	rsp, err := c.CreateStickRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStickRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateStickRuleParams, body CreateStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStickRuleResponse, error) {
	rsp, err := c.CreateStickRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStickRuleResponse(rsp)
}

// ReplaceStickRuleWithBodyWithResponse request with arbitrary body returning *ReplaceStickRuleResponse
func (c *ClientWithResponses) ReplaceStickRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error) {
	rsp, err := c.ReplaceStickRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStickRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceStickRuleParams, body ReplaceStickRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStickRuleResponse, error) {
	rsp, err := c.ReplaceStickRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStickRuleResponse(rsp)
}

// GetAllTCPCheckBackendWithResponse request returning *GetAllTCPCheckBackendResponse
func (c *ClientWithResponses) GetAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckBackendResponse, error) {
	rsp, err := c.GetAllTCPCheckBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPCheckBackendResponse(rsp)
}

// ReplaceAllTCPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPCheckBackendResponse
func (c *ClientWithResponses) ReplaceAllTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckBackendParams, body ReplaceAllTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckBackendResponse(rsp)
}

// DeleteTCPCheckBackendWithResponse request returning *DeleteTCPCheckBackendResponse
func (c *ClientWithResponses) DeleteTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckBackendResponse, error) {
	rsp, err := c.DeleteTCPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPCheckBackendResponse(rsp)
}

// GetTCPCheckBackendWithResponse request returning *GetTCPCheckBackendResponse
func (c *ClientWithResponses) GetTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckBackendParams, reqEditors ...RequestEditorFn) (*GetTCPCheckBackendResponse, error) {
	rsp, err := c.GetTCPCheckBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPCheckBackendResponse(rsp)
}

// CreateTCPCheckBackendWithBodyWithResponse request with arbitrary body returning *CreateTCPCheckBackendResponse
func (c *ClientWithResponses) CreateTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error) {
	rsp, err := c.CreateTCPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckBackendParams, body CreateTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckBackendResponse, error) {
	rsp, err := c.CreateTCPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckBackendResponse(rsp)
}

// ReplaceTCPCheckBackendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPCheckBackendResponse
func (c *ClientWithResponses) ReplaceTCPCheckBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceTCPCheckBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPCheckBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckBackendParams, body ReplaceTCPCheckBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckBackendResponse, error) {
	rsp, err := c.ReplaceTCPCheckBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckBackendResponse(rsp)
}

// GetAllTCPRequestRuleBackendWithResponse request returning *GetAllTCPRequestRuleBackendResponse
func (c *ClientWithResponses) GetAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleBackendResponse, error) {
	rsp, err := c.GetAllTCPRequestRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPRequestRuleBackendResponse(rsp)
}

// ReplaceAllTCPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleBackendParams, body ReplaceAllTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleBackendResponse(rsp)
}

// DeleteTCPRequestRuleBackendWithResponse request returning *DeleteTCPRequestRuleBackendResponse
func (c *ClientWithResponses) DeleteTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleBackendResponse, error) {
	rsp, err := c.DeleteTCPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPRequestRuleBackendResponse(rsp)
}

// GetTCPRequestRuleBackendWithResponse request returning *GetTCPRequestRuleBackendResponse
func (c *ClientWithResponses) GetTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleBackendResponse, error) {
	rsp, err := c.GetTCPRequestRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPRequestRuleBackendResponse(rsp)
}

// CreateTCPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateTCPRequestRuleBackendResponse
func (c *ClientWithResponses) CreateTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleBackendParams, body CreateTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleBackendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleBackendResponse(rsp)
}

// ReplaceTCPRequestRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPRequestRuleBackendResponse
func (c *ClientWithResponses) ReplaceTCPRequestRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPRequestRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleBackendParams, body ReplaceTCPRequestRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleBackendResponse(rsp)
}

// GetAllTCPResponseRuleBackendWithResponse request returning *GetAllTCPResponseRuleBackendResponse
func (c *ClientWithResponses) GetAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllTCPResponseRuleBackendResponse, error) {
	rsp, err := c.GetAllTCPResponseRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPResponseRuleBackendResponse(rsp)
}

// ReplaceAllTCPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPResponseRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPResponseRuleBackendParams, body ReplaceAllTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllTCPResponseRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPResponseRuleBackendResponse(rsp)
}

// DeleteTCPResponseRuleBackendWithResponse request returning *DeleteTCPResponseRuleBackendResponse
func (c *ClientWithResponses) DeleteTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteTCPResponseRuleBackendResponse, error) {
	rsp, err := c.DeleteTCPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPResponseRuleBackendResponse(rsp)
}

// GetTCPResponseRuleBackendWithResponse request returning *GetTCPResponseRuleBackendResponse
func (c *ClientWithResponses) GetTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPResponseRuleBackendParams, reqEditors ...RequestEditorFn) (*GetTCPResponseRuleBackendResponse, error) {
	rsp, err := c.GetTCPResponseRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPResponseRuleBackendResponse(rsp)
}

// CreateTCPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateTCPResponseRuleBackendResponse
func (c *ClientWithResponses) CreateTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateTCPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPResponseRuleBackendParams, body CreateTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPResponseRuleBackendResponse, error) {
	rsp, err := c.CreateTCPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPResponseRuleBackendResponse(rsp)
}

// ReplaceTCPResponseRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPResponseRuleBackendResponse
func (c *ClientWithResponses) ReplaceTCPResponseRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPResponseRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPResponseRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPResponseRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPResponseRuleBackendParams, body ReplaceTCPResponseRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPResponseRuleBackendResponse, error) {
	rsp, err := c.ReplaceTCPResponseRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPResponseRuleBackendResponse(rsp)
}

// GetAllWafBodyRuleBackendWithResponse request returning *GetAllWafBodyRuleBackendResponse
func (c *ClientWithResponses) GetAllWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *GetAllWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*GetAllWafBodyRuleBackendResponse, error) {
	rsp, err := c.GetAllWafBodyRuleBackend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllWafBodyRuleBackendResponse(rsp)
}

// ReplaceAllWafBodyRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceAllWafBodyRuleBackendResponse
func (c *ClientWithResponses) ReplaceAllWafBodyRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllWafBodyRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllWafBodyRuleBackendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllWafBodyRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleBackendParams, body ReplaceAllWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllWafBodyRuleBackendResponse, error) {
	rsp, err := c.ReplaceAllWafBodyRuleBackend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllWafBodyRuleBackendResponse(rsp)
}

// DeleteWafBodyRuleBackendWithResponse request returning *DeleteWafBodyRuleBackendResponse
func (c *ClientWithResponses) DeleteWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*DeleteWafBodyRuleBackendResponse, error) {
	rsp, err := c.DeleteWafBodyRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWafBodyRuleBackendResponse(rsp)
}

// GetWafBodyRuleBackendWithResponse request returning *GetWafBodyRuleBackendResponse
func (c *ClientWithResponses) GetWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetWafBodyRuleBackendParams, reqEditors ...RequestEditorFn) (*GetWafBodyRuleBackendResponse, error) {
	rsp, err := c.GetWafBodyRuleBackend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWafBodyRuleBackendResponse(rsp)
}

// CreateWafBodyRuleBackendWithBodyWithResponse request with arbitrary body returning *CreateWafBodyRuleBackendResponse
func (c *ClientWithResponses) CreateWafBodyRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWafBodyRuleBackendResponse, error) {
	rsp, err := c.CreateWafBodyRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWafBodyRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) CreateWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleBackendParams, body CreateWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWafBodyRuleBackendResponse, error) {
	rsp, err := c.CreateWafBodyRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWafBodyRuleBackendResponse(rsp)
}

// ReplaceWafBodyRuleBackendWithBodyWithResponse request with arbitrary body returning *ReplaceWafBodyRuleBackendResponse
func (c *ClientWithResponses) ReplaceWafBodyRuleBackendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceWafBodyRuleBackendResponse, error) {
	rsp, err := c.ReplaceWafBodyRuleBackendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceWafBodyRuleBackendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceWafBodyRuleBackendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleBackendParams, body ReplaceWafBodyRuleBackendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceWafBodyRuleBackendResponse, error) {
	rsp, err := c.ReplaceWafBodyRuleBackend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceWafBodyRuleBackendResponse(rsp)
}

// GetBotmgmtProfilesWithResponse request returning *GetBotmgmtProfilesResponse
func (c *ClientWithResponses) GetBotmgmtProfilesWithResponse(ctx context.Context, params *GetBotmgmtProfilesParams, reqEditors ...RequestEditorFn) (*GetBotmgmtProfilesResponse, error) {
	rsp, err := c.GetBotmgmtProfiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBotmgmtProfilesResponse(rsp)
}

// CreateBotmgmtProfileWithBodyWithResponse request with arbitrary body returning *CreateBotmgmtProfileResponse
func (c *ClientWithResponses) CreateBotmgmtProfileWithBodyWithResponse(ctx context.Context, params *CreateBotmgmtProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBotmgmtProfileResponse, error) {
	rsp, err := c.CreateBotmgmtProfileWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBotmgmtProfileResponse(rsp)
}

func (c *ClientWithResponses) CreateBotmgmtProfileWithResponse(ctx context.Context, params *CreateBotmgmtProfileParams, body CreateBotmgmtProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBotmgmtProfileResponse, error) {
	rsp, err := c.CreateBotmgmtProfile(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBotmgmtProfileResponse(rsp)
}

// DeleteBotmgmtProfileWithResponse request returning *DeleteBotmgmtProfileResponse
func (c *ClientWithResponses) DeleteBotmgmtProfileWithResponse(ctx context.Context, name string, params *DeleteBotmgmtProfileParams, reqEditors ...RequestEditorFn) (*DeleteBotmgmtProfileResponse, error) {
	rsp, err := c.DeleteBotmgmtProfile(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBotmgmtProfileResponse(rsp)
}

// GetBotmgmtProfileWithResponse request returning *GetBotmgmtProfileResponse
func (c *ClientWithResponses) GetBotmgmtProfileWithResponse(ctx context.Context, name string, params *GetBotmgmtProfileParams, reqEditors ...RequestEditorFn) (*GetBotmgmtProfileResponse, error) {
	rsp, err := c.GetBotmgmtProfile(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBotmgmtProfileResponse(rsp)
}

// EditBotmgmtProfileWithBodyWithResponse request with arbitrary body returning *EditBotmgmtProfileResponse
func (c *ClientWithResponses) EditBotmgmtProfileWithBodyWithResponse(ctx context.Context, name string, params *EditBotmgmtProfileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditBotmgmtProfileResponse, error) {
	rsp, err := c.EditBotmgmtProfileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditBotmgmtProfileResponse(rsp)
}

func (c *ClientWithResponses) EditBotmgmtProfileWithResponse(ctx context.Context, name string, params *EditBotmgmtProfileParams, body EditBotmgmtProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*EditBotmgmtProfileResponse, error) {
	rsp, err := c.EditBotmgmtProfile(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditBotmgmtProfileResponse(rsp)
}

// GetCachesWithResponse request returning *GetCachesResponse
func (c *ClientWithResponses) GetCachesWithResponse(ctx context.Context, params *GetCachesParams, reqEditors ...RequestEditorFn) (*GetCachesResponse, error) {
	rsp, err := c.GetCaches(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCachesResponse(rsp)
}

// CreateCacheWithBodyWithResponse request with arbitrary body returning *CreateCacheResponse
func (c *ClientWithResponses) CreateCacheWithBodyWithResponse(ctx context.Context, params *CreateCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error) {
	rsp, err := c.CreateCacheWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCacheResponse(rsp)
}

func (c *ClientWithResponses) CreateCacheWithResponse(ctx context.Context, params *CreateCacheParams, body CreateCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCacheResponse, error) {
	rsp, err := c.CreateCache(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCacheResponse(rsp)
}

// DeleteCacheWithResponse request returning *DeleteCacheResponse
func (c *ClientWithResponses) DeleteCacheWithResponse(ctx context.Context, name string, params *DeleteCacheParams, reqEditors ...RequestEditorFn) (*DeleteCacheResponse, error) {
	rsp, err := c.DeleteCache(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCacheResponse(rsp)
}

// GetCacheWithResponse request returning *GetCacheResponse
func (c *ClientWithResponses) GetCacheWithResponse(ctx context.Context, name string, params *GetCacheParams, reqEditors ...RequestEditorFn) (*GetCacheResponse, error) {
	rsp, err := c.GetCache(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCacheResponse(rsp)
}

// ReplaceCacheWithBodyWithResponse request with arbitrary body returning *ReplaceCacheResponse
func (c *ClientWithResponses) ReplaceCacheWithBodyWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error) {
	rsp, err := c.ReplaceCacheWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCacheResponse(rsp)
}

func (c *ClientWithResponses) ReplaceCacheWithResponse(ctx context.Context, name string, params *ReplaceCacheParams, body ReplaceCacheJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCacheResponse, error) {
	rsp, err := c.ReplaceCache(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCacheResponse(rsp)
}

// GetCaptchasWithResponse request returning *GetCaptchasResponse
func (c *ClientWithResponses) GetCaptchasWithResponse(ctx context.Context, params *GetCaptchasParams, reqEditors ...RequestEditorFn) (*GetCaptchasResponse, error) {
	rsp, err := c.GetCaptchas(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptchasResponse(rsp)
}

// CreateCaptchaWithBodyWithResponse request with arbitrary body returning *CreateCaptchaResponse
func (c *ClientWithResponses) CreateCaptchaWithBodyWithResponse(ctx context.Context, params *CreateCaptchaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCaptchaResponse, error) {
	rsp, err := c.CreateCaptchaWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCaptchaResponse(rsp)
}

func (c *ClientWithResponses) CreateCaptchaWithResponse(ctx context.Context, params *CreateCaptchaParams, body CreateCaptchaJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCaptchaResponse, error) {
	rsp, err := c.CreateCaptcha(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCaptchaResponse(rsp)
}

// DeleteCaptchaWithResponse request returning *DeleteCaptchaResponse
func (c *ClientWithResponses) DeleteCaptchaWithResponse(ctx context.Context, name string, params *DeleteCaptchaParams, reqEditors ...RequestEditorFn) (*DeleteCaptchaResponse, error) {
	rsp, err := c.DeleteCaptcha(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCaptchaResponse(rsp)
}

// GetCaptchaWithResponse request returning *GetCaptchaResponse
func (c *ClientWithResponses) GetCaptchaWithResponse(ctx context.Context, name string, params *GetCaptchaParams, reqEditors ...RequestEditorFn) (*GetCaptchaResponse, error) {
	rsp, err := c.GetCaptcha(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptchaResponse(rsp)
}

// EditCaptchaWithBodyWithResponse request with arbitrary body returning *EditCaptchaResponse
func (c *ClientWithResponses) EditCaptchaWithBodyWithResponse(ctx context.Context, name string, params *EditCaptchaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCaptchaResponse, error) {
	rsp, err := c.EditCaptchaWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCaptchaResponse(rsp)
}

func (c *ClientWithResponses) EditCaptchaWithResponse(ctx context.Context, name string, params *EditCaptchaParams, body EditCaptchaJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCaptchaResponse, error) {
	rsp, err := c.EditCaptcha(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCaptchaResponse(rsp)
}

// GetClusterConfigurationVersionWithResponse request returning *GetClusterConfigurationVersionResponse
func (c *ClientWithResponses) GetClusterConfigurationVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetClusterConfigurationVersionResponse, error) {
	rsp, err := c.GetClusterConfigurationVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterConfigurationVersionResponse(rsp)
}

// GetCrtLoadsWithResponse request returning *GetCrtLoadsResponse
func (c *ClientWithResponses) GetCrtLoadsWithResponse(ctx context.Context, params *GetCrtLoadsParams, reqEditors ...RequestEditorFn) (*GetCrtLoadsResponse, error) {
	rsp, err := c.GetCrtLoads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtLoadsResponse(rsp)
}

// CreateCrtLoadWithBodyWithResponse request with arbitrary body returning *CreateCrtLoadResponse
func (c *ClientWithResponses) CreateCrtLoadWithBodyWithResponse(ctx context.Context, params *CreateCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error) {
	rsp, err := c.CreateCrtLoadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtLoadResponse(rsp)
}

func (c *ClientWithResponses) CreateCrtLoadWithResponse(ctx context.Context, params *CreateCrtLoadParams, body CreateCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtLoadResponse, error) {
	rsp, err := c.CreateCrtLoad(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtLoadResponse(rsp)
}

// DeleteCrtLoadWithResponse request returning *DeleteCrtLoadResponse
func (c *ClientWithResponses) DeleteCrtLoadWithResponse(ctx context.Context, certificate string, params *DeleteCrtLoadParams, reqEditors ...RequestEditorFn) (*DeleteCrtLoadResponse, error) {
	rsp, err := c.DeleteCrtLoad(ctx, certificate, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCrtLoadResponse(rsp)
}

// GetCrtLoadWithResponse request returning *GetCrtLoadResponse
func (c *ClientWithResponses) GetCrtLoadWithResponse(ctx context.Context, certificate string, params *GetCrtLoadParams, reqEditors ...RequestEditorFn) (*GetCrtLoadResponse, error) {
	rsp, err := c.GetCrtLoad(ctx, certificate, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtLoadResponse(rsp)
}

// ReplaceCrtLoadWithBodyWithResponse request with arbitrary body returning *ReplaceCrtLoadResponse
func (c *ClientWithResponses) ReplaceCrtLoadWithBodyWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error) {
	rsp, err := c.ReplaceCrtLoadWithBody(ctx, certificate, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCrtLoadResponse(rsp)
}

func (c *ClientWithResponses) ReplaceCrtLoadWithResponse(ctx context.Context, certificate string, params *ReplaceCrtLoadParams, body ReplaceCrtLoadJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceCrtLoadResponse, error) {
	rsp, err := c.ReplaceCrtLoad(ctx, certificate, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceCrtLoadResponse(rsp)
}

// GetCrtStoresWithResponse request returning *GetCrtStoresResponse
func (c *ClientWithResponses) GetCrtStoresWithResponse(ctx context.Context, params *GetCrtStoresParams, reqEditors ...RequestEditorFn) (*GetCrtStoresResponse, error) {
	rsp, err := c.GetCrtStores(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtStoresResponse(rsp)
}

// CreateCrtStoreWithBodyWithResponse request with arbitrary body returning *CreateCrtStoreResponse
func (c *ClientWithResponses) CreateCrtStoreWithBodyWithResponse(ctx context.Context, params *CreateCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error) {
	rsp, err := c.CreateCrtStoreWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtStoreResponse(rsp)
}

func (c *ClientWithResponses) CreateCrtStoreWithResponse(ctx context.Context, params *CreateCrtStoreParams, body CreateCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCrtStoreResponse, error) {
	rsp, err := c.CreateCrtStore(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCrtStoreResponse(rsp)
}

// DeleteCrtStoreWithResponse request returning *DeleteCrtStoreResponse
func (c *ClientWithResponses) DeleteCrtStoreWithResponse(ctx context.Context, name string, params *DeleteCrtStoreParams, reqEditors ...RequestEditorFn) (*DeleteCrtStoreResponse, error) {
	rsp, err := c.DeleteCrtStore(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCrtStoreResponse(rsp)
}

// GetCrtStoreWithResponse request returning *GetCrtStoreResponse
func (c *ClientWithResponses) GetCrtStoreWithResponse(ctx context.Context, name string, params *GetCrtStoreParams, reqEditors ...RequestEditorFn) (*GetCrtStoreResponse, error) {
	rsp, err := c.GetCrtStore(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCrtStoreResponse(rsp)
}

// EditCrtStoreWithBodyWithResponse request with arbitrary body returning *EditCrtStoreResponse
func (c *ClientWithResponses) EditCrtStoreWithBodyWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error) {
	rsp, err := c.EditCrtStoreWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCrtStoreResponse(rsp)
}

func (c *ClientWithResponses) EditCrtStoreWithResponse(ctx context.Context, name string, params *EditCrtStoreParams, body EditCrtStoreJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCrtStoreResponse, error) {
	rsp, err := c.EditCrtStore(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCrtStoreResponse(rsp)
}

// GetDefaultsSectionsWithResponse request returning *GetDefaultsSectionsResponse
func (c *ClientWithResponses) GetDefaultsSectionsWithResponse(ctx context.Context, params *GetDefaultsSectionsParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionsResponse, error) {
	rsp, err := c.GetDefaultsSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultsSectionsResponse(rsp)
}

// CreateDefaultsSectionWithBodyWithResponse request with arbitrary body returning *CreateDefaultsSectionResponse
func (c *ClientWithResponses) CreateDefaultsSectionWithBodyWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error) {
	rsp, err := c.CreateDefaultsSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDefaultsSectionResponse(rsp)
}

func (c *ClientWithResponses) CreateDefaultsSectionWithResponse(ctx context.Context, params *CreateDefaultsSectionParams, body CreateDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDefaultsSectionResponse, error) {
	rsp, err := c.CreateDefaultsSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDefaultsSectionResponse(rsp)
}

// DeleteDefaultsSectionWithResponse request returning *DeleteDefaultsSectionResponse
func (c *ClientWithResponses) DeleteDefaultsSectionWithResponse(ctx context.Context, name string, params *DeleteDefaultsSectionParams, reqEditors ...RequestEditorFn) (*DeleteDefaultsSectionResponse, error) {
	rsp, err := c.DeleteDefaultsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDefaultsSectionResponse(rsp)
}

// GetDefaultsSectionWithResponse request returning *GetDefaultsSectionResponse
func (c *ClientWithResponses) GetDefaultsSectionWithResponse(ctx context.Context, name string, params *GetDefaultsSectionParams, reqEditors ...RequestEditorFn) (*GetDefaultsSectionResponse, error) {
	rsp, err := c.GetDefaultsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultsSectionResponse(rsp)
}

// ReplaceDefaultsSectionWithBodyWithResponse request with arbitrary body returning *ReplaceDefaultsSectionResponse
func (c *ClientWithResponses) ReplaceDefaultsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error) {
	rsp, err := c.ReplaceDefaultsSectionWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDefaultsSectionResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDefaultsSectionWithResponse(ctx context.Context, name string, params *ReplaceDefaultsSectionParams, body ReplaceDefaultsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDefaultsSectionResponse, error) {
	rsp, err := c.ReplaceDefaultsSection(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDefaultsSectionResponse(rsp)
}

// GetAllHTTPCheckDefaultsWithResponse request returning *GetAllHTTPCheckDefaultsResponse
func (c *ClientWithResponses) GetAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPCheckDefaultsResponse, error) {
	rsp, err := c.GetAllHTTPCheckDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPCheckDefaultsResponse(rsp)
}

// ReplaceAllHTTPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceAllHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPCheckDefaultsParams, body ReplaceAllHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPCheckDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPCheckDefaultsResponse(rsp)
}

// DeleteHTTPCheckDefaultsWithResponse request returning *DeleteHTTPCheckDefaultsResponse
func (c *ClientWithResponses) DeleteHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPCheckDefaultsResponse, error) {
	rsp, err := c.DeleteHTTPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPCheckDefaultsResponse(rsp)
}

// GetHTTPCheckDefaultsWithResponse request returning *GetHTTPCheckDefaultsResponse
func (c *ClientWithResponses) GetHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPCheckDefaultsResponse, error) {
	rsp, err := c.GetHTTPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPCheckDefaultsResponse(rsp)
}

// CreateHTTPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *CreateHTTPCheckDefaultsResponse
func (c *ClientWithResponses) CreateHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error) {
	rsp, err := c.CreateHTTPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPCheckDefaultsParams, body CreateHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPCheckDefaultsResponse, error) {
	rsp, err := c.CreateHTTPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPCheckDefaultsResponse(rsp)
}

// ReplaceHTTPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceHTTPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPCheckDefaultsParams, body ReplaceHTTPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPCheckDefaultsResponse(rsp)
}

// GetAllHTTPErrorRuleDefaultsWithResponse request returning *GetAllHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) GetAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.GetAllHTTPErrorRuleDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPErrorRuleDefaultsResponse(rsp)
}

// ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleDefaultsParams, body ReplaceAllHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleDefaultsResponse(rsp)
}

// DeleteHTTPErrorRuleDefaultsWithResponse request returning *DeleteHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) DeleteHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.DeleteHTTPErrorRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorRuleDefaultsResponse(rsp)
}

// GetHTTPErrorRuleDefaultsWithResponse request returning *GetHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) GetHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleDefaultsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.GetHTTPErrorRuleDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorRuleDefaultsResponse(rsp)
}

// CreateHTTPErrorRuleDefaultsWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) CreateHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleDefaultsParams, body CreateHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleDefaultsResponse(rsp)
}

// ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorRuleDefaultsResponse
func (c *ClientWithResponses) ReplaceHTTPErrorRuleDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorRuleDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleDefaultsParams, body ReplaceHTTPErrorRuleDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleDefaultsResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleDefaultsResponse(rsp)
}

// GetAllLogTargetDefaultsWithResponse request returning *GetAllLogTargetDefaultsResponse
func (c *ClientWithResponses) GetAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetDefaultsResponse, error) {
	rsp, err := c.GetAllLogTargetDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetDefaultsResponse(rsp)
}

// ReplaceAllLogTargetDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetDefaultsResponse
func (c *ClientWithResponses) ReplaceAllLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceAllLogTargetDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetDefaultsParams, body ReplaceAllLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceAllLogTargetDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetDefaultsResponse(rsp)
}

// DeleteLogTargetDefaultsWithResponse request returning *DeleteLogTargetDefaultsResponse
func (c *ClientWithResponses) DeleteLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetDefaultsResponse, error) {
	rsp, err := c.DeleteLogTargetDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetDefaultsResponse(rsp)
}

// GetLogTargetDefaultsWithResponse request returning *GetLogTargetDefaultsResponse
func (c *ClientWithResponses) GetLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetDefaultsParams, reqEditors ...RequestEditorFn) (*GetLogTargetDefaultsResponse, error) {
	rsp, err := c.GetLogTargetDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetDefaultsResponse(rsp)
}

// CreateLogTargetDefaultsWithBodyWithResponse request with arbitrary body returning *CreateLogTargetDefaultsResponse
func (c *ClientWithResponses) CreateLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error) {
	rsp, err := c.CreateLogTargetDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetDefaultsParams, body CreateLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetDefaultsResponse, error) {
	rsp, err := c.CreateLogTargetDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetDefaultsResponse(rsp)
}

// ReplaceLogTargetDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetDefaultsResponse
func (c *ClientWithResponses) ReplaceLogTargetDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceLogTargetDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetDefaultsParams, body ReplaceLogTargetDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetDefaultsResponse, error) {
	rsp, err := c.ReplaceLogTargetDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetDefaultsResponse(rsp)
}

// GetAllTCPCheckDefaultsWithResponse request returning *GetAllTCPCheckDefaultsResponse
func (c *ClientWithResponses) GetAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetAllTCPCheckDefaultsResponse, error) {
	rsp, err := c.GetAllTCPCheckDefaults(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPCheckDefaultsResponse(rsp)
}

// ReplaceAllTCPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceAllTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckDefaultsWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPCheckDefaultsParams, body ReplaceAllTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceAllTCPCheckDefaults(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPCheckDefaultsResponse(rsp)
}

// DeleteTCPCheckDefaultsWithResponse request returning *DeleteTCPCheckDefaultsResponse
func (c *ClientWithResponses) DeleteTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*DeleteTCPCheckDefaultsResponse, error) {
	rsp, err := c.DeleteTCPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPCheckDefaultsResponse(rsp)
}

// GetTCPCheckDefaultsWithResponse request returning *GetTCPCheckDefaultsResponse
func (c *ClientWithResponses) GetTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPCheckDefaultsParams, reqEditors ...RequestEditorFn) (*GetTCPCheckDefaultsResponse, error) {
	rsp, err := c.GetTCPCheckDefaults(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPCheckDefaultsResponse(rsp)
}

// CreateTCPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *CreateTCPCheckDefaultsResponse
func (c *ClientWithResponses) CreateTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error) {
	rsp, err := c.CreateTCPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPCheckDefaultsParams, body CreateTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPCheckDefaultsResponse, error) {
	rsp, err := c.CreateTCPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPCheckDefaultsResponse(rsp)
}

// ReplaceTCPCheckDefaultsWithBodyWithResponse request with arbitrary body returning *ReplaceTCPCheckDefaultsResponse
func (c *ClientWithResponses) ReplaceTCPCheckDefaultsWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPCheckDefaultsWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckDefaultsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPCheckDefaultsWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPCheckDefaultsParams, body ReplaceTCPCheckDefaultsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPCheckDefaultsResponse, error) {
	rsp, err := c.ReplaceTCPCheckDefaults(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPCheckDefaultsResponse(rsp)
}

// GetDynamicUpdateRulesWithResponse request returning *GetDynamicUpdateRulesResponse
func (c *ClientWithResponses) GetDynamicUpdateRulesWithResponse(ctx context.Context, params *GetDynamicUpdateRulesParams, reqEditors ...RequestEditorFn) (*GetDynamicUpdateRulesResponse, error) {
	rsp, err := c.GetDynamicUpdateRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDynamicUpdateRulesResponse(rsp)
}

// ReplaceDynamicUpdateRulesWithBodyWithResponse request with arbitrary body returning *ReplaceDynamicUpdateRulesResponse
func (c *ClientWithResponses) ReplaceDynamicUpdateRulesWithBodyWithResponse(ctx context.Context, params *ReplaceDynamicUpdateRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDynamicUpdateRulesResponse, error) {
	rsp, err := c.ReplaceDynamicUpdateRulesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDynamicUpdateRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDynamicUpdateRulesWithResponse(ctx context.Context, params *ReplaceDynamicUpdateRulesParams, body ReplaceDynamicUpdateRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDynamicUpdateRulesResponse, error) {
	rsp, err := c.ReplaceDynamicUpdateRules(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDynamicUpdateRulesResponse(rsp)
}

// DeleteDynamicUpdateRuleWithResponse request returning *DeleteDynamicUpdateRuleResponse
func (c *ClientWithResponses) DeleteDynamicUpdateRuleWithResponse(ctx context.Context, index int, params *DeleteDynamicUpdateRuleParams, reqEditors ...RequestEditorFn) (*DeleteDynamicUpdateRuleResponse, error) {
	rsp, err := c.DeleteDynamicUpdateRule(ctx, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDynamicUpdateRuleResponse(rsp)
}

// GetDynamicUpdateRuleWithResponse request returning *GetDynamicUpdateRuleResponse
func (c *ClientWithResponses) GetDynamicUpdateRuleWithResponse(ctx context.Context, index int, params *GetDynamicUpdateRuleParams, reqEditors ...RequestEditorFn) (*GetDynamicUpdateRuleResponse, error) {
	rsp, err := c.GetDynamicUpdateRule(ctx, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDynamicUpdateRuleResponse(rsp)
}

// CreateDynamicUpdateRuleWithBodyWithResponse request with arbitrary body returning *CreateDynamicUpdateRuleResponse
func (c *ClientWithResponses) CreateDynamicUpdateRuleWithBodyWithResponse(ctx context.Context, index int, params *CreateDynamicUpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDynamicUpdateRuleResponse, error) {
	rsp, err := c.CreateDynamicUpdateRuleWithBody(ctx, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDynamicUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateDynamicUpdateRuleWithResponse(ctx context.Context, index int, params *CreateDynamicUpdateRuleParams, body CreateDynamicUpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDynamicUpdateRuleResponse, error) {
	rsp, err := c.CreateDynamicUpdateRule(ctx, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDynamicUpdateRuleResponse(rsp)
}

// ReplaceDynamicUpdateRuleWithBodyWithResponse request with arbitrary body returning *ReplaceDynamicUpdateRuleResponse
func (c *ClientWithResponses) ReplaceDynamicUpdateRuleWithBodyWithResponse(ctx context.Context, index int, params *ReplaceDynamicUpdateRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDynamicUpdateRuleResponse, error) {
	rsp, err := c.ReplaceDynamicUpdateRuleWithBody(ctx, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDynamicUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDynamicUpdateRuleWithResponse(ctx context.Context, index int, params *ReplaceDynamicUpdateRuleParams, body ReplaceDynamicUpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDynamicUpdateRuleResponse, error) {
	rsp, err := c.ReplaceDynamicUpdateRule(ctx, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDynamicUpdateRuleResponse(rsp)
}

// DeleteDynamicUpdateSectionWithResponse request returning *DeleteDynamicUpdateSectionResponse
func (c *ClientWithResponses) DeleteDynamicUpdateSectionWithResponse(ctx context.Context, params *DeleteDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*DeleteDynamicUpdateSectionResponse, error) {
	rsp, err := c.DeleteDynamicUpdateSection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDynamicUpdateSectionResponse(rsp)
}

// GetDynamicUpdateSectionWithResponse request returning *GetDynamicUpdateSectionResponse
func (c *ClientWithResponses) GetDynamicUpdateSectionWithResponse(ctx context.Context, params *GetDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*GetDynamicUpdateSectionResponse, error) {
	rsp, err := c.GetDynamicUpdateSection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDynamicUpdateSectionResponse(rsp)
}

// CreateDynamicUpdateSectionWithResponse request returning *CreateDynamicUpdateSectionResponse
func (c *ClientWithResponses) CreateDynamicUpdateSectionWithResponse(ctx context.Context, params *CreateDynamicUpdateSectionParams, reqEditors ...RequestEditorFn) (*CreateDynamicUpdateSectionResponse, error) {
	rsp, err := c.CreateDynamicUpdateSection(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDynamicUpdateSectionResponse(rsp)
}

// GetFCGIAppsWithResponse request returning *GetFCGIAppsResponse
func (c *ClientWithResponses) GetFCGIAppsWithResponse(ctx context.Context, params *GetFCGIAppsParams, reqEditors ...RequestEditorFn) (*GetFCGIAppsResponse, error) {
	rsp, err := c.GetFCGIApps(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFCGIAppsResponse(rsp)
}

// CreateFCGIAppWithBodyWithResponse request with arbitrary body returning *CreateFCGIAppResponse
func (c *ClientWithResponses) CreateFCGIAppWithBodyWithResponse(ctx context.Context, params *CreateFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error) {
	rsp, err := c.CreateFCGIAppWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) CreateFCGIAppWithResponse(ctx context.Context, params *CreateFCGIAppParams, body CreateFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFCGIAppResponse, error) {
	rsp, err := c.CreateFCGIApp(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFCGIAppResponse(rsp)
}

// DeleteFCGIAppWithResponse request returning *DeleteFCGIAppResponse
func (c *ClientWithResponses) DeleteFCGIAppWithResponse(ctx context.Context, name string, params *DeleteFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteFCGIAppResponse, error) {
	rsp, err := c.DeleteFCGIApp(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFCGIAppResponse(rsp)
}

// GetFCGIAppWithResponse request returning *GetFCGIAppResponse
func (c *ClientWithResponses) GetFCGIAppWithResponse(ctx context.Context, name string, params *GetFCGIAppParams, reqEditors ...RequestEditorFn) (*GetFCGIAppResponse, error) {
	rsp, err := c.GetFCGIApp(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFCGIAppResponse(rsp)
}

// ReplaceFCGIAppWithBodyWithResponse request with arbitrary body returning *ReplaceFCGIAppResponse
func (c *ClientWithResponses) ReplaceFCGIAppWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error) {
	rsp, err := c.ReplaceFCGIAppWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFCGIAppWithResponse(ctx context.Context, name string, params *ReplaceFCGIAppParams, body ReplaceFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFCGIAppResponse, error) {
	rsp, err := c.ReplaceFCGIApp(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFCGIAppResponse(rsp)
}

// GetAllAclFCGIAppWithResponse request returning *GetAllAclFCGIAppResponse
func (c *ClientWithResponses) GetAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAllAclFCGIAppResponse, error) {
	rsp, err := c.GetAllAclFCGIApp(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclFCGIAppResponse(rsp)
}

// ReplaceAllAclFCGIAppWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclFCGIAppResponse
func (c *ClientWithResponses) ReplaceAllAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAllAclFCGIAppWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFCGIAppParams, body ReplaceAllAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAllAclFCGIApp(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFCGIAppResponse(rsp)
}

// DeleteAclFCGIAppWithResponse request returning *DeleteAclFCGIAppResponse
func (c *ClientWithResponses) DeleteAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFCGIAppParams, reqEditors ...RequestEditorFn) (*DeleteAclFCGIAppResponse, error) {
	rsp, err := c.DeleteAclFCGIApp(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclFCGIAppResponse(rsp)
}

// GetAclFCGIAppWithResponse request returning *GetAclFCGIAppResponse
func (c *ClientWithResponses) GetAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFCGIAppParams, reqEditors ...RequestEditorFn) (*GetAclFCGIAppResponse, error) {
	rsp, err := c.GetAclFCGIApp(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclFCGIAppResponse(rsp)
}

// CreateAclFCGIAppWithBodyWithResponse request with arbitrary body returning *CreateAclFCGIAppResponse
func (c *ClientWithResponses) CreateAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error) {
	rsp, err := c.CreateAclFCGIAppWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) CreateAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFCGIAppParams, body CreateAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFCGIAppResponse, error) {
	rsp, err := c.CreateAclFCGIApp(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFCGIAppResponse(rsp)
}

// ReplaceAclFCGIAppWithBodyWithResponse request with arbitrary body returning *ReplaceAclFCGIAppResponse
func (c *ClientWithResponses) ReplaceAclFCGIAppWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAclFCGIAppWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFCGIAppResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclFCGIAppWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFCGIAppParams, body ReplaceAclFCGIAppJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFCGIAppResponse, error) {
	rsp, err := c.ReplaceAclFCGIApp(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFCGIAppResponse(rsp)
}

// GetFrontendsWithResponse request returning *GetFrontendsResponse
func (c *ClientWithResponses) GetFrontendsWithResponse(ctx context.Context, params *GetFrontendsParams, reqEditors ...RequestEditorFn) (*GetFrontendsResponse, error) {
	rsp, err := c.GetFrontends(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFrontendsResponse(rsp)
}

// CreateFrontendWithBodyWithResponse request with arbitrary body returning *CreateFrontendResponse
func (c *ClientWithResponses) CreateFrontendWithBodyWithResponse(ctx context.Context, params *CreateFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error) {
	rsp, err := c.CreateFrontendWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateFrontendWithResponse(ctx context.Context, params *CreateFrontendParams, body CreateFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFrontendResponse, error) {
	rsp, err := c.CreateFrontend(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFrontendResponse(rsp)
}

// DeleteFrontendWithResponse request returning *DeleteFrontendResponse
func (c *ClientWithResponses) DeleteFrontendWithResponse(ctx context.Context, name string, params *DeleteFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFrontendResponse, error) {
	rsp, err := c.DeleteFrontend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFrontendResponse(rsp)
}

// GetFrontendWithResponse request returning *GetFrontendResponse
func (c *ClientWithResponses) GetFrontendWithResponse(ctx context.Context, name string, params *GetFrontendParams, reqEditors ...RequestEditorFn) (*GetFrontendResponse, error) {
	rsp, err := c.GetFrontend(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFrontendResponse(rsp)
}

// ReplaceFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceFrontendResponse
func (c *ClientWithResponses) ReplaceFrontendWithBodyWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error) {
	rsp, err := c.ReplaceFrontendWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFrontendWithResponse(ctx context.Context, name string, params *ReplaceFrontendParams, body ReplaceFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFrontendResponse, error) {
	rsp, err := c.ReplaceFrontend(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFrontendResponse(rsp)
}

// GetAllAclFrontendWithResponse request returning *GetAllAclFrontendResponse
func (c *ClientWithResponses) GetAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAllAclFrontendResponse, error) {
	rsp, err := c.GetAllAclFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllAclFrontendResponse(rsp)
}

// ReplaceAllAclFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllAclFrontendResponse
func (c *ClientWithResponses) ReplaceAllAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error) {
	rsp, err := c.ReplaceAllAclFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllAclFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllAclFrontendParams, body ReplaceAllAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllAclFrontendResponse, error) {
	rsp, err := c.ReplaceAllAclFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllAclFrontendResponse(rsp)
}

// DeleteAclFrontendWithResponse request returning *DeleteAclFrontendResponse
func (c *ClientWithResponses) DeleteAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteAclFrontendParams, reqEditors ...RequestEditorFn) (*DeleteAclFrontendResponse, error) {
	rsp, err := c.DeleteAclFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAclFrontendResponse(rsp)
}

// GetAclFrontendWithResponse request returning *GetAclFrontendResponse
func (c *ClientWithResponses) GetAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetAclFrontendParams, reqEditors ...RequestEditorFn) (*GetAclFrontendResponse, error) {
	rsp, err := c.GetAclFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAclFrontendResponse(rsp)
}

// CreateAclFrontendWithBodyWithResponse request with arbitrary body returning *CreateAclFrontendResponse
func (c *ClientWithResponses) CreateAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error) {
	rsp, err := c.CreateAclFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateAclFrontendParams, body CreateAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAclFrontendResponse, error) {
	rsp, err := c.CreateAclFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAclFrontendResponse(rsp)
}

// ReplaceAclFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAclFrontendResponse
func (c *ClientWithResponses) ReplaceAclFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error) {
	rsp, err := c.ReplaceAclFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAclFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceAclFrontendParams, body ReplaceAclFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAclFrontendResponse, error) {
	rsp, err := c.ReplaceAclFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAclFrontendResponse(rsp)
}

// GetBackendSwitchingRulesWithResponse request returning *GetBackendSwitchingRulesResponse
func (c *ClientWithResponses) GetBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *GetBackendSwitchingRulesParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRulesResponse, error) {
	rsp, err := c.GetBackendSwitchingRules(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendSwitchingRulesResponse(rsp)
}

// ReplaceBackendSwitchingRulesWithBodyWithResponse request with arbitrary body returning *ReplaceBackendSwitchingRulesResponse
func (c *ClientWithResponses) ReplaceBackendSwitchingRulesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRulesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRulesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBackendSwitchingRulesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceBackendSwitchingRulesParams, body ReplaceBackendSwitchingRulesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRulesResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRules(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRulesResponse(rsp)
}

// DeleteBackendSwitchingRuleWithResponse request returning *DeleteBackendSwitchingRuleResponse
func (c *ClientWithResponses) DeleteBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*DeleteBackendSwitchingRuleResponse, error) {
	rsp, err := c.DeleteBackendSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBackendSwitchingRuleResponse(rsp)
}

// GetBackendSwitchingRuleWithResponse request returning *GetBackendSwitchingRuleResponse
func (c *ClientWithResponses) GetBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *GetBackendSwitchingRuleParams, reqEditors ...RequestEditorFn) (*GetBackendSwitchingRuleResponse, error) {
	rsp, err := c.GetBackendSwitchingRule(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackendSwitchingRuleResponse(rsp)
}

// CreateBackendSwitchingRuleWithBodyWithResponse request with arbitrary body returning *CreateBackendSwitchingRuleResponse
func (c *ClientWithResponses) CreateBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error) {
	rsp, err := c.CreateBackendSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateBackendSwitchingRuleParams, body CreateBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBackendSwitchingRuleResponse, error) {
	rsp, err := c.CreateBackendSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackendSwitchingRuleResponse(rsp)
}

// ReplaceBackendSwitchingRuleWithBodyWithResponse request with arbitrary body returning *ReplaceBackendSwitchingRuleResponse
func (c *ClientWithResponses) ReplaceBackendSwitchingRuleWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRuleWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRuleResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBackendSwitchingRuleWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceBackendSwitchingRuleParams, body ReplaceBackendSwitchingRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBackendSwitchingRuleResponse, error) {
	rsp, err := c.ReplaceBackendSwitchingRule(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBackendSwitchingRuleResponse(rsp)
}

// GetAllBindFrontendWithResponse request returning *GetAllBindFrontendResponse
func (c *ClientWithResponses) GetAllBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindFrontendParams, reqEditors ...RequestEditorFn) (*GetAllBindFrontendResponse, error) {
	rsp, err := c.GetAllBindFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBindFrontendResponse(rsp)
}

// CreateBindFrontendWithBodyWithResponse request with arbitrary body returning *CreateBindFrontendResponse
func (c *ClientWithResponses) CreateBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error) {
	rsp, err := c.CreateBindFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateBindFrontendWithResponse(ctx context.Context, parentName ParentName, params *CreateBindFrontendParams, body CreateBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindFrontendResponse, error) {
	rsp, err := c.CreateBindFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindFrontendResponse(rsp)
}

// DeleteBindFrontendWithResponse request returning *DeleteBindFrontendResponse
func (c *ClientWithResponses) DeleteBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindFrontendParams, reqEditors ...RequestEditorFn) (*DeleteBindFrontendResponse, error) {
	rsp, err := c.DeleteBindFrontend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBindFrontendResponse(rsp)
}

// GetBindFrontendWithResponse request returning *GetBindFrontendResponse
func (c *ClientWithResponses) GetBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindFrontendParams, reqEditors ...RequestEditorFn) (*GetBindFrontendResponse, error) {
	rsp, err := c.GetBindFrontend(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindFrontendResponse(rsp)
}

// ReplaceBindFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceBindFrontendResponse
func (c *ClientWithResponses) ReplaceBindFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error) {
	rsp, err := c.ReplaceBindFrontendWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBindFrontendWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindFrontendParams, body ReplaceBindFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindFrontendResponse, error) {
	rsp, err := c.ReplaceBindFrontend(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindFrontendResponse(rsp)
}

// GetDeclareCapturesWithResponse request returning *GetDeclareCapturesResponse
func (c *ClientWithResponses) GetDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *GetDeclareCapturesParams, reqEditors ...RequestEditorFn) (*GetDeclareCapturesResponse, error) {
	rsp, err := c.GetDeclareCaptures(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeclareCapturesResponse(rsp)
}

// ReplaceDeclareCapturesWithBodyWithResponse request with arbitrary body returning *ReplaceDeclareCapturesResponse
func (c *ClientWithResponses) ReplaceDeclareCapturesWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error) {
	rsp, err := c.ReplaceDeclareCapturesWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCapturesResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDeclareCapturesWithResponse(ctx context.Context, parentName ParentName, params *ReplaceDeclareCapturesParams, body ReplaceDeclareCapturesJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCapturesResponse, error) {
	rsp, err := c.ReplaceDeclareCaptures(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCapturesResponse(rsp)
}

// DeleteDeclareCaptureWithResponse request returning *DeleteDeclareCaptureResponse
func (c *ClientWithResponses) DeleteDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteDeclareCaptureParams, reqEditors ...RequestEditorFn) (*DeleteDeclareCaptureResponse, error) {
	rsp, err := c.DeleteDeclareCapture(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDeclareCaptureResponse(rsp)
}

// GetDeclareCaptureWithResponse request returning *GetDeclareCaptureResponse
func (c *ClientWithResponses) GetDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *GetDeclareCaptureParams, reqEditors ...RequestEditorFn) (*GetDeclareCaptureResponse, error) {
	rsp, err := c.GetDeclareCapture(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDeclareCaptureResponse(rsp)
}

// CreateDeclareCaptureWithBodyWithResponse request with arbitrary body returning *CreateDeclareCaptureResponse
func (c *ClientWithResponses) CreateDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error) {
	rsp, err := c.CreateDeclareCaptureWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeclareCaptureResponse(rsp)
}

func (c *ClientWithResponses) CreateDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateDeclareCaptureParams, body CreateDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDeclareCaptureResponse, error) {
	rsp, err := c.CreateDeclareCapture(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDeclareCaptureResponse(rsp)
}

// ReplaceDeclareCaptureWithBodyWithResponse request with arbitrary body returning *ReplaceDeclareCaptureResponse
func (c *ClientWithResponses) ReplaceDeclareCaptureWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error) {
	rsp, err := c.ReplaceDeclareCaptureWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCaptureResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDeclareCaptureWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceDeclareCaptureParams, body ReplaceDeclareCaptureJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDeclareCaptureResponse, error) {
	rsp, err := c.ReplaceDeclareCapture(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDeclareCaptureResponse(rsp)
}

// GetAllFilterFrontendWithResponse request returning *GetAllFilterFrontendResponse
func (c *ClientWithResponses) GetAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetAllFilterFrontendResponse, error) {
	rsp, err := c.GetAllFilterFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllFilterFrontendResponse(rsp)
}

// ReplaceAllFilterFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllFilterFrontendResponse
func (c *ClientWithResponses) ReplaceAllFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error) {
	rsp, err := c.ReplaceAllFilterFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllFilterFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllFilterFrontendParams, body ReplaceAllFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllFilterFrontendResponse, error) {
	rsp, err := c.ReplaceAllFilterFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllFilterFrontendResponse(rsp)
}

// DeleteFilterFrontendWithResponse request returning *DeleteFilterFrontendResponse
func (c *ClientWithResponses) DeleteFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteFilterFrontendParams, reqEditors ...RequestEditorFn) (*DeleteFilterFrontendResponse, error) {
	rsp, err := c.DeleteFilterFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFilterFrontendResponse(rsp)
}

// GetFilterFrontendWithResponse request returning *GetFilterFrontendResponse
func (c *ClientWithResponses) GetFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetFilterFrontendParams, reqEditors ...RequestEditorFn) (*GetFilterFrontendResponse, error) {
	rsp, err := c.GetFilterFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFilterFrontendResponse(rsp)
}

// CreateFilterFrontendWithBodyWithResponse request with arbitrary body returning *CreateFilterFrontendResponse
func (c *ClientWithResponses) CreateFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error) {
	rsp, err := c.CreateFilterFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateFilterFrontendParams, body CreateFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFilterFrontendResponse, error) {
	rsp, err := c.CreateFilterFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFilterFrontendResponse(rsp)
}

// ReplaceFilterFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceFilterFrontendResponse
func (c *ClientWithResponses) ReplaceFilterFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error) {
	rsp, err := c.ReplaceFilterFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceFilterFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceFilterFrontendParams, body ReplaceFilterFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceFilterFrontendResponse, error) {
	rsp, err := c.ReplaceFilterFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceFilterFrontendResponse(rsp)
}

// GetAllHTTPAfterResponseRuleFrontendWithResponse request returning *GetAllHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPAfterResponseRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPAfterResponseRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPAfterResponseRuleFrontendParams, body ReplaceAllHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPAfterResponseRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPAfterResponseRuleFrontendResponse(rsp)
}

// DeleteHTTPAfterResponseRuleFrontendWithResponse request returning *DeleteHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPAfterResponseRuleFrontendResponse(rsp)
}

// GetHTTPAfterResponseRuleFrontendWithResponse request returning *GetHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPAfterResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPAfterResponseRuleFrontendResponse(rsp)
}

// CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPAfterResponseRuleFrontendParams, body CreateHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPAfterResponseRuleFrontendResponse(rsp)
}

// ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPAfterResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPAfterResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPAfterResponseRuleFrontendParams, body ReplaceHTTPAfterResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPAfterResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPAfterResponseRuleFrontendResponse(rsp)
}

// GetAllHTTPErrorRuleFrontendWithResponse request returning *GetAllHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPErrorRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPErrorRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPErrorRuleFrontendParams, body ReplaceAllHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPErrorRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPErrorRuleFrontendResponse(rsp)
}

// DeleteHTTPErrorRuleFrontendWithResponse request returning *DeleteHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPErrorRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorRuleFrontendResponse(rsp)
}

// GetHTTPErrorRuleFrontendWithResponse request returning *GetHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPErrorRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPErrorRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorRuleFrontendResponse(rsp)
}

// CreateHTTPErrorRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPErrorRuleFrontendParams, body CreateHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPErrorRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorRuleFrontendResponse(rsp)
}

// ReplaceHTTPErrorRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPErrorRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPErrorRuleFrontendParams, body ReplaceHTTPErrorRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPErrorRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorRuleFrontendResponse(rsp)
}

// GetAllHTTPRequestRuleFrontendWithResponse request returning *GetAllHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPRequestRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPRequestRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPRequestRuleFrontendParams, body ReplaceAllHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPRequestRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPRequestRuleFrontendResponse(rsp)
}

// DeleteHTTPRequestRuleFrontendWithResponse request returning *DeleteHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPRequestRuleFrontendResponse(rsp)
}

// GetHTTPRequestRuleFrontendWithResponse request returning *GetHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPRequestRuleFrontendResponse(rsp)
}

// CreateHTTPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPRequestRuleFrontendParams, body CreateHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPRequestRuleFrontendResponse(rsp)
}

// ReplaceHTTPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPRequestRuleFrontendParams, body ReplaceHTTPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPRequestRuleFrontendResponse(rsp)
}

// GetAllHTTPResponseRuleFrontendWithResponse request returning *GetAllHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) GetAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.GetAllHTTPResponseRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllHTTPResponseRuleFrontendResponse(rsp)
}

// ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllHTTPResponseRuleFrontendParams, body ReplaceAllHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllHTTPResponseRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllHTTPResponseRuleFrontendResponse(rsp)
}

// DeleteHTTPResponseRuleFrontendWithResponse request returning *DeleteHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) DeleteHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.DeleteHTTPResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPResponseRuleFrontendResponse(rsp)
}

// GetHTTPResponseRuleFrontendWithResponse request returning *GetHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) GetHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetHTTPResponseRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.GetHTTPResponseRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPResponseRuleFrontendResponse(rsp)
}

// CreateHTTPResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) CreateHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateHTTPResponseRuleFrontendParams, body CreateHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.CreateHTTPResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPResponseRuleFrontendResponse(rsp)
}

// ReplaceHTTPResponseRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPResponseRuleFrontendResponse
func (c *ClientWithResponses) ReplaceHTTPResponseRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPResponseRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceHTTPResponseRuleFrontendParams, body ReplaceHTTPResponseRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPResponseRuleFrontendResponse, error) {
	rsp, err := c.ReplaceHTTPResponseRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPResponseRuleFrontendResponse(rsp)
}

// GetAllLogTargetFrontendWithResponse request returning *GetAllLogTargetFrontendResponse
func (c *ClientWithResponses) GetAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetFrontendResponse, error) {
	rsp, err := c.GetAllLogTargetFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetFrontendResponse(rsp)
}

// ReplaceAllLogTargetFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetFrontendResponse
func (c *ClientWithResponses) ReplaceAllLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetFrontendParams, body ReplaceAllLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceAllLogTargetFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetFrontendResponse(rsp)
}

// DeleteLogTargetFrontendWithResponse request returning *DeleteLogTargetFrontendResponse
func (c *ClientWithResponses) DeleteLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetFrontendResponse, error) {
	rsp, err := c.DeleteLogTargetFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetFrontendResponse(rsp)
}

// GetLogTargetFrontendWithResponse request returning *GetLogTargetFrontendResponse
func (c *ClientWithResponses) GetLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetFrontendParams, reqEditors ...RequestEditorFn) (*GetLogTargetFrontendResponse, error) {
	rsp, err := c.GetLogTargetFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetFrontendResponse(rsp)
}

// CreateLogTargetFrontendWithBodyWithResponse request with arbitrary body returning *CreateLogTargetFrontendResponse
func (c *ClientWithResponses) CreateLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error) {
	rsp, err := c.CreateLogTargetFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetFrontendParams, body CreateLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetFrontendResponse, error) {
	rsp, err := c.CreateLogTargetFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetFrontendResponse(rsp)
}

// ReplaceLogTargetFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetFrontendResponse
func (c *ClientWithResponses) ReplaceLogTargetFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceLogTargetFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetFrontendParams, body ReplaceLogTargetFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetFrontendResponse, error) {
	rsp, err := c.ReplaceLogTargetFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetFrontendResponse(rsp)
}

// GetAllTCPRequestRuleFrontendWithResponse request returning *GetAllTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetAllTCPRequestRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllTCPRequestRuleFrontendResponse(rsp)
}

// ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllTCPRequestRuleFrontendParams, body ReplaceAllTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllTCPRequestRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllTCPRequestRuleFrontendResponse(rsp)
}

// DeleteTCPRequestRuleFrontendWithResponse request returning *DeleteTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) DeleteTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.DeleteTCPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTCPRequestRuleFrontendResponse(rsp)
}

// GetTCPRequestRuleFrontendWithResponse request returning *GetTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) GetTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetTCPRequestRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.GetTCPRequestRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTCPRequestRuleFrontendResponse(rsp)
}

// CreateTCPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) CreateTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateTCPRequestRuleFrontendParams, body CreateTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.CreateTCPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTCPRequestRuleFrontendResponse(rsp)
}

// ReplaceTCPRequestRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceTCPRequestRuleFrontendResponse
func (c *ClientWithResponses) ReplaceTCPRequestRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTCPRequestRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceTCPRequestRuleFrontendParams, body ReplaceTCPRequestRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTCPRequestRuleFrontendResponse, error) {
	rsp, err := c.ReplaceTCPRequestRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTCPRequestRuleFrontendResponse(rsp)
}

// GetAllWafBodyRuleFrontendWithResponse request returning *GetAllWafBodyRuleFrontendResponse
func (c *ClientWithResponses) GetAllWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *GetAllWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetAllWafBodyRuleFrontendResponse, error) {
	rsp, err := c.GetAllWafBodyRuleFrontend(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllWafBodyRuleFrontendResponse(rsp)
}

// ReplaceAllWafBodyRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceAllWafBodyRuleFrontendResponse
func (c *ClientWithResponses) ReplaceAllWafBodyRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllWafBodyRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllWafBodyRuleFrontendWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllWafBodyRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllWafBodyRuleFrontendParams, body ReplaceAllWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllWafBodyRuleFrontendResponse, error) {
	rsp, err := c.ReplaceAllWafBodyRuleFrontend(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllWafBodyRuleFrontendResponse(rsp)
}

// DeleteWafBodyRuleFrontendWithResponse request returning *DeleteWafBodyRuleFrontendResponse
func (c *ClientWithResponses) DeleteWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*DeleteWafBodyRuleFrontendResponse, error) {
	rsp, err := c.DeleteWafBodyRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWafBodyRuleFrontendResponse(rsp)
}

// GetWafBodyRuleFrontendWithResponse request returning *GetWafBodyRuleFrontendResponse
func (c *ClientWithResponses) GetWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *GetWafBodyRuleFrontendParams, reqEditors ...RequestEditorFn) (*GetWafBodyRuleFrontendResponse, error) {
	rsp, err := c.GetWafBodyRuleFrontend(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWafBodyRuleFrontendResponse(rsp)
}

// CreateWafBodyRuleFrontendWithBodyWithResponse request with arbitrary body returning *CreateWafBodyRuleFrontendResponse
func (c *ClientWithResponses) CreateWafBodyRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWafBodyRuleFrontendResponse, error) {
	rsp, err := c.CreateWafBodyRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWafBodyRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) CreateWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateWafBodyRuleFrontendParams, body CreateWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWafBodyRuleFrontendResponse, error) {
	rsp, err := c.CreateWafBodyRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWafBodyRuleFrontendResponse(rsp)
}

// ReplaceWafBodyRuleFrontendWithBodyWithResponse request with arbitrary body returning *ReplaceWafBodyRuleFrontendResponse
func (c *ClientWithResponses) ReplaceWafBodyRuleFrontendWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceWafBodyRuleFrontendResponse, error) {
	rsp, err := c.ReplaceWafBodyRuleFrontendWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceWafBodyRuleFrontendResponse(rsp)
}

func (c *ClientWithResponses) ReplaceWafBodyRuleFrontendWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceWafBodyRuleFrontendParams, body ReplaceWafBodyRuleFrontendJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceWafBodyRuleFrontendResponse, error) {
	rsp, err := c.ReplaceWafBodyRuleFrontend(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceWafBodyRuleFrontendResponse(rsp)
}

// GetGlobalWithResponse request returning *GetGlobalResponse
func (c *ClientWithResponses) GetGlobalWithResponse(ctx context.Context, params *GetGlobalParams, reqEditors ...RequestEditorFn) (*GetGlobalResponse, error) {
	rsp, err := c.GetGlobal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalResponse(rsp)
}

// ReplaceGlobalWithBodyWithResponse request with arbitrary body returning *ReplaceGlobalResponse
func (c *ClientWithResponses) ReplaceGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error) {
	rsp, err := c.ReplaceGlobalWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGlobalResponse(rsp)
}

func (c *ClientWithResponses) ReplaceGlobalWithResponse(ctx context.Context, params *ReplaceGlobalParams, body ReplaceGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGlobalResponse, error) {
	rsp, err := c.ReplaceGlobal(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGlobalResponse(rsp)
}

// GetAllLogTargetGlobalWithResponse request returning *GetAllLogTargetGlobalResponse
func (c *ClientWithResponses) GetAllLogTargetGlobalWithResponse(ctx context.Context, params *GetAllLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetGlobalResponse, error) {
	rsp, err := c.GetAllLogTargetGlobal(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetGlobalResponse(rsp)
}

// ReplaceAllLogTargetGlobalWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetGlobalResponse
func (c *ClientWithResponses) ReplaceAllLogTargetGlobalWithBodyWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceAllLogTargetGlobalWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetGlobalResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetGlobalWithResponse(ctx context.Context, params *ReplaceAllLogTargetGlobalParams, body ReplaceAllLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceAllLogTargetGlobal(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetGlobalResponse(rsp)
}

// DeleteLogTargetGlobalWithResponse request returning *DeleteLogTargetGlobalResponse
func (c *ClientWithResponses) DeleteLogTargetGlobalWithResponse(ctx context.Context, index int, params *DeleteLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetGlobalResponse, error) {
	rsp, err := c.DeleteLogTargetGlobal(ctx, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetGlobalResponse(rsp)
}

// GetLogTargetGlobalWithResponse request returning *GetLogTargetGlobalResponse
func (c *ClientWithResponses) GetLogTargetGlobalWithResponse(ctx context.Context, index int, params *GetLogTargetGlobalParams, reqEditors ...RequestEditorFn) (*GetLogTargetGlobalResponse, error) {
	rsp, err := c.GetLogTargetGlobal(ctx, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetGlobalResponse(rsp)
}

// CreateLogTargetGlobalWithBodyWithResponse request with arbitrary body returning *CreateLogTargetGlobalResponse
func (c *ClientWithResponses) CreateLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error) {
	rsp, err := c.CreateLogTargetGlobalWithBody(ctx, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetGlobalResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetGlobalWithResponse(ctx context.Context, index int, params *CreateLogTargetGlobalParams, body CreateLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetGlobalResponse, error) {
	rsp, err := c.CreateLogTargetGlobal(ctx, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetGlobalResponse(rsp)
}

// ReplaceLogTargetGlobalWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetGlobalResponse
func (c *ClientWithResponses) ReplaceLogTargetGlobalWithBodyWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceLogTargetGlobalWithBody(ctx, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetGlobalResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetGlobalWithResponse(ctx context.Context, index int, params *ReplaceLogTargetGlobalParams, body ReplaceLogTargetGlobalJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetGlobalResponse, error) {
	rsp, err := c.ReplaceLogTargetGlobal(ctx, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetGlobalResponse(rsp)
}

// GetGroupsWithResponse request returning *GetGroupsResponse
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, params *GetGroupsParams, reqEditors ...RequestEditorFn) (*GetGroupsResponse, error) {
	rsp, err := c.GetGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupsResponse(rsp)
}

// CreateGroupWithBodyWithResponse request with arbitrary body returning *CreateGroupResponse
func (c *ClientWithResponses) CreateGroupWithBodyWithResponse(ctx context.Context, params *CreateGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateGroupWithResponse(ctx context.Context, params *CreateGroupParams, body CreateGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupResponse, error) {
	rsp, err := c.CreateGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupResponse(rsp)
}

// DeleteGroupWithResponse request returning *DeleteGroupResponse
func (c *ClientWithResponses) DeleteGroupWithResponse(ctx context.Context, name string, params *DeleteGroupParams, reqEditors ...RequestEditorFn) (*DeleteGroupResponse, error) {
	rsp, err := c.DeleteGroup(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupResponse(rsp)
}

// GetGroupWithResponse request returning *GetGroupResponse
func (c *ClientWithResponses) GetGroupWithResponse(ctx context.Context, name string, params *GetGroupParams, reqEditors ...RequestEditorFn) (*GetGroupResponse, error) {
	rsp, err := c.GetGroup(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupResponse(rsp)
}

// ReplaceGroupWithBodyWithResponse request with arbitrary body returning *ReplaceGroupResponse
func (c *ClientWithResponses) ReplaceGroupWithBodyWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error) {
	rsp, err := c.ReplaceGroupWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGroupResponse(rsp)
}

func (c *ClientWithResponses) ReplaceGroupWithResponse(ctx context.Context, name string, params *ReplaceGroupParams, body ReplaceGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGroupResponse, error) {
	rsp, err := c.ReplaceGroup(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGroupResponse(rsp)
}

// GetHTTPErrorsSectionsWithResponse request returning *GetHTTPErrorsSectionsResponse
func (c *ClientWithResponses) GetHTTPErrorsSectionsWithResponse(ctx context.Context, params *GetHTTPErrorsSectionsParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionsResponse, error) {
	rsp, err := c.GetHTTPErrorsSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorsSectionsResponse(rsp)
}

// CreateHTTPErrorsSectionWithBodyWithResponse request with arbitrary body returning *CreateHTTPErrorsSectionResponse
func (c *ClientWithResponses) CreateHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error) {
	rsp, err := c.CreateHTTPErrorsSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorsSectionResponse(rsp)
}

func (c *ClientWithResponses) CreateHTTPErrorsSectionWithResponse(ctx context.Context, params *CreateHTTPErrorsSectionParams, body CreateHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateHTTPErrorsSectionResponse, error) {
	rsp, err := c.CreateHTTPErrorsSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateHTTPErrorsSectionResponse(rsp)
}

// DeleteHTTPErrorsSectionWithResponse request returning *DeleteHTTPErrorsSectionResponse
func (c *ClientWithResponses) DeleteHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *DeleteHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*DeleteHTTPErrorsSectionResponse, error) {
	rsp, err := c.DeleteHTTPErrorsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteHTTPErrorsSectionResponse(rsp)
}

// GetHTTPErrorsSectionWithResponse request returning *GetHTTPErrorsSectionResponse
func (c *ClientWithResponses) GetHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *GetHTTPErrorsSectionParams, reqEditors ...RequestEditorFn) (*GetHTTPErrorsSectionResponse, error) {
	rsp, err := c.GetHTTPErrorsSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHTTPErrorsSectionResponse(rsp)
}

// ReplaceHTTPErrorsSectionWithBodyWithResponse request with arbitrary body returning *ReplaceHTTPErrorsSectionResponse
func (c *ClientWithResponses) ReplaceHTTPErrorsSectionWithBodyWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error) {
	rsp, err := c.ReplaceHTTPErrorsSectionWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorsSectionResponse(rsp)
}

func (c *ClientWithResponses) ReplaceHTTPErrorsSectionWithResponse(ctx context.Context, name string, params *ReplaceHTTPErrorsSectionParams, body ReplaceHTTPErrorsSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceHTTPErrorsSectionResponse, error) {
	rsp, err := c.ReplaceHTTPErrorsSection(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceHTTPErrorsSectionResponse(rsp)
}

// GetLogForwardsWithResponse request returning *GetLogForwardsResponse
func (c *ClientWithResponses) GetLogForwardsWithResponse(ctx context.Context, params *GetLogForwardsParams, reqEditors ...RequestEditorFn) (*GetLogForwardsResponse, error) {
	rsp, err := c.GetLogForwards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogForwardsResponse(rsp)
}

// CreateLogForwardWithBodyWithResponse request with arbitrary body returning *CreateLogForwardResponse
func (c *ClientWithResponses) CreateLogForwardWithBodyWithResponse(ctx context.Context, params *CreateLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error) {
	rsp, err := c.CreateLogForwardWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateLogForwardWithResponse(ctx context.Context, params *CreateLogForwardParams, body CreateLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogForwardResponse, error) {
	rsp, err := c.CreateLogForward(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogForwardResponse(rsp)
}

// DeleteLogForwardWithResponse request returning *DeleteLogForwardResponse
func (c *ClientWithResponses) DeleteLogForwardWithResponse(ctx context.Context, name string, params *DeleteLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogForwardResponse, error) {
	rsp, err := c.DeleteLogForward(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogForwardResponse(rsp)
}

// GetLogForwardWithResponse request returning *GetLogForwardResponse
func (c *ClientWithResponses) GetLogForwardWithResponse(ctx context.Context, name string, params *GetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogForwardResponse, error) {
	rsp, err := c.GetLogForward(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogForwardResponse(rsp)
}

// ReplaceLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceLogForwardResponse
func (c *ClientWithResponses) ReplaceLogForwardWithBodyWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error) {
	rsp, err := c.ReplaceLogForwardWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogForwardWithResponse(ctx context.Context, name string, params *ReplaceLogForwardParams, body ReplaceLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogForwardResponse, error) {
	rsp, err := c.ReplaceLogForward(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogForwardResponse(rsp)
}

// GetAllBindLogForwardWithResponse request returning *GetAllBindLogForwardResponse
func (c *ClientWithResponses) GetAllBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllBindLogForwardResponse, error) {
	rsp, err := c.GetAllBindLogForward(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBindLogForwardResponse(rsp)
}

// CreateBindLogForwardWithBodyWithResponse request with arbitrary body returning *CreateBindLogForwardResponse
func (c *ClientWithResponses) CreateBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error) {
	rsp, err := c.CreateBindLogForwardWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *CreateBindLogForwardParams, body CreateBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindLogForwardResponse, error) {
	rsp, err := c.CreateBindLogForward(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindLogForwardResponse(rsp)
}

// DeleteBindLogForwardWithResponse request returning *DeleteBindLogForwardResponse
func (c *ClientWithResponses) DeleteBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteBindLogForwardResponse, error) {
	rsp, err := c.DeleteBindLogForward(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBindLogForwardResponse(rsp)
}

// GetBindLogForwardWithResponse request returning *GetBindLogForwardResponse
func (c *ClientWithResponses) GetBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetBindLogForwardResponse, error) {
	rsp, err := c.GetBindLogForward(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindLogForwardResponse(rsp)
}

// ReplaceBindLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceBindLogForwardResponse
func (c *ClientWithResponses) ReplaceBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error) {
	rsp, err := c.ReplaceBindLogForwardWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindLogForwardParams, body ReplaceBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindLogForwardResponse, error) {
	rsp, err := c.ReplaceBindLogForward(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindLogForwardResponse(rsp)
}

// GetAllDgramBindLogForwardWithResponse request returning *GetAllDgramBindLogForwardResponse
func (c *ClientWithResponses) GetAllDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllDgramBindLogForwardResponse, error) {
	rsp, err := c.GetAllDgramBindLogForward(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDgramBindLogForwardResponse(rsp)
}

// CreateDgramBindLogForwardWithBodyWithResponse request with arbitrary body returning *CreateDgramBindLogForwardResponse
func (c *ClientWithResponses) CreateDgramBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDgramBindLogForwardResponse, error) {
	rsp, err := c.CreateDgramBindLogForwardWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDgramBindLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindLogForwardParams, body CreateDgramBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDgramBindLogForwardResponse, error) {
	rsp, err := c.CreateDgramBindLogForward(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDgramBindLogForwardResponse(rsp)
}

// DeleteDgramBindLogForwardWithResponse request returning *DeleteDgramBindLogForwardResponse
func (c *ClientWithResponses) DeleteDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteDgramBindLogForwardResponse, error) {
	rsp, err := c.DeleteDgramBindLogForward(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDgramBindLogForwardResponse(rsp)
}

// GetDgramBindLogForwardWithResponse request returning *GetDgramBindLogForwardResponse
func (c *ClientWithResponses) GetDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *GetDgramBindLogForwardParams, reqEditors ...RequestEditorFn) (*GetDgramBindLogForwardResponse, error) {
	rsp, err := c.GetDgramBindLogForward(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDgramBindLogForwardResponse(rsp)
}

// ReplaceDgramBindLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceDgramBindLogForwardResponse
func (c *ClientWithResponses) ReplaceDgramBindLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDgramBindLogForwardResponse, error) {
	rsp, err := c.ReplaceDgramBindLogForwardWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDgramBindLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDgramBindLogForwardWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindLogForwardParams, body ReplaceDgramBindLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDgramBindLogForwardResponse, error) {
	rsp, err := c.ReplaceDgramBindLogForward(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDgramBindLogForwardResponse(rsp)
}

// GetAllLogTargetLogForwardWithResponse request returning *GetAllLogTargetLogForwardResponse
func (c *ClientWithResponses) GetAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetLogForwardResponse, error) {
	rsp, err := c.GetAllLogTargetLogForward(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetLogForwardResponse(rsp)
}

// ReplaceAllLogTargetLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetLogForwardResponse
func (c *ClientWithResponses) ReplaceAllLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceAllLogTargetLogForwardWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetLogForwardParams, body ReplaceAllLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceAllLogTargetLogForward(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetLogForwardResponse(rsp)
}

// DeleteLogTargetLogForwardWithResponse request returning *DeleteLogTargetLogForwardResponse
func (c *ClientWithResponses) DeleteLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetLogForwardResponse, error) {
	rsp, err := c.DeleteLogTargetLogForward(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetLogForwardResponse(rsp)
}

// GetLogTargetLogForwardWithResponse request returning *GetLogTargetLogForwardResponse
func (c *ClientWithResponses) GetLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetLogForwardParams, reqEditors ...RequestEditorFn) (*GetLogTargetLogForwardResponse, error) {
	rsp, err := c.GetLogTargetLogForward(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetLogForwardResponse(rsp)
}

// CreateLogTargetLogForwardWithBodyWithResponse request with arbitrary body returning *CreateLogTargetLogForwardResponse
func (c *ClientWithResponses) CreateLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error) {
	rsp, err := c.CreateLogTargetLogForwardWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetLogForwardResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetLogForwardParams, body CreateLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetLogForwardResponse, error) {
	rsp, err := c.CreateLogTargetLogForward(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetLogForwardResponse(rsp)
}

// ReplaceLogTargetLogForwardWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetLogForwardResponse
func (c *ClientWithResponses) ReplaceLogTargetLogForwardWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceLogTargetLogForwardWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetLogForwardResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetLogForwardWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetLogForwardParams, body ReplaceLogTargetLogForwardJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetLogForwardResponse, error) {
	rsp, err := c.ReplaceLogTargetLogForward(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetLogForwardResponse(rsp)
}

// GetMailerEntriesWithResponse request returning *GetMailerEntriesResponse
func (c *ClientWithResponses) GetMailerEntriesWithResponse(ctx context.Context, params *GetMailerEntriesParams, reqEditors ...RequestEditorFn) (*GetMailerEntriesResponse, error) {
	rsp, err := c.GetMailerEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailerEntriesResponse(rsp)
}

// CreateMailerEntryWithBodyWithResponse request with arbitrary body returning *CreateMailerEntryResponse
func (c *ClientWithResponses) CreateMailerEntryWithBodyWithResponse(ctx context.Context, params *CreateMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error) {
	rsp, err := c.CreateMailerEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailerEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateMailerEntryWithResponse(ctx context.Context, params *CreateMailerEntryParams, body CreateMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailerEntryResponse, error) {
	rsp, err := c.CreateMailerEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailerEntryResponse(rsp)
}

// DeleteMailerEntryWithResponse request returning *DeleteMailerEntryResponse
func (c *ClientWithResponses) DeleteMailerEntryWithResponse(ctx context.Context, name string, params *DeleteMailerEntryParams, reqEditors ...RequestEditorFn) (*DeleteMailerEntryResponse, error) {
	rsp, err := c.DeleteMailerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMailerEntryResponse(rsp)
}

// GetMailerEntryWithResponse request returning *GetMailerEntryResponse
func (c *ClientWithResponses) GetMailerEntryWithResponse(ctx context.Context, name string, params *GetMailerEntryParams, reqEditors ...RequestEditorFn) (*GetMailerEntryResponse, error) {
	rsp, err := c.GetMailerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailerEntryResponse(rsp)
}

// ReplaceMailerEntryWithBodyWithResponse request with arbitrary body returning *ReplaceMailerEntryResponse
func (c *ClientWithResponses) ReplaceMailerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error) {
	rsp, err := c.ReplaceMailerEntryWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceMailerEntryResponse(rsp)
}

func (c *ClientWithResponses) ReplaceMailerEntryWithResponse(ctx context.Context, name string, params *ReplaceMailerEntryParams, body ReplaceMailerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceMailerEntryResponse, error) {
	rsp, err := c.ReplaceMailerEntry(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceMailerEntryResponse(rsp)
}

// GetMailersSectionsWithResponse request returning *GetMailersSectionsResponse
func (c *ClientWithResponses) GetMailersSectionsWithResponse(ctx context.Context, params *GetMailersSectionsParams, reqEditors ...RequestEditorFn) (*GetMailersSectionsResponse, error) {
	rsp, err := c.GetMailersSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailersSectionsResponse(rsp)
}

// CreateMailersSectionWithBodyWithResponse request with arbitrary body returning *CreateMailersSectionResponse
func (c *ClientWithResponses) CreateMailersSectionWithBodyWithResponse(ctx context.Context, params *CreateMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error) {
	rsp, err := c.CreateMailersSectionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailersSectionResponse(rsp)
}

func (c *ClientWithResponses) CreateMailersSectionWithResponse(ctx context.Context, params *CreateMailersSectionParams, body CreateMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateMailersSectionResponse, error) {
	rsp, err := c.CreateMailersSection(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateMailersSectionResponse(rsp)
}

// DeleteMailersSectionWithResponse request returning *DeleteMailersSectionResponse
func (c *ClientWithResponses) DeleteMailersSectionWithResponse(ctx context.Context, name string, params *DeleteMailersSectionParams, reqEditors ...RequestEditorFn) (*DeleteMailersSectionResponse, error) {
	rsp, err := c.DeleteMailersSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMailersSectionResponse(rsp)
}

// GetMailersSectionWithResponse request returning *GetMailersSectionResponse
func (c *ClientWithResponses) GetMailersSectionWithResponse(ctx context.Context, name string, params *GetMailersSectionParams, reqEditors ...RequestEditorFn) (*GetMailersSectionResponse, error) {
	rsp, err := c.GetMailersSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMailersSectionResponse(rsp)
}

// EditMailersSectionWithBodyWithResponse request with arbitrary body returning *EditMailersSectionResponse
func (c *ClientWithResponses) EditMailersSectionWithBodyWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error) {
	rsp, err := c.EditMailersSectionWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMailersSectionResponse(rsp)
}

func (c *ClientWithResponses) EditMailersSectionWithResponse(ctx context.Context, name string, params *EditMailersSectionParams, body EditMailersSectionJSONRequestBody, reqEditors ...RequestEditorFn) (*EditMailersSectionResponse, error) {
	rsp, err := c.EditMailersSection(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditMailersSectionResponse(rsp)
}

// GetNameserversWithResponse request returning *GetNameserversResponse
func (c *ClientWithResponses) GetNameserversWithResponse(ctx context.Context, params *GetNameserversParams, reqEditors ...RequestEditorFn) (*GetNameserversResponse, error) {
	rsp, err := c.GetNameservers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNameserversResponse(rsp)
}

// CreateNameserverWithBodyWithResponse request with arbitrary body returning *CreateNameserverResponse
func (c *ClientWithResponses) CreateNameserverWithBodyWithResponse(ctx context.Context, params *CreateNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error) {
	rsp, err := c.CreateNameserverWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNameserverResponse(rsp)
}

func (c *ClientWithResponses) CreateNameserverWithResponse(ctx context.Context, params *CreateNameserverParams, body CreateNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNameserverResponse, error) {
	rsp, err := c.CreateNameserver(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNameserverResponse(rsp)
}

// DeleteNameserverWithResponse request returning *DeleteNameserverResponse
func (c *ClientWithResponses) DeleteNameserverWithResponse(ctx context.Context, name string, params *DeleteNameserverParams, reqEditors ...RequestEditorFn) (*DeleteNameserverResponse, error) {
	rsp, err := c.DeleteNameserver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNameserverResponse(rsp)
}

// GetNameserverWithResponse request returning *GetNameserverResponse
func (c *ClientWithResponses) GetNameserverWithResponse(ctx context.Context, name string, params *GetNameserverParams, reqEditors ...RequestEditorFn) (*GetNameserverResponse, error) {
	rsp, err := c.GetNameserver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNameserverResponse(rsp)
}

// ReplaceNameserverWithBodyWithResponse request with arbitrary body returning *ReplaceNameserverResponse
func (c *ClientWithResponses) ReplaceNameserverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error) {
	rsp, err := c.ReplaceNameserverWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceNameserverResponse(rsp)
}

func (c *ClientWithResponses) ReplaceNameserverWithResponse(ctx context.Context, name string, params *ReplaceNameserverParams, body ReplaceNameserverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceNameserverResponse, error) {
	rsp, err := c.ReplaceNameserver(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceNameserverResponse(rsp)
}

// GetPeerEntriesWithResponse request returning *GetPeerEntriesResponse
func (c *ClientWithResponses) GetPeerEntriesWithResponse(ctx context.Context, params *GetPeerEntriesParams, reqEditors ...RequestEditorFn) (*GetPeerEntriesResponse, error) {
	rsp, err := c.GetPeerEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerEntriesResponse(rsp)
}

// CreatePeerEntryWithBodyWithResponse request with arbitrary body returning *CreatePeerEntryResponse
func (c *ClientWithResponses) CreatePeerEntryWithBodyWithResponse(ctx context.Context, params *CreatePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error) {
	rsp, err := c.CreatePeerEntryWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerEntryResponse(rsp)
}

func (c *ClientWithResponses) CreatePeerEntryWithResponse(ctx context.Context, params *CreatePeerEntryParams, body CreatePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerEntryResponse, error) {
	rsp, err := c.CreatePeerEntry(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerEntryResponse(rsp)
}

// DeletePeerEntryWithResponse request returning *DeletePeerEntryResponse
func (c *ClientWithResponses) DeletePeerEntryWithResponse(ctx context.Context, name string, params *DeletePeerEntryParams, reqEditors ...RequestEditorFn) (*DeletePeerEntryResponse, error) {
	rsp, err := c.DeletePeerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePeerEntryResponse(rsp)
}

// GetPeerEntryWithResponse request returning *GetPeerEntryResponse
func (c *ClientWithResponses) GetPeerEntryWithResponse(ctx context.Context, name string, params *GetPeerEntryParams, reqEditors ...RequestEditorFn) (*GetPeerEntryResponse, error) {
	rsp, err := c.GetPeerEntry(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerEntryResponse(rsp)
}

// ReplacePeerEntryWithBodyWithResponse request with arbitrary body returning *ReplacePeerEntryResponse
func (c *ClientWithResponses) ReplacePeerEntryWithBodyWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error) {
	rsp, err := c.ReplacePeerEntryWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplacePeerEntryResponse(rsp)
}

func (c *ClientWithResponses) ReplacePeerEntryWithResponse(ctx context.Context, name string, params *ReplacePeerEntryParams, body ReplacePeerEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplacePeerEntryResponse, error) {
	rsp, err := c.ReplacePeerEntry(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplacePeerEntryResponse(rsp)
}

// GetPeerSectionsWithResponse request returning *GetPeerSectionsResponse
func (c *ClientWithResponses) GetPeerSectionsWithResponse(ctx context.Context, params *GetPeerSectionsParams, reqEditors ...RequestEditorFn) (*GetPeerSectionsResponse, error) {
	rsp, err := c.GetPeerSections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerSectionsResponse(rsp)
}

// CreatePeerWithBodyWithResponse request with arbitrary body returning *CreatePeerResponse
func (c *ClientWithResponses) CreatePeerWithBodyWithResponse(ctx context.Context, params *CreatePeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error) {
	rsp, err := c.CreatePeerWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerResponse(rsp)
}

func (c *ClientWithResponses) CreatePeerWithResponse(ctx context.Context, params *CreatePeerParams, body CreatePeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePeerResponse, error) {
	rsp, err := c.CreatePeer(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePeerResponse(rsp)
}

// DeletePeerWithResponse request returning *DeletePeerResponse
func (c *ClientWithResponses) DeletePeerWithResponse(ctx context.Context, name string, params *DeletePeerParams, reqEditors ...RequestEditorFn) (*DeletePeerResponse, error) {
	rsp, err := c.DeletePeer(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePeerResponse(rsp)
}

// GetPeerSectionWithResponse request returning *GetPeerSectionResponse
func (c *ClientWithResponses) GetPeerSectionWithResponse(ctx context.Context, name string, params *GetPeerSectionParams, reqEditors ...RequestEditorFn) (*GetPeerSectionResponse, error) {
	rsp, err := c.GetPeerSection(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeerSectionResponse(rsp)
}

// GetAllBindPeerWithResponse request returning *GetAllBindPeerResponse
func (c *ClientWithResponses) GetAllBindPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllBindPeerParams, reqEditors ...RequestEditorFn) (*GetAllBindPeerResponse, error) {
	rsp, err := c.GetAllBindPeer(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllBindPeerResponse(rsp)
}

// CreateBindPeerWithBodyWithResponse request with arbitrary body returning *CreateBindPeerResponse
func (c *ClientWithResponses) CreateBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error) {
	rsp, err := c.CreateBindPeerWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindPeerResponse(rsp)
}

func (c *ClientWithResponses) CreateBindPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateBindPeerParams, body CreateBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBindPeerResponse, error) {
	rsp, err := c.CreateBindPeer(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBindPeerResponse(rsp)
}

// DeleteBindPeerWithResponse request returning *DeleteBindPeerResponse
func (c *ClientWithResponses) DeleteBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteBindPeerParams, reqEditors ...RequestEditorFn) (*DeleteBindPeerResponse, error) {
	rsp, err := c.DeleteBindPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBindPeerResponse(rsp)
}

// GetBindPeerWithResponse request returning *GetBindPeerResponse
func (c *ClientWithResponses) GetBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetBindPeerParams, reqEditors ...RequestEditorFn) (*GetBindPeerResponse, error) {
	rsp, err := c.GetBindPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBindPeerResponse(rsp)
}

// ReplaceBindPeerWithBodyWithResponse request with arbitrary body returning *ReplaceBindPeerResponse
func (c *ClientWithResponses) ReplaceBindPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error) {
	rsp, err := c.ReplaceBindPeerWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceBindPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceBindPeerParams, body ReplaceBindPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceBindPeerResponse, error) {
	rsp, err := c.ReplaceBindPeer(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceBindPeerResponse(rsp)
}

// GetAllLogTargetPeerWithResponse request returning *GetAllLogTargetPeerResponse
func (c *ClientWithResponses) GetAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetPeerResponse, error) {
	rsp, err := c.GetAllLogTargetPeer(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetPeerResponse(rsp)
}

// ReplaceAllLogTargetPeerWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetPeerResponse
func (c *ClientWithResponses) ReplaceAllLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceAllLogTargetPeerWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetPeerParams, body ReplaceAllLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceAllLogTargetPeer(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetPeerResponse(rsp)
}

// DeleteLogTargetPeerWithResponse request returning *DeleteLogTargetPeerResponse
func (c *ClientWithResponses) DeleteLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetPeerParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetPeerResponse, error) {
	rsp, err := c.DeleteLogTargetPeer(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetPeerResponse(rsp)
}

// GetLogTargetPeerWithResponse request returning *GetLogTargetPeerResponse
func (c *ClientWithResponses) GetLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetPeerParams, reqEditors ...RequestEditorFn) (*GetLogTargetPeerResponse, error) {
	rsp, err := c.GetLogTargetPeer(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetPeerResponse(rsp)
}

// CreateLogTargetPeerWithBodyWithResponse request with arbitrary body returning *CreateLogTargetPeerResponse
func (c *ClientWithResponses) CreateLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error) {
	rsp, err := c.CreateLogTargetPeerWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetPeerResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetPeerParams, body CreateLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetPeerResponse, error) {
	rsp, err := c.CreateLogTargetPeer(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetPeerResponse(rsp)
}

// ReplaceLogTargetPeerWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetPeerResponse
func (c *ClientWithResponses) ReplaceLogTargetPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceLogTargetPeerWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetPeerWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetPeerParams, body ReplaceLogTargetPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetPeerResponse, error) {
	rsp, err := c.ReplaceLogTargetPeer(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetPeerResponse(rsp)
}

// GetAllServerPeerWithResponse request returning *GetAllServerPeerResponse
func (c *ClientWithResponses) GetAllServerPeerWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerPeerParams, reqEditors ...RequestEditorFn) (*GetAllServerPeerResponse, error) {
	rsp, err := c.GetAllServerPeer(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerPeerResponse(rsp)
}

// CreateServerPeerWithBodyWithResponse request with arbitrary body returning *CreateServerPeerResponse
func (c *ClientWithResponses) CreateServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error) {
	rsp, err := c.CreateServerPeerWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerPeerResponse(rsp)
}

func (c *ClientWithResponses) CreateServerPeerWithResponse(ctx context.Context, parentName ParentName, params *CreateServerPeerParams, body CreateServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerPeerResponse, error) {
	rsp, err := c.CreateServerPeer(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerPeerResponse(rsp)
}

// DeleteServerPeerWithResponse request returning *DeleteServerPeerResponse
func (c *ClientWithResponses) DeleteServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerPeerParams, reqEditors ...RequestEditorFn) (*DeleteServerPeerResponse, error) {
	rsp, err := c.DeleteServerPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerPeerResponse(rsp)
}

// GetServerPeerWithResponse request returning *GetServerPeerResponse
func (c *ClientWithResponses) GetServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerPeerParams, reqEditors ...RequestEditorFn) (*GetServerPeerResponse, error) {
	rsp, err := c.GetServerPeer(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerPeerResponse(rsp)
}

// ReplaceServerPeerWithBodyWithResponse request with arbitrary body returning *ReplaceServerPeerResponse
func (c *ClientWithResponses) ReplaceServerPeerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error) {
	rsp, err := c.ReplaceServerPeerWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerPeerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerPeerWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerPeerParams, body ReplaceServerPeerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerPeerResponse, error) {
	rsp, err := c.ReplaceServerPeer(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerPeerResponse(rsp)
}

// GetTablesWithResponse request returning *GetTablesResponse
func (c *ClientWithResponses) GetTablesWithResponse(ctx context.Context, parentName ParentName, params *GetTablesParams, reqEditors ...RequestEditorFn) (*GetTablesResponse, error) {
	rsp, err := c.GetTables(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTablesResponse(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableResponse
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTableWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, parentName ParentName, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTable(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

// DeleteTableWithResponse request returning *DeleteTableResponse
func (c *ClientWithResponses) DeleteTableWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error) {
	rsp, err := c.DeleteTable(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTableResponse(rsp)
}

// GetTableWithResponse request returning *GetTableResponse
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, parentName ParentName, name string, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error) {
	rsp, err := c.GetTable(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResponse(rsp)
}

// ReplaceTableWithBodyWithResponse request with arbitrary body returning *ReplaceTableResponse
func (c *ClientWithResponses) ReplaceTableWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error) {
	rsp, err := c.ReplaceTableWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTableResponse(rsp)
}

func (c *ClientWithResponses) ReplaceTableWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceTableParams, body ReplaceTableJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceTableResponse, error) {
	rsp, err := c.ReplaceTable(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceTableResponse(rsp)
}

// GetProgramsWithResponse request returning *GetProgramsResponse
func (c *ClientWithResponses) GetProgramsWithResponse(ctx context.Context, params *GetProgramsParams, reqEditors ...RequestEditorFn) (*GetProgramsResponse, error) {
	rsp, err := c.GetPrograms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramsResponse(rsp)
}

// CreateProgramWithBodyWithResponse request with arbitrary body returning *CreateProgramResponse
func (c *ClientWithResponses) CreateProgramWithBodyWithResponse(ctx context.Context, params *CreateProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error) {
	rsp, err := c.CreateProgramWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResponse(rsp)
}

func (c *ClientWithResponses) CreateProgramWithResponse(ctx context.Context, params *CreateProgramParams, body CreateProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateProgramResponse, error) {
	rsp, err := c.CreateProgram(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateProgramResponse(rsp)
}

// DeleteProgramWithResponse request returning *DeleteProgramResponse
func (c *ClientWithResponses) DeleteProgramWithResponse(ctx context.Context, name string, params *DeleteProgramParams, reqEditors ...RequestEditorFn) (*DeleteProgramResponse, error) {
	rsp, err := c.DeleteProgram(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProgramResponse(rsp)
}

// GetProgramWithResponse request returning *GetProgramResponse
func (c *ClientWithResponses) GetProgramWithResponse(ctx context.Context, name string, params *GetProgramParams, reqEditors ...RequestEditorFn) (*GetProgramResponse, error) {
	rsp, err := c.GetProgram(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProgramResponse(rsp)
}

// ReplaceProgramWithBodyWithResponse request with arbitrary body returning *ReplaceProgramResponse
func (c *ClientWithResponses) ReplaceProgramWithBodyWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error) {
	rsp, err := c.ReplaceProgramWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceProgramResponse(rsp)
}

func (c *ClientWithResponses) ReplaceProgramWithResponse(ctx context.Context, name string, params *ReplaceProgramParams, body ReplaceProgramJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceProgramResponse, error) {
	rsp, err := c.ReplaceProgram(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceProgramResponse(rsp)
}

// GetHAProxyConfigurationWithResponse request returning *GetHAProxyConfigurationResponse
func (c *ClientWithResponses) GetHAProxyConfigurationWithResponse(ctx context.Context, params *GetHAProxyConfigurationParams, reqEditors ...RequestEditorFn) (*GetHAProxyConfigurationResponse, error) {
	rsp, err := c.GetHAProxyConfiguration(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHAProxyConfigurationResponse(rsp)
}

// PostHAProxyConfigurationWithBodyWithResponse request with arbitrary body returning *PostHAProxyConfigurationResponse
func (c *ClientWithResponses) PostHAProxyConfigurationWithBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error) {
	rsp, err := c.PostHAProxyConfigurationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHAProxyConfigurationResponse(rsp)
}

func (c *ClientWithResponses) PostHAProxyConfigurationWithTextBodyWithResponse(ctx context.Context, params *PostHAProxyConfigurationParams, body PostHAProxyConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*PostHAProxyConfigurationResponse, error) {
	rsp, err := c.PostHAProxyConfigurationWithTextBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostHAProxyConfigurationResponse(rsp)
}

// GetResolversWithResponse request returning *GetResolversResponse
func (c *ClientWithResponses) GetResolversWithResponse(ctx context.Context, params *GetResolversParams, reqEditors ...RequestEditorFn) (*GetResolversResponse, error) {
	rsp, err := c.GetResolvers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResolversResponse(rsp)
}

// CreateResolverWithBodyWithResponse request with arbitrary body returning *CreateResolverResponse
func (c *ClientWithResponses) CreateResolverWithBodyWithResponse(ctx context.Context, params *CreateResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error) {
	rsp, err := c.CreateResolverWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResolverResponse(rsp)
}

func (c *ClientWithResponses) CreateResolverWithResponse(ctx context.Context, params *CreateResolverParams, body CreateResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateResolverResponse, error) {
	rsp, err := c.CreateResolver(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResolverResponse(rsp)
}

// DeleteResolverWithResponse request returning *DeleteResolverResponse
func (c *ClientWithResponses) DeleteResolverWithResponse(ctx context.Context, name string, params *DeleteResolverParams, reqEditors ...RequestEditorFn) (*DeleteResolverResponse, error) {
	rsp, err := c.DeleteResolver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResolverResponse(rsp)
}

// GetResolverWithResponse request returning *GetResolverResponse
func (c *ClientWithResponses) GetResolverWithResponse(ctx context.Context, name string, params *GetResolverParams, reqEditors ...RequestEditorFn) (*GetResolverResponse, error) {
	rsp, err := c.GetResolver(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResolverResponse(rsp)
}

// ReplaceResolverWithBodyWithResponse request with arbitrary body returning *ReplaceResolverResponse
func (c *ClientWithResponses) ReplaceResolverWithBodyWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error) {
	rsp, err := c.ReplaceResolverWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResolverResponse(rsp)
}

func (c *ClientWithResponses) ReplaceResolverWithResponse(ctx context.Context, name string, params *ReplaceResolverParams, body ReplaceResolverJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceResolverResponse, error) {
	rsp, err := c.ReplaceResolver(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceResolverResponse(rsp)
}

// GetRingsWithResponse request returning *GetRingsResponse
func (c *ClientWithResponses) GetRingsWithResponse(ctx context.Context, params *GetRingsParams, reqEditors ...RequestEditorFn) (*GetRingsResponse, error) {
	rsp, err := c.GetRings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRingsResponse(rsp)
}

// CreateRingWithBodyWithResponse request with arbitrary body returning *CreateRingResponse
func (c *ClientWithResponses) CreateRingWithBodyWithResponse(ctx context.Context, params *CreateRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRingResponse, error) {
	rsp, err := c.CreateRingWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRingResponse(rsp)
}

func (c *ClientWithResponses) CreateRingWithResponse(ctx context.Context, params *CreateRingParams, body CreateRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRingResponse, error) {
	rsp, err := c.CreateRing(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRingResponse(rsp)
}

// DeleteRingWithResponse request returning *DeleteRingResponse
func (c *ClientWithResponses) DeleteRingWithResponse(ctx context.Context, name string, params *DeleteRingParams, reqEditors ...RequestEditorFn) (*DeleteRingResponse, error) {
	rsp, err := c.DeleteRing(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRingResponse(rsp)
}

// GetRingWithResponse request returning *GetRingResponse
func (c *ClientWithResponses) GetRingWithResponse(ctx context.Context, name string, params *GetRingParams, reqEditors ...RequestEditorFn) (*GetRingResponse, error) {
	rsp, err := c.GetRing(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRingResponse(rsp)
}

// ReplaceRingWithBodyWithResponse request with arbitrary body returning *ReplaceRingResponse
func (c *ClientWithResponses) ReplaceRingWithBodyWithResponse(ctx context.Context, name string, params *ReplaceRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error) {
	rsp, err := c.ReplaceRingWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRingResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRingWithResponse(ctx context.Context, name string, params *ReplaceRingParams, body ReplaceRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRingResponse, error) {
	rsp, err := c.ReplaceRing(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRingResponse(rsp)
}

// GetAllServerRingWithResponse request returning *GetAllServerRingResponse
func (c *ClientWithResponses) GetAllServerRingWithResponse(ctx context.Context, parentName ParentName, params *GetAllServerRingParams, reqEditors ...RequestEditorFn) (*GetAllServerRingResponse, error) {
	rsp, err := c.GetAllServerRing(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllServerRingResponse(rsp)
}

// CreateServerRingWithBodyWithResponse request with arbitrary body returning *CreateServerRingResponse
func (c *ClientWithResponses) CreateServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error) {
	rsp, err := c.CreateServerRingWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerRingResponse(rsp)
}

func (c *ClientWithResponses) CreateServerRingWithResponse(ctx context.Context, parentName ParentName, params *CreateServerRingParams, body CreateServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServerRingResponse, error) {
	rsp, err := c.CreateServerRing(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServerRingResponse(rsp)
}

// DeleteServerRingWithResponse request returning *DeleteServerRingResponse
func (c *ClientWithResponses) DeleteServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteServerRingParams, reqEditors ...RequestEditorFn) (*DeleteServerRingResponse, error) {
	rsp, err := c.DeleteServerRing(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServerRingResponse(rsp)
}

// GetServerRingWithResponse request returning *GetServerRingResponse
func (c *ClientWithResponses) GetServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *GetServerRingParams, reqEditors ...RequestEditorFn) (*GetServerRingResponse, error) {
	rsp, err := c.GetServerRing(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServerRingResponse(rsp)
}

// ReplaceServerRingWithBodyWithResponse request with arbitrary body returning *ReplaceServerRingResponse
func (c *ClientWithResponses) ReplaceServerRingWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error) {
	rsp, err := c.ReplaceServerRingWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerRingResponse(rsp)
}

func (c *ClientWithResponses) ReplaceServerRingWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceServerRingParams, body ReplaceServerRingJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceServerRingResponse, error) {
	rsp, err := c.ReplaceServerRing(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceServerRingResponse(rsp)
}

// GetHAProxyConfigurationStructuredWithResponse request returning *GetHAProxyConfigurationStructuredResponse
func (c *ClientWithResponses) GetHAProxyConfigurationStructuredWithResponse(ctx context.Context, params *GetHAProxyConfigurationStructuredParams, reqEditors ...RequestEditorFn) (*GetHAProxyConfigurationStructuredResponse, error) {
	rsp, err := c.GetHAProxyConfigurationStructured(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHAProxyConfigurationStructuredResponse(rsp)
}

// ReplaceStructuredWithBodyWithResponse request with arbitrary body returning *ReplaceStructuredResponse
func (c *ClientWithResponses) ReplaceStructuredWithBodyWithResponse(ctx context.Context, params *ReplaceStructuredParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStructuredResponse, error) {
	rsp, err := c.ReplaceStructuredWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStructuredResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStructuredWithResponse(ctx context.Context, params *ReplaceStructuredParams, body ReplaceStructuredJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStructuredResponse, error) {
	rsp, err := c.ReplaceStructured(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStructuredResponse(rsp)
}

// GetUDPLbsWithResponse request returning *GetUDPLbsResponse
func (c *ClientWithResponses) GetUDPLbsWithResponse(ctx context.Context, params *GetUDPLbsParams, reqEditors ...RequestEditorFn) (*GetUDPLbsResponse, error) {
	rsp, err := c.GetUDPLbs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUDPLbsResponse(rsp)
}

// CreateUDPLbWithBodyWithResponse request with arbitrary body returning *CreateUDPLbResponse
func (c *ClientWithResponses) CreateUDPLbWithBodyWithResponse(ctx context.Context, params *CreateUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUDPLbResponse, error) {
	rsp, err := c.CreateUDPLbWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUDPLbResponse(rsp)
}

func (c *ClientWithResponses) CreateUDPLbWithResponse(ctx context.Context, params *CreateUDPLbParams, body CreateUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUDPLbResponse, error) {
	rsp, err := c.CreateUDPLb(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUDPLbResponse(rsp)
}

// DeleteUDPLbWithResponse request returning *DeleteUDPLbResponse
func (c *ClientWithResponses) DeleteUDPLbWithResponse(ctx context.Context, name string, params *DeleteUDPLbParams, reqEditors ...RequestEditorFn) (*DeleteUDPLbResponse, error) {
	rsp, err := c.DeleteUDPLb(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUDPLbResponse(rsp)
}

// GetUDPlbWithResponse request returning *GetUDPlbResponse
func (c *ClientWithResponses) GetUDPlbWithResponse(ctx context.Context, name string, params *GetUDPlbParams, reqEditors ...RequestEditorFn) (*GetUDPlbResponse, error) {
	rsp, err := c.GetUDPlb(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUDPlbResponse(rsp)
}

// ReplaceUDPLbWithBodyWithResponse request with arbitrary body returning *ReplaceUDPLbResponse
func (c *ClientWithResponses) ReplaceUDPLbWithBodyWithResponse(ctx context.Context, name string, params *ReplaceUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceUDPLbResponse, error) {
	rsp, err := c.ReplaceUDPLbWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceUDPLbResponse(rsp)
}

func (c *ClientWithResponses) ReplaceUDPLbWithResponse(ctx context.Context, name string, params *ReplaceUDPLbParams, body ReplaceUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceUDPLbResponse, error) {
	rsp, err := c.ReplaceUDPLb(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceUDPLbResponse(rsp)
}

// GetAllDgramBindUDPLbWithResponse request returning *GetAllDgramBindUDPLbResponse
func (c *ClientWithResponses) GetAllDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, params *GetAllDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*GetAllDgramBindUDPLbResponse, error) {
	rsp, err := c.GetAllDgramBindUDPLb(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDgramBindUDPLbResponse(rsp)
}

// CreateDgramBindUDPLbWithBodyWithResponse request with arbitrary body returning *CreateDgramBindUDPLbResponse
func (c *ClientWithResponses) CreateDgramBindUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDgramBindUDPLbResponse, error) {
	rsp, err := c.CreateDgramBindUDPLbWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDgramBindUDPLbResponse(rsp)
}

func (c *ClientWithResponses) CreateDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, params *CreateDgramBindUDPLbParams, body CreateDgramBindUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDgramBindUDPLbResponse, error) {
	rsp, err := c.CreateDgramBindUDPLb(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDgramBindUDPLbResponse(rsp)
}

// DeleteDgramBindUDPLbWithResponse request returning *DeleteDgramBindUDPLbResponse
func (c *ClientWithResponses) DeleteDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*DeleteDgramBindUDPLbResponse, error) {
	rsp, err := c.DeleteDgramBindUDPLb(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDgramBindUDPLbResponse(rsp)
}

// GetDgramBindUDPLbWithResponse request returning *GetDgramBindUDPLbResponse
func (c *ClientWithResponses) GetDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, name string, params *GetDgramBindUDPLbParams, reqEditors ...RequestEditorFn) (*GetDgramBindUDPLbResponse, error) {
	rsp, err := c.GetDgramBindUDPLb(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDgramBindUDPLbResponse(rsp)
}

// ReplaceDgramBindUDPLbWithBodyWithResponse request with arbitrary body returning *ReplaceDgramBindUDPLbResponse
func (c *ClientWithResponses) ReplaceDgramBindUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceDgramBindUDPLbResponse, error) {
	rsp, err := c.ReplaceDgramBindUDPLbWithBody(ctx, parentName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDgramBindUDPLbResponse(rsp)
}

func (c *ClientWithResponses) ReplaceDgramBindUDPLbWithResponse(ctx context.Context, parentName ParentName, name string, params *ReplaceDgramBindUDPLbParams, body ReplaceDgramBindUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceDgramBindUDPLbResponse, error) {
	rsp, err := c.ReplaceDgramBindUDPLb(ctx, parentName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceDgramBindUDPLbResponse(rsp)
}

// GetAllLogTargetUDPLbWithResponse request returning *GetAllLogTargetUDPLbResponse
func (c *ClientWithResponses) GetAllLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, params *GetAllLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*GetAllLogTargetUDPLbResponse, error) {
	rsp, err := c.GetAllLogTargetUDPLb(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllLogTargetUDPLbResponse(rsp)
}

// ReplaceAllLogTargetUDPLbWithBodyWithResponse request with arbitrary body returning *ReplaceAllLogTargetUDPLbResponse
func (c *ClientWithResponses) ReplaceAllLogTargetUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetUDPLbResponse, error) {
	rsp, err := c.ReplaceAllLogTargetUDPLbWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetUDPLbResponse(rsp)
}

func (c *ClientWithResponses) ReplaceAllLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, params *ReplaceAllLogTargetUDPLbParams, body ReplaceAllLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceAllLogTargetUDPLbResponse, error) {
	rsp, err := c.ReplaceAllLogTargetUDPLb(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceAllLogTargetUDPLbResponse(rsp)
}

// DeleteLogTargetUDPLbWithResponse request returning *DeleteLogTargetUDPLbResponse
func (c *ClientWithResponses) DeleteLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, index int, params *DeleteLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*DeleteLogTargetUDPLbResponse, error) {
	rsp, err := c.DeleteLogTargetUDPLb(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogTargetUDPLbResponse(rsp)
}

// GetLogTargetUDPLbWithResponse request returning *GetLogTargetUDPLbResponse
func (c *ClientWithResponses) GetLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, index int, params *GetLogTargetUDPLbParams, reqEditors ...RequestEditorFn) (*GetLogTargetUDPLbResponse, error) {
	rsp, err := c.GetLogTargetUDPLb(ctx, parentName, index, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogTargetUDPLbResponse(rsp)
}

// CreateLogTargetUDPLbWithBodyWithResponse request with arbitrary body returning *CreateLogTargetUDPLbResponse
func (c *ClientWithResponses) CreateLogTargetUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogTargetUDPLbResponse, error) {
	rsp, err := c.CreateLogTargetUDPLbWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetUDPLbResponse(rsp)
}

func (c *ClientWithResponses) CreateLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, index int, params *CreateLogTargetUDPLbParams, body CreateLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogTargetUDPLbResponse, error) {
	rsp, err := c.CreateLogTargetUDPLb(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogTargetUDPLbResponse(rsp)
}

// ReplaceLogTargetUDPLbWithBodyWithResponse request with arbitrary body returning *ReplaceLogTargetUDPLbResponse
func (c *ClientWithResponses) ReplaceLogTargetUDPLbWithBodyWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogTargetUDPLbResponse, error) {
	rsp, err := c.ReplaceLogTargetUDPLbWithBody(ctx, parentName, index, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetUDPLbResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogTargetUDPLbWithResponse(ctx context.Context, parentName ParentName, index int, params *ReplaceLogTargetUDPLbParams, body ReplaceLogTargetUDPLbJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogTargetUDPLbResponse, error) {
	rsp, err := c.ReplaceLogTargetUDPLb(ctx, parentName, index, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogTargetUDPLbResponse(rsp)
}

// GetUserlistsWithResponse request returning *GetUserlistsResponse
func (c *ClientWithResponses) GetUserlistsWithResponse(ctx context.Context, params *GetUserlistsParams, reqEditors ...RequestEditorFn) (*GetUserlistsResponse, error) {
	rsp, err := c.GetUserlists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserlistsResponse(rsp)
}

// CreateUserlistWithBodyWithResponse request with arbitrary body returning *CreateUserlistResponse
func (c *ClientWithResponses) CreateUserlistWithBodyWithResponse(ctx context.Context, params *CreateUserlistParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error) {
	rsp, err := c.CreateUserlistWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserlistResponse(rsp)
}

func (c *ClientWithResponses) CreateUserlistWithResponse(ctx context.Context, params *CreateUserlistParams, body CreateUserlistJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserlistResponse, error) {
	rsp, err := c.CreateUserlist(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserlistResponse(rsp)
}

// DeleteUserlistWithResponse request returning *DeleteUserlistResponse
func (c *ClientWithResponses) DeleteUserlistWithResponse(ctx context.Context, name string, params *DeleteUserlistParams, reqEditors ...RequestEditorFn) (*DeleteUserlistResponse, error) {
	rsp, err := c.DeleteUserlist(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserlistResponse(rsp)
}

// GetUserlistWithResponse request returning *GetUserlistResponse
func (c *ClientWithResponses) GetUserlistWithResponse(ctx context.Context, name string, params *GetUserlistParams, reqEditors ...RequestEditorFn) (*GetUserlistResponse, error) {
	rsp, err := c.GetUserlist(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserlistResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// CreateUserWithBodyWithResponse request with arbitrary body returning *CreateUserResponse
func (c *ClientWithResponses) CreateUserWithBodyWithResponse(ctx context.Context, params *CreateUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

func (c *ClientWithResponses) CreateUserWithResponse(ctx context.Context, params *CreateUserParams, body CreateUserJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserResponse, error) {
	rsp, err := c.CreateUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserResponse(rsp)
}

// DeleteUserWithResponse request returning *DeleteUserResponse
func (c *ClientWithResponses) DeleteUserWithResponse(ctx context.Context, username string, params *DeleteUserParams, reqEditors ...RequestEditorFn) (*DeleteUserResponse, error) {
	rsp, err := c.DeleteUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, username string, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ReplaceUserWithBodyWithResponse request with arbitrary body returning *ReplaceUserResponse
func (c *ClientWithResponses) ReplaceUserWithBodyWithResponse(ctx context.Context, username string, params *ReplaceUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error) {
	rsp, err := c.ReplaceUserWithBody(ctx, username, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceUserResponse(rsp)
}

func (c *ClientWithResponses) ReplaceUserWithResponse(ctx context.Context, username string, params *ReplaceUserParams, body ReplaceUserJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceUserResponse, error) {
	rsp, err := c.ReplaceUser(ctx, username, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceUserResponse(rsp)
}

// GetConfigurationVersionWithResponse request returning *GetConfigurationVersionResponse
func (c *ClientWithResponses) GetConfigurationVersionWithResponse(ctx context.Context, params *GetConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetConfigurationVersionResponse, error) {
	rsp, err := c.GetConfigurationVersion(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigurationVersionResponse(rsp)
}

// GetLogConfigWithResponse request returning *GetLogConfigResponse
func (c *ClientWithResponses) GetLogConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogConfigResponse, error) {
	rsp, err := c.GetLogConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogConfigResponse(rsp)
}

// ReplaceLogConfigWithBodyWithResponse request with arbitrary body returning *ReplaceLogConfigResponse
func (c *ClientWithResponses) ReplaceLogConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogConfigResponse, error) {
	rsp, err := c.ReplaceLogConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogConfigResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogConfigWithResponse(ctx context.Context, body ReplaceLogConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogConfigResponse, error) {
	rsp, err := c.ReplaceLogConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogConfigResponse(rsp)
}

// GetLogInputsWithResponse request returning *GetLogInputsResponse
func (c *ClientWithResponses) GetLogInputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogInputsResponse, error) {
	rsp, err := c.GetLogInputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogInputsResponse(rsp)
}

// CreateLogInputWithBodyWithResponse request with arbitrary body returning *CreateLogInputResponse
func (c *ClientWithResponses) CreateLogInputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogInputResponse, error) {
	rsp, err := c.CreateLogInputWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogInputResponse(rsp)
}

func (c *ClientWithResponses) CreateLogInputWithResponse(ctx context.Context, body CreateLogInputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogInputResponse, error) {
	rsp, err := c.CreateLogInput(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogInputResponse(rsp)
}

// DeleteLogInputWithResponse request returning *DeleteLogInputResponse
func (c *ClientWithResponses) DeleteLogInputWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLogInputResponse, error) {
	rsp, err := c.DeleteLogInput(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogInputResponse(rsp)
}

// GetLogInputWithResponse request returning *GetLogInputResponse
func (c *ClientWithResponses) GetLogInputWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLogInputResponse, error) {
	rsp, err := c.GetLogInput(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogInputResponse(rsp)
}

// ReplaceLogInputWithBodyWithResponse request with arbitrary body returning *ReplaceLogInputResponse
func (c *ClientWithResponses) ReplaceLogInputWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogInputResponse, error) {
	rsp, err := c.ReplaceLogInputWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogInputResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogInputWithResponse(ctx context.Context, id string, body ReplaceLogInputJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogInputResponse, error) {
	rsp, err := c.ReplaceLogInput(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogInputResponse(rsp)
}

// GetLogOutputsWithResponse request returning *GetLogOutputsResponse
func (c *ClientWithResponses) GetLogOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLogOutputsResponse, error) {
	rsp, err := c.GetLogOutputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogOutputsResponse(rsp)
}

// CreateLogOutputWithBodyWithResponse request with arbitrary body returning *CreateLogOutputResponse
func (c *ClientWithResponses) CreateLogOutputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateLogOutputResponse, error) {
	rsp, err := c.CreateLogOutputWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogOutputResponse(rsp)
}

func (c *ClientWithResponses) CreateLogOutputWithResponse(ctx context.Context, body CreateLogOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateLogOutputResponse, error) {
	rsp, err := c.CreateLogOutput(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLogOutputResponse(rsp)
}

// DeleteLogOutputWithResponse request returning *DeleteLogOutputResponse
func (c *ClientWithResponses) DeleteLogOutputWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteLogOutputResponse, error) {
	rsp, err := c.DeleteLogOutput(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLogOutputResponse(rsp)
}

// GetLogOutputWithResponse request returning *GetLogOutputResponse
func (c *ClientWithResponses) GetLogOutputWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetLogOutputResponse, error) {
	rsp, err := c.GetLogOutput(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLogOutputResponse(rsp)
}

// ReplaceLogOutputWithBodyWithResponse request with arbitrary body returning *ReplaceLogOutputResponse
func (c *ClientWithResponses) ReplaceLogOutputWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceLogOutputResponse, error) {
	rsp, err := c.ReplaceLogOutputWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogOutputResponse(rsp)
}

func (c *ClientWithResponses) ReplaceLogOutputWithResponse(ctx context.Context, id string, body ReplaceLogOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceLogOutputResponse, error) {
	rsp, err := c.ReplaceLogOutput(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceLogOutputResponse(rsp)
}

// GetReloadsWithResponse request returning *GetReloadsResponse
func (c *ClientWithResponses) GetReloadsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReloadsResponse, error) {
	rsp, err := c.GetReloads(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReloadsResponse(rsp)
}

// GetReloadWithResponse request returning *GetReloadResponse
func (c *ClientWithResponses) GetReloadWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetReloadResponse, error) {
	rsp, err := c.GetReload(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReloadResponse(rsp)
}

// GetRuntimeEndpointsWithResponse request returning *GetRuntimeEndpointsResponse
func (c *ClientWithResponses) GetRuntimeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRuntimeEndpointsResponse, error) {
	rsp, err := c.GetRuntimeEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeEndpointsResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsWithResponse request returning *GetServicesHaproxyRuntimeAclsResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAcls(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsIdWithResponse request returning *GetServicesHaproxyRuntimeAclsIdResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsIdResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAclsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsIdResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse request returning *GetServicesHaproxyRuntimeAclsParentNameEntriesResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAclsParentNameEntries(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp)
}

// PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse request with arbitrary body returning *PostServicesHaproxyRuntimeAclsParentNameEntriesResponse
func (c *ClientWithResponses) PostServicesHaproxyRuntimeAclsParentNameEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	rsp, err := c.PostServicesHaproxyRuntimeAclsParentNameEntriesWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp)
}

func (c *ClientWithResponses) PostServicesHaproxyRuntimeAclsParentNameEntriesWithResponse(ctx context.Context, parentName ParentName, body PostServicesHaproxyRuntimeAclsParentNameEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	rsp, err := c.PostServicesHaproxyRuntimeAclsParentNameEntries(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp)
}

// AddPayloadRuntimeACLWithBodyWithResponse request with arbitrary body returning *AddPayloadRuntimeACLResponse
func (c *ClientWithResponses) AddPayloadRuntimeACLWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error) {
	rsp, err := c.AddPayloadRuntimeACLWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeACLResponse(rsp)
}

func (c *ClientWithResponses) AddPayloadRuntimeACLWithResponse(ctx context.Context, parentName ParentName, body AddPayloadRuntimeACLJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeACLResponse, error) {
	rsp, err := c.AddPayloadRuntimeACL(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeACLResponse(rsp)
}

// DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request returning *DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse
func (c *ClientWithResponses) DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	rsp, err := c.DeleteServicesHaproxyRuntimeAclsParentNameEntriesId(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp)
}

// GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse request returning *GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse
func (c *ClientWithResponses) GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	rsp, err := c.GetServicesHaproxyRuntimeAclsParentNameEntriesId(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp)
}

// GetAllRuntimeServerWithResponse request returning *GetAllRuntimeServerResponse
func (c *ClientWithResponses) GetAllRuntimeServerWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetAllRuntimeServerResponse, error) {
	rsp, err := c.GetAllRuntimeServer(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRuntimeServerResponse(rsp)
}

// AddRuntimeServerWithBodyWithResponse request with arbitrary body returning *AddRuntimeServerResponse
func (c *ClientWithResponses) AddRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error) {
	rsp, err := c.AddRuntimeServerWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuntimeServerResponse(rsp)
}

func (c *ClientWithResponses) AddRuntimeServerWithResponse(ctx context.Context, parentName ParentName, body AddRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRuntimeServerResponse, error) {
	rsp, err := c.AddRuntimeServer(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRuntimeServerResponse(rsp)
}

// DeleteRuntimeServerWithResponse request returning *DeleteRuntimeServerResponse
func (c *ClientWithResponses) DeleteRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*DeleteRuntimeServerResponse, error) {
	rsp, err := c.DeleteRuntimeServer(ctx, parentName, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuntimeServerResponse(rsp)
}

// GetRuntimeServerWithResponse request returning *GetRuntimeServerResponse
func (c *ClientWithResponses) GetRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, reqEditors ...RequestEditorFn) (*GetRuntimeServerResponse, error) {
	rsp, err := c.GetRuntimeServer(ctx, parentName, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeServerResponse(rsp)
}

// ReplaceRuntimeServerWithBodyWithResponse request with arbitrary body returning *ReplaceRuntimeServerResponse
func (c *ClientWithResponses) ReplaceRuntimeServerWithBodyWithResponse(ctx context.Context, parentName ParentName, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error) {
	rsp, err := c.ReplaceRuntimeServerWithBody(ctx, parentName, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeServerResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRuntimeServerWithResponse(ctx context.Context, parentName ParentName, name string, body ReplaceRuntimeServerJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeServerResponse, error) {
	rsp, err := c.ReplaceRuntimeServer(ctx, parentName, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeServerResponse(rsp)
}

// GetHaproxyProcessInfoWithResponse request returning *GetHaproxyProcessInfoResponse
func (c *ClientWithResponses) GetHaproxyProcessInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHaproxyProcessInfoResponse, error) {
	rsp, err := c.GetHaproxyProcessInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHaproxyProcessInfoResponse(rsp)
}

// GetAllRuntimeMapFilesWithResponse request returning *GetAllRuntimeMapFilesResponse
func (c *ClientWithResponses) GetAllRuntimeMapFilesWithResponse(ctx context.Context, params *GetAllRuntimeMapFilesParams, reqEditors ...RequestEditorFn) (*GetAllRuntimeMapFilesResponse, error) {
	rsp, err := c.GetAllRuntimeMapFiles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllRuntimeMapFilesResponse(rsp)
}

// ClearRuntimeMapWithResponse request returning *ClearRuntimeMapResponse
func (c *ClientWithResponses) ClearRuntimeMapWithResponse(ctx context.Context, name string, params *ClearRuntimeMapParams, reqEditors ...RequestEditorFn) (*ClearRuntimeMapResponse, error) {
	rsp, err := c.ClearRuntimeMap(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearRuntimeMapResponse(rsp)
}

// GetOneRuntimeMapWithResponse request returning *GetOneRuntimeMapResponse
func (c *ClientWithResponses) GetOneRuntimeMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneRuntimeMapResponse, error) {
	rsp, err := c.GetOneRuntimeMap(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneRuntimeMapResponse(rsp)
}

// AddPayloadRuntimeMapWithBodyWithResponse request with arbitrary body returning *AddPayloadRuntimeMapResponse
func (c *ClientWithResponses) AddPayloadRuntimeMapWithBodyWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error) {
	rsp, err := c.AddPayloadRuntimeMapWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeMapResponse(rsp)
}

func (c *ClientWithResponses) AddPayloadRuntimeMapWithResponse(ctx context.Context, name string, params *AddPayloadRuntimeMapParams, body AddPayloadRuntimeMapJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPayloadRuntimeMapResponse, error) {
	rsp, err := c.AddPayloadRuntimeMap(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPayloadRuntimeMapResponse(rsp)
}

// ShowRuntimeMapWithResponse request returning *ShowRuntimeMapResponse
func (c *ClientWithResponses) ShowRuntimeMapWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*ShowRuntimeMapResponse, error) {
	rsp, err := c.ShowRuntimeMap(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowRuntimeMapResponse(rsp)
}

// AddMapEntryWithBodyWithResponse request with arbitrary body returning *AddMapEntryResponse
func (c *ClientWithResponses) AddMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error) {
	rsp, err := c.AddMapEntryWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMapEntryResponse(rsp)
}

func (c *ClientWithResponses) AddMapEntryWithResponse(ctx context.Context, parentName ParentName, params *AddMapEntryParams, body AddMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMapEntryResponse, error) {
	rsp, err := c.AddMapEntry(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMapEntryResponse(rsp)
}

// DeleteRuntimeMapEntryWithResponse request returning *DeleteRuntimeMapEntryResponse
func (c *ClientWithResponses) DeleteRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *DeleteRuntimeMapEntryParams, reqEditors ...RequestEditorFn) (*DeleteRuntimeMapEntryResponse, error) {
	rsp, err := c.DeleteRuntimeMapEntry(ctx, parentName, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuntimeMapEntryResponse(rsp)
}

// GetRuntimeMapEntryWithResponse request returning *GetRuntimeMapEntryResponse
func (c *ClientWithResponses) GetRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetRuntimeMapEntryResponse, error) {
	rsp, err := c.GetRuntimeMapEntry(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRuntimeMapEntryResponse(rsp)
}

// ReplaceRuntimeMapEntryWithBodyWithResponse request with arbitrary body returning *ReplaceRuntimeMapEntryResponse
func (c *ClientWithResponses) ReplaceRuntimeMapEntryWithBodyWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error) {
	rsp, err := c.ReplaceRuntimeMapEntryWithBody(ctx, parentName, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeMapEntryResponse(rsp)
}

func (c *ClientWithResponses) ReplaceRuntimeMapEntryWithResponse(ctx context.Context, parentName ParentName, id string, params *ReplaceRuntimeMapEntryParams, body ReplaceRuntimeMapEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceRuntimeMapEntryResponse, error) {
	rsp, err := c.ReplaceRuntimeMapEntry(ctx, parentName, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceRuntimeMapEntryResponse(rsp)
}

// GetStickTablesWithResponse request returning *GetStickTablesResponse
func (c *ClientWithResponses) GetStickTablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStickTablesResponse, error) {
	rsp, err := c.GetStickTables(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickTablesResponse(rsp)
}

// GetStickTableWithResponse request returning *GetStickTableResponse
func (c *ClientWithResponses) GetStickTableWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetStickTableResponse, error) {
	rsp, err := c.GetStickTable(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickTableResponse(rsp)
}

// GetStickTableEntriesWithResponse request returning *GetStickTableEntriesResponse
func (c *ClientWithResponses) GetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, params *GetStickTableEntriesParams, reqEditors ...RequestEditorFn) (*GetStickTableEntriesResponse, error) {
	rsp, err := c.GetStickTableEntries(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStickTableEntriesResponse(rsp)
}

// SetStickTableEntriesWithBodyWithResponse request with arbitrary body returning *SetStickTableEntriesResponse
func (c *ClientWithResponses) SetStickTableEntriesWithBodyWithResponse(ctx context.Context, parentName ParentName, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error) {
	rsp, err := c.SetStickTableEntriesWithBody(ctx, parentName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetStickTableEntriesResponse(rsp)
}

func (c *ClientWithResponses) SetStickTableEntriesWithResponse(ctx context.Context, parentName ParentName, body SetStickTableEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetStickTableEntriesResponse, error) {
	rsp, err := c.SetStickTableEntries(ctx, parentName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetStickTableEntriesResponse(rsp)
}

// GetSitesWithResponse request returning *GetSitesResponse
func (c *ClientWithResponses) GetSitesWithResponse(ctx context.Context, params *GetSitesParams, reqEditors ...RequestEditorFn) (*GetSitesResponse, error) {
	rsp, err := c.GetSites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSitesResponse(rsp)
}

// CreateSiteWithBodyWithResponse request with arbitrary body returning *CreateSiteResponse
func (c *ClientWithResponses) CreateSiteWithBodyWithResponse(ctx context.Context, params *CreateSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSiteWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

func (c *ClientWithResponses) CreateSiteWithResponse(ctx context.Context, params *CreateSiteParams, body CreateSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSiteResponse, error) {
	rsp, err := c.CreateSite(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSiteResponse(rsp)
}

// DeleteSiteWithResponse request returning *DeleteSiteResponse
func (c *ClientWithResponses) DeleteSiteWithResponse(ctx context.Context, name string, params *DeleteSiteParams, reqEditors ...RequestEditorFn) (*DeleteSiteResponse, error) {
	rsp, err := c.DeleteSite(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSiteResponse(rsp)
}

// GetSiteWithResponse request returning *GetSiteResponse
func (c *ClientWithResponses) GetSiteWithResponse(ctx context.Context, name string, params *GetSiteParams, reqEditors ...RequestEditorFn) (*GetSiteResponse, error) {
	rsp, err := c.GetSite(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSiteResponse(rsp)
}

// ReplaceSiteWithBodyWithResponse request with arbitrary body returning *ReplaceSiteResponse
func (c *ClientWithResponses) ReplaceSiteWithBodyWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error) {
	rsp, err := c.ReplaceSiteWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSiteResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSiteWithResponse(ctx context.Context, name string, params *ReplaceSiteParams, body ReplaceSiteJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSiteResponse, error) {
	rsp, err := c.ReplaceSite(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSiteResponse(rsp)
}

// GetSpoeEndpointsWithResponse request returning *GetSpoeEndpointsResponse
func (c *ClientWithResponses) GetSpoeEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpoeEndpointsResponse, error) {
	rsp, err := c.GetSpoeEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeEndpointsResponse(rsp)
}

// GetAllSpoeFilesWithResponse request returning *GetAllSpoeFilesResponse
func (c *ClientWithResponses) GetAllSpoeFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllSpoeFilesResponse, error) {
	rsp, err := c.GetAllSpoeFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeFilesResponse(rsp)
}

// CreateSpoeWithBodyWithResponse request with arbitrary body returning *CreateSpoeResponse
func (c *ClientWithResponses) CreateSpoeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeResponse, error) {
	rsp, err := c.CreateSpoeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeResponse(rsp)
}

// DeleteSpoeFileWithResponse request returning *DeleteSpoeFileResponse
func (c *ClientWithResponses) DeleteSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteSpoeFileResponse, error) {
	rsp, err := c.DeleteSpoeFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeFileResponse(rsp)
}

// GetOneSpoeFileWithResponse request returning *GetOneSpoeFileResponse
func (c *ClientWithResponses) GetOneSpoeFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneSpoeFileResponse, error) {
	rsp, err := c.GetOneSpoeFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneSpoeFileResponse(rsp)
}

// GetAllSpoeScopeWithResponse request returning *GetAllSpoeScopeResponse
func (c *ClientWithResponses) GetAllSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetAllSpoeScopeResponse, error) {
	rsp, err := c.GetAllSpoeScope(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeScopeResponse(rsp)
}

// CreateSpoeScopeWithBodyWithResponse request with arbitrary body returning *CreateSpoeScopeResponse
func (c *ClientWithResponses) CreateSpoeScopeWithBodyWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error) {
	rsp, err := c.CreateSpoeScopeWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeScopeResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeScopeWithResponse(ctx context.Context, parentName ParentName, params *CreateSpoeScopeParams, body CreateSpoeScopeJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeScopeResponse, error) {
	rsp, err := c.CreateSpoeScope(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeScopeResponse(rsp)
}

// DeleteSpoeScopeWithResponse request returning *DeleteSpoeScopeResponse
func (c *ClientWithResponses) DeleteSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *DeleteSpoeScopeParams, reqEditors ...RequestEditorFn) (*DeleteSpoeScopeResponse, error) {
	rsp, err := c.DeleteSpoeScope(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeScopeResponse(rsp)
}

// GetSpoeScopeWithResponse request returning *GetSpoeScopeResponse
func (c *ClientWithResponses) GetSpoeScopeWithResponse(ctx context.Context, parentName ParentName, name string, params *GetSpoeScopeParams, reqEditors ...RequestEditorFn) (*GetSpoeScopeResponse, error) {
	rsp, err := c.GetSpoeScope(ctx, parentName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeScopeResponse(rsp)
}

// GetAllSpoeAgentWithResponse request returning *GetAllSpoeAgentResponse
func (c *ClientWithResponses) GetAllSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetAllSpoeAgentResponse, error) {
	rsp, err := c.GetAllSpoeAgent(ctx, parentName, scopeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeAgentResponse(rsp)
}

// CreateSpoeAgentWithBodyWithResponse request with arbitrary body returning *CreateSpoeAgentResponse
func (c *ClientWithResponses) CreateSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error) {
	rsp, err := c.CreateSpoeAgentWithBody(ctx, parentName, scopeName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeAgentResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeAgentParams, body CreateSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeAgentResponse, error) {
	rsp, err := c.CreateSpoeAgent(ctx, parentName, scopeName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeAgentResponse(rsp)
}

// DeleteSpoeAgentWithResponse request returning *DeleteSpoeAgentResponse
func (c *ClientWithResponses) DeleteSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeAgentParams, reqEditors ...RequestEditorFn) (*DeleteSpoeAgentResponse, error) {
	rsp, err := c.DeleteSpoeAgent(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeAgentResponse(rsp)
}

// GetSpoeAgentWithResponse request returning *GetSpoeAgentResponse
func (c *ClientWithResponses) GetSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeAgentParams, reqEditors ...RequestEditorFn) (*GetSpoeAgentResponse, error) {
	rsp, err := c.GetSpoeAgent(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeAgentResponse(rsp)
}

// ReplaceSpoeAgentWithBodyWithResponse request with arbitrary body returning *ReplaceSpoeAgentResponse
func (c *ClientWithResponses) ReplaceSpoeAgentWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error) {
	rsp, err := c.ReplaceSpoeAgentWithBody(ctx, parentName, scopeName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeAgentResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSpoeAgentWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeAgentParams, body ReplaceSpoeAgentJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeAgentResponse, error) {
	rsp, err := c.ReplaceSpoeAgent(ctx, parentName, scopeName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeAgentResponse(rsp)
}

// GetAllSpoeGroupWithResponse request returning *GetAllSpoeGroupResponse
func (c *ClientWithResponses) GetAllSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetAllSpoeGroupResponse, error) {
	rsp, err := c.GetAllSpoeGroup(ctx, parentName, scopeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeGroupResponse(rsp)
}

// CreateSpoeGroupWithBodyWithResponse request with arbitrary body returning *CreateSpoeGroupResponse
func (c *ClientWithResponses) CreateSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error) {
	rsp, err := c.CreateSpoeGroupWithBody(ctx, parentName, scopeName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeGroupParams, body CreateSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeGroupResponse, error) {
	rsp, err := c.CreateSpoeGroup(ctx, parentName, scopeName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeGroupResponse(rsp)
}

// DeleteSpoeGroupWithResponse request returning *DeleteSpoeGroupResponse
func (c *ClientWithResponses) DeleteSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeGroupParams, reqEditors ...RequestEditorFn) (*DeleteSpoeGroupResponse, error) {
	rsp, err := c.DeleteSpoeGroup(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeGroupResponse(rsp)
}

// GetSpoeGroupWithResponse request returning *GetSpoeGroupResponse
func (c *ClientWithResponses) GetSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeGroupParams, reqEditors ...RequestEditorFn) (*GetSpoeGroupResponse, error) {
	rsp, err := c.GetSpoeGroup(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeGroupResponse(rsp)
}

// ReplaceSpoeGroupWithBodyWithResponse request with arbitrary body returning *ReplaceSpoeGroupResponse
func (c *ClientWithResponses) ReplaceSpoeGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error) {
	rsp, err := c.ReplaceSpoeGroupWithBody(ctx, parentName, scopeName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeGroupResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSpoeGroupWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeGroupParams, body ReplaceSpoeGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeGroupResponse, error) {
	rsp, err := c.ReplaceSpoeGroup(ctx, parentName, scopeName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeGroupResponse(rsp)
}

// GetAllSpoeMessageWithResponse request returning *GetAllSpoeMessageResponse
func (c *ClientWithResponses) GetAllSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *GetAllSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetAllSpoeMessageResponse, error) {
	rsp, err := c.GetAllSpoeMessage(ctx, parentName, scopeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeMessageResponse(rsp)
}

// CreateSpoeMessageWithBodyWithResponse request with arbitrary body returning *CreateSpoeMessageResponse
func (c *ClientWithResponses) CreateSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error) {
	rsp, err := c.CreateSpoeMessageWithBody(ctx, parentName, scopeName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeMessageResponse(rsp)
}

func (c *ClientWithResponses) CreateSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, params *CreateSpoeMessageParams, body CreateSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpoeMessageResponse, error) {
	rsp, err := c.CreateSpoeMessage(ctx, parentName, scopeName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpoeMessageResponse(rsp)
}

// DeleteSpoeMessageWithResponse request returning *DeleteSpoeMessageResponse
func (c *ClientWithResponses) DeleteSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *DeleteSpoeMessageParams, reqEditors ...RequestEditorFn) (*DeleteSpoeMessageResponse, error) {
	rsp, err := c.DeleteSpoeMessage(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeMessageResponse(rsp)
}

// GetSpoeMessageWithResponse request returning *GetSpoeMessageResponse
func (c *ClientWithResponses) GetSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *GetSpoeMessageParams, reqEditors ...RequestEditorFn) (*GetSpoeMessageResponse, error) {
	rsp, err := c.GetSpoeMessage(ctx, parentName, scopeName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeMessageResponse(rsp)
}

// ReplaceSpoeMessageWithBodyWithResponse request with arbitrary body returning *ReplaceSpoeMessageResponse
func (c *ClientWithResponses) ReplaceSpoeMessageWithBodyWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error) {
	rsp, err := c.ReplaceSpoeMessageWithBody(ctx, parentName, scopeName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeMessageResponse(rsp)
}

func (c *ClientWithResponses) ReplaceSpoeMessageWithResponse(ctx context.Context, parentName ParentName, scopeName string, name string, params *ReplaceSpoeMessageParams, body ReplaceSpoeMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceSpoeMessageResponse, error) {
	rsp, err := c.ReplaceSpoeMessage(ctx, parentName, scopeName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceSpoeMessageResponse(rsp)
}

// GetAllSpoeTransactionWithResponse request returning *GetAllSpoeTransactionResponse
func (c *ClientWithResponses) GetAllSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *GetAllSpoeTransactionParams, reqEditors ...RequestEditorFn) (*GetAllSpoeTransactionResponse, error) {
	rsp, err := c.GetAllSpoeTransaction(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllSpoeTransactionResponse(rsp)
}

// StartSpoeTransactionWithResponse request returning *StartSpoeTransactionResponse
func (c *ClientWithResponses) StartSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, params *StartSpoeTransactionParams, reqEditors ...RequestEditorFn) (*StartSpoeTransactionResponse, error) {
	rsp, err := c.StartSpoeTransaction(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartSpoeTransactionResponse(rsp)
}

// DeleteSpoeTransactionWithResponse request returning *DeleteSpoeTransactionResponse
func (c *ClientWithResponses) DeleteSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*DeleteSpoeTransactionResponse, error) {
	rsp, err := c.DeleteSpoeTransaction(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpoeTransactionResponse(rsp)
}

// GetSpoeTransactionWithResponse request returning *GetSpoeTransactionResponse
func (c *ClientWithResponses) GetSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, reqEditors ...RequestEditorFn) (*GetSpoeTransactionResponse, error) {
	rsp, err := c.GetSpoeTransaction(ctx, parentName, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeTransactionResponse(rsp)
}

// CommitSpoeTransactionWithResponse request returning *CommitSpoeTransactionResponse
func (c *ClientWithResponses) CommitSpoeTransactionWithResponse(ctx context.Context, parentName ParentName, id string, params *CommitSpoeTransactionParams, reqEditors ...RequestEditorFn) (*CommitSpoeTransactionResponse, error) {
	rsp, err := c.CommitSpoeTransaction(ctx, parentName, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitSpoeTransactionResponse(rsp)
}

// GetSpoeConfigurationVersionWithResponse request returning *GetSpoeConfigurationVersionResponse
func (c *ClientWithResponses) GetSpoeConfigurationVersionWithResponse(ctx context.Context, parentName ParentName, params *GetSpoeConfigurationVersionParams, reqEditors ...RequestEditorFn) (*GetSpoeConfigurationVersionResponse, error) {
	rsp, err := c.GetSpoeConfigurationVersion(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpoeConfigurationVersionResponse(rsp)
}

// GetStatsEndpointsWithResponse request returning *GetStatsEndpointsResponse
func (c *ClientWithResponses) GetStatsEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatsEndpointsResponse, error) {
	rsp, err := c.GetStatsEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsEndpointsResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, params *GetStatsParams, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// GetStorageEndpointsWithResponse request returning *GetStorageEndpointsResponse
func (c *ClientWithResponses) GetStorageEndpointsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStorageEndpointsResponse, error) {
	rsp, err := c.GetStorageEndpoints(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStorageEndpointsResponse(rsp)
}

// GetAllStorageGeneralFilesWithResponse request returning *GetAllStorageGeneralFilesResponse
func (c *ClientWithResponses) GetAllStorageGeneralFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageGeneralFilesResponse, error) {
	rsp, err := c.GetAllStorageGeneralFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageGeneralFilesResponse(rsp)
}

// CreateStorageGeneralFileWithBodyWithResponse request with arbitrary body returning *CreateStorageGeneralFileResponse
func (c *ClientWithResponses) CreateStorageGeneralFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageGeneralFileResponse, error) {
	rsp, err := c.CreateStorageGeneralFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageGeneralFileResponse(rsp)
}

// DeleteStorageGeneralFileWithResponse request returning *DeleteStorageGeneralFileResponse
func (c *ClientWithResponses) DeleteStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageGeneralFileResponse, error) {
	rsp, err := c.DeleteStorageGeneralFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageGeneralFileResponse(rsp)
}

// GetOneStorageGeneralFileWithResponse request returning *GetOneStorageGeneralFileResponse
func (c *ClientWithResponses) GetOneStorageGeneralFileWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageGeneralFileResponse, error) {
	rsp, err := c.GetOneStorageGeneralFile(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageGeneralFileResponse(rsp)
}

// ReplaceStorageGeneralFileWithBodyWithResponse request with arbitrary body returning *ReplaceStorageGeneralFileResponse
func (c *ClientWithResponses) ReplaceStorageGeneralFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageGeneralFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageGeneralFileResponse, error) {
	rsp, err := c.ReplaceStorageGeneralFileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageGeneralFileResponse(rsp)
}

// GetAllStorageMapFilesWithResponse request returning *GetAllStorageMapFilesResponse
func (c *ClientWithResponses) GetAllStorageMapFilesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageMapFilesResponse, error) {
	rsp, err := c.GetAllStorageMapFiles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageMapFilesResponse(rsp)
}

// CreateStorageMapFileWithBodyWithResponse request with arbitrary body returning *CreateStorageMapFileResponse
func (c *ClientWithResponses) CreateStorageMapFileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageMapFileResponse, error) {
	rsp, err := c.CreateStorageMapFileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageMapFileResponse(rsp)
}

// DeleteStorageMapWithResponse request returning *DeleteStorageMapResponse
func (c *ClientWithResponses) DeleteStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteStorageMapResponse, error) {
	rsp, err := c.DeleteStorageMap(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageMapResponse(rsp)
}

// GetOneStorageMapWithResponse request returning *GetOneStorageMapResponse
func (c *ClientWithResponses) GetOneStorageMapWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageMapResponse, error) {
	rsp, err := c.GetOneStorageMap(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageMapResponse(rsp)
}

// ReplaceStorageMapFileWithBodyWithResponse request with arbitrary body returning *ReplaceStorageMapFileResponse
func (c *ClientWithResponses) ReplaceStorageMapFileWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error) {
	rsp, err := c.ReplaceStorageMapFileWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageMapFileResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStorageMapFileWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageMapFileParams, body ReplaceStorageMapFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageMapFileResponse, error) {
	rsp, err := c.ReplaceStorageMapFileWithTextBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageMapFileResponse(rsp)
}

// GetAllStorageSSLCertificatesWithResponse request returning *GetAllStorageSSLCertificatesResponse
func (c *ClientWithResponses) GetAllStorageSSLCertificatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllStorageSSLCertificatesResponse, error) {
	rsp, err := c.GetAllStorageSSLCertificates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllStorageSSLCertificatesResponse(rsp)
}

// CreateStorageSSLCertificateWithBodyWithResponse request with arbitrary body returning *CreateStorageSSLCertificateResponse
func (c *ClientWithResponses) CreateStorageSSLCertificateWithBodyWithResponse(ctx context.Context, params *CreateStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStorageSSLCertificateResponse, error) {
	rsp, err := c.CreateStorageSSLCertificateWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStorageSSLCertificateResponse(rsp)
}

// DeleteStorageSSLCertificateWithResponse request returning *DeleteStorageSSLCertificateResponse
func (c *ClientWithResponses) DeleteStorageSSLCertificateWithResponse(ctx context.Context, name string, params *DeleteStorageSSLCertificateParams, reqEditors ...RequestEditorFn) (*DeleteStorageSSLCertificateResponse, error) {
	rsp, err := c.DeleteStorageSSLCertificate(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStorageSSLCertificateResponse(rsp)
}

// GetOneStorageSSLCertificateWithResponse request returning *GetOneStorageSSLCertificateResponse
func (c *ClientWithResponses) GetOneStorageSSLCertificateWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetOneStorageSSLCertificateResponse, error) {
	rsp, err := c.GetOneStorageSSLCertificate(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOneStorageSSLCertificateResponse(rsp)
}

// ReplaceStorageSSLCertificateWithBodyWithResponse request with arbitrary body returning *ReplaceStorageSSLCertificateResponse
func (c *ClientWithResponses) ReplaceStorageSSLCertificateWithBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error) {
	rsp, err := c.ReplaceStorageSSLCertificateWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageSSLCertificateResponse(rsp)
}

func (c *ClientWithResponses) ReplaceStorageSSLCertificateWithTextBodyWithResponse(ctx context.Context, name string, params *ReplaceStorageSSLCertificateParams, body ReplaceStorageSSLCertificateTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceStorageSSLCertificateResponse, error) {
	rsp, err := c.ReplaceStorageSSLCertificateWithTextBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceStorageSSLCertificateResponse(rsp)
}

// GetTransactionsWithResponse request returning *GetTransactionsResponse
func (c *ClientWithResponses) GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error) {
	rsp, err := c.GetTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsResponse(rsp)
}

// StartTransactionWithResponse request returning *StartTransactionResponse
func (c *ClientWithResponses) StartTransactionWithResponse(ctx context.Context, params *StartTransactionParams, reqEditors ...RequestEditorFn) (*StartTransactionResponse, error) {
	rsp, err := c.StartTransaction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartTransactionResponse(rsp)
}

// DeleteTransactionWithResponse request returning *DeleteTransactionResponse
func (c *ClientWithResponses) DeleteTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error) {
	rsp, err := c.DeleteTransaction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionResponse(rsp)
}

// GetTransactionWithResponse request returning *GetTransactionResponse
func (c *ClientWithResponses) GetTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionResponse, error) {
	rsp, err := c.GetTransaction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionResponse(rsp)
}

// CommitTransactionWithResponse request returning *CommitTransactionResponse
func (c *ClientWithResponses) CommitTransactionWithResponse(ctx context.Context, id string, params *CommitTransactionParams, reqEditors ...RequestEditorFn) (*CommitTransactionResponse, error) {
	rsp, err := c.CommitTransaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitTransactionResponse(rsp)
}

// GetWafRulesetsWithResponse request returning *GetWafRulesetsResponse
func (c *ClientWithResponses) GetWafRulesetsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWafRulesetsResponse, error) {
	rsp, err := c.GetWafRulesets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWafRulesetsResponse(rsp)
}

// CreateWafRulesetWithBodyWithResponse request with arbitrary body returning *CreateWafRulesetResponse
func (c *ClientWithResponses) CreateWafRulesetWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWafRulesetResponse, error) {
	rsp, err := c.CreateWafRulesetWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWafRulesetResponse(rsp)
}

// DeleteWafRulesetWithResponse request returning *DeleteWafRulesetResponse
func (c *ClientWithResponses) DeleteWafRulesetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteWafRulesetResponse, error) {
	rsp, err := c.DeleteWafRuleset(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWafRulesetResponse(rsp)
}

// GetWafRulesetWithResponse request returning *GetWafRulesetResponse
func (c *ClientWithResponses) GetWafRulesetWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetWafRulesetResponse, error) {
	rsp, err := c.GetWafRuleset(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWafRulesetResponse(rsp)
}

// ReplaceWafRulesetWithBodyWithResponse request with arbitrary body returning *ReplaceWafRulesetResponse
func (c *ClientWithResponses) ReplaceWafRulesetWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceWafRulesetResponse, error) {
	rsp, err := c.ReplaceWafRulesetWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceWafRulesetResponse(rsp)
}

// GetWafFilesWithResponse request returning *GetWafFilesResponse
func (c *ClientWithResponses) GetWafFilesWithResponse(ctx context.Context, rulesetName RulesetName, params *GetWafFilesParams, reqEditors ...RequestEditorFn) (*GetWafFilesResponse, error) {
	rsp, err := c.GetWafFiles(ctx, rulesetName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWafFilesResponse(rsp)
}

// CreateWafFileWithBodyWithResponse request with arbitrary body returning *CreateWafFileResponse
func (c *ClientWithResponses) CreateWafFileWithBodyWithResponse(ctx context.Context, rulesetName RulesetName, params *CreateWafFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWafFileResponse, error) {
	rsp, err := c.CreateWafFileWithBody(ctx, rulesetName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWafFileResponse(rsp)
}

// DeleteWafFileWithResponse request returning *DeleteWafFileResponse
func (c *ClientWithResponses) DeleteWafFileWithResponse(ctx context.Context, rulesetName RulesetName, name string, params *DeleteWafFileParams, reqEditors ...RequestEditorFn) (*DeleteWafFileResponse, error) {
	rsp, err := c.DeleteWafFile(ctx, rulesetName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWafFileResponse(rsp)
}

// GetWafFileWithResponse request returning *GetWafFileResponse
func (c *ClientWithResponses) GetWafFileWithResponse(ctx context.Context, rulesetName RulesetName, name string, params *GetWafFileParams, reqEditors ...RequestEditorFn) (*GetWafFileResponse, error) {
	rsp, err := c.GetWafFile(ctx, rulesetName, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWafFileResponse(rsp)
}

// ReplaceWafFileWithBodyWithResponse request with arbitrary body returning *ReplaceWafFileResponse
func (c *ClientWithResponses) ReplaceWafFileWithBodyWithResponse(ctx context.Context, rulesetName RulesetName, name string, params *ReplaceWafFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceWafFileResponse, error) {
	rsp, err := c.ReplaceWafFileWithBody(ctx, rulesetName, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceWafFileResponse(rsp)
}

func (c *ClientWithResponses) ReplaceWafFileWithTextBodyWithResponse(ctx context.Context, rulesetName RulesetName, name string, params *ReplaceWafFileParams, body ReplaceWafFileTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceWafFileResponse, error) {
	rsp, err := c.ReplaceWafFileWithTextBody(ctx, rulesetName, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceWafFileResponse(rsp)
}

// GetKeepalivedClusterConfigurationVersionWithResponse request returning *GetKeepalivedClusterConfigurationVersionResponse
func (c *ClientWithResponses) GetKeepalivedClusterConfigurationVersionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeepalivedClusterConfigurationVersionResponse, error) {
	rsp, err := c.GetKeepalivedClusterConfigurationVersion(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeepalivedClusterConfigurationVersionResponse(rsp)
}

// GetGlobalDefsWithResponse request returning *GetGlobalDefsResponse
func (c *ClientWithResponses) GetGlobalDefsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalDefsResponse, error) {
	rsp, err := c.GetGlobalDefs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalDefsResponse(rsp)
}

// ReplaceGlobalDefsWithBodyWithResponse request with arbitrary body returning *ReplaceGlobalDefsResponse
func (c *ClientWithResponses) ReplaceGlobalDefsWithBodyWithResponse(ctx context.Context, params *ReplaceGlobalDefsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceGlobalDefsResponse, error) {
	rsp, err := c.ReplaceGlobalDefsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGlobalDefsResponse(rsp)
}

func (c *ClientWithResponses) ReplaceGlobalDefsWithResponse(ctx context.Context, params *ReplaceGlobalDefsParams, body ReplaceGlobalDefsJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceGlobalDefsResponse, error) {
	rsp, err := c.ReplaceGlobalDefs(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceGlobalDefsResponse(rsp)
}

// GetKeepalivedConfigurationWithResponse request returning *GetKeepalivedConfigurationResponse
func (c *ClientWithResponses) GetKeepalivedConfigurationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetKeepalivedConfigurationResponse, error) {
	rsp, err := c.GetKeepalivedConfiguration(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeepalivedConfigurationResponse(rsp)
}

// ReplaceKeepalivedConfigurationWithBodyWithResponse request with arbitrary body returning *ReplaceKeepalivedConfigurationResponse
func (c *ClientWithResponses) ReplaceKeepalivedConfigurationWithBodyWithResponse(ctx context.Context, params *ReplaceKeepalivedConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceKeepalivedConfigurationResponse, error) {
	rsp, err := c.ReplaceKeepalivedConfigurationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceKeepalivedConfigurationResponse(rsp)
}

func (c *ClientWithResponses) ReplaceKeepalivedConfigurationWithTextBodyWithResponse(ctx context.Context, params *ReplaceKeepalivedConfigurationParams, body ReplaceKeepalivedConfigurationTextRequestBody, reqEditors ...RequestEditorFn) (*ReplaceKeepalivedConfigurationResponse, error) {
	rsp, err := c.ReplaceKeepalivedConfigurationWithTextBody(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceKeepalivedConfigurationResponse(rsp)
}

// GetAllVRRPInstanceWithResponse request returning *GetAllVRRPInstanceResponse
func (c *ClientWithResponses) GetAllVRRPInstanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVRRPInstanceResponse, error) {
	rsp, err := c.GetAllVRRPInstance(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllVRRPInstanceResponse(rsp)
}

// CreateVRRPInstanceWithBodyWithResponse request with arbitrary body returning *CreateVRRPInstanceResponse
func (c *ClientWithResponses) CreateVRRPInstanceWithBodyWithResponse(ctx context.Context, params *CreateVRRPInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVRRPInstanceResponse, error) {
	rsp, err := c.CreateVRRPInstanceWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVRRPInstanceResponse(rsp)
}

func (c *ClientWithResponses) CreateVRRPInstanceWithResponse(ctx context.Context, params *CreateVRRPInstanceParams, body CreateVRRPInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVRRPInstanceResponse, error) {
	rsp, err := c.CreateVRRPInstance(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVRRPInstanceResponse(rsp)
}

// DeleteVRRPInstanceWithResponse request returning *DeleteVRRPInstanceResponse
func (c *ClientWithResponses) DeleteVRRPInstanceWithResponse(ctx context.Context, parentName ParentName, params *DeleteVRRPInstanceParams, reqEditors ...RequestEditorFn) (*DeleteVRRPInstanceResponse, error) {
	rsp, err := c.DeleteVRRPInstance(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVRRPInstanceResponse(rsp)
}

// GetVRRPInstanceWithResponse request returning *GetVRRPInstanceResponse
func (c *ClientWithResponses) GetVRRPInstanceWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetVRRPInstanceResponse, error) {
	rsp, err := c.GetVRRPInstance(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVRRPInstanceResponse(rsp)
}

// ReplaceVRRPInstanceWithBodyWithResponse request with arbitrary body returning *ReplaceVRRPInstanceResponse
func (c *ClientWithResponses) ReplaceVRRPInstanceWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPInstanceParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceVRRPInstanceResponse, error) {
	rsp, err := c.ReplaceVRRPInstanceWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceVRRPInstanceResponse(rsp)
}

func (c *ClientWithResponses) ReplaceVRRPInstanceWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPInstanceParams, body ReplaceVRRPInstanceJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceVRRPInstanceResponse, error) {
	rsp, err := c.ReplaceVRRPInstance(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceVRRPInstanceResponse(rsp)
}

// GetAllVRRPSyncGroupWithResponse request returning *GetAllVRRPSyncGroupResponse
func (c *ClientWithResponses) GetAllVRRPSyncGroupWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVRRPSyncGroupResponse, error) {
	rsp, err := c.GetAllVRRPSyncGroup(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllVRRPSyncGroupResponse(rsp)
}

// CreateVRRPSyncGroupWithBodyWithResponse request with arbitrary body returning *CreateVRRPSyncGroupResponse
func (c *ClientWithResponses) CreateVRRPSyncGroupWithBodyWithResponse(ctx context.Context, params *CreateVRRPSyncGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVRRPSyncGroupResponse, error) {
	rsp, err := c.CreateVRRPSyncGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVRRPSyncGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateVRRPSyncGroupWithResponse(ctx context.Context, params *CreateVRRPSyncGroupParams, body CreateVRRPSyncGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVRRPSyncGroupResponse, error) {
	rsp, err := c.CreateVRRPSyncGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVRRPSyncGroupResponse(rsp)
}

// DeleteVRRPSyncGroupWithResponse request returning *DeleteVRRPSyncGroupResponse
func (c *ClientWithResponses) DeleteVRRPSyncGroupWithResponse(ctx context.Context, parentName ParentName, params *DeleteVRRPSyncGroupParams, reqEditors ...RequestEditorFn) (*DeleteVRRPSyncGroupResponse, error) {
	rsp, err := c.DeleteVRRPSyncGroup(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVRRPSyncGroupResponse(rsp)
}

// GetVRRPSyncGroupWithResponse request returning *GetVRRPSyncGroupResponse
func (c *ClientWithResponses) GetVRRPSyncGroupWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetVRRPSyncGroupResponse, error) {
	rsp, err := c.GetVRRPSyncGroup(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVRRPSyncGroupResponse(rsp)
}

// ReplaceVRRPSyncGroupWithBodyWithResponse request with arbitrary body returning *ReplaceVRRPSyncGroupResponse
func (c *ClientWithResponses) ReplaceVRRPSyncGroupWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPSyncGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceVRRPSyncGroupResponse, error) {
	rsp, err := c.ReplaceVRRPSyncGroupWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceVRRPSyncGroupResponse(rsp)
}

func (c *ClientWithResponses) ReplaceVRRPSyncGroupWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPSyncGroupParams, body ReplaceVRRPSyncGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceVRRPSyncGroupResponse, error) {
	rsp, err := c.ReplaceVRRPSyncGroup(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceVRRPSyncGroupResponse(rsp)
}

// GetAllVRRPScriptWithResponse request returning *GetAllVRRPScriptResponse
func (c *ClientWithResponses) GetAllVRRPScriptWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllVRRPScriptResponse, error) {
	rsp, err := c.GetAllVRRPScript(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllVRRPScriptResponse(rsp)
}

// CreateVRRPScriptWithBodyWithResponse request with arbitrary body returning *CreateVRRPScriptResponse
func (c *ClientWithResponses) CreateVRRPScriptWithBodyWithResponse(ctx context.Context, params *CreateVRRPScriptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateVRRPScriptResponse, error) {
	rsp, err := c.CreateVRRPScriptWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVRRPScriptResponse(rsp)
}

func (c *ClientWithResponses) CreateVRRPScriptWithResponse(ctx context.Context, params *CreateVRRPScriptParams, body CreateVRRPScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateVRRPScriptResponse, error) {
	rsp, err := c.CreateVRRPScript(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateVRRPScriptResponse(rsp)
}

// DeleteVRRPScriptWithResponse request returning *DeleteVRRPScriptResponse
func (c *ClientWithResponses) DeleteVRRPScriptWithResponse(ctx context.Context, parentName ParentName, params *DeleteVRRPScriptParams, reqEditors ...RequestEditorFn) (*DeleteVRRPScriptResponse, error) {
	rsp, err := c.DeleteVRRPScript(ctx, parentName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteVRRPScriptResponse(rsp)
}

// GetVRRPScriptWithResponse request returning *GetVRRPScriptResponse
func (c *ClientWithResponses) GetVRRPScriptWithResponse(ctx context.Context, parentName ParentName, reqEditors ...RequestEditorFn) (*GetVRRPScriptResponse, error) {
	rsp, err := c.GetVRRPScript(ctx, parentName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetVRRPScriptResponse(rsp)
}

// ReplaceVRRPScriptWithBodyWithResponse request with arbitrary body returning *ReplaceVRRPScriptResponse
func (c *ClientWithResponses) ReplaceVRRPScriptWithBodyWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPScriptParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReplaceVRRPScriptResponse, error) {
	rsp, err := c.ReplaceVRRPScriptWithBody(ctx, parentName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceVRRPScriptResponse(rsp)
}

func (c *ClientWithResponses) ReplaceVRRPScriptWithResponse(ctx context.Context, parentName ParentName, params *ReplaceVRRPScriptParams, body ReplaceVRRPScriptJSONRequestBody, reqEditors ...RequestEditorFn) (*ReplaceVRRPScriptResponse, error) {
	rsp, err := c.ReplaceVRRPScript(ctx, parentName, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReplaceVRRPScriptResponse(rsp)
}

// GetAllKeepalivedReloadWithResponse request returning *GetAllKeepalivedReloadResponse
func (c *ClientWithResponses) GetAllKeepalivedReloadWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAllKeepalivedReloadResponse, error) {
	rsp, err := c.GetAllKeepalivedReload(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllKeepalivedReloadResponse(rsp)
}

// GetKeepalivedReloadWithResponse request returning *GetKeepalivedReloadResponse
func (c *ClientWithResponses) GetKeepalivedReloadWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeepalivedReloadResponse, error) {
	rsp, err := c.GetKeepalivedReload(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeepalivedReloadResponse(rsp)
}

// GetAllKeepalivedTransactionWithResponse request returning *GetAllKeepalivedTransactionResponse
func (c *ClientWithResponses) GetAllKeepalivedTransactionWithResponse(ctx context.Context, params *GetAllKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*GetAllKeepalivedTransactionResponse, error) {
	rsp, err := c.GetAllKeepalivedTransaction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllKeepalivedTransactionResponse(rsp)
}

// StartKeepalivedTransactionWithResponse request returning *StartKeepalivedTransactionResponse
func (c *ClientWithResponses) StartKeepalivedTransactionWithResponse(ctx context.Context, params *StartKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*StartKeepalivedTransactionResponse, error) {
	rsp, err := c.StartKeepalivedTransaction(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStartKeepalivedTransactionResponse(rsp)
}

// DeleteKeepalivedTransactionWithResponse request returning *DeleteKeepalivedTransactionResponse
func (c *ClientWithResponses) DeleteKeepalivedTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteKeepalivedTransactionResponse, error) {
	rsp, err := c.DeleteKeepalivedTransaction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteKeepalivedTransactionResponse(rsp)
}

// GetKeepalivedTransactionWithResponse request returning *GetKeepalivedTransactionResponse
func (c *ClientWithResponses) GetKeepalivedTransactionWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetKeepalivedTransactionResponse, error) {
	rsp, err := c.GetKeepalivedTransaction(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeepalivedTransactionResponse(rsp)
}

// CommitKeepalivedTransactionWithResponse request returning *CommitKeepalivedTransactionResponse
func (c *ClientWithResponses) CommitKeepalivedTransactionWithResponse(ctx context.Context, id string, params *CommitKeepalivedTransactionParams, reqEditors ...RequestEditorFn) (*CommitKeepalivedTransactionResponse, error) {
	rsp, err := c.CommitKeepalivedTransaction(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitKeepalivedTransactionResponse(rsp)
}

// GetSpecificationWithResponse request returning *GetSpecificationResponse
func (c *ClientWithResponses) GetSpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSpecificationResponse, error) {
	rsp, err := c.GetSpecification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpecificationResponse(rsp)
}

// GetOpenapiv3SpecificationWithResponse request returning *GetOpenapiv3SpecificationResponse
func (c *ClientWithResponses) GetOpenapiv3SpecificationWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOpenapiv3SpecificationResponse, error) {
	rsp, err := c.GetOpenapiv3Specification(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOpenapiv3SpecificationResponse(rsp)
}

// GetSummaryWithResponse request returning *GetSummaryResponse
func (c *ClientWithResponses) GetSummaryWithResponse(ctx context.Context, params *GetSummaryParams, reqEditors ...RequestEditorFn) (*GetSummaryResponse, error) {
	rsp, err := c.GetSummary(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSummaryResponse(rsp)
}

// ParseGetAPIEndpointsResponse parses an HTTP response from a GetAPIEndpointsWithResponse call
func ParseGetAPIEndpointsResponse(rsp *http.Response) (*GetAPIEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAPIEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAlohaEndpointsResponse parses an HTTP response from a GetAlohaEndpointsWithResponse call
func ParseGetAlohaEndpointsResponse(rsp *http.Response) (*GetAlohaEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlohaEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAlohaActionsResponse parses an HTTP response from a GetAlohaActionsWithResponse call
func ParseGetAlohaActionsResponse(rsp *http.Response) (*GetAlohaActionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlohaActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlohaActions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExecuteAlohaActionResponse parses an HTTP response from a ExecuteAlohaActionWithResponse call
func ParseExecuteAlohaActionResponse(rsp *http.Response) (*ExecuteAlohaActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteAlohaActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlohaAction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAlohaActionResponse parses an HTTP response from a GetAlohaActionWithResponse call
func ParseGetAlohaActionResponse(rsp *http.Response) (*GetAlohaActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAlohaActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AlohaAction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostClusterResponse parses an HTTP response from a PostClusterWithResponse call
func ParsePostClusterResponse(rsp *http.Response) (*PostClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditClusterResponse parses an HTTP response from a EditClusterWithResponse call
func ParseEditClusterResponse(rsp *http.Response) (*EditClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseInitiateCertificateRefreshResponse parses an HTTP response from a InitiateCertificateRefreshWithResponse call
func ParseInitiateCertificateRefreshResponse(rsp *http.Response) (*InitiateCertificateRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InitiateCertificateRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFactsResponse parses an HTTP response from a GetFactsWithResponse call
func ParseGetFactsResponse(rsp *http.Response) (*GetFactsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFactsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Facts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest Facts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHealthResponse parses an HTTP response from a GetHealthWithResponse call
func ParseGetHealthResponse(rsp *http.Response) (*GetHealthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHealthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Health
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetInfoResponse parses an HTTP response from a GetInfoWithResponse call
func ParseGetInfoResponse(rsp *http.Response) (*GetInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Info
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAWSRegionsResponse parses an HTTP response from a GetAWSRegionsWithResponse call
func ParseGetAWSRegionsResponse(rsp *http.Response) (*GetAWSRegionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAWSRegionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AwsRegions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAWSRegionResponse parses an HTTP response from a CreateAWSRegionWithResponse call
func ParseCreateAWSRegionResponse(rsp *http.Response) (*CreateAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AwsRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAWSRegionResponse parses an HTTP response from a DeleteAWSRegionWithResponse call
func ParseDeleteAWSRegionResponse(rsp *http.Response) (*DeleteAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAWSRegionResponse parses an HTTP response from a GetAWSRegionWithResponse call
func ParseGetAWSRegionResponse(rsp *http.Response) (*GetAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AwsRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAWSRegionResponse parses an HTTP response from a ReplaceAWSRegionWithResponse call
func ParseReplaceAWSRegionResponse(rsp *http.Response) (*ReplaceAWSRegionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAWSRegionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AwsRegion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConsulsResponse parses an HTTP response from a GetConsulsWithResponse call
func ParseGetConsulsResponse(rsp *http.Response) (*GetConsulsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsulsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consuls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateConsulResponse parses an HTTP response from a CreateConsulWithResponse call
func ParseCreateConsulResponse(rsp *http.Response) (*CreateConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Consul
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteConsulResponse parses an HTTP response from a DeleteConsulWithResponse call
func ParseDeleteConsulResponse(rsp *http.Response) (*DeleteConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConsulResponse parses an HTTP response from a GetConsulWithResponse call
func ParseGetConsulResponse(rsp *http.Response) (*GetConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consul
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceConsulResponse parses an HTTP response from a ReplaceConsulWithResponse call
func ParseReplaceConsulResponse(rsp *http.Response) (*ReplaceConsulResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceConsulResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Consul
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesEndpointsResponse parses an HTTP response from a GetServicesEndpointsWithResponse call
func ParseGetServicesEndpointsResponse(rsp *http.Response) (*GetServicesEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseRunActionsResponse parses an HTTP response from a RunActionsWithResponse call
func ParseRunActionsResponse(rsp *http.Response) (*RunActionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Actions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGitEndpointsResponse parses an HTTP response from a GetGitEndpointsWithResponse call
func ParseGetGitEndpointsResponse(rsp *http.Response) (*GetGitEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGitEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGitActionsResponse parses an HTTP response from a GetGitActionsWithResponse call
func ParseGetGitActionsResponse(rsp *http.Response) (*GetGitActionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGitActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitActions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExecuteGitActionResponse parses an HTTP response from a ExecuteGitActionWithResponse call
func ParseExecuteGitActionResponse(rsp *http.Response) (*ExecuteGitActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExecuteGitActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGitActionResponse parses an HTTP response from a GetGitActionWithResponse call
func ParseGetGitActionResponse(rsp *http.Response) (*GetGitActionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGitActionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitAction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGitSettingsResponse parses an HTTP response from a GetGitSettingsWithResponse call
func ParseGetGitSettingsResponse(rsp *http.Response) (*GetGitSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGitSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceGitSettingsResponse parses an HTTP response from a ReplaceGitSettingsWithResponse call
func ParseReplaceGitSettingsResponse(rsp *http.Response) (*ReplaceGitSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceGitSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitSettings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHaproxyEndpointsResponse parses an HTTP response from a GetHaproxyEndpointsWithResponse call
func ParseGetHaproxyEndpointsResponse(rsp *http.Response) (*GetHaproxyEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHaproxyEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationEndpointsResponse parses an HTTP response from a GetConfigurationEndpointsWithResponse call
func ParseGetConfigurationEndpointsResponse(rsp *http.Response) (*GetConfigurationEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendsResponse parses an HTTP response from a GetBackendsWithResponse call
func ParseGetBackendsResponse(rsp *http.Response) (*GetBackendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backends
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBackendResponse parses an HTTP response from a CreateBackendWithResponse call
func ParseCreateBackendResponse(rsp *http.Response) (*CreateBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBackendResponse parses an HTTP response from a DeleteBackendWithResponse call
func ParseDeleteBackendResponse(rsp *http.Response) (*DeleteBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendResponse parses an HTTP response from a GetBackendWithResponse call
func ParseGetBackendResponse(rsp *http.Response) (*GetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBackendResponse parses an HTTP response from a ReplaceBackendWithResponse call
func ParseReplaceBackendResponse(rsp *http.Response) (*ReplaceBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Backend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclBackendResponse parses an HTTP response from a GetAllAclBackendWithResponse call
func ParseGetAllAclBackendResponse(rsp *http.Response) (*GetAllAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclBackendResponse parses an HTTP response from a ReplaceAllAclBackendWithResponse call
func ParseReplaceAllAclBackendResponse(rsp *http.Response) (*ReplaceAllAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclBackendResponse parses an HTTP response from a DeleteAclBackendWithResponse call
func ParseDeleteAclBackendResponse(rsp *http.Response) (*DeleteAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclBackendResponse parses an HTTP response from a GetAclBackendWithResponse call
func ParseGetAclBackendResponse(rsp *http.Response) (*GetAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclBackendResponse parses an HTTP response from a CreateAclBackendWithResponse call
func ParseCreateAclBackendResponse(rsp *http.Response) (*CreateAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclBackendResponse parses an HTTP response from a ReplaceAclBackendWithResponse call
func ParseReplaceAclBackendResponse(rsp *http.Response) (*ReplaceAclBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllFilterBackendResponse parses an HTTP response from a GetAllFilterBackendWithResponse call
func ParseGetAllFilterBackendResponse(rsp *http.Response) (*GetAllFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllFilterBackendResponse parses an HTTP response from a ReplaceAllFilterBackendWithResponse call
func ParseReplaceAllFilterBackendResponse(rsp *http.Response) (*ReplaceAllFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFilterBackendResponse parses an HTTP response from a DeleteFilterBackendWithResponse call
func ParseDeleteFilterBackendResponse(rsp *http.Response) (*DeleteFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFilterBackendResponse parses an HTTP response from a GetFilterBackendWithResponse call
func ParseGetFilterBackendResponse(rsp *http.Response) (*GetFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFilterBackendResponse parses an HTTP response from a CreateFilterBackendWithResponse call
func ParseCreateFilterBackendResponse(rsp *http.Response) (*CreateFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFilterBackendResponse parses an HTTP response from a ReplaceFilterBackendWithResponse call
func ParseReplaceFilterBackendResponse(rsp *http.Response) (*ReplaceFilterBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFilterBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPAfterResponseRuleBackendResponse parses an HTTP response from a GetAllHTTPAfterResponseRuleBackendWithResponse call
func ParseGetAllHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*GetAllHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPAfterResponseRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPAfterResponseRuleBackendWithResponse call
func ParseReplaceAllHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPAfterResponseRuleBackendResponse parses an HTTP response from a DeleteHTTPAfterResponseRuleBackendWithResponse call
func ParseDeleteHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*DeleteHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPAfterResponseRuleBackendResponse parses an HTTP response from a GetHTTPAfterResponseRuleBackendWithResponse call
func ParseGetHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*GetHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPAfterResponseRuleBackendResponse parses an HTTP response from a CreateHTTPAfterResponseRuleBackendWithResponse call
func ParseCreateHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*CreateHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPAfterResponseRuleBackendResponse parses an HTTP response from a ReplaceHTTPAfterResponseRuleBackendWithResponse call
func ParseReplaceHTTPAfterResponseRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPAfterResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPAfterResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPCheckBackendResponse parses an HTTP response from a GetAllHTTPCheckBackendWithResponse call
func ParseGetAllHTTPCheckBackendResponse(rsp *http.Response) (*GetAllHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPCheckBackendResponse parses an HTTP response from a ReplaceAllHTTPCheckBackendWithResponse call
func ParseReplaceAllHTTPCheckBackendResponse(rsp *http.Response) (*ReplaceAllHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPCheckBackendResponse parses an HTTP response from a DeleteHTTPCheckBackendWithResponse call
func ParseDeleteHTTPCheckBackendResponse(rsp *http.Response) (*DeleteHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPCheckBackendResponse parses an HTTP response from a GetHTTPCheckBackendWithResponse call
func ParseGetHTTPCheckBackendResponse(rsp *http.Response) (*GetHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPCheckBackendResponse parses an HTTP response from a CreateHTTPCheckBackendWithResponse call
func ParseCreateHTTPCheckBackendResponse(rsp *http.Response) (*CreateHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPCheckBackendResponse parses an HTTP response from a ReplaceHTTPCheckBackendWithResponse call
func ParseReplaceHTTPCheckBackendResponse(rsp *http.Response) (*ReplaceHTTPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPErrorRuleBackendResponse parses an HTTP response from a GetAllHTTPErrorRuleBackendWithResponse call
func ParseGetAllHTTPErrorRuleBackendResponse(rsp *http.Response) (*GetAllHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPErrorRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPErrorRuleBackendWithResponse call
func ParseReplaceAllHTTPErrorRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorRuleBackendResponse parses an HTTP response from a DeleteHTTPErrorRuleBackendWithResponse call
func ParseDeleteHTTPErrorRuleBackendResponse(rsp *http.Response) (*DeleteHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorRuleBackendResponse parses an HTTP response from a GetHTTPErrorRuleBackendWithResponse call
func ParseGetHTTPErrorRuleBackendResponse(rsp *http.Response) (*GetHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorRuleBackendResponse parses an HTTP response from a CreateHTTPErrorRuleBackendWithResponse call
func ParseCreateHTTPErrorRuleBackendResponse(rsp *http.Response) (*CreateHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorRuleBackendResponse parses an HTTP response from a ReplaceHTTPErrorRuleBackendWithResponse call
func ParseReplaceHTTPErrorRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPErrorRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPRequestRuleBackendResponse parses an HTTP response from a GetAllHTTPRequestRuleBackendWithResponse call
func ParseGetAllHTTPRequestRuleBackendResponse(rsp *http.Response) (*GetAllHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPRequestRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPRequestRuleBackendWithResponse call
func ParseReplaceAllHTTPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPRequestRuleBackendResponse parses an HTTP response from a DeleteHTTPRequestRuleBackendWithResponse call
func ParseDeleteHTTPRequestRuleBackendResponse(rsp *http.Response) (*DeleteHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPRequestRuleBackendResponse parses an HTTP response from a GetHTTPRequestRuleBackendWithResponse call
func ParseGetHTTPRequestRuleBackendResponse(rsp *http.Response) (*GetHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPRequestRuleBackendResponse parses an HTTP response from a CreateHTTPRequestRuleBackendWithResponse call
func ParseCreateHTTPRequestRuleBackendResponse(rsp *http.Response) (*CreateHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPRequestRuleBackendResponse parses an HTTP response from a ReplaceHTTPRequestRuleBackendWithResponse call
func ParseReplaceHTTPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPResponseRuleBackendResponse parses an HTTP response from a GetAllHTTPResponseRuleBackendWithResponse call
func ParseGetAllHTTPResponseRuleBackendResponse(rsp *http.Response) (*GetAllHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPResponseRuleBackendResponse parses an HTTP response from a ReplaceAllHTTPResponseRuleBackendWithResponse call
func ParseReplaceAllHTTPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceAllHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPResponseRuleBackendResponse parses an HTTP response from a DeleteHTTPResponseRuleBackendWithResponse call
func ParseDeleteHTTPResponseRuleBackendResponse(rsp *http.Response) (*DeleteHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPResponseRuleBackendResponse parses an HTTP response from a GetHTTPResponseRuleBackendWithResponse call
func ParseGetHTTPResponseRuleBackendResponse(rsp *http.Response) (*GetHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPResponseRuleBackendResponse parses an HTTP response from a CreateHTTPResponseRuleBackendWithResponse call
func ParseCreateHTTPResponseRuleBackendResponse(rsp *http.Response) (*CreateHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPResponseRuleBackendResponse parses an HTTP response from a ReplaceHTTPResponseRuleBackendWithResponse call
func ParseReplaceHTTPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceHTTPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetBackendResponse parses an HTTP response from a GetAllLogTargetBackendWithResponse call
func ParseGetAllLogTargetBackendResponse(rsp *http.Response) (*GetAllLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetBackendResponse parses an HTTP response from a ReplaceAllLogTargetBackendWithResponse call
func ParseReplaceAllLogTargetBackendResponse(rsp *http.Response) (*ReplaceAllLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetBackendResponse parses an HTTP response from a DeleteLogTargetBackendWithResponse call
func ParseDeleteLogTargetBackendResponse(rsp *http.Response) (*DeleteLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetBackendResponse parses an HTTP response from a GetLogTargetBackendWithResponse call
func ParseGetLogTargetBackendResponse(rsp *http.Response) (*GetLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetBackendResponse parses an HTTP response from a CreateLogTargetBackendWithResponse call
func ParseCreateLogTargetBackendResponse(rsp *http.Response) (*CreateLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetBackendResponse parses an HTTP response from a ReplaceLogTargetBackendWithResponse call
func ParseReplaceLogTargetBackendResponse(rsp *http.Response) (*ReplaceLogTargetBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerSwitchingRulesResponse parses an HTTP response from a GetServerSwitchingRulesWithResponse call
func ParseGetServerSwitchingRulesResponse(rsp *http.Response) (*GetServerSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerSwitchingRulesResponse parses an HTTP response from a ReplaceServerSwitchingRulesWithResponse call
func ParseReplaceServerSwitchingRulesResponse(rsp *http.Response) (*ReplaceServerSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerSwitchingRuleResponse parses an HTTP response from a DeleteServerSwitchingRuleWithResponse call
func ParseDeleteServerSwitchingRuleResponse(rsp *http.Response) (*DeleteServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerSwitchingRuleResponse parses an HTTP response from a GetServerSwitchingRuleWithResponse call
func ParseGetServerSwitchingRuleResponse(rsp *http.Response) (*GetServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerSwitchingRuleResponse parses an HTTP response from a CreateServerSwitchingRuleWithResponse call
func ParseCreateServerSwitchingRuleResponse(rsp *http.Response) (*CreateServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerSwitchingRuleResponse parses an HTTP response from a ReplaceServerSwitchingRuleWithResponse call
func ParseReplaceServerSwitchingRuleResponse(rsp *http.Response) (*ReplaceServerSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerTemplatesResponse parses an HTTP response from a GetServerTemplatesWithResponse call
func ParseGetServerTemplatesResponse(rsp *http.Response) (*GetServerTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTemplates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerTemplateResponse parses an HTTP response from a CreateServerTemplateWithResponse call
func ParseCreateServerTemplateResponse(rsp *http.Response) (*CreateServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerTemplateResponse parses an HTTP response from a DeleteServerTemplateWithResponse call
func ParseDeleteServerTemplateResponse(rsp *http.Response) (*DeleteServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerTemplateResponse parses an HTTP response from a GetServerTemplateWithResponse call
func ParseGetServerTemplateResponse(rsp *http.Response) (*GetServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerTemplateResponse parses an HTTP response from a ReplaceServerTemplateWithResponse call
func ParseReplaceServerTemplateResponse(rsp *http.Response) (*ReplaceServerTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest ServerTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllServerBackendResponse parses an HTTP response from a GetAllServerBackendWithResponse call
func ParseGetAllServerBackendResponse(rsp *http.Response) (*GetAllServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Servers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerBackendResponse parses an HTTP response from a CreateServerBackendWithResponse call
func ParseCreateServerBackendResponse(rsp *http.Response) (*CreateServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerBackendResponse parses an HTTP response from a DeleteServerBackendWithResponse call
func ParseDeleteServerBackendResponse(rsp *http.Response) (*DeleteServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerBackendResponse parses an HTTP response from a GetServerBackendWithResponse call
func ParseGetServerBackendResponse(rsp *http.Response) (*GetServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerBackendResponse parses an HTTP response from a ReplaceServerBackendWithResponse call
func ParseReplaceServerBackendResponse(rsp *http.Response) (*ReplaceServerBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickRulesResponse parses an HTTP response from a GetStickRulesWithResponse call
func ParseGetStickRulesResponse(rsp *http.Response) (*GetStickRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStickRulesResponse parses an HTTP response from a ReplaceStickRulesWithResponse call
func ParseReplaceStickRulesResponse(rsp *http.Response) (*ReplaceStickRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStickRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest StickRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStickRuleResponse parses an HTTP response from a DeleteStickRuleWithResponse call
func ParseDeleteStickRuleResponse(rsp *http.Response) (*DeleteStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickRuleResponse parses an HTTP response from a GetStickRuleWithResponse call
func ParseGetStickRuleResponse(rsp *http.Response) (*GetStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStickRuleResponse parses an HTTP response from a CreateStickRuleWithResponse call
func ParseCreateStickRuleResponse(rsp *http.Response) (*CreateStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStickRuleResponse parses an HTTP response from a ReplaceStickRuleWithResponse call
func ParseReplaceStickRuleResponse(rsp *http.Response) (*ReplaceStickRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStickRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest StickRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPCheckBackendResponse parses an HTTP response from a GetAllTCPCheckBackendWithResponse call
func ParseGetAllTCPCheckBackendResponse(rsp *http.Response) (*GetAllTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPCheckBackendResponse parses an HTTP response from a ReplaceAllTCPCheckBackendWithResponse call
func ParseReplaceAllTCPCheckBackendResponse(rsp *http.Response) (*ReplaceAllTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPCheckBackendResponse parses an HTTP response from a DeleteTCPCheckBackendWithResponse call
func ParseDeleteTCPCheckBackendResponse(rsp *http.Response) (*DeleteTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPCheckBackendResponse parses an HTTP response from a GetTCPCheckBackendWithResponse call
func ParseGetTCPCheckBackendResponse(rsp *http.Response) (*GetTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPCheckBackendResponse parses an HTTP response from a CreateTCPCheckBackendWithResponse call
func ParseCreateTCPCheckBackendResponse(rsp *http.Response) (*CreateTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPCheckBackendResponse parses an HTTP response from a ReplaceTCPCheckBackendWithResponse call
func ParseReplaceTCPCheckBackendResponse(rsp *http.Response) (*ReplaceTCPCheckBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPCheckBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPRequestRuleBackendResponse parses an HTTP response from a GetAllTCPRequestRuleBackendWithResponse call
func ParseGetAllTCPRequestRuleBackendResponse(rsp *http.Response) (*GetAllTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPRequestRuleBackendResponse parses an HTTP response from a ReplaceAllTCPRequestRuleBackendWithResponse call
func ParseReplaceAllTCPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceAllTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPRequestRuleBackendResponse parses an HTTP response from a DeleteTCPRequestRuleBackendWithResponse call
func ParseDeleteTCPRequestRuleBackendResponse(rsp *http.Response) (*DeleteTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPRequestRuleBackendResponse parses an HTTP response from a GetTCPRequestRuleBackendWithResponse call
func ParseGetTCPRequestRuleBackendResponse(rsp *http.Response) (*GetTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPRequestRuleBackendResponse parses an HTTP response from a CreateTCPRequestRuleBackendWithResponse call
func ParseCreateTCPRequestRuleBackendResponse(rsp *http.Response) (*CreateTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPRequestRuleBackendResponse parses an HTTP response from a ReplaceTCPRequestRuleBackendWithResponse call
func ParseReplaceTCPRequestRuleBackendResponse(rsp *http.Response) (*ReplaceTCPRequestRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPRequestRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPResponseRuleBackendResponse parses an HTTP response from a GetAllTCPResponseRuleBackendWithResponse call
func ParseGetAllTCPResponseRuleBackendResponse(rsp *http.Response) (*GetAllTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPResponseRuleBackendResponse parses an HTTP response from a ReplaceAllTCPResponseRuleBackendWithResponse call
func ParseReplaceAllTCPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceAllTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPResponseRuleBackendResponse parses an HTTP response from a DeleteTCPResponseRuleBackendWithResponse call
func ParseDeleteTCPResponseRuleBackendResponse(rsp *http.Response) (*DeleteTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPResponseRuleBackendResponse parses an HTTP response from a GetTCPResponseRuleBackendWithResponse call
func ParseGetTCPResponseRuleBackendResponse(rsp *http.Response) (*GetTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPResponseRuleBackendResponse parses an HTTP response from a CreateTCPResponseRuleBackendWithResponse call
func ParseCreateTCPResponseRuleBackendResponse(rsp *http.Response) (*CreateTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPResponseRuleBackendResponse parses an HTTP response from a ReplaceTCPResponseRuleBackendWithResponse call
func ParseReplaceTCPResponseRuleBackendResponse(rsp *http.Response) (*ReplaceTCPResponseRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPResponseRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllWafBodyRuleBackendResponse parses an HTTP response from a GetAllWafBodyRuleBackendWithResponse call
func ParseGetAllWafBodyRuleBackendResponse(rsp *http.Response) (*GetAllWafBodyRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllWafBodyRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafBodyRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllWafBodyRuleBackendResponse parses an HTTP response from a ReplaceAllWafBodyRuleBackendWithResponse call
func ParseReplaceAllWafBodyRuleBackendResponse(rsp *http.Response) (*ReplaceAllWafBodyRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllWafBodyRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafBodyRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest WafBodyRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteWafBodyRuleBackendResponse parses an HTTP response from a DeleteWafBodyRuleBackendWithResponse call
func ParseDeleteWafBodyRuleBackendResponse(rsp *http.Response) (*DeleteWafBodyRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWafBodyRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWafBodyRuleBackendResponse parses an HTTP response from a GetWafBodyRuleBackendWithResponse call
func ParseGetWafBodyRuleBackendResponse(rsp *http.Response) (*GetWafBodyRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWafBodyRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateWafBodyRuleBackendResponse parses an HTTP response from a CreateWafBodyRuleBackendWithResponse call
func ParseCreateWafBodyRuleBackendResponse(rsp *http.Response) (*CreateWafBodyRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWafBodyRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceWafBodyRuleBackendResponse parses an HTTP response from a ReplaceWafBodyRuleBackendWithResponse call
func ParseReplaceWafBodyRuleBackendResponse(rsp *http.Response) (*ReplaceWafBodyRuleBackendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceWafBodyRuleBackendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBotmgmtProfilesResponse parses an HTTP response from a GetBotmgmtProfilesWithResponse call
func ParseGetBotmgmtProfilesResponse(rsp *http.Response) (*GetBotmgmtProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBotmgmtProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotmgmtProfiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBotmgmtProfileResponse parses an HTTP response from a CreateBotmgmtProfileWithResponse call
func ParseCreateBotmgmtProfileResponse(rsp *http.Response) (*CreateBotmgmtProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBotmgmtProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BotmgmtProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BotmgmtProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBotmgmtProfileResponse parses an HTTP response from a DeleteBotmgmtProfileWithResponse call
func ParseDeleteBotmgmtProfileResponse(rsp *http.Response) (*DeleteBotmgmtProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBotmgmtProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBotmgmtProfileResponse parses an HTTP response from a GetBotmgmtProfileWithResponse call
func ParseGetBotmgmtProfileResponse(rsp *http.Response) (*GetBotmgmtProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBotmgmtProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotmgmtProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditBotmgmtProfileResponse parses an HTTP response from a EditBotmgmtProfileWithResponse call
func ParseEditBotmgmtProfileResponse(rsp *http.Response) (*EditBotmgmtProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditBotmgmtProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BotmgmtProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BotmgmtProfile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCachesResponse parses an HTTP response from a GetCachesWithResponse call
func ParseGetCachesResponse(rsp *http.Response) (*GetCachesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCachesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Caches
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCacheResponse parses an HTTP response from a CreateCacheWithResponse call
func ParseCreateCacheResponse(rsp *http.Response) (*CreateCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCacheResponse parses an HTTP response from a DeleteCacheWithResponse call
func ParseDeleteCacheResponse(rsp *http.Response) (*DeleteCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCacheResponse parses an HTTP response from a GetCacheWithResponse call
func ParseGetCacheResponse(rsp *http.Response) (*GetCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceCacheResponse parses an HTTP response from a ReplaceCacheWithResponse call
func ParseReplaceCacheResponse(rsp *http.Response) (*ReplaceCacheResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceCacheResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Cache
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCaptchasResponse parses an HTTP response from a GetCaptchasWithResponse call
func ParseGetCaptchasResponse(rsp *http.Response) (*GetCaptchasResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaptchasResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Captchas
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCaptchaResponse parses an HTTP response from a CreateCaptchaWithResponse call
func ParseCreateCaptchaResponse(rsp *http.Response) (*CreateCaptchaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCaptchaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Captcha
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Captcha
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCaptchaResponse parses an HTTP response from a DeleteCaptchaWithResponse call
func ParseDeleteCaptchaResponse(rsp *http.Response) (*DeleteCaptchaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCaptchaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCaptchaResponse parses an HTTP response from a GetCaptchaWithResponse call
func ParseGetCaptchaResponse(rsp *http.Response) (*GetCaptchaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaptchaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Captcha
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditCaptchaResponse parses an HTTP response from a EditCaptchaWithResponse call
func ParseEditCaptchaResponse(rsp *http.Response) (*EditCaptchaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCaptchaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Captcha
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Captcha
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClusterConfigurationVersionResponse parses an HTTP response from a GetClusterConfigurationVersionWithResponse call
func ParseGetClusterConfigurationVersionResponse(rsp *http.Response) (*GetClusterConfigurationVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterConfigurationVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtLoadsResponse parses an HTTP response from a GetCrtLoadsWithResponse call
func ParseGetCrtLoadsResponse(rsp *http.Response) (*GetCrtLoadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtLoadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtLoads
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCrtLoadResponse parses an HTTP response from a CreateCrtLoadWithResponse call
func ParseCreateCrtLoadResponse(rsp *http.Response) (*CreateCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCrtLoadResponse parses an HTTP response from a DeleteCrtLoadWithResponse call
func ParseDeleteCrtLoadResponse(rsp *http.Response) (*DeleteCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtLoadResponse parses an HTTP response from a GetCrtLoadWithResponse call
func ParseGetCrtLoadResponse(rsp *http.Response) (*GetCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceCrtLoadResponse parses an HTTP response from a ReplaceCrtLoadWithResponse call
func ParseReplaceCrtLoadResponse(rsp *http.Response) (*ReplaceCrtLoadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceCrtLoadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtLoad
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtStoresResponse parses an HTTP response from a GetCrtStoresWithResponse call
func ParseGetCrtStoresResponse(rsp *http.Response) (*GetCrtStoresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtStoresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtStores
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateCrtStoreResponse parses an HTTP response from a CreateCrtStoreWithResponse call
func ParseCreateCrtStoreResponse(rsp *http.Response) (*CreateCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteCrtStoreResponse parses an HTTP response from a DeleteCrtStoreWithResponse call
func ParseDeleteCrtStoreResponse(rsp *http.Response) (*DeleteCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCrtStoreResponse parses an HTTP response from a GetCrtStoreWithResponse call
func ParseGetCrtStoreResponse(rsp *http.Response) (*GetCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditCrtStoreResponse parses an HTTP response from a EditCrtStoreWithResponse call
func ParseEditCrtStoreResponse(rsp *http.Response) (*EditCrtStoreResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCrtStoreResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CrtStore
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDefaultsSectionsResponse parses an HTTP response from a GetDefaultsSectionsWithResponse call
func ParseGetDefaultsSectionsResponse(rsp *http.Response) (*GetDefaultsSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultsSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DefaultsSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDefaultsSectionResponse parses an HTTP response from a CreateDefaultsSectionWithResponse call
func ParseCreateDefaultsSectionResponse(rsp *http.Response) (*CreateDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDefaultsSectionResponse parses an HTTP response from a DeleteDefaultsSectionWithResponse call
func ParseDeleteDefaultsSectionResponse(rsp *http.Response) (*DeleteDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDefaultsSectionResponse parses an HTTP response from a GetDefaultsSectionWithResponse call
func ParseGetDefaultsSectionResponse(rsp *http.Response) (*GetDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDefaultsSectionResponse parses an HTTP response from a ReplaceDefaultsSectionWithResponse call
func ParseReplaceDefaultsSectionResponse(rsp *http.Response) (*ReplaceDefaultsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDefaultsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Defaults
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPCheckDefaultsResponse parses an HTTP response from a GetAllHTTPCheckDefaultsWithResponse call
func ParseGetAllHTTPCheckDefaultsResponse(rsp *http.Response) (*GetAllHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPCheckDefaultsResponse parses an HTTP response from a ReplaceAllHTTPCheckDefaultsWithResponse call
func ParseReplaceAllHTTPCheckDefaultsResponse(rsp *http.Response) (*ReplaceAllHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPCheckDefaultsResponse parses an HTTP response from a DeleteHTTPCheckDefaultsWithResponse call
func ParseDeleteHTTPCheckDefaultsResponse(rsp *http.Response) (*DeleteHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPCheckDefaultsResponse parses an HTTP response from a GetHTTPCheckDefaultsWithResponse call
func ParseGetHTTPCheckDefaultsResponse(rsp *http.Response) (*GetHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPCheckDefaultsResponse parses an HTTP response from a CreateHTTPCheckDefaultsWithResponse call
func ParseCreateHTTPCheckDefaultsResponse(rsp *http.Response) (*CreateHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPCheckDefaultsResponse parses an HTTP response from a ReplaceHTTPCheckDefaultsWithResponse call
func ParseReplaceHTTPCheckDefaultsResponse(rsp *http.Response) (*ReplaceHTTPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPErrorRuleDefaultsResponse parses an HTTP response from a GetAllHTTPErrorRuleDefaultsWithResponse call
func ParseGetAllHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*GetAllHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPErrorRuleDefaultsResponse parses an HTTP response from a ReplaceAllHTTPErrorRuleDefaultsWithResponse call
func ParseReplaceAllHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*ReplaceAllHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorRuleDefaultsResponse parses an HTTP response from a DeleteHTTPErrorRuleDefaultsWithResponse call
func ParseDeleteHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*DeleteHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorRuleDefaultsResponse parses an HTTP response from a GetHTTPErrorRuleDefaultsWithResponse call
func ParseGetHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*GetHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorRuleDefaultsResponse parses an HTTP response from a CreateHTTPErrorRuleDefaultsWithResponse call
func ParseCreateHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*CreateHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorRuleDefaultsResponse parses an HTTP response from a ReplaceHTTPErrorRuleDefaultsWithResponse call
func ParseReplaceHTTPErrorRuleDefaultsResponse(rsp *http.Response) (*ReplaceHTTPErrorRuleDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorRuleDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetDefaultsResponse parses an HTTP response from a GetAllLogTargetDefaultsWithResponse call
func ParseGetAllLogTargetDefaultsResponse(rsp *http.Response) (*GetAllLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetDefaultsResponse parses an HTTP response from a ReplaceAllLogTargetDefaultsWithResponse call
func ParseReplaceAllLogTargetDefaultsResponse(rsp *http.Response) (*ReplaceAllLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetDefaultsResponse parses an HTTP response from a DeleteLogTargetDefaultsWithResponse call
func ParseDeleteLogTargetDefaultsResponse(rsp *http.Response) (*DeleteLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetDefaultsResponse parses an HTTP response from a GetLogTargetDefaultsWithResponse call
func ParseGetLogTargetDefaultsResponse(rsp *http.Response) (*GetLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetDefaultsResponse parses an HTTP response from a CreateLogTargetDefaultsWithResponse call
func ParseCreateLogTargetDefaultsResponse(rsp *http.Response) (*CreateLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetDefaultsResponse parses an HTTP response from a ReplaceLogTargetDefaultsWithResponse call
func ParseReplaceLogTargetDefaultsResponse(rsp *http.Response) (*ReplaceLogTargetDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPCheckDefaultsResponse parses an HTTP response from a GetAllTCPCheckDefaultsWithResponse call
func ParseGetAllTCPCheckDefaultsResponse(rsp *http.Response) (*GetAllTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPCheckDefaultsResponse parses an HTTP response from a ReplaceAllTCPCheckDefaultsWithResponse call
func ParseReplaceAllTCPCheckDefaultsResponse(rsp *http.Response) (*ReplaceAllTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpChecks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPCheckDefaultsResponse parses an HTTP response from a DeleteTCPCheckDefaultsWithResponse call
func ParseDeleteTCPCheckDefaultsResponse(rsp *http.Response) (*DeleteTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPCheckDefaultsResponse parses an HTTP response from a GetTCPCheckDefaultsWithResponse call
func ParseGetTCPCheckDefaultsResponse(rsp *http.Response) (*GetTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPCheckDefaultsResponse parses an HTTP response from a CreateTCPCheckDefaultsWithResponse call
func ParseCreateTCPCheckDefaultsResponse(rsp *http.Response) (*CreateTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPCheckDefaultsResponse parses an HTTP response from a ReplaceTCPCheckDefaultsWithResponse call
func ParseReplaceTCPCheckDefaultsResponse(rsp *http.Response) (*ReplaceTCPCheckDefaultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPCheckDefaultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpCheck
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDynamicUpdateRulesResponse parses an HTTP response from a GetDynamicUpdateRulesWithResponse call
func ParseGetDynamicUpdateRulesResponse(rsp *http.Response) (*GetDynamicUpdateRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDynamicUpdateRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DynamicUpdateRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDynamicUpdateRulesResponse parses an HTTP response from a ReplaceDynamicUpdateRulesWithResponse call
func ParseReplaceDynamicUpdateRulesResponse(rsp *http.Response) (*ReplaceDynamicUpdateRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDynamicUpdateRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DynamicUpdateRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DynamicUpdateRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDynamicUpdateRuleResponse parses an HTTP response from a DeleteDynamicUpdateRuleWithResponse call
func ParseDeleteDynamicUpdateRuleResponse(rsp *http.Response) (*DeleteDynamicUpdateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDynamicUpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDynamicUpdateRuleResponse parses an HTTP response from a GetDynamicUpdateRuleWithResponse call
func ParseGetDynamicUpdateRuleResponse(rsp *http.Response) (*GetDynamicUpdateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDynamicUpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DynamicUpdateRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDynamicUpdateRuleResponse parses an HTTP response from a CreateDynamicUpdateRuleWithResponse call
func ParseCreateDynamicUpdateRuleResponse(rsp *http.Response) (*CreateDynamicUpdateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDynamicUpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DynamicUpdateRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DynamicUpdateRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDynamicUpdateRuleResponse parses an HTTP response from a ReplaceDynamicUpdateRuleWithResponse call
func ParseReplaceDynamicUpdateRuleResponse(rsp *http.Response) (*ReplaceDynamicUpdateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDynamicUpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DynamicUpdateRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DynamicUpdateRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDynamicUpdateSectionResponse parses an HTTP response from a DeleteDynamicUpdateSectionWithResponse call
func ParseDeleteDynamicUpdateSectionResponse(rsp *http.Response) (*DeleteDynamicUpdateSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDynamicUpdateSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDynamicUpdateSectionResponse parses an HTTP response from a GetDynamicUpdateSectionWithResponse call
func ParseGetDynamicUpdateSectionResponse(rsp *http.Response) (*GetDynamicUpdateSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDynamicUpdateSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDynamicUpdateSectionResponse parses an HTTP response from a CreateDynamicUpdateSectionWithResponse call
func ParseCreateDynamicUpdateSectionResponse(rsp *http.Response) (*CreateDynamicUpdateSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDynamicUpdateSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFCGIAppsResponse parses an HTTP response from a GetFCGIAppsWithResponse call
func ParseGetFCGIAppsResponse(rsp *http.Response) (*GetFCGIAppsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFCGIAppsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FcgiApps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFCGIAppResponse parses an HTTP response from a CreateFCGIAppWithResponse call
func ParseCreateFCGIAppResponse(rsp *http.Response) (*CreateFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFCGIAppResponse parses an HTTP response from a DeleteFCGIAppWithResponse call
func ParseDeleteFCGIAppResponse(rsp *http.Response) (*DeleteFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFCGIAppResponse parses an HTTP response from a GetFCGIAppWithResponse call
func ParseGetFCGIAppResponse(rsp *http.Response) (*GetFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFCGIAppResponse parses an HTTP response from a ReplaceFCGIAppWithResponse call
func ParseReplaceFCGIAppResponse(rsp *http.Response) (*ReplaceFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest FCGIApp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclFCGIAppResponse parses an HTTP response from a GetAllAclFCGIAppWithResponse call
func ParseGetAllAclFCGIAppResponse(rsp *http.Response) (*GetAllAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclFCGIAppResponse parses an HTTP response from a ReplaceAllAclFCGIAppWithResponse call
func ParseReplaceAllAclFCGIAppResponse(rsp *http.Response) (*ReplaceAllAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclFCGIAppResponse parses an HTTP response from a DeleteAclFCGIAppWithResponse call
func ParseDeleteAclFCGIAppResponse(rsp *http.Response) (*DeleteAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclFCGIAppResponse parses an HTTP response from a GetAclFCGIAppWithResponse call
func ParseGetAclFCGIAppResponse(rsp *http.Response) (*GetAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclFCGIAppResponse parses an HTTP response from a CreateAclFCGIAppWithResponse call
func ParseCreateAclFCGIAppResponse(rsp *http.Response) (*CreateAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclFCGIAppResponse parses an HTTP response from a ReplaceAclFCGIAppWithResponse call
func ParseReplaceAclFCGIAppResponse(rsp *http.Response) (*ReplaceAclFCGIAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclFCGIAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFrontendsResponse parses an HTTP response from a GetFrontendsWithResponse call
func ParseGetFrontendsResponse(rsp *http.Response) (*GetFrontendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFrontendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Frontends
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFrontendResponse parses an HTTP response from a CreateFrontendWithResponse call
func ParseCreateFrontendResponse(rsp *http.Response) (*CreateFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFrontendResponse parses an HTTP response from a DeleteFrontendWithResponse call
func ParseDeleteFrontendResponse(rsp *http.Response) (*DeleteFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFrontendResponse parses an HTTP response from a GetFrontendWithResponse call
func ParseGetFrontendResponse(rsp *http.Response) (*GetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFrontendResponse parses an HTTP response from a ReplaceFrontendWithResponse call
func ParseReplaceFrontendResponse(rsp *http.Response) (*ReplaceFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Frontend
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllAclFrontendResponse parses an HTTP response from a GetAllAclFrontendWithResponse call
func ParseGetAllAclFrontendResponse(rsp *http.Response) (*GetAllAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllAclFrontendResponse parses an HTTP response from a ReplaceAllAclFrontendWithResponse call
func ParseReplaceAllAclFrontendResponse(rsp *http.Response) (*ReplaceAllAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acls
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteAclFrontendResponse parses an HTTP response from a DeleteAclFrontendWithResponse call
func ParseDeleteAclFrontendResponse(rsp *http.Response) (*DeleteAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAclFrontendResponse parses an HTTP response from a GetAclFrontendWithResponse call
func ParseGetAclFrontendResponse(rsp *http.Response) (*GetAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAclFrontendResponse parses an HTTP response from a CreateAclFrontendWithResponse call
func ParseCreateAclFrontendResponse(rsp *http.Response) (*CreateAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAclFrontendResponse parses an HTTP response from a ReplaceAclFrontendWithResponse call
func ParseReplaceAclFrontendResponse(rsp *http.Response) (*ReplaceAclFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAclFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Acl
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendSwitchingRulesResponse parses an HTTP response from a GetBackendSwitchingRulesWithResponse call
func ParseGetBackendSwitchingRulesResponse(rsp *http.Response) (*GetBackendSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBackendSwitchingRulesResponse parses an HTTP response from a ReplaceBackendSwitchingRulesWithResponse call
func ParseReplaceBackendSwitchingRulesResponse(rsp *http.Response) (*ReplaceBackendSwitchingRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBackendSwitchingRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackendSwitchingRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBackendSwitchingRuleResponse parses an HTTP response from a DeleteBackendSwitchingRuleWithResponse call
func ParseDeleteBackendSwitchingRuleResponse(rsp *http.Response) (*DeleteBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBackendSwitchingRuleResponse parses an HTTP response from a GetBackendSwitchingRuleWithResponse call
func ParseGetBackendSwitchingRuleResponse(rsp *http.Response) (*GetBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBackendSwitchingRuleResponse parses an HTTP response from a CreateBackendSwitchingRuleWithResponse call
func ParseCreateBackendSwitchingRuleResponse(rsp *http.Response) (*CreateBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBackendSwitchingRuleResponse parses an HTTP response from a ReplaceBackendSwitchingRuleWithResponse call
func ParseReplaceBackendSwitchingRuleResponse(rsp *http.Response) (*ReplaceBackendSwitchingRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBackendSwitchingRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest BackendSwitchingRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllBindFrontendResponse parses an HTTP response from a GetAllBindFrontendWithResponse call
func ParseGetAllBindFrontendResponse(rsp *http.Response) (*GetAllBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBindFrontendResponse parses an HTTP response from a CreateBindFrontendWithResponse call
func ParseCreateBindFrontendResponse(rsp *http.Response) (*CreateBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBindFrontendResponse parses an HTTP response from a DeleteBindFrontendWithResponse call
func ParseDeleteBindFrontendResponse(rsp *http.Response) (*DeleteBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBindFrontendResponse parses an HTTP response from a GetBindFrontendWithResponse call
func ParseGetBindFrontendResponse(rsp *http.Response) (*GetBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBindFrontendResponse parses an HTTP response from a ReplaceBindFrontendWithResponse call
func ParseReplaceBindFrontendResponse(rsp *http.Response) (*ReplaceBindFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBindFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeclareCapturesResponse parses an HTTP response from a GetDeclareCapturesWithResponse call
func ParseGetDeclareCapturesResponse(rsp *http.Response) (*GetDeclareCapturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeclareCapturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Captures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDeclareCapturesResponse parses an HTTP response from a ReplaceDeclareCapturesWithResponse call
func ParseReplaceDeclareCapturesResponse(rsp *http.Response) (*ReplaceDeclareCapturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDeclareCapturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Captures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Captures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDeclareCaptureResponse parses an HTTP response from a DeleteDeclareCaptureWithResponse call
func ParseDeleteDeclareCaptureResponse(rsp *http.Response) (*DeleteDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDeclareCaptureResponse parses an HTTP response from a GetDeclareCaptureWithResponse call
func ParseGetDeclareCaptureResponse(rsp *http.Response) (*GetDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDeclareCaptureResponse parses an HTTP response from a CreateDeclareCaptureWithResponse call
func ParseCreateDeclareCaptureResponse(rsp *http.Response) (*CreateDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDeclareCaptureResponse parses an HTTP response from a ReplaceDeclareCaptureWithResponse call
func ParseReplaceDeclareCaptureResponse(rsp *http.Response) (*ReplaceDeclareCaptureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDeclareCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Capture
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllFilterFrontendResponse parses an HTTP response from a GetAllFilterFrontendWithResponse call
func ParseGetAllFilterFrontendResponse(rsp *http.Response) (*GetAllFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllFilterFrontendResponse parses an HTTP response from a ReplaceAllFilterFrontendWithResponse call
func ParseReplaceAllFilterFrontendResponse(rsp *http.Response) (*ReplaceAllFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteFilterFrontendResponse parses an HTTP response from a DeleteFilterFrontendWithResponse call
func ParseDeleteFilterFrontendResponse(rsp *http.Response) (*DeleteFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetFilterFrontendResponse parses an HTTP response from a GetFilterFrontendWithResponse call
func ParseGetFilterFrontendResponse(rsp *http.Response) (*GetFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateFilterFrontendResponse parses an HTTP response from a CreateFilterFrontendWithResponse call
func ParseCreateFilterFrontendResponse(rsp *http.Response) (*CreateFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceFilterFrontendResponse parses an HTTP response from a ReplaceFilterFrontendWithResponse call
func ParseReplaceFilterFrontendResponse(rsp *http.Response) (*ReplaceFilterFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceFilterFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Filter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a GetAllHTTPAfterResponseRuleFrontendWithResponse call
func ParseGetAllHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPAfterResponseRuleFrontendWithResponse call
func ParseReplaceAllHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a DeleteHTTPAfterResponseRuleFrontendWithResponse call
func ParseDeleteHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a GetHTTPAfterResponseRuleFrontendWithResponse call
func ParseGetHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*GetHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a CreateHTTPAfterResponseRuleFrontendWithResponse call
func ParseCreateHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*CreateHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPAfterResponseRuleFrontendResponse parses an HTTP response from a ReplaceHTTPAfterResponseRuleFrontendWithResponse call
func ParseReplaceHTTPAfterResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPAfterResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPAfterResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpAfterResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPErrorRuleFrontendResponse parses an HTTP response from a GetAllHTTPErrorRuleFrontendWithResponse call
func ParseGetAllHTTPErrorRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPErrorRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPErrorRuleFrontendWithResponse call
func ParseReplaceAllHTTPErrorRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorRuleFrontendResponse parses an HTTP response from a DeleteHTTPErrorRuleFrontendWithResponse call
func ParseDeleteHTTPErrorRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorRuleFrontendResponse parses an HTTP response from a GetHTTPErrorRuleFrontendWithResponse call
func ParseGetHTTPErrorRuleFrontendResponse(rsp *http.Response) (*GetHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorRuleFrontendResponse parses an HTTP response from a CreateHTTPErrorRuleFrontendWithResponse call
func ParseCreateHTTPErrorRuleFrontendResponse(rsp *http.Response) (*CreateHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorRuleFrontendResponse parses an HTTP response from a ReplaceHTTPErrorRuleFrontendWithResponse call
func ParseReplaceHTTPErrorRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPErrorRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPRequestRuleFrontendResponse parses an HTTP response from a GetAllHTTPRequestRuleFrontendWithResponse call
func ParseGetAllHTTPRequestRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPRequestRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPRequestRuleFrontendWithResponse call
func ParseReplaceAllHTTPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPRequestRuleFrontendResponse parses an HTTP response from a DeleteHTTPRequestRuleFrontendWithResponse call
func ParseDeleteHTTPRequestRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPRequestRuleFrontendResponse parses an HTTP response from a GetHTTPRequestRuleFrontendWithResponse call
func ParseGetHTTPRequestRuleFrontendResponse(rsp *http.Response) (*GetHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPRequestRuleFrontendResponse parses an HTTP response from a CreateHTTPRequestRuleFrontendWithResponse call
func ParseCreateHTTPRequestRuleFrontendResponse(rsp *http.Response) (*CreateHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPRequestRuleFrontendResponse parses an HTTP response from a ReplaceHTTPRequestRuleFrontendWithResponse call
func ParseReplaceHTTPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllHTTPResponseRuleFrontendResponse parses an HTTP response from a GetAllHTTPResponseRuleFrontendWithResponse call
func ParseGetAllHTTPResponseRuleFrontendResponse(rsp *http.Response) (*GetAllHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllHTTPResponseRuleFrontendResponse parses an HTTP response from a ReplaceAllHTTPResponseRuleFrontendWithResponse call
func ParseReplaceAllHTTPResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceAllHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPResponseRuleFrontendResponse parses an HTTP response from a DeleteHTTPResponseRuleFrontendWithResponse call
func ParseDeleteHTTPResponseRuleFrontendResponse(rsp *http.Response) (*DeleteHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPResponseRuleFrontendResponse parses an HTTP response from a GetHTTPResponseRuleFrontendWithResponse call
func ParseGetHTTPResponseRuleFrontendResponse(rsp *http.Response) (*GetHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPResponseRuleFrontendResponse parses an HTTP response from a CreateHTTPResponseRuleFrontendWithResponse call
func ParseCreateHTTPResponseRuleFrontendResponse(rsp *http.Response) (*CreateHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPResponseRuleFrontendResponse parses an HTTP response from a ReplaceHTTPResponseRuleFrontendWithResponse call
func ParseReplaceHTTPResponseRuleFrontendResponse(rsp *http.Response) (*ReplaceHTTPResponseRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPResponseRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpResponseRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetFrontendResponse parses an HTTP response from a GetAllLogTargetFrontendWithResponse call
func ParseGetAllLogTargetFrontendResponse(rsp *http.Response) (*GetAllLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetFrontendResponse parses an HTTP response from a ReplaceAllLogTargetFrontendWithResponse call
func ParseReplaceAllLogTargetFrontendResponse(rsp *http.Response) (*ReplaceAllLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetFrontendResponse parses an HTTP response from a DeleteLogTargetFrontendWithResponse call
func ParseDeleteLogTargetFrontendResponse(rsp *http.Response) (*DeleteLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetFrontendResponse parses an HTTP response from a GetLogTargetFrontendWithResponse call
func ParseGetLogTargetFrontendResponse(rsp *http.Response) (*GetLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetFrontendResponse parses an HTTP response from a CreateLogTargetFrontendWithResponse call
func ParseCreateLogTargetFrontendResponse(rsp *http.Response) (*CreateLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetFrontendResponse parses an HTTP response from a ReplaceLogTargetFrontendWithResponse call
func ParseReplaceLogTargetFrontendResponse(rsp *http.Response) (*ReplaceLogTargetFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllTCPRequestRuleFrontendResponse parses an HTTP response from a GetAllTCPRequestRuleFrontendWithResponse call
func ParseGetAllTCPRequestRuleFrontendResponse(rsp *http.Response) (*GetAllTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllTCPRequestRuleFrontendResponse parses an HTTP response from a ReplaceAllTCPRequestRuleFrontendWithResponse call
func ParseReplaceAllTCPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceAllTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTCPRequestRuleFrontendResponse parses an HTTP response from a DeleteTCPRequestRuleFrontendWithResponse call
func ParseDeleteTCPRequestRuleFrontendResponse(rsp *http.Response) (*DeleteTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTCPRequestRuleFrontendResponse parses an HTTP response from a GetTCPRequestRuleFrontendWithResponse call
func ParseGetTCPRequestRuleFrontendResponse(rsp *http.Response) (*GetTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTCPRequestRuleFrontendResponse parses an HTTP response from a CreateTCPRequestRuleFrontendWithResponse call
func ParseCreateTCPRequestRuleFrontendResponse(rsp *http.Response) (*CreateTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTCPRequestRuleFrontendResponse parses an HTTP response from a ReplaceTCPRequestRuleFrontendWithResponse call
func ParseReplaceTCPRequestRuleFrontendResponse(rsp *http.Response) (*ReplaceTCPRequestRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTCPRequestRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest TcpRequestRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllWafBodyRuleFrontendResponse parses an HTTP response from a GetAllWafBodyRuleFrontendWithResponse call
func ParseGetAllWafBodyRuleFrontendResponse(rsp *http.Response) (*GetAllWafBodyRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllWafBodyRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafBodyRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllWafBodyRuleFrontendResponse parses an HTTP response from a ReplaceAllWafBodyRuleFrontendWithResponse call
func ParseReplaceAllWafBodyRuleFrontendResponse(rsp *http.Response) (*ReplaceAllWafBodyRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllWafBodyRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafBodyRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest WafBodyRules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteWafBodyRuleFrontendResponse parses an HTTP response from a DeleteWafBodyRuleFrontendWithResponse call
func ParseDeleteWafBodyRuleFrontendResponse(rsp *http.Response) (*DeleteWafBodyRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWafBodyRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWafBodyRuleFrontendResponse parses an HTTP response from a GetWafBodyRuleFrontendWithResponse call
func ParseGetWafBodyRuleFrontendResponse(rsp *http.Response) (*GetWafBodyRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWafBodyRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateWafBodyRuleFrontendResponse parses an HTTP response from a CreateWafBodyRuleFrontendWithResponse call
func ParseCreateWafBodyRuleFrontendResponse(rsp *http.Response) (*CreateWafBodyRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWafBodyRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceWafBodyRuleFrontendResponse parses an HTTP response from a ReplaceWafBodyRuleFrontendWithResponse call
func ParseReplaceWafBodyRuleFrontendResponse(rsp *http.Response) (*ReplaceWafBodyRuleFrontendResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceWafBodyRuleFrontendResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest WafBodyRule
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGlobalResponse parses an HTTP response from a GetGlobalWithResponse call
func ParseGetGlobalResponse(rsp *http.Response) (*GetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceGlobalResponse parses an HTTP response from a ReplaceGlobalWithResponse call
func ParseReplaceGlobalResponse(rsp *http.Response) (*ReplaceGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Global
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetGlobalResponse parses an HTTP response from a GetAllLogTargetGlobalWithResponse call
func ParseGetAllLogTargetGlobalResponse(rsp *http.Response) (*GetAllLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetGlobalResponse parses an HTTP response from a ReplaceAllLogTargetGlobalWithResponse call
func ParseReplaceAllLogTargetGlobalResponse(rsp *http.Response) (*ReplaceAllLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetGlobalResponse parses an HTTP response from a DeleteLogTargetGlobalWithResponse call
func ParseDeleteLogTargetGlobalResponse(rsp *http.Response) (*DeleteLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetGlobalResponse parses an HTTP response from a GetLogTargetGlobalWithResponse call
func ParseGetLogTargetGlobalResponse(rsp *http.Response) (*GetLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetGlobalResponse parses an HTTP response from a CreateLogTargetGlobalWithResponse call
func ParseCreateLogTargetGlobalResponse(rsp *http.Response) (*CreateLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetGlobalResponse parses an HTTP response from a ReplaceLogTargetGlobalWithResponse call
func ParseReplaceLogTargetGlobalResponse(rsp *http.Response) (*ReplaceLogTargetGlobalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetGlobalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupsResponse parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsResponse(rsp *http.Response) (*GetGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Groups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateGroupResponse parses an HTTP response from a CreateGroupWithResponse call
func ParseCreateGroupResponse(rsp *http.Response) (*CreateGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteGroupResponse parses an HTTP response from a DeleteGroupWithResponse call
func ParseDeleteGroupResponse(rsp *http.Response) (*DeleteGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGroupResponse parses an HTTP response from a GetGroupWithResponse call
func ParseGetGroupResponse(rsp *http.Response) (*GetGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceGroupResponse parses an HTTP response from a ReplaceGroupWithResponse call
func ParseReplaceGroupResponse(rsp *http.Response) (*ReplaceGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Group
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorsSectionsResponse parses an HTTP response from a GetHTTPErrorsSectionsWithResponse call
func ParseGetHTTPErrorsSectionsResponse(rsp *http.Response) (*GetHTTPErrorsSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorsSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorsSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateHTTPErrorsSectionResponse parses an HTTP response from a CreateHTTPErrorsSectionWithResponse call
func ParseCreateHTTPErrorsSectionResponse(rsp *http.Response) (*CreateHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteHTTPErrorsSectionResponse parses an HTTP response from a DeleteHTTPErrorsSectionWithResponse call
func ParseDeleteHTTPErrorsSectionResponse(rsp *http.Response) (*DeleteHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHTTPErrorsSectionResponse parses an HTTP response from a GetHTTPErrorsSectionWithResponse call
func ParseGetHTTPErrorsSectionResponse(rsp *http.Response) (*GetHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceHTTPErrorsSectionResponse parses an HTTP response from a ReplaceHTTPErrorsSectionWithResponse call
func ParseReplaceHTTPErrorsSectionResponse(rsp *http.Response) (*ReplaceHTTPErrorsSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceHTTPErrorsSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest HttpErrorsSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogForwardsResponse parses an HTTP response from a GetLogForwardsWithResponse call
func ParseGetLogForwardsResponse(rsp *http.Response) (*GetLogForwardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogForwardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogForwards
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogForwardResponse parses an HTTP response from a CreateLogForwardWithResponse call
func ParseCreateLogForwardResponse(rsp *http.Response) (*CreateLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogForwardResponse parses an HTTP response from a DeleteLogForwardWithResponse call
func ParseDeleteLogForwardResponse(rsp *http.Response) (*DeleteLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogForwardResponse parses an HTTP response from a GetLogForwardWithResponse call
func ParseGetLogForwardResponse(rsp *http.Response) (*GetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogForwardResponse parses an HTTP response from a ReplaceLogForwardWithResponse call
func ParseReplaceLogForwardResponse(rsp *http.Response) (*ReplaceLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogForward
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllBindLogForwardResponse parses an HTTP response from a GetAllBindLogForwardWithResponse call
func ParseGetAllBindLogForwardResponse(rsp *http.Response) (*GetAllBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBindLogForwardResponse parses an HTTP response from a CreateBindLogForwardWithResponse call
func ParseCreateBindLogForwardResponse(rsp *http.Response) (*CreateBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBindLogForwardResponse parses an HTTP response from a DeleteBindLogForwardWithResponse call
func ParseDeleteBindLogForwardResponse(rsp *http.Response) (*DeleteBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBindLogForwardResponse parses an HTTP response from a GetBindLogForwardWithResponse call
func ParseGetBindLogForwardResponse(rsp *http.Response) (*GetBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBindLogForwardResponse parses an HTTP response from a ReplaceBindLogForwardWithResponse call
func ParseReplaceBindLogForwardResponse(rsp *http.Response) (*ReplaceBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllDgramBindLogForwardResponse parses an HTTP response from a GetAllDgramBindLogForwardWithResponse call
func ParseGetAllDgramBindLogForwardResponse(rsp *http.Response) (*GetAllDgramBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDgramBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBinds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDgramBindLogForwardResponse parses an HTTP response from a CreateDgramBindLogForwardWithResponse call
func ParseCreateDgramBindLogForwardResponse(rsp *http.Response) (*CreateDgramBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDgramBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDgramBindLogForwardResponse parses an HTTP response from a DeleteDgramBindLogForwardWithResponse call
func ParseDeleteDgramBindLogForwardResponse(rsp *http.Response) (*DeleteDgramBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDgramBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDgramBindLogForwardResponse parses an HTTP response from a GetDgramBindLogForwardWithResponse call
func ParseGetDgramBindLogForwardResponse(rsp *http.Response) (*GetDgramBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDgramBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDgramBindLogForwardResponse parses an HTTP response from a ReplaceDgramBindLogForwardWithResponse call
func ParseReplaceDgramBindLogForwardResponse(rsp *http.Response) (*ReplaceDgramBindLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDgramBindLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetLogForwardResponse parses an HTTP response from a GetAllLogTargetLogForwardWithResponse call
func ParseGetAllLogTargetLogForwardResponse(rsp *http.Response) (*GetAllLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetLogForwardResponse parses an HTTP response from a ReplaceAllLogTargetLogForwardWithResponse call
func ParseReplaceAllLogTargetLogForwardResponse(rsp *http.Response) (*ReplaceAllLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetLogForwardResponse parses an HTTP response from a DeleteLogTargetLogForwardWithResponse call
func ParseDeleteLogTargetLogForwardResponse(rsp *http.Response) (*DeleteLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetLogForwardResponse parses an HTTP response from a GetLogTargetLogForwardWithResponse call
func ParseGetLogTargetLogForwardResponse(rsp *http.Response) (*GetLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetLogForwardResponse parses an HTTP response from a CreateLogTargetLogForwardWithResponse call
func ParseCreateLogTargetLogForwardResponse(rsp *http.Response) (*CreateLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetLogForwardResponse parses an HTTP response from a ReplaceLogTargetLogForwardWithResponse call
func ParseReplaceLogTargetLogForwardResponse(rsp *http.Response) (*ReplaceLogTargetLogForwardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetLogForwardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailerEntriesResponse parses an HTTP response from a GetMailerEntriesWithResponse call
func ParseGetMailerEntriesResponse(rsp *http.Response) (*GetMailerEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailerEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailerEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateMailerEntryResponse parses an HTTP response from a CreateMailerEntryWithResponse call
func ParseCreateMailerEntryResponse(rsp *http.Response) (*CreateMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMailerEntryResponse parses an HTTP response from a DeleteMailerEntryWithResponse call
func ParseDeleteMailerEntryResponse(rsp *http.Response) (*DeleteMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailerEntryResponse parses an HTTP response from a GetMailerEntryWithResponse call
func ParseGetMailerEntryResponse(rsp *http.Response) (*GetMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceMailerEntryResponse parses an HTTP response from a ReplaceMailerEntryWithResponse call
func ParseReplaceMailerEntryResponse(rsp *http.Response) (*ReplaceMailerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceMailerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailersSectionsResponse parses an HTTP response from a GetMailersSectionsWithResponse call
func ParseGetMailersSectionsResponse(rsp *http.Response) (*GetMailersSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailersSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailersSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateMailersSectionResponse parses an HTTP response from a CreateMailersSectionWithResponse call
func ParseCreateMailersSectionResponse(rsp *http.Response) (*CreateMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteMailersSectionResponse parses an HTTP response from a DeleteMailersSectionWithResponse call
func ParseDeleteMailersSectionResponse(rsp *http.Response) (*DeleteMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMailersSectionResponse parses an HTTP response from a GetMailersSectionWithResponse call
func ParseGetMailersSectionResponse(rsp *http.Response) (*GetMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseEditMailersSectionResponse parses an HTTP response from a EditMailersSectionWithResponse call
func ParseEditMailersSectionResponse(rsp *http.Response) (*EditMailersSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditMailersSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest MailersSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetNameserversResponse parses an HTTP response from a GetNameserversWithResponse call
func ParseGetNameserversResponse(rsp *http.Response) (*GetNameserversResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNameserversResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nameservers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateNameserverResponse parses an HTTP response from a CreateNameserverWithResponse call
func ParseCreateNameserverResponse(rsp *http.Response) (*CreateNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteNameserverResponse parses an HTTP response from a DeleteNameserverWithResponse call
func ParseDeleteNameserverResponse(rsp *http.Response) (*DeleteNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetNameserverResponse parses an HTTP response from a GetNameserverWithResponse call
func ParseGetNameserverResponse(rsp *http.Response) (*GetNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceNameserverResponse parses an HTTP response from a ReplaceNameserverWithResponse call
func ParseReplaceNameserverResponse(rsp *http.Response) (*ReplaceNameserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceNameserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Nameserver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerEntriesResponse parses an HTTP response from a GetPeerEntriesWithResponse call
func ParseGetPeerEntriesResponse(rsp *http.Response) (*GetPeerEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePeerEntryResponse parses an HTTP response from a CreatePeerEntryWithResponse call
func ParseCreatePeerEntryResponse(rsp *http.Response) (*CreatePeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePeerEntryResponse parses an HTTP response from a DeletePeerEntryWithResponse call
func ParseDeletePeerEntryResponse(rsp *http.Response) (*DeletePeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerEntryResponse parses an HTTP response from a GetPeerEntryWithResponse call
func ParseGetPeerEntryResponse(rsp *http.Response) (*GetPeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplacePeerEntryResponse parses an HTTP response from a ReplacePeerEntryWithResponse call
func ParseReplacePeerEntryResponse(rsp *http.Response) (*ReplacePeerEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplacePeerEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PeerEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerSectionsResponse parses an HTTP response from a GetPeerSectionsWithResponse call
func ParseGetPeerSectionsResponse(rsp *http.Response) (*GetPeerSectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerSectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerSections
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreatePeerResponse parses an HTTP response from a CreatePeerWithResponse call
func ParseCreatePeerResponse(rsp *http.Response) (*CreatePeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PeerSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest PeerSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeletePeerResponse parses an HTTP response from a DeletePeerWithResponse call
func ParseDeletePeerResponse(rsp *http.Response) (*DeletePeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPeerSectionResponse parses an HTTP response from a GetPeerSectionWithResponse call
func ParseGetPeerSectionResponse(rsp *http.Response) (*GetPeerSectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeerSectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeerSection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllBindPeerResponse parses an HTTP response from a GetAllBindPeerWithResponse call
func ParseGetAllBindPeerResponse(rsp *http.Response) (*GetAllBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Binds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateBindPeerResponse parses an HTTP response from a CreateBindPeerWithResponse call
func ParseCreateBindPeerResponse(rsp *http.Response) (*CreateBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteBindPeerResponse parses an HTTP response from a DeleteBindPeerWithResponse call
func ParseDeleteBindPeerResponse(rsp *http.Response) (*DeleteBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBindPeerResponse parses an HTTP response from a GetBindPeerWithResponse call
func ParseGetBindPeerResponse(rsp *http.Response) (*GetBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceBindPeerResponse parses an HTTP response from a ReplaceBindPeerWithResponse call
func ParseReplaceBindPeerResponse(rsp *http.Response) (*ReplaceBindPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceBindPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Bind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetPeerResponse parses an HTTP response from a GetAllLogTargetPeerWithResponse call
func ParseGetAllLogTargetPeerResponse(rsp *http.Response) (*GetAllLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetPeerResponse parses an HTTP response from a ReplaceAllLogTargetPeerWithResponse call
func ParseReplaceAllLogTargetPeerResponse(rsp *http.Response) (*ReplaceAllLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetPeerResponse parses an HTTP response from a DeleteLogTargetPeerWithResponse call
func ParseDeleteLogTargetPeerResponse(rsp *http.Response) (*DeleteLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetPeerResponse parses an HTTP response from a GetLogTargetPeerWithResponse call
func ParseGetLogTargetPeerResponse(rsp *http.Response) (*GetLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetPeerResponse parses an HTTP response from a CreateLogTargetPeerWithResponse call
func ParseCreateLogTargetPeerResponse(rsp *http.Response) (*CreateLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetPeerResponse parses an HTTP response from a ReplaceLogTargetPeerWithResponse call
func ParseReplaceLogTargetPeerResponse(rsp *http.Response) (*ReplaceLogTargetPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllServerPeerResponse parses an HTTP response from a GetAllServerPeerWithResponse call
func ParseGetAllServerPeerResponse(rsp *http.Response) (*GetAllServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Servers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerPeerResponse parses an HTTP response from a CreateServerPeerWithResponse call
func ParseCreateServerPeerResponse(rsp *http.Response) (*CreateServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerPeerResponse parses an HTTP response from a DeleteServerPeerWithResponse call
func ParseDeleteServerPeerResponse(rsp *http.Response) (*DeleteServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerPeerResponse parses an HTTP response from a GetServerPeerWithResponse call
func ParseGetServerPeerResponse(rsp *http.Response) (*GetServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerPeerResponse parses an HTTP response from a ReplaceServerPeerWithResponse call
func ParseReplaceServerPeerResponse(rsp *http.Response) (*ReplaceServerPeerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerPeerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTablesResponse parses an HTTP response from a GetTablesWithResponse call
func ParseGetTablesResponse(rsp *http.Response) (*GetTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Tables
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateTableResponse parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableResponse(rsp *http.Response) (*CreateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTableResponse parses an HTTP response from a DeleteTableWithResponse call
func ParseDeleteTableResponse(rsp *http.Response) (*DeleteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTableResponse parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResponse(rsp *http.Response) (*GetTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceTableResponse parses an HTTP response from a ReplaceTableWithResponse call
func ParseReplaceTableResponse(rsp *http.Response) (*ReplaceTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProgramsResponse parses an HTTP response from a GetProgramsWithResponse call
func ParseGetProgramsResponse(rsp *http.Response) (*GetProgramsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Programs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateProgramResponse parses an HTTP response from a CreateProgramWithResponse call
func ParseCreateProgramResponse(rsp *http.Response) (*CreateProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteProgramResponse parses an HTTP response from a DeleteProgramWithResponse call
func ParseDeleteProgramResponse(rsp *http.Response) (*DeleteProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetProgramResponse parses an HTTP response from a GetProgramWithResponse call
func ParseGetProgramResponse(rsp *http.Response) (*GetProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceProgramResponse parses an HTTP response from a ReplaceProgramWithResponse call
func ParseReplaceProgramResponse(rsp *http.Response) (*ReplaceProgramResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceProgramResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Program
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHAProxyConfigurationResponse parses an HTTP response from a GetHAProxyConfigurationWithResponse call
func ParseGetHAProxyConfigurationResponse(rsp *http.Response) (*GetHAProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHAProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostHAProxyConfigurationResponse parses an HTTP response from a PostHAProxyConfigurationWithResponse call
func ParsePostHAProxyConfigurationResponse(rsp *http.Response) (*PostHAProxyConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostHAProxyConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetResolversResponse parses an HTTP response from a GetResolversWithResponse call
func ParseGetResolversResponse(rsp *http.Response) (*GetResolversResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResolversResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resolvers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateResolverResponse parses an HTTP response from a CreateResolverWithResponse call
func ParseCreateResolverResponse(rsp *http.Response) (*CreateResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteResolverResponse parses an HTTP response from a DeleteResolverWithResponse call
func ParseDeleteResolverResponse(rsp *http.Response) (*DeleteResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetResolverResponse parses an HTTP response from a GetResolverWithResponse call
func ParseGetResolverResponse(rsp *http.Response) (*GetResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceResolverResponse parses an HTTP response from a ReplaceResolverWithResponse call
func ParseReplaceResolverResponse(rsp *http.Response) (*ReplaceResolverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceResolverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Resolver
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRingsResponse parses an HTTP response from a GetRingsWithResponse call
func ParseGetRingsResponse(rsp *http.Response) (*GetRingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Rings
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateRingResponse parses an HTTP response from a CreateRingWithResponse call
func ParseCreateRingResponse(rsp *http.Response) (*CreateRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRingResponse parses an HTTP response from a DeleteRingWithResponse call
func ParseDeleteRingResponse(rsp *http.Response) (*DeleteRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRingResponse parses an HTTP response from a GetRingWithResponse call
func ParseGetRingResponse(rsp *http.Response) (*GetRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceRingResponse parses an HTTP response from a ReplaceRingWithResponse call
func ParseReplaceRingResponse(rsp *http.Response) (*ReplaceRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Ring
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllServerRingResponse parses an HTTP response from a GetAllServerRingWithResponse call
func ParseGetAllServerRingResponse(rsp *http.Response) (*GetAllServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Servers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateServerRingResponse parses an HTTP response from a CreateServerRingWithResponse call
func ParseCreateServerRingResponse(rsp *http.Response) (*CreateServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServerRingResponse parses an HTTP response from a DeleteServerRingWithResponse call
func ParseDeleteServerRingResponse(rsp *http.Response) (*DeleteServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServerRingResponse parses an HTTP response from a GetServerRingWithResponse call
func ParseGetServerRingResponse(rsp *http.Response) (*GetServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceServerRingResponse parses an HTTP response from a ReplaceServerRingWithResponse call
func ParseReplaceServerRingResponse(rsp *http.Response) (*ReplaceServerRingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceServerRingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Server
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHAProxyConfigurationStructuredResponse parses an HTTP response from a GetHAProxyConfigurationStructuredWithResponse call
func ParseGetHAProxyConfigurationStructuredResponse(rsp *http.Response) (*GetHAProxyConfigurationStructuredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHAProxyConfigurationStructuredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Structured
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStructuredResponse parses an HTTP response from a ReplaceStructuredWithResponse call
func ParseReplaceStructuredResponse(rsp *http.Response) (*ReplaceStructuredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStructuredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Structured
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Structured
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUDPLbsResponse parses an HTTP response from a GetUDPLbsWithResponse call
func ParseGetUDPLbsResponse(rsp *http.Response) (*GetUDPLbsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUDPLbsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UdpLbs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUDPLbResponse parses an HTTP response from a CreateUDPLbWithResponse call
func ParseCreateUDPLbResponse(rsp *http.Response) (*CreateUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UDPLb
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UDPLb
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUDPLbResponse parses an HTTP response from a DeleteUDPLbWithResponse call
func ParseDeleteUDPLbResponse(rsp *http.Response) (*DeleteUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUDPlbResponse parses an HTTP response from a GetUDPlbWithResponse call
func ParseGetUDPlbResponse(rsp *http.Response) (*GetUDPlbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUDPlbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UDPLb
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceUDPLbResponse parses an HTTP response from a ReplaceUDPLbWithResponse call
func ParseReplaceUDPLbResponse(rsp *http.Response) (*ReplaceUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UDPLb
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UDPLb
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllDgramBindUDPLbResponse parses an HTTP response from a GetAllDgramBindUDPLbWithResponse call
func ParseGetAllDgramBindUDPLbResponse(rsp *http.Response) (*GetAllDgramBindUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDgramBindUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBinds
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateDgramBindUDPLbResponse parses an HTTP response from a CreateDgramBindUDPLbWithResponse call
func ParseCreateDgramBindUDPLbResponse(rsp *http.Response) (*CreateDgramBindUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDgramBindUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteDgramBindUDPLbResponse parses an HTTP response from a DeleteDgramBindUDPLbWithResponse call
func ParseDeleteDgramBindUDPLbResponse(rsp *http.Response) (*DeleteDgramBindUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDgramBindUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetDgramBindUDPLbResponse parses an HTTP response from a GetDgramBindUDPLbWithResponse call
func ParseGetDgramBindUDPLbResponse(rsp *http.Response) (*GetDgramBindUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDgramBindUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceDgramBindUDPLbResponse parses an HTTP response from a ReplaceDgramBindUDPLbWithResponse call
func ParseReplaceDgramBindUDPLbResponse(rsp *http.Response) (*ReplaceDgramBindUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceDgramBindUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest DgramBind
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllLogTargetUDPLbResponse parses an HTTP response from a GetAllLogTargetUDPLbWithResponse call
func ParseGetAllLogTargetUDPLbResponse(rsp *http.Response) (*GetAllLogTargetUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllLogTargetUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceAllLogTargetUDPLbResponse parses an HTTP response from a ReplaceAllLogTargetUDPLbWithResponse call
func ParseReplaceAllLogTargetUDPLbResponse(rsp *http.Response) (*ReplaceAllLogTargetUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceAllLogTargetUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTargets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogTargetUDPLbResponse parses an HTTP response from a DeleteLogTargetUDPLbWithResponse call
func ParseDeleteLogTargetUDPLbResponse(rsp *http.Response) (*DeleteLogTargetUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogTargetUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogTargetUDPLbResponse parses an HTTP response from a GetLogTargetUDPLbWithResponse call
func ParseGetLogTargetUDPLbResponse(rsp *http.Response) (*GetLogTargetUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogTargetUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogTargetUDPLbResponse parses an HTTP response from a CreateLogTargetUDPLbWithResponse call
func ParseCreateLogTargetUDPLbResponse(rsp *http.Response) (*CreateLogTargetUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogTargetUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogTargetUDPLbResponse parses an HTTP response from a ReplaceLogTargetUDPLbWithResponse call
func ParseReplaceLogTargetUDPLbResponse(rsp *http.Response) (*ReplaceLogTargetUDPLbResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogTargetUDPLbResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest LogTarget
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserlistsResponse parses an HTTP response from a GetUserlistsWithResponse call
func ParseGetUserlistsResponse(rsp *http.Response) (*GetUserlistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserlistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Userlists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserlistResponse parses an HTTP response from a CreateUserlistWithResponse call
func ParseCreateUserlistResponse(rsp *http.Response) (*CreateUserlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Userlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Userlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserlistResponse parses an HTTP response from a DeleteUserlistWithResponse call
func ParseDeleteUserlistResponse(rsp *http.Response) (*DeleteUserlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserlistResponse parses an HTTP response from a GetUserlistWithResponse call
func ParseGetUserlistResponse(rsp *http.Response) (*GetUserlistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserlistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Userlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateUserResponse parses an HTTP response from a CreateUserWithResponse call
func ParseCreateUserResponse(rsp *http.Response) (*CreateUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteUserResponse parses an HTTP response from a DeleteUserWithResponse call
func ParseDeleteUserResponse(rsp *http.Response) (*DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceUserResponse parses an HTTP response from a ReplaceUserWithResponse call
func ParseReplaceUserResponse(rsp *http.Response) (*ReplaceUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetConfigurationVersionResponse parses an HTTP response from a GetConfigurationVersionWithResponse call
func ParseGetConfigurationVersionResponse(rsp *http.Response) (*GetConfigurationVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigurationVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogConfigResponse parses an HTTP response from a GetLogConfigWithResponse call
func ParseGetLogConfigResponse(rsp *http.Response) (*GetLogConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogConfigResponse parses an HTTP response from a ReplaceLogConfigWithResponse call
func ParseReplaceLogConfigResponse(rsp *http.Response) (*ReplaceLogConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogConfiguration
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogInputsResponse parses an HTTP response from a GetLogInputsWithResponse call
func ParseGetLogInputsResponse(rsp *http.Response) (*GetLogInputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogInputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogInputs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogInputResponse parses an HTTP response from a CreateLogInputWithResponse call
func ParseCreateLogInputResponse(rsp *http.Response) (*CreateLogInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogInput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogInputResponse parses an HTTP response from a DeleteLogInputWithResponse call
func ParseDeleteLogInputResponse(rsp *http.Response) (*DeleteLogInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogInputResponse parses an HTTP response from a GetLogInputWithResponse call
func ParseGetLogInputResponse(rsp *http.Response) (*GetLogInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogInput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogInputResponse parses an HTTP response from a ReplaceLogInputWithResponse call
func ParseReplaceLogInputResponse(rsp *http.Response) (*ReplaceLogInputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogInputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogInput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogOutputsResponse parses an HTTP response from a GetLogOutputsWithResponse call
func ParseGetLogOutputsResponse(rsp *http.Response) (*GetLogOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogOutputs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateLogOutputResponse parses an HTTP response from a CreateLogOutputWithResponse call
func ParseCreateLogOutputResponse(rsp *http.Response) (*CreateLogOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLogOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest LogOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteLogOutputResponse parses an HTTP response from a DeleteLogOutputWithResponse call
func ParseDeleteLogOutputResponse(rsp *http.Response) (*DeleteLogOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLogOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLogOutputResponse parses an HTTP response from a GetLogOutputWithResponse call
func ParseGetLogOutputResponse(rsp *http.Response) (*GetLogOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLogOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceLogOutputResponse parses an HTTP response from a ReplaceLogOutputWithResponse call
func ParseReplaceLogOutputResponse(rsp *http.Response) (*ReplaceLogOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceLogOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReloadsResponse parses an HTTP response from a GetReloadsWithResponse call
func ParseGetReloadsResponse(rsp *http.Response) (*GetReloadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReloadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reloads
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetReloadResponse parses an HTTP response from a GetReloadWithResponse call
func ParseGetReloadResponse(rsp *http.Response) (*GetReloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRuntimeEndpointsResponse parses an HTTP response from a GetRuntimeEndpointsWithResponse call
func ParseGetRuntimeEndpointsResponse(rsp *http.Response) (*GetRuntimeEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsWithResponse call
func ParseGetServicesHaproxyRuntimeAclsResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsIdResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsIdWithResponse call
func ParseGetServicesHaproxyRuntimeAclsIdResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsParentNameEntriesResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsParentNameEntriesWithResponse call
func ParseGetServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsParentNameEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFilesEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse parses an HTTP response from a PostServicesHaproxyRuntimeAclsParentNameEntriesWithResponse call
func ParsePostServicesHaproxyRuntimeAclsParentNameEntriesResponse(rsp *http.Response) (*PostServicesHaproxyRuntimeAclsParentNameEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostServicesHaproxyRuntimeAclsParentNameEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AclFileEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddPayloadRuntimeACLResponse parses an HTTP response from a AddPayloadRuntimeACLWithResponse call
func ParseAddPayloadRuntimeACLResponse(rsp *http.Response) (*AddPayloadRuntimeACLResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPayloadRuntimeACLResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AclFilesEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse parses an HTTP response from a DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse call
func ParseDeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp *http.Response) (*DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServicesHaproxyRuntimeAclsParentNameEntriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse parses an HTTP response from a GetServicesHaproxyRuntimeAclsParentNameEntriesIdWithResponse call
func ParseGetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse(rsp *http.Response) (*GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServicesHaproxyRuntimeAclsParentNameEntriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AclFileEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllRuntimeServerResponse parses an HTTP response from a GetAllRuntimeServerWithResponse call
func ParseGetAllRuntimeServerResponse(rsp *http.Response) (*GetAllRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeServers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddRuntimeServerResponse parses an HTTP response from a AddRuntimeServerWithResponse call
func ParseAddRuntimeServerResponse(rsp *http.Response) (*AddRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RuntimeAddServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRuntimeServerResponse parses an HTTP response from a DeleteRuntimeServerWithResponse call
func ParseDeleteRuntimeServerResponse(rsp *http.Response) (*DeleteRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRuntimeServerResponse parses an HTTP response from a GetRuntimeServerWithResponse call
func ParseGetRuntimeServerResponse(rsp *http.Response) (*GetRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceRuntimeServerResponse parses an HTTP response from a ReplaceRuntimeServerWithResponse call
func ParseReplaceRuntimeServerResponse(rsp *http.Response) (*ReplaceRuntimeServerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRuntimeServerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeServer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetHaproxyProcessInfoResponse parses an HTTP response from a GetHaproxyProcessInfoWithResponse call
func ParseGetHaproxyProcessInfoResponse(rsp *http.Response) (*GetHaproxyProcessInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHaproxyProcessInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProcessInfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllRuntimeMapFilesResponse parses an HTTP response from a GetAllRuntimeMapFilesWithResponse call
func ParseGetAllRuntimeMapFilesResponse(rsp *http.Response) (*GetAllRuntimeMapFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllRuntimeMapFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Maps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseClearRuntimeMapResponse parses an HTTP response from a ClearRuntimeMapWithResponse call
func ParseClearRuntimeMapResponse(rsp *http.Response) (*ClearRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneRuntimeMapResponse parses an HTTP response from a GetOneRuntimeMapWithResponse call
func ParseGetOneRuntimeMapResponse(rsp *http.Response) (*GetOneRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Map
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddPayloadRuntimeMapResponse parses an HTTP response from a AddPayloadRuntimeMapWithResponse call
func ParseAddPayloadRuntimeMapResponse(rsp *http.Response) (*AddPayloadRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPayloadRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MapEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseShowRuntimeMapResponse parses an HTTP response from a ShowRuntimeMapWithResponse call
func ParseShowRuntimeMapResponse(rsp *http.Response) (*ShowRuntimeMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowRuntimeMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MapEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseAddMapEntryResponse parses an HTTP response from a AddMapEntryWithResponse call
func ParseAddMapEntryResponse(rsp *http.Response) (*AddMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MapEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteRuntimeMapEntryResponse parses an HTTP response from a DeleteRuntimeMapEntryWithResponse call
func ParseDeleteRuntimeMapEntryResponse(rsp *http.Response) (*DeleteRuntimeMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuntimeMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRuntimeMapEntryResponse parses an HTTP response from a GetRuntimeMapEntryWithResponse call
func ParseGetRuntimeMapEntryResponse(rsp *http.Response) (*GetRuntimeMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRuntimeMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MapEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceRuntimeMapEntryResponse parses an HTTP response from a ReplaceRuntimeMapEntryWithResponse call
func ParseReplaceRuntimeMapEntryResponse(rsp *http.Response) (*ReplaceRuntimeMapEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceRuntimeMapEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MapEntry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickTablesResponse parses an HTTP response from a GetStickTablesWithResponse call
func ParseGetStickTablesResponse(rsp *http.Response) (*GetStickTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickTables
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickTableResponse parses an HTTP response from a GetStickTableWithResponse call
func ParseGetStickTableResponse(rsp *http.Response) (*GetStickTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickTable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStickTableEntriesResponse parses an HTTP response from a GetStickTableEntriesWithResponse call
func ParseGetStickTableEntriesResponse(rsp *http.Response) (*GetStickTableEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStickTableEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StickTableEntries
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSetStickTableEntriesResponse parses an HTTP response from a SetStickTableEntriesWithResponse call
func ParseSetStickTableEntriesResponse(rsp *http.Response) (*SetStickTableEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetStickTableEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSitesResponse parses an HTTP response from a GetSitesWithResponse call
func ParseGetSitesResponse(rsp *http.Response) (*GetSitesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Sites
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSiteResponse parses an HTTP response from a CreateSiteWithResponse call
func ParseCreateSiteResponse(rsp *http.Response) (*CreateSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSiteResponse parses an HTTP response from a DeleteSiteWithResponse call
func ParseDeleteSiteResponse(rsp *http.Response) (*DeleteSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSiteResponse parses an HTTP response from a GetSiteWithResponse call
func ParseGetSiteResponse(rsp *http.Response) (*GetSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSiteResponse parses an HTTP response from a ReplaceSiteWithResponse call
func ParseReplaceSiteResponse(rsp *http.Response) (*ReplaceSiteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSiteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Site
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeEndpointsResponse parses an HTTP response from a GetSpoeEndpointsWithResponse call
func ParseGetSpoeEndpointsResponse(rsp *http.Response) (*GetSpoeEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeFilesResponse parses an HTTP response from a GetAllSpoeFilesWithResponse call
func ParseGetAllSpoeFilesResponse(rsp *http.Response) (*GetAllSpoeFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeResponse parses an HTTP response from a CreateSpoeWithResponse call
func ParseCreateSpoeResponse(rsp *http.Response) (*CreateSpoeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeFileResponse parses an HTTP response from a DeleteSpoeFileWithResponse call
func ParseDeleteSpoeFileResponse(rsp *http.Response) (*DeleteSpoeFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneSpoeFileResponse parses an HTTP response from a GetOneSpoeFileWithResponse call
func ParseGetOneSpoeFileResponse(rsp *http.Response) (*GetOneSpoeFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneSpoeFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *string `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeScopeResponse parses an HTTP response from a GetAllSpoeScopeWithResponse call
func ParseGetAllSpoeScopeResponse(rsp *http.Response) (*GetAllSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeScopes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeScopeResponse parses an HTTP response from a CreateSpoeScopeWithResponse call
func ParseCreateSpoeScopeResponse(rsp *http.Response) (*CreateSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeScope
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeScopeResponse parses an HTTP response from a DeleteSpoeScopeWithResponse call
func ParseDeleteSpoeScopeResponse(rsp *http.Response) (*DeleteSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeScopeResponse parses an HTTP response from a GetSpoeScopeWithResponse call
func ParseGetSpoeScopeResponse(rsp *http.Response) (*GetSpoeScopeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeScopeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeScope
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeAgentResponse parses an HTTP response from a GetAllSpoeAgentWithResponse call
func ParseGetAllSpoeAgentResponse(rsp *http.Response) (*GetAllSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeAgents
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeAgentResponse parses an HTTP response from a CreateSpoeAgentWithResponse call
func ParseCreateSpoeAgentResponse(rsp *http.Response) (*CreateSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeAgent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeAgentResponse parses an HTTP response from a DeleteSpoeAgentWithResponse call
func ParseDeleteSpoeAgentResponse(rsp *http.Response) (*DeleteSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeAgentResponse parses an HTTP response from a GetSpoeAgentWithResponse call
func ParseGetSpoeAgentResponse(rsp *http.Response) (*GetSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeAgent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSpoeAgentResponse parses an HTTP response from a ReplaceSpoeAgentWithResponse call
func ParseReplaceSpoeAgentResponse(rsp *http.Response) (*ReplaceSpoeAgentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSpoeAgentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeAgent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeGroupResponse parses an HTTP response from a GetAllSpoeGroupWithResponse call
func ParseGetAllSpoeGroupResponse(rsp *http.Response) (*GetAllSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeGroupResponse parses an HTTP response from a CreateSpoeGroupWithResponse call
func ParseCreateSpoeGroupResponse(rsp *http.Response) (*CreateSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeGroupResponse parses an HTTP response from a DeleteSpoeGroupWithResponse call
func ParseDeleteSpoeGroupResponse(rsp *http.Response) (*DeleteSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeGroupResponse parses an HTTP response from a GetSpoeGroupWithResponse call
func ParseGetSpoeGroupResponse(rsp *http.Response) (*GetSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSpoeGroupResponse parses an HTTP response from a ReplaceSpoeGroupWithResponse call
func ParseReplaceSpoeGroupResponse(rsp *http.Response) (*ReplaceSpoeGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSpoeGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeMessageResponse parses an HTTP response from a GetAllSpoeMessageWithResponse call
func ParseGetAllSpoeMessageResponse(rsp *http.Response) (*GetAllSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeMessages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSpoeMessageResponse parses an HTTP response from a CreateSpoeMessageWithResponse call
func ParseCreateSpoeMessageResponse(rsp *http.Response) (*CreateSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeMessageResponse parses an HTTP response from a DeleteSpoeMessageWithResponse call
func ParseDeleteSpoeMessageResponse(rsp *http.Response) (*DeleteSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeMessageResponse parses an HTTP response from a GetSpoeMessageWithResponse call
func ParseGetSpoeMessageResponse(rsp *http.Response) (*GetSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceSpoeMessageResponse parses an HTTP response from a ReplaceSpoeMessageWithResponse call
func ParseReplaceSpoeMessageResponse(rsp *http.Response) (*ReplaceSpoeMessageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceSpoeMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeMessage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllSpoeTransactionResponse parses an HTTP response from a GetAllSpoeTransactionWithResponse call
func ParseGetAllSpoeTransactionResponse(rsp *http.Response) (*GetAllSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeTransactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartSpoeTransactionResponse parses an HTTP response from a StartSpoeTransactionWithResponse call
func ParseStartSpoeTransactionResponse(rsp *http.Response) (*StartSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Code    *int    `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteSpoeTransactionResponse parses an HTTP response from a DeleteSpoeTransactionWithResponse call
func ParseDeleteSpoeTransactionResponse(rsp *http.Response) (*DeleteSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeTransactionResponse parses an HTTP response from a GetSpoeTransactionWithResponse call
func ParseGetSpoeTransactionResponse(rsp *http.Response) (*GetSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitSpoeTransactionResponse parses an HTTP response from a CommitSpoeTransactionWithResponse call
func ParseCommitSpoeTransactionResponse(rsp *http.Response) (*CommitSpoeTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitSpoeTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SpoeTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpoeConfigurationVersionResponse parses an HTTP response from a GetSpoeConfigurationVersionWithResponse call
func ParseGetSpoeConfigurationVersionResponse(rsp *http.Response) (*GetSpoeConfigurationVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpoeConfigurationVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest int
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatsEndpointsResponse parses an HTTP response from a GetStatsEndpointsWithResponse call
func ParseGetStatsEndpointsResponse(rsp *http.Response) (*GetStatsEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NativeStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest NativeStats
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStorageEndpointsResponse parses an HTTP response from a GetStorageEndpointsWithResponse call
func ParseGetStorageEndpointsResponse(rsp *http.Response) (*GetStorageEndpointsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStorageEndpointsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Endpoints
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageGeneralFilesResponse parses an HTTP response from a GetAllStorageGeneralFilesWithResponse call
func ParseGetAllStorageGeneralFilesResponse(rsp *http.Response) (*GetAllStorageGeneralFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageGeneralFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GeneralFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageGeneralFileResponse parses an HTTP response from a CreateStorageGeneralFileWithResponse call
func ParseCreateStorageGeneralFileResponse(rsp *http.Response) (*CreateStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GeneralFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageGeneralFileResponse parses an HTTP response from a DeleteStorageGeneralFileWithResponse call
func ParseDeleteStorageGeneralFileResponse(rsp *http.Response) (*DeleteStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageGeneralFileResponse parses an HTTP response from a GetOneStorageGeneralFileWithResponse call
func ParseGetOneStorageGeneralFileResponse(rsp *http.Response) (*GetOneStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageGeneralFileResponse parses an HTTP response from a ReplaceStorageGeneralFileWithResponse call
func ParseReplaceStorageGeneralFileResponse(rsp *http.Response) (*ReplaceStorageGeneralFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageGeneralFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageMapFilesResponse parses an HTTP response from a GetAllStorageMapFilesWithResponse call
func ParseGetAllStorageMapFilesResponse(rsp *http.Response) (*GetAllStorageMapFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageMapFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Maps
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageMapFileResponse parses an HTTP response from a CreateStorageMapFileWithResponse call
func ParseCreateStorageMapFileResponse(rsp *http.Response) (*CreateStorageMapFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageMapFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Map
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageMapResponse parses an HTTP response from a DeleteStorageMapWithResponse call
func ParseDeleteStorageMapResponse(rsp *http.Response) (*DeleteStorageMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageMapResponse parses an HTTP response from a GetOneStorageMapWithResponse call
func ParseGetOneStorageMapResponse(rsp *http.Response) (*GetOneStorageMapResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageMapResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageMapFileResponse parses an HTTP response from a ReplaceStorageMapFileWithResponse call
func ParseReplaceStorageMapFileResponse(rsp *http.Response) (*ReplaceStorageMapFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageMapFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllStorageSSLCertificatesResponse parses an HTTP response from a GetAllStorageSSLCertificatesWithResponse call
func ParseGetAllStorageSSLCertificatesResponse(rsp *http.Response) (*GetAllStorageSSLCertificatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllStorageSSLCertificatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateStorageSSLCertificateResponse parses an HTTP response from a CreateStorageSSLCertificateWithResponse call
func ParseCreateStorageSSLCertificateResponse(rsp *http.Response) (*CreateStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteStorageSSLCertificateResponse parses an HTTP response from a DeleteStorageSSLCertificateWithResponse call
func ParseDeleteStorageSSLCertificateResponse(rsp *http.Response) (*DeleteStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOneStorageSSLCertificateResponse parses an HTTP response from a GetOneStorageSSLCertificateWithResponse call
func ParseGetOneStorageSSLCertificateResponse(rsp *http.Response) (*GetOneStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOneStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceStorageSSLCertificateResponse parses an HTTP response from a ReplaceStorageSSLCertificateWithResponse call
func ParseReplaceStorageSSLCertificateResponse(rsp *http.Response) (*ReplaceStorageSSLCertificateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceStorageSSLCertificateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest SslCertificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTransactionsResponse parses an HTTP response from a GetTransactionsWithResponse call
func ParseGetTransactionsResponse(rsp *http.Response) (*GetTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartTransactionResponse parses an HTTP response from a StartTransactionWithResponse call
func ParseStartTransactionResponse(rsp *http.Response) (*StartTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Code    *int    `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteTransactionResponse parses an HTTP response from a DeleteTransactionWithResponse call
func ParseDeleteTransactionResponse(rsp *http.Response) (*DeleteTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTransactionResponse parses an HTTP response from a GetTransactionWithResponse call
func ParseGetTransactionResponse(rsp *http.Response) (*GetTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitTransactionResponse parses an HTTP response from a CommitTransactionWithResponse call
func ParseCommitTransactionResponse(rsp *http.Response) (*CommitTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest Transaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest NotAcceptable
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWafRulesetsResponse parses an HTTP response from a GetWafRulesetsWithResponse call
func ParseGetWafRulesetsResponse(rsp *http.Response) (*GetWafRulesetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWafRulesetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafRulesets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateWafRulesetResponse parses an HTTP response from a CreateWafRulesetWithResponse call
func ParseCreateWafRulesetResponse(rsp *http.Response) (*CreateWafRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWafRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WafRuleset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteWafRulesetResponse parses an HTTP response from a DeleteWafRulesetWithResponse call
func ParseDeleteWafRulesetResponse(rsp *http.Response) (*DeleteWafRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWafRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWafRulesetResponse parses an HTTP response from a GetWafRulesetWithResponse call
func ParseGetWafRulesetResponse(rsp *http.Response) (*GetWafRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWafRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafRuleset
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceWafRulesetResponse parses an HTTP response from a ReplaceWafRulesetWithResponse call
func ParseReplaceWafRulesetResponse(rsp *http.Response) (*ReplaceWafRulesetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceWafRulesetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWafFilesResponse parses an HTTP response from a GetWafFilesWithResponse call
func ParseGetWafFilesResponse(rsp *http.Response) (*GetWafFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWafFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WafFiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateWafFileResponse parses an HTTP response from a CreateWafFileWithResponse call
func ParseCreateWafFileResponse(rsp *http.Response) (*CreateWafFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWafFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WafFile
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteWafFileResponse parses an HTTP response from a DeleteWafFileWithResponse call
func ParseDeleteWafFileResponse(rsp *http.Response) (*DeleteWafFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWafFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetWafFileResponse parses an HTTP response from a GetWafFileWithResponse call
func ParseGetWafFileResponse(rsp *http.Response) (*GetWafFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWafFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceWafFileResponse parses an HTTP response from a ReplaceWafFileWithResponse call
func ParseReplaceWafFileResponse(rsp *http.Response) (*ReplaceWafFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceWafFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeepalivedClusterConfigurationVersionResponse parses an HTTP response from a GetKeepalivedClusterConfigurationVersionWithResponse call
func ParseGetKeepalivedClusterConfigurationVersionResponse(rsp *http.Response) (*GetKeepalivedClusterConfigurationVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeepalivedClusterConfigurationVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterVersion
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGlobalDefsResponse parses an HTTP response from a GetGlobalDefsWithResponse call
func ParseGetGlobalDefsResponse(rsp *http.Response) (*GetGlobalDefsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalDefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpGlobalDefs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceGlobalDefsResponse parses an HTTP response from a ReplaceGlobalDefsWithResponse call
func ParseReplaceGlobalDefsResponse(rsp *http.Response) (*ReplaceGlobalDefsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceGlobalDefsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpGlobalDefs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VrrpGlobalDefs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeepalivedConfigurationResponse parses an HTTP response from a GetKeepalivedConfigurationWithResponse call
func ParseGetKeepalivedConfigurationResponse(rsp *http.Response) (*GetKeepalivedConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeepalivedConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data string `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceKeepalivedConfigurationResponse parses an HTTP response from a ReplaceKeepalivedConfigurationWithResponse call
func ParseReplaceKeepalivedConfigurationResponse(rsp *http.Response) (*ReplaceKeepalivedConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceKeepalivedConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Data string `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			Data string `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllVRRPInstanceResponse parses an HTTP response from a GetAllVRRPInstanceWithResponse call
func ParseGetAllVRRPInstanceResponse(rsp *http.Response) (*GetAllVRRPInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllVRRPInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpInstances
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVRRPInstanceResponse parses an HTTP response from a CreateVRRPInstanceWithResponse call
func ParseCreateVRRPInstanceResponse(rsp *http.Response) (*CreateVRRPInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVRRPInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VrrpInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VrrpInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVRRPInstanceResponse parses an HTTP response from a DeleteVRRPInstanceWithResponse call
func ParseDeleteVRRPInstanceResponse(rsp *http.Response) (*DeleteVRRPInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVRRPInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVRRPInstanceResponse parses an HTTP response from a GetVRRPInstanceWithResponse call
func ParseGetVRRPInstanceResponse(rsp *http.Response) (*GetVRRPInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVRRPInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceVRRPInstanceResponse parses an HTTP response from a ReplaceVRRPInstanceWithResponse call
func ParseReplaceVRRPInstanceResponse(rsp *http.Response) (*ReplaceVRRPInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceVRRPInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VrrpInstance
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllVRRPSyncGroupResponse parses an HTTP response from a GetAllVRRPSyncGroupWithResponse call
func ParseGetAllVRRPSyncGroupResponse(rsp *http.Response) (*GetAllVRRPSyncGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllVRRPSyncGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpSyncGroups
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVRRPSyncGroupResponse parses an HTTP response from a CreateVRRPSyncGroupWithResponse call
func ParseCreateVRRPSyncGroupResponse(rsp *http.Response) (*CreateVRRPSyncGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVRRPSyncGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VrrpSyncGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VrrpSyncGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVRRPSyncGroupResponse parses an HTTP response from a DeleteVRRPSyncGroupWithResponse call
func ParseDeleteVRRPSyncGroupResponse(rsp *http.Response) (*DeleteVRRPSyncGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVRRPSyncGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVRRPSyncGroupResponse parses an HTTP response from a GetVRRPSyncGroupWithResponse call
func ParseGetVRRPSyncGroupResponse(rsp *http.Response) (*GetVRRPSyncGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVRRPSyncGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpSyncGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceVRRPSyncGroupResponse parses an HTTP response from a ReplaceVRRPSyncGroupWithResponse call
func ParseReplaceVRRPSyncGroupResponse(rsp *http.Response) (*ReplaceVRRPSyncGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceVRRPSyncGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpSyncGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VrrpSyncGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllVRRPScriptResponse parses an HTTP response from a GetAllVRRPScriptWithResponse call
func ParseGetAllVRRPScriptResponse(rsp *http.Response) (*GetAllVRRPScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllVRRPScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpTrackScripts
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateVRRPScriptResponse parses an HTTP response from a CreateVRRPScriptWithResponse call
func ParseCreateVRRPScriptResponse(rsp *http.Response) (*CreateVRRPScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateVRRPScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest VrrpTrackScript
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VrrpTrackScript
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest AlreadyExists
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteVRRPScriptResponse parses an HTTP response from a DeleteVRRPScriptWithResponse call
func ParseDeleteVRRPScriptResponse(rsp *http.Response) (*DeleteVRRPScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteVRRPScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetVRRPScriptResponse parses an HTTP response from a GetVRRPScriptWithResponse call
func ParseGetVRRPScriptResponse(rsp *http.Response) (*GetVRRPScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetVRRPScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpTrackScript
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseReplaceVRRPScriptResponse parses an HTTP response from a ReplaceVRRPScriptWithResponse call
func ParseReplaceVRRPScriptResponse(rsp *http.Response) (*ReplaceVRRPScriptResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReplaceVRRPScriptResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VrrpTrackScript
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest VrrpTrackScript
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllKeepalivedReloadResponse parses an HTTP response from a GetAllKeepalivedReloadWithResponse call
func ParseGetAllKeepalivedReloadResponse(rsp *http.Response) (*GetAllKeepalivedReloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllKeepalivedReloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeepalivedReloads
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeepalivedReloadResponse parses an HTTP response from a GetKeepalivedReloadWithResponse call
func ParseGetKeepalivedReloadResponse(rsp *http.Response) (*GetKeepalivedReloadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeepalivedReloadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeepalivedReload
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAllKeepalivedTransactionResponse parses an HTTP response from a GetAllKeepalivedTransactionWithResponse call
func ParseGetAllKeepalivedTransactionResponse(rsp *http.Response) (*GetAllKeepalivedTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllKeepalivedTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeepalivedTransactions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseStartKeepalivedTransactionResponse parses an HTTP response from a StartKeepalivedTransactionWithResponse call
func ParseStartKeepalivedTransactionResponse(rsp *http.Response) (*StartKeepalivedTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StartKeepalivedTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest KeepalivedTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest struct {
			Code    *int    `json:"code,omitempty"`
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseDeleteKeepalivedTransactionResponse parses an HTTP response from a DeleteKeepalivedTransactionWithResponse call
func ParseDeleteKeepalivedTransactionResponse(rsp *http.Response) (*DeleteKeepalivedTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteKeepalivedTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKeepalivedTransactionResponse parses an HTTP response from a GetKeepalivedTransactionWithResponse call
func ParseGetKeepalivedTransactionResponse(rsp *http.Response) (*GetKeepalivedTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeepalivedTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeepalivedTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCommitKeepalivedTransactionResponse parses an HTTP response from a CommitKeepalivedTransactionWithResponse call
func ParseCommitKeepalivedTransactionResponse(rsp *http.Response) (*CommitKeepalivedTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitKeepalivedTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeepalivedTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest KeepalivedTransaction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSpecificationResponse parses an HTTP response from a GetSpecificationWithResponse call
func ParseGetSpecificationResponse(rsp *http.Response) (*GetSpecificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpecificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetOpenapiv3SpecificationResponse parses an HTTP response from a GetOpenapiv3SpecificationWithResponse call
func ParseGetOpenapiv3SpecificationResponse(rsp *http.Response) (*GetOpenapiv3SpecificationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOpenapiv3SpecificationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSummaryResponse parses an HTTP response from a GetSummaryWithResponse call
func ParseGetSummaryResponse(rsp *http.Response) (*GetSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Summary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest DefaultError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9DXfctpIg+ldwOPtOkr3dSuvLTnzOnDeKbCd+kW2tpdyZN5GXQZPobozYAA2AkjpZ",
	"/az3B94v24MCQIIkyGZ/yMm965lzY3U3UFUACoVCoT7+iBK+zDkjTMnoxR9RjgVeEkUEfJpxkZBYkIzj",
	"VH9OiUwEzRXlLHoRvZkhSdQIpRxhBE2RaQpfMa7QPaZK/4LUgqCEsxmdF4Kkttk4JRleHaBzzHTjKUGF",
	"JCm6XxCGlMBM4kRjQlQimZOEzihJRwhLlCwwmxOJaL0dFgSw4jzPKElRSgVJVLZCipfIsW55EI0iqkfw",
	"qSBiFY0ihpckelEf7iiSyYIssRn3DBeZil7McCbJKFKrXLefcp4RzKLHx1E0K7IsliQxc9OaKpbSBCtN",
	"8wwmw5E8m5FESfiqHCNKFjTTkyR5IRIi9ZDvSZZ1Ue1j3pDqHAvCVGwgNYm+hB8R/GhR51gtKsx+71Ek",
	"yKeCCpJGL5QoiE+IRSyVoGwOeEWREUm6EL/DS4K4mSjbMkxADcxmFMhbmq/lbMYtq6J7mmWaQymjimJF",
	"UoRnighU5ClWpGNlfBwbLowspnFKRZu0q2JqGZuLFeyA9iQ1ybCwfBJyrBQRuvH//PVs/J94/Ptk/P04",
	"Pvj4t/8WjQLT5e2zmIZm7KVbMH9H3i+IIOieoHvMlN6GOE2hEc+J3YrB3X9HhGzu/K5N26CsZ9VH0cOY",
	"FVmGpxmxc/84iiyu9pD+bokAsrQQSxYkuaVsXhcmjthN5Zj/ywJLRNVXEvH7Cl7HeB29gYFSpsiciPBI",
	"9a4jMudMEpDtZ5kgOF29eqDSiP6EM0WY0n+CBE1geN/+lzSTU2H7b4LMohfRv3xbHR3fml/lt0QILqJH",
	"ja0+m9c1CedkG8KGCkQMGaNoQXBqT59zf5rHf+9ap1ozNKMZQT1zVPK0JvEHnH4gnwoi1dNPwA9YD9sg",
	"+8zDfGnkzSsg7ckH+iNhROAMGXSfeajvuDpLEpIrw/p/ElcnpSRYYJZmJP0TpuE1L1j6p83APZagi82A",
	"is86+kf3M2DDSQb/pCnVgHB2KfTho6iWgvb8bY+okKCAaFaSEp1zpgTP0IWWUejrs/OLb1Au+B1NtXKG",
	"Zhl5oNOMIMmzAqhVHOVEzLhY3jA7/UjeU5Us9PGBWYrmZpMY5VThW4JSklA9OommWB8fnCHXlTwogRNF",
	"0hs2E3xpjnwjSkb2gxHsiAuE2QoRdkcFZ0vCFM6QVFgV8uBGT1zujR4mp1TBfI0Aj38/G//nzc04vrk5",
	"uLl5MRl/H1QMRlEiqCLCLqAP4n/e3MiOPnc4K0iHXlhqcL9WxPlYPo4iRZXe2tHZ+QW6oIzICgef/hdJ",
	"lMahO2ueafOV7vZa/9KcjFqzgPJg1J7W11JxgeeknMeA7uQRbDF30hsTpsSqTfV7RpDrj15Bmyb9hj59",
	"nL5n2crpwJvMviM0iKyTZBmYYyHwSm8gUTBFl/q6kyHTdhRRRZZynbwp1y8wfxIB/IomDB99kmAaaS9p",
	"toX+kzPSonRTQu3CBcl9ZYkJEhyg8aezS8EfVrAGmeZwBB3Q1wkXZqunErTpJLN3AXpH5DcbkNykE/ZR",
	"z7SGb7VnDJ0lTuBJhYUaIal4PirtAILA18hpzwgjScQdTchBi3+JU0/WsvBATs/4PDC5F3wuEVlSpS9x",
	"05W5elua0PvcHBIHcJtcA7+8xAD1rFhqqQXjjUAs5ADE3v7sTMAvWhzDVzNB5CK+w4JqdUWCdGvJF0Ob",
	"j2OBc80f0Si6JSTHGb0DDUOupCLLMJACTrKeafMvnyVnOJtCYO/rX0KzS6XSW8o1GMyS0L+FO7hnMr7A",
	"ccWTjSMtp7F3pWvNhD5c40JkwR/NxS5eYLlo/64vVSnJCUsJS1bV7384kRrlhVwYHWkgh+ZYynsuUmtr",
	"W2IFJg77ZaCDO+gHQfcWveRO89WsyKJRNMNUq6YfB7C6G6mDkxdZFpvZ0vu4kAv3KcR9hSSi+3j0z3z4",
	"1Vskr+/Inxh/lT+G+NPjkR4uPbt4/9OZlWESkQeSFAq20jCm9RnRZ10faoiB7+Vrmjkba519b0ng8P+Z",
	"gJqolVIs9emkiBihQmplUosvwzqeGo4VWiiVyxfffpvyRB7ge3mAl/h3zg4Svvw2yei3GVZEqm8FmRFB",
	"WEK+JcnRtwbtlIwpkwqzhMiDhVpm/8LzxlgC6kTDeKK/diYhQ7EdQtC85POAngIHN7i29/IDmYcPpH+/",
	"QgJ+q9toolFEHvAyN/oghj0Q35IVmLKi/974v4vnP15rHssyfp9RqaIXv9qFiRSej336XkRv7Ey9+Anf",
	"UTZ/cb2g8sU1nkePH/XFgq3aEF68qtRzD1JK7kjGc/hWdyZMHwqlMRNInWjezO9OYpymAvZ2lAt6Z0yQ",
	"zh4s4NqQjt3JoafXzFdUyDHBUo0P4UslVrFWenihoheH+qhJBFFxNT+ByZH8ArSH5kWiNqWhdbF3Kc3L",
	"b14ehFjJm/CW1RNY2xzWGpjhKGkMbYqXHLYg6NX5ESrZ19ocB+/oamc+Nvatlv58qaHkysrJR3+B90kx",
	"nTMuyBMS3X/RKRnvj5Zy4E62xvIWitsbrVaqzPJW9kfDv+HL4Xpdr8btrVkmGUkUul/QZIHeXN6dINsU",
	"JvbKbAD0ksqE3xGxAkOrlaTuWWqKk1vCUtABiUDEXnfKk67cXnkxzWgSPOA6Drdq4wV/qm2/5sheOssH",
	"ZUiSBFR+ysZTou4JYSjFCiN9CuszwNoCYGiO3yzmUbSkjC71WA5HATtxYMuHNu8VNPP2cHADmymM4Q1x",
	"LdvWG1e9ZcaVjLUGUHsqOZyEyff6zAW/V4uYskSQpbV4Devi1JsSW0QeDL0UZx4z6MsYFnCaVD9/7J4J",
	"g6SQJLbXy9Ceahx/5VuWXT+3G5sc09gavmHEX/7u41P2nZ/2yrmBDLJn8mONjoD2Y/cbnBpZ9n4GZ2Mf",
	"bNvBsMTj6I+ADcuJ4DW3XmAzI3gHdZlVYlWrUzE8+cVOB49FkZFBcLo6V5DhcjwcFjSvesPNeUNyqj4V",
	"HCtHNoTk9/JhbTVL7fnJ+DxWWMyJGgSlal4TKs74OpycYE8fpj5VQYvuti8PwuDgmHdf+G5HkAaSosnt",
	"BsMtmxs1InFMORhC2aUEsDE/NTt5kDblplYvgHWPZ/GUp6vhcGo9pDGP1EXqx/ZLn9Eo7qlaIJxl5mkX",
	"nDoEYZVfR0s6a3VtzsdWj7dgPJlZnoobvGY4W6JTc/ruRemdWcDoBezhZHELd/FMK6ZGXs+5oGqxjF5E",
	"ghcsFXxKQeTPuLjHIp0ZA16pQJZ/WamQLG497WBJ1ILrVj++0vetQtDoRfStocB7l49+ur6+/Pbw4FBD",
	"WfKUWPI8FwDNL9NquhoHxJQLxVmScVmzYVQHa0ql+TN0lGN4Towpu8MZTeOalNoUHJiQqMwzvHKrbF4r",
	"0RsDHumxog8OvEZfLYpnACxXJ0txPnZTtlzJT1n5KZ/7nwRJqSw/yaUDIGU2XpAs42PzWSUO3iDq0zvN",
	"HCk6hy7mEqdXosjlPiYny9APFtpjjRX7FQbT7HEUGRHmKdnNW0lDPzQ2PlACxwWjWhNcSvOt2zLuFgWg",
	"E5ws9sEF5xUwMEMuc63U2atD31j9psaAyUiinmjEnN9Ssp4iaAX3TAAb20NpTb9G63X31MAkvvTaP3oL",
	"ELzHpiuGlzSJDbnu5jPkBbNtB64mxkI9sDYdmDh9ZJAlplmMMyLWHjh+03WXcaPElY9wg1R16FM+rTWt",
	"BdXxA+4br+2bXciMUAKS8UzwZVyplVsQIwdT81rwpZaSrwymHtoynhxPjgaRkPEkqnU73qjbg2YanLUF",
	"9Zbi4JUFWInVOoo44cslNpeowSzbhwKdW4BtVOBxuTc8lxqaURgSEuf6jA9Zz64XVKIZJVmKqEQpyQVJ",
	"wLZEGZrhOy4Qn6EaDFDmRuBb4Xw1BVnyO9MHo1mhCgEOygTL9uN/ws1suoWjM62RsMxdrdcKcM6MSmal",
	"cBor61W2Xngw+1jkO68+PvYhQdcaeNNyAJB87B9DCmY1me5ECCidr/XUXtrVaS5XqTeXW/z/1Lms5q05",
	"YT2izG96QaXqEGF1lbrXTFG11P0EX/Z5+L7o8MqZFVmm1YcBOsPjKJoXNN0Gy+IwTrAkMU7/q9BKO58X",
	"0lMQNpabteU3l4PqPRZuCcHV/+kQnQEF6AdNAViKzcAWWC5iq0HGM5woM//rZwQ6OkNir52jbGhvReNp",
	"MZsRMRaVK+pnmwd93TDoHXZHFOMmPuOzk5Pxe6TnVWDwa0FARWlYGheSjBfqYT1Z2+lyHcSWhjqjYFPO",
	"YteydimDS6al1LD1uPbdLSH5GDw2dpg5R4wGFgOw/Sj8g1eteTMAanJBFGFpXPqkPBnnVBj5w+fnT8CK",
	"oFPTcPoXWAVB9DgTpWmKF6kAv8TaXVzfFzVn6lkiGVHmtQHOtCGn8weLwJkqYOToJ/DvRe8AWUVLUbeR",
	"4PkcLquAHGf3el+PIkbuYEYknu1jV0jNhJrY2Dgd96xG9yivFwSZ7sg0cs+GiiONoHQbI8IESAUtXOvM",
	"3V7r8ml1/Uljnod3VJ7rQL5oz/vUnt/A3HraYGCyv+jPtZlrTVmPAl1r26NBU+ZGp2KpBLGbcse7+ZsK",
	"KrqyUOGZCqexezNSWBFjFHE+6A7pPONTeFLOeAL/Ms5I0O6c8bkWYJlauFeV3Wm/4HMtqTO1MNdx74Ft",
	"voED/xI/+LrHp4IYF7AhZ16doLf4gS6LJdLQEEBDBlpp6q/rV8ZADdMXdjUEE3hpuRgihwM9PI+OTe83",
	"jGeUzbe8zNTn5p0D9TiKuKBzynCm+LrheC0fR5F3RuxIjbc1nRgTRbb2slNr+2gfJTZan0APeOIhMyLi",
	"DEu1y/WxMUYAii6wVN6NEBjyaSzq8CiTY5Us1s2C19L6DtnDYr26YNxGBtrQP+jGyBwdVprNKHua0del",
	"Jc26YmgCZJrVgcgmgpwx272nPwmty010u0Zr3R+efNf2M610+zyjCYlxYXb8jox9BdDQWWGkggW+i70h",
	"CP9DZUIoUeztobTEUb2Nypzne7O5X+U8r+ztUtypJL/F+79d6vMrqFFZnr4+v0Q/6+PwDO7QHi1xwtR2",
	"x+yVhYDOmapBpGlGttsoshfPmxQiqEIbqUTN1F32JLgBcBi5wkrGzpt9rUeM37j0qCkji/sfQSGQxO+h",
	"dVoscvpEj7MqyWO5xEI5E9UetsR1kqMrDROdW5gG0WfdFu39AJkTTO6RfQzSg6aBF4yR7GnWqJAkniVz",
	"GuM8H3TMvcZSnf/4Bnlx22F/Uc/703kf/YBlMNLU+RLVHdt29Cqqgps1sEaCjGbYop4G17EMX/ym7otk",
	"bqLm6utdYaM/kCCfYimzWDKKxhTd398f2H4HCV+ix8hc/B6iF5OBDkL/iPdtaGGcDcaG7j+imSDktY0i",
	"M6zqRShGc6LOzi9kZbtZ6eu1i7F+7LjzbPDS6xjvnXFgbtPXoMa2b1BkqRnI5Fcl330osg3YvSfoNszS",
	"XSG4QV4eHorbsRkf1420O1Z36mZ13QA39PD2dk+DNBmkovTUajjjVS6E1YabUWGSomC50P+kWqpmBEsF",
	"D5KjSGCW8qX+I83H1ttm5Lsglgq2OeNpMhbCuhTq/2ZGEw9aDOA5jjz4Dlfrtm1tEKUVGkPwZ+jVAMsF",
	"evXg+2k5w/zG2JoprkrsqehAXhnmHWLNsylfYspiDqE3LdeioUNeg/QXSdBLQIQgxufRrWScCnwvA/EZ",
	"AxFbfgji/gC/oZeA4RFYxjl5bSzgBlBSMWSYmjRH5/B7uQSFoHFKcrXYfvyar4PofhEUvQTYFlFG2BOh",
	"uSDMIcmxWuzISr2oLrFalBykEd4veEaeCNm/A+xHX2zsh2W6tm6Fp4OmDF2anz2anEGMS7XL+g7D7Hy3",
	"uLnbV0Qs8UN8j+nnIOEtfkD/Tuh80X5rqACHwoWndKNgI8rSymyzRiduHG1VkGKpyEaHR88PJgeTg8No",
	"NNS6nnPjJFoC+W4CJncTxffs9PT4tB7Vt94EqEGOBWZzMrahVxXww92AD4iHcIqHC0xGepJbgQilVkFt",
	"zIO3Ei82Wwjjsc+IkgnOiIgTmodjAW3L0o+g7WELMcnxRCjV9XvOdtCZzy4u36FLwRVPeCad/pbxeTg9",
	"BY7tSyIRYojqIGXmbbbSGznBsaRzVj5O7Qgmx1JuCyZkhcdS5gthov00kjsi6Gw1mNoEl01bFNN8YaOr",
	"th2zgVBQG/e1LZiMwqskneNsvhMgke28jELtia1E9bS9LYhC3O00sS6KwKelemYfJoAHhdDPiIiN+Ohw",
	"zU/SxS6rQh5yLkk8S2EYhNXZ1kNkXHOlzO6O+xqoTN4dTta2OFzb4mhtiw46XIKAONGiembyIQ9S4jqm",
	"aF7LyNZj/v5R8CJHb14CFfrvQcY308s598wLmsa5IDP6sM27cCh5XMiIzZNboiyp4AQ5w0k4tUBG7kjm",
	"36ILCaM3VhbIvInTJYX8OJU+YhuFnvSd82/Z+PDo+CSkTTjTbRtI6BzY0LBkm8vcjrsiHed5sPXUEb6e",
	"Ed4VyykB96fKjxNg0AayYK4ExmN33G/LsozHCa5c8nYA07XhN4GhMhkrqjlO7g4pLF02BnK4DyBH+wCy",
	"2+zm4awf1m/Bnv9tfcSTl7lWCwdJDadAlsLqU0GTcZKM9c3IFxFJMaUJeFzeC8J40B4GfUGaj8FzIEwc",
	"tJIgrWoIqm01itzB1ZEhQ6t1ahXzQuVFDQi4ROmbh96sYNGDTjU5Ztusf0Ex9nCNcGddy37dngwpszjB",
	"Tg3bzlQwUDm+urpA52cmjajDXB2n+0Vv4etLfsO/5urq4u44GkXXF1d3hweT8q/D8q+j8q/j8PJrwJQ9",
	"AWDj/SwZ3WX7qiSP9VG5wTug7jXjYQZRC0FwOH1sJYPjW7IKn5+NB882/KIjNy2c9qEf7k7unoVB3T3r",
	"MOSZVPl0tgpsVW7TZvo1GAZu157VqLIHPAbMDMZC0PPOUTM3dL3fgClim4cb2ngLoR0PIVwtMcNzSEjk",
	"ex40Uka8v37749trtORp6/20nSkVF4rHZnLCybiWWNEEskubVuCt7nDYzGOcQW4KfIcpsDXENVAi0ddu",
	"4uS35dXDL95CmXH912qgyXGhhZJdq2+8xFB+tDVWuCMfMxh3baJAyGoFqb710hCUcZyayg9t1jaFN1rg",
	"XgEdJv8XdlNhy3QcBHI+2winRvItfs+g7EdOBOXpAbIZ9IFlTtGSskIRGcpy1hYKKWcq4/OY6ZMoC+Ai",
	"EOcExWEyPp9TNtfTUWXqtMTbBN7tubXWovA0OIhVskhvJW9035sI2Xw5XQiWPIW0kv2TbVOmQwkQuiSo",
	"zFR+E11gqcZvLZSbqEpXDnxkwiwObhg9IAdVkY37BVELzacCEskrbuehYpTpCkmilBvYTfRmVmIZX1GW",
	"EMBlA1RqqILj9Lwq68Nk5bXBNtHUEKnwNKNygbB3m3Ap2Iwv4gF6M0MF86t+LAgyPuDoxiG8iRBIPERN",
	"ekBD33rO2i3dWmfmOZgpOyJkW0G2PK1YLHOzCVK3QzBi5L6Wnr/cLXo8py553bDNYhPzthPyZzyxhQA0",
	"W5m6MnWJkWCmRYYjzIiNgTfOh24WfwPDgCXFS8i/qv/+ynX4CpUVs0ZGGAJVdGbTqiK1wMolQSXIdLND",
	"gW1CpWZiRJdLklKsSLaylYW0xmBYm0pEmcnxWs5ACdFkk0Zfw+ZpQ4Gk0xqMPRW/ObhhEB+0JJhJnzoh",
	"lZnNcmmXeIVwJrmJBtKnrpb+swq3EdLVjOvB6L265BArlBCmgWNWrZTzTs9WVrZXo4GACDsmSGQd3qaN",
	"tx/NMO1Xn8dQsEnbiqcP5/kS7P/ubNrAB+oH0xvZ3nYyLRtCmk+cCC4lWhaZonlW5sGtcn1iln6rN5ZJ",
	"Fdw+ntZEIXRws0y4IHFnXSOo2KGboPLhrCy4ZDxaDqJNH5iUwMYJN3Q+aBFuXfJchSgj4mcEq0IAuroT",
	"X+XDp5VLzQZ8Nguq+wArtlbf9VqbXfBGrxJOTuxtvD1jzKtJBs2QrCS+yycqSOmnd7A2z3HLp8ny06Xl",
	"p6A3U51je1Jb25Zj29JROzgje3NvPIZ128BsBqfP/eqVxkoEweXhXfIEuMyOwWU2sCHIQ04F2a9XptHx",
	"9hwuQH8fSqVp6i78rRUvM0y1Ljkf9CXnXP+Mqup/9enSV3c8J53P8yGv6nIorkCaBmLoid2wOofh9zEH",
	"PxYrvxhHwKq6ZaRVLjjkrL3DxkbVMdX+LZwrbMwZbhzlw/fJ5PvT/lS5azYvrEPUtX49t1Tz+2a+eGWi",
	"sBp2dEU6U84nOFfJAm94wjVKMLk6ngaWvasGbqc57UgknFN0S1ZGl5SSSKkvxVDG80fO5xlBH4gD/oop",
	"InJBzWHUfgkvpIpdxYQmHmPzc8L68v3VdXkLsNq5MWSAuDF6uncCQV0s0ETHhIXTPQP2hVp2lRj66frt",
	"hdWQtErgIqql1odA9FlyoBiUm8/ucerrUgzx3GtKZbprFbRdA6/0bBoAr1RxA+PpmdEwdqOdQI2rIQoD",
	"NB+bkliAxDtfN8zkaNCbhNcDhm9a7nnwVUmORiJzk2SAmjqxAMo0LUt8lourFebhGIM3ql8+XLhRug3n",
	"z61fo6ftL7vEiZ3FUD52mDOX5F7SObNGB35LyQG6oFoJh99OjtB0Za0ogazvsZdUry5F0tTcwcwbylcS",
	"vbkss75TZpfkp7dn5716ZTB42D5sNqSgnSFb8U2MQIA5Jf6FvuiYFqPqz/ju2P9ESmk2umGLsvlMuNn/",
	"eiYoYWm2cuvxzQipQjCpqNkOei15/UrU/766/prgErsFzHFO1Ndkp+N4w3s15lH8lrCDjlMaNIdQ2YBL",
	"8xuiprzqpmeAESScZauYW1/zOnyXm8RcdnRDBJUEhVTjHM8JMlnvt5AkVogET7lLUzAATjo+VZgy/5ab",
	"NJgpPDKqSAdwqEGwC2yTxdblom+e9+ConNEZMbYJtoH1ZrBGuVaTMqpKUJeCn3puPW4KNr3tOP3oMaw6",
	"FSIQypARNg86cQfqJVWFX8uI2I+jYbWQLBpvhl6SJMOCoHNLWcdMFWKDrKBulI9tNPanUkVtTVBGk9sF",
	"LyTx3nKbxwJLUcbnYDo81+1/0u3BJqSP9rYSOcUqWZR6ulcFYjIZhQq6aUIpk0TYPDfQX//x8ocDBAav",
	"lMxgu8DRTn8vj3loebC2UEaSFVIRMaBiuTc+2ym4EdMpRGrG3hOEHeRpc4Qvf/AtzNChsTf7aXeoagbu",
	"LmSVj0wdre3sjaWOYf3E+KvdTj+YFXIRg8vTnXsmccU4Dk9l1CTTZQ5J/euJqQNjrIlz6WxxsMIkRVMy",
	"48ZsvAJ+cQdatWAHN+zNDFW8h6hEguBGbwS0vrGkjip8JVDfDltHgH7i9+ROKxG0iYhxVSFbeQ8pPjZk",
	"LCDSYE0KASX6DbfzmSEDTMqBodWnWDfTgvJTAXZqPoMKtEucIfPcIUdIE2OM2u6BF82ELVmOWYow0oIe",
	"yWI2ow8jrbEuEJbot+PJZCl/G6HfxocHp4vftP7y29Hi5HT52wH6O6Q5h4HpzmbSfmPQvJC/oa914///",
	"/5O/fTNCvxko8J+l/s/it7ACtOBSxTkXw0pENFo36vA11SHzC7BXbUMchOvzgQEwTnjBVF1yde8z28ko",
	"Ip4H2prKPQss0s0QQZcN0WixrrJg6SXlTJ/XF1eBJzC33YNvbc4zoXEvscX+Bs128yXAeDZ6RQKdUGrx",
	"RyhMxMl3+6IYHjD8ggTJsL3EYF/EN04wzpVUAudOk2vfz0zXQJBkFUmyZdUsnFO4YpfZm9f2cOPv8CRp",
	"5GIfUnu1LMPSnenMG2gQQmXh6YyS6YtdCQTCWE85XzczCaWKNF+vkjl6LXoP3pr0Zudmdi/4/BomZU2G",
	"s2bzrjTn7sxdX2h0wGw19fsOoA3ZAOGztgZ2h8dVk27fcGkGCpXOBc8yeB0rnzpDmm0zK5ikbA4Xe7eb",
	"wk5hUHLXz0QJ/j4Q5w9nrrUO3GOq93iMc32JMsW91kxuYDROUkQ9csZ7nmtkI4DEbCZivnOXtivc9gRk",
	"tQpKtEOyx4J8qqVASAlTVGm+nP9Oc9C+Zpmpgyfw/dh9CqZHaPNp+dBYFwY7Y+vYRcZYMoakdtGci+WL",
	"m2h8E/UQJ8fNy9KT0BYIJDGuZ/Ua0oHbIry2LYbON5/NoOx02BlxlTfG+gSTCkgcV22AqBuS3BFSeF+0",
	"0vS0tsdTPDnekpUNzN48l9PPZIUujE0AnNXzQnRK3lZGQXQJreHV09UfHuYis92LJuR7svpPKXpTyO/g",
	"7D79qXlBeHNBNg7f8nZwbmolPotGHpnl/plShsUquH/vBVUkNk74w8qZBs6GAM/JItv8JU4WmUs43FvD",
	"y9UF9iOPu0oJG7Xg+0m7GPDkcbSpUhrQGbs8AmpWAecZ4PlTOAcaMOTYbCXgLuCuxnDFddWN1ymrmxW4",
	"9XOuxjnPaFK3zjhf5qYX54wy6wlpIBhPRr1WZpUlcpok3G7gbs146ryoNFvQlOifTSUwZ4N3bzE3DCGN",
	"+gW47eqe5u7c7KjbYbZ6gbABT2UbNp3pJoizBrFUoq/0BYqy+VcAJ8vWwsmyGgxDVA3KkrJ1UPRAKy/L",
	"srcDSSWaw/KDOyj5VODM3TK/CqxXvKTsK+NTCdOG0BuLQpOwwBJlRMoG2Z5frFoQ1gOYqsYwbG04/yHB",
	"MglmK1NJ3NjowglowngG5VToYFbnQK/BgO/8nqs297ycuV1is/U2kvdCVfrNSijXogH3dA18wtrLiS+p",
	"B5Rf/lIxefOKyaY15Ef1S8Y/QZy3w+PXeX9CNFC1QJA5echDz5nzIsMCVbmqmsXkLRipz0gNKmiihLfa",
	"weSvM4B0Vaf2H/QaO6JDI5Kh90j4YUPnKKNfPTYJCLpFlT4GDV1HKdFjtrLi9Y8tlcC6redM4+o3B+km",
	"XSYgk8jrcxFrsnmtIdc06iTYZAXsUL6Uyrvjzygz1+Xwr/oISDMSlmFL/JDRGRnugtgXn85Lp8xA1C6X",
	"qnsEZe2VDqmW2Jfm8K29biOA2wncaSSxxkjITvBxsONxayMKFTu7QfONFacSYeTFmhq/A4zgeua/Esm2",
	"R2BGQ4/25x4w0yRkl65Ht3ZDmNGMWHN/251IyiL03vD+/OoSmR97+6919OjrzBOZd6D2PPb6+8dd4W5l",
	"tB+qA7TtN/dsSVTAX+yKzhlJkT/d13RJpMLLHIHvRfcAmoVBvPX0DwkPtIkrSroswI5L+9xAvAwj+nwE",
	"iJZffUxXYFoYerC43THsTNfNS9PFBlf9K2NLR0uSLDCjclkOALPU7rba+NxN2Q/uw0F3cE1SpSY2rq8Q",
	"sWXkKxfwbD0jKjHBnTV8UGAwvEm2g55XG6kberniQ5ZIbusVt843KcA7Qf6EZeph0BYguQkXGrYK+Cql",
	"ZFrM/SjjhhxmnFlRVnm+H31/8v2z50ffnw6J8/lUUNJx/P5OBI/vsWB6IgMtQrYwl61phxx9ndnmLOz+",
	"ZHOOM13SuXbJ6mEkNa5mH9sYrryy1pVZbBh018Nsr8dRc11NZUKwAQzyfyibV6XaTCVpUWRkOIiqj6w/",
	"+Q4C4b8Q24wLZgiDiSi7yEFpCMsYbtBVcJYhqr6SKFnQLBXglG9yCLef7RrqrRc2Vl+Z7XKolwbQfuGN",
	"p1wozkw1yQ3T3lepDq2pKvbLFu6jUD9AR28M9FppwG7keysNEsZe1QnB6V27TIitvxeNoizF+dj8bgtI",
	"lZ+g+FD5CYrwlJ9skZcIkpmMFyTL+Nh8VomDN4j69A6zRKtXrvgIzrIpTm6LfB81v86yDP1godXzS27+",
	"9vSD7VzP8N2fNtw00+ci7O4nKawAoMtL2Y4Tdl4Bgxf3WT0dZ8/72vnFa3TB7UM9JHh6stpJFv5Twd6+",
	"yEdjRoDMQE0bh2P7mjbnFoKraVNC3HNNmxJPd02bCvWea9pUuLtr2jR8O/pNY0s/Cb31rnsiJuJMQQWd",
	"EBcNrKqhKCt4IdGVwopKRRNZN9r1j9UkZfeUTFvBYNNY011LWYS0ygHanmv9WG65eHEUF/lc4HQfYu6l",
	"DbDTp+W3R+gXC/jRAxPU89v5bHYlxABE7wzACoVmxv3A/0ppuYzeaYCVCdKVBbBXooHWP7LENItxRsRa",
	"BdVvuu7Z2SjTZVD/oLsg9AlG59c11le63WubUyBkqzDI13hcltikKW1a3QG2oFgOJvm14EvNo68Mpp4B",
	"ZDw5nhwNIiHjSVTrdrxRtwfNKDjbW+25VxZgpQLWUcQJXy5xW3ZtkGm8jgKdW4BtVM5jeD94LrHxU5px",
	"cY9FOuNrxZ/XUvcTfLlNdoBZkWUuL+x6s8biME6wJDFO/6uQKp7yeSFtjs49rO5Ph+gMAKMfNGBklKJO",
	"vHsrZ9rEW5kgwGnXqubxDCeKi4ETpTu6p4heA0HZ0FoYxtNiNiNivL87J1zzDFRRXTUBVyHJeKEe9oXk",
	"F0hV9h+lsaQKS4hDRYrNFd2SYlZzXPvulpB8DNWOww4hGocrGS74lMh9DcRUzkaXBqhD5ZVyfhJVEJAw",
	"XkW67WMo7zh6CfAcglwQRVgKozFzu7mRxLeKPOFcCGKzlAryKXaloGqLXL4TauUxI8bbGFJwDZqhDxZB",
	"zRCDvFJQ0httUbfB4Pkc7giAHGf3eCUhY7B5vJd41sO0Ui8AODGYTHs9c9dnD0m9FHom8RKE2jR2OXiJ",
	"QOkOD9u+trsxzZkZcwiH1/9ttLb9B9sRgAprSACPKdtz18E5UOAQlpEYhFLM2T5tcfqWjM41YPSe1axw",
	"//jl+HuU4+rnWA5L9a8vJDZTzdXLz17wXxLNm4p4CvyGstLY7+cb3JwyPscS53sa1tnV2aX17PBPMKjW",
	"vp1FyYUUW8EDkEyo+IwLtMSUKUwZZXNUHeBeiKJs1FHYigBXabeE19AvTLCa9abUezmcx4RRxUVcCLpO",
	"UvlNH631e6Py/IEeOyT1YjyjbL4XUf7OgXocRS7tpHHl7xuO19KkhpN0L8rqpYVUAS3L7vaRU2v7aN8j",
	"NlqfQI+qDEGGpdrffeMSgKILLP3nTthGT6NMwXtMjlWyWDcLXst6ot/1Vx7j19hZGLRZRJ4kdLYyWb60",
	"0mJS5sKftbzcABVhNMM0I6mv2thD68leDiz8p4G93ERLarTW/aGgRNxpN960pL+ppnMF4B7LGrHryDKt",
	"dPs8AyfjQvF9UAPQ0FlhZIsFvr/7sIXvPbuWKPam3ZU4KrXOFfTfB3Rz8LZfixyO7V+LriwE91pUQtzz",
	"a1GJp/u1qEK959eiCnf3axFsLd9DqHcn1Bo/jiKFRU6f6GaskjyWSyyUV1Zt19L+SY6uNEhkPASiGhqr",
	"ue0Vj9XeLKK9bIr2blDJ8Kuk7m1vko0qIruS5UHTwAvGSPY0nFEw+qkgMU07L2ChyrHQCb15iWZlCaAK",
	"UGUw2ACQ7fT42PLukuiHWqKTloebjMuMZJ2ZYJuBkBvGPdSyWTfJ60kNmxITSaMyLLtdB8EfIt4gCLj5",
	"mmsy1Or+jyPIsdpXtrLe9/+5ev8OuWcufe0sS98NuiheQOtaPKuXXHJIcS3byxbyNkoaXJ/5MBa6KluH",
	"vSDnAi9LH8gwc2R8juzLCIL2Yb/GXUN2+0sO7lLHr/0rTTrCMbZJVjKk5vFu8EzypI50fz31nfprN/mb",
	"FZYVPFF7maRPhFScsZnsqDhwDUGV2LBv6CbQoLzMbuUu23JoLV8KBpfXGVfuCIG4oXQzK1VXfFHe8YNX",
	"PCQQ8lOIOanydA1gXOhA0/XG86qxlzZv2I128PXX3IbizUWJ7bhdgO5GZddsiuOhtV42YK6H/qV9YORh",
	"II0PZS3FAW2haMuQto1wBZqaxOWB4K6P4S073HMjtN99WWF+Rr+YGk0filoBi1JqNJxnAllCoYU0KZaX",
	"mnkwU3D6LYmUeB4qChHwEbi5ufrbv+n/hLd4s3QuWRIxh+cuE0mXCArBrUJATigT0zCKGFcm4wRlMx7Z",
	"cIuwBRbTrLvQeL8z2VvT11PZQj5ly9WCS9UZNW8sFgNnpMFGNgTHjQGAeRENr/QP6MxOVeugIizNOWUq",
	"lNzd/GJSsdKgytJI3dEJoPo6FOJsKO3sbn4PFZULJUuHjNg2ur8cXF8asFetRu3ZCUY7Z5lNgcJnqGo4",
	"8AwvSQtQItFZR/Jewu6o4KxZnbC+KPAarQi76wkzDnNiyC5va9SWcclre/wdWgZjsxyYNen3LmEAr9hd",
	"0OusbcaWRCFvZtAdFhQq0nTB7fJL8yduwKv9kt8RiEwJIkfkAeIcNCNyRiQq68qZK8k/8gpdDV6eq4Fr",
	"c9W7MAXbeGFkx6qUq4AoQ1jMC6hqEr7qwWtrd5zQusSb0dnlGwSOkO3YTvtQuF69sAfpIPVSmpoxa9sV",
	"g9TVZiiwJrmixz9i7BDD81cWWg5OgD3TjyaT0Qn873B0MjkenUxORieT09HJ5PnoZPLd6ORwMjo5PB6d",
	"HJ2OTo6+H51OJqPTyeHodHI0Op0cj04nJx9Dsxe2WoTzJjRdIzXxZelmzxU2OJZgOsKnGtXuCf86NJHO",
	"TZDx5E9bQ3vMr8knLDKtCWqKQrkSZjhRcoed/Fr3h+qNEumbZcX85hd4tEJvzS8t5MmcnuX58Au37fBD",
	"OH4UJ9mggEucZMNCLc/yfNcoy9fnP77RQ6xG+0MwttyZPl5jqc5/fINwXpbgW2MdS3kiOFfBcPUyl1vK",
	"E5DnSDdF3NXiWXJFkFbAD9D1wi+QBJYNU1m6oFnqZ7izRV75rKS17CbR1fmHN5fX8es3F6/enb19BbH+",
	"l2fXP8XXH87eXV2cXb96eYBMLVKMlpilGOLobbbqYKKfOVExoJTdhXurQkvSjkwJSu5wpsmsjjgv47WX",
	"57sqbL1FCRXKUvLQP/fm+8oBMM/1BdHUNcXolw9vTEUmyA5ouA3JDMsF+vom+vYm+gYqEBEVWAOXW6+1",
	"EG4d9BqU882q9Pd98w1OSM75p1EBkWSZrGH02bRd6ViDcvkc3GzznDA7eArFeCAhi3vbhUrDbsJHnajA",
	"4082QbuCs1AWHSoycpNj0T5Ob7G84GOmUiI2CA7R+/yCz6+g28AsG0v8EAvySfanwPe5yhqivHSDCWeu",
	"kEKVzU0PvzZzmCHzMHngsgmGJthuIIvL7SCkpVn89uw/4g+v/scVSgso9uWtQFlMWu+mkV5gjY/fESFo",
	"Sgw1hgkP0OtCaHZZckFGLneiT0LKiSkmkfKy9OwDZXMAC+XLjG95DeraTHXL/EECd28gTWSR51woO8el",
	"2PBo2n4uL//jKj5//+7djrO5OWeH65zYYjl6SwaGMrwSdY6ltK+Tm22cSyxl5a48YOfkGDL/zXi3ENbi",
	"pZVzTnFEHpTAifKENJzacGhBfVysFmMNuqpN9cuHN1B5upAjdFNMJscJpLmDPwlaFlKhBb4jSN1zV3BI",
	"vvAqU6vy6+bRMCrRmlSNzaZADGSVN9VdYGeYWkDAGuV2yYmYcbFES6ySBVThZ450g6NsOdObKHh+SHNo",
	"v3n3+n3wCA8ayl05ws0W/IqoSyhiODD5deBm7jQg7+b1urkJpx0P21Yp24xmq9A1jVB1wd8pXjI+n8O6",
	"zNDV9ctXHz6UNuGqjnlYjmgpJPXydx7o6IfyAX7kaqV7BeisyJRNxAd9b67toDSc0Iwqkxuu0vbNd6Eg",
	"tsrdwbU234S0PePJ7rX90fm2tx8ubPJx19KmEw+J/eqpvWyrvwg6iNQy0/pjrVjPMOMjHDYt0G/NAYSy",
	"/aCQZVLs+grBm7D0EX/Q3/QlPXcNwX9h7TOMRWC7e5vrylC0vly93ROeTG8/llirkzkcXXXyMkjGOqto",
	"YaiPFGe/DmyPgxv23u6GbDVCK17AaTnjWcbvjcqgVWuGzs4vbB3WMqf1CFFmi24lWJLOHahvFAUkD6PK",
	"FGK0eksJSe9LvXIHN+wtl6oxDJNUGmeC4HSF8B2mmakmz7uVak01yH/IiohuIKrmJipPIT1QIIURSPlM",
	"pc1PRu9IOW0OPcgXTUNeiJxLMiuybIW0lFUkPbhh50Z/1BNoM4BDt5vorFALLujvQNRNNEI3EciWcesH",
	"fVwseD6ersYLntcGXuF5p++dpbCr0JxzpghTY81GNxHAqr40FQRvIgRBXOv4AU1Jggvp1Ulz855wducK",
	"7MEEuUPvIGCNNC4XZQ7+GZRaybRkHJj8wfCFzVORxso6ya4TCg5zUyD0IUHX1mF2AyNW7QgO1YryVUGv",
	"hrC/H+tXDDifpLmhjspyhdOV1ZfMYWAVJr1DFb4lCFv3Nr0qhlzDgRL0Melq01Ws/Rfb7v8snNMTGrYJ",
	"U9GZWsWckTglc0HIYIe8TR3wUqzwcAe8l1jh0m7tHqNNnKczGw56VIJUoTUYm/nRWQPrCq1xqDPpsLdM",
	"x2Y6y3pZDX3fIbbEpdOezXfC5CKUkPWw9uoBv0ftOhpJuC5FmyFdnL3L5r9QyyzlS5PRHzOcrX6vl8L6",
	"lFENBvJz4yxbX11lPc57PKvhi3GSDYzq3QzuLMNzuV/IeT6gKKmW42Oc51X5ES2WbUJ1sJYUtj7t0HwY",
	"QerqQqV8W40cekuymMs4o0s63IO6byqWPIWU0lpHNvCLlKpY8ViuZH8SuJpL+TZIrJ9QVXlt/4immKX3",
	"NFULM2Udi/3aLKWxIvsV/CFv7nSFvpJEjUtYY4D1lc0/DAc1hLVBkVTsHnsTVHZA0MHWoDWC54mY5ddo",
	"ep/R5Zjq2TJ/Qqp9Mxk8Xe2RdcpdZM6ZTTx/N98ENtneoz2xNzv++4bxa41pRqUE/dh/qu9LdRjtiR6j",
	"ZYRcx2aCEGsTsHPacCY7O79oeJDhJItLL7LEXBF2Po1czrKSARvvH8bu7tncpyvlzDa2SrP1bicpGGrN",
	"1Y0IylO4sRH7cgOWwinxnC5mXOiGY5NSwCTJXmCh93b3FrXGIKP1Gi3Znf8u4Hupb3ws1ZqqtX7aglSa",
	"8kAV7D1u51YRNTe9ZkLC8+teuKC0smlY1gdxCrkteB6YFoEVMXNil6NzgvtmFZT97qk15ay7p3ZJs4x6",
	"Vc2HhwzV5r3FjJ3bcquVacUnmRKRM2pL+T6N6K8LDi2ejdyHUJqn1huC9Q/OkLGw+Y8DosgsG5m2UyLR",
	"PTzSZvBQLMvT1+p96ci9Jug/E76cGsO8Zg/HvZJkJFGuuDsYfghTJou8UTPs5bJg1dYOC4oBksHw8IAl",
	"ewL2AoNrlUJ9Z5WpPMW/yOUnkcv70qGrdeLzmDyomHH2OxH8aYDLhPcWNN0eNGGymXir/HJU/f23pZxv",
	"czm1022xl4Z+SJzDpVqfdGrLkXnA4w3qtg5HUD6F7O3yazK0PhET3Wf7hbmkrLRktQVU+VZnHRRa0qqS",
	"UFo0GC1juoLSRCB6yEOSFcavZUFQhqVCOYbMECDnlngFkmuJs4wIkGrUmmHXKkP/lFKtmXNIkAw/gGOE",
	"ySq3xUWsfltw2e1spH9MWMLTcNmQjSFzZ9XccSv9Gk25Ws6X7lzWms24nZ53fbW/jS6oVq/bygMX6mas",
	"n4Ad1ECZcxIbp8qnMwZoJB46wuaU7cH2EAAvs0Rk3ng2BgUAasBouiugsgp5Q9n2fBaUe/usyiRLRXDa",
	"qKiMOCMjqzVT65ClaHI7Nv1T47FUlY6yLnCQUbHnKvhXVqH9ixGMMk6wInMu6O8k3e+ZZcA/yRG7aRKN",
	"zeVLhQQqm6630vYgNHDGKZWiyJVV/5oqWomt1mr/JmGHx4Wj718GmlefBXlIi2W+1YFl34UqYPsxrnaC",
	"FwwSp2gVadsz1sEM54FJCPqAWcqX6HWF5jH4QPaEuC8tjkCtzA5ZYczO9Qoao+pFxhxA7qEvGnXYbs2m",
	"GpXqgjsLgs6jhSSxOdX3fwfTsEOpcva/yzSmOyye6FnnHlOlyffdYPeNpeGxBa19L0j3jtPxtNyTgsMd",
	"gaAAoq8TLqxfvfQKNZfeGN8Mje61L0uPTRq7I3tnkP0yF7QvslfKLJ4Ws+FuBFf6vmL1jB8g93rHE3wt",
	"338dqVcHY21hGKhP4NKBDfShrswAQ7PezCDtbzg9i88nbTK7o/2sLHxd1jFgimxS5dD16Cr6t1nQlin8",
	"pcHJe2r8m4cX2gt3NVBdQpquMLh1hRzNM5Tx1x5EjPMOr3bjoG5u47rk4RDzUqZG3LDyYaDzXksp1vLQ",
	"bwbJ7+XD2mqc7RHuXuRx42E1OwGkezyL4cl7MJhaj2FhjK/tFtw5ltFtfk8Q7FIx0sFoBTh6HkutqleR",
	"0hPoPnZVsmgVqPBSWh9NJhNnHXIpqO0IAfbMG2ZTVv2JxSf3VfGwvxJgTftwFrTKRqXysAr7pWTgmqlT",
	"SdfMfSkt+JcuLfhE1f/+CtX8aimK1nvPeu3/uYr5fYZSfV+q7f0fX23Pu8iGF9O/6UrZkQPycxegmxc0",
	"3abfn1aK7h+pRtuWytZnL+Y2mNh/gqpvg9fkzykPt9eqbruN9a9U/u1z11Db/w3qsxRLG5ZZ7Z+/qNrn",
	"qIH2ZKXJhhy/T1aj7EmrglljjL4r99UDm2GaDS0IBm13qiX2T1ID7KlrEn2pMTSgxtBOVWvA6yUuHWv6",
	"zRhsRuex3+OfpuzNZ7XObVq1Znss9uj/CxaJaWXc8V+YnQm/q3CMM6b3PTW7JpsVe/DN9E1yQjnb54QR",
	"gbMyXLxOzI/mV1RIYmq0rMno3U5yE06o6rSuzpwsrShPW6vTd5odUN5AcYHnlQ9Od1bvwEBbi+ZPVWDh",
	"4Kke8RmaN2ANTvJdW4sAcWDD6XQJmFMtZcK51c9M9PM9QeSBJIUiLv3VnCrIoCQpZJw0IbRYIklUkQfy",
	"H5Xwy7B041ymBc1sZtxtlpBeH4pSGlecvJAL+CcL+824pvFUYGbKPa4TVRUhnWGnDr+NPNVkxV525D1g",
	"MEMF+NRGiOL0PctWnZmU/YO0lxOoqg5dV2emK7dAUxrZdp48+pHq06KeUN/j65JxAlx9QSWk+KtASMdD",
	"6WC+rjjzMUSU7OBmf7bqVDn1AbIisZIgYGeDqc27PrS23CmSxCb2KjnbfDUrsmgUmUqeAe6FuW+sujfA",
	"Us/pmHeboUwGk8zAL+CW67Ypul8QQfQ+vsdMuawrMzoHQWO9hvV2I2l7AuI7ImSdgzxZiQu1AC1Fyljx",
	"WxMI405byFx4z0U6wGURAC2JWvC0b/fUUNnUArWOpX8fljSJRvUOPbW8AUxJ79MOwtBWUV9IInoy8e+I",
	"wuqvnWeqO+5SKoYQ4Jqv89nX4IwbfKODW6ElWXKxgjNAhB0jh6fk9melIcHcjgjupTJB3jD/K9O+y/tq",
	"Fz+Yz+h5YnMAlsPfxevEQFiTVHvKVZUWeuiNLdwJjn2XoXuwb3TjGdkAgId0Lkkscy2K4Sa3bweIQioi",
	"YkkSQYZdPs5NF3RlusDu5bdxssDZgSTK1iiMsVKCTgtFhmbHaZXLGJu6heisgqSR5UW8xI0Eno0cU3mh",
	"j59ho7n8RW8/6/uTBFNghlM66bbfXkMFPQOhsesduFFJz5paIueXv7zF+ZBaIprot3oOQgC6Xj9TTJa1",
	"I9J/TyfTYj6U7euN/TQPWC0CVXjct3sJEzBGLhsn0JDWNhQocucJJLSx39h+H9cV9yhdqtdKJ1uk9FIP",
	"bwv3imvyYAM5q5QDWuuhTCrMTAaurhqn/asT6NNdMam/NFO7Czg251omkYecCKp/xFlceobLDseFB732",
	"2Fb0H1YD+JXtg86hz7o8c/1etF0duz3O++G1u4Demw5zR//xDTwbzIWtMrq9QG/67LgM2PAqiaZE3RPC",
	"0NWbH3+5+nAIobqC4AxJPlNjqXgePhbmghf5DufXj9DfuAVYJ8ocrzKO01hrBjFmK09BbLNL3ZugR9Q7",
	"N4eOQnKDCsbZMnE9G/6nw3MsifFAWOOS4jftksQNX4lOrXdxGKc8ZlxVj3OUQTgIieHePCOiLwhZgziK",
	"77m4xYIXLLVeGfdkah8HjH9Gx5ZdYJHGmkWM2/g+2fQnLFJ0pXiOzmbKdWy9OWORmrta87arVyjOBb2j",
	"GZmTFGp1BnjjU0GTLV7hVLLxM1q4jFLzwPgJBvQByL8sqb8E4jeBULmAGM/YgTIr1MXz/Y/bxZvWQ4Mu",
	"AxSWDyTPcEJGSJC0SAjiAkFWDZMAP7OWGGNxQwDVHY1anoEhxJbWCu4nTcsM0+wvPQakKSwE6RhEubNn",
	"XNzG95ipLifAsqUkqqBpb1uIVCZp7PZCoAVPcJaTDZNANd+ME5yVmstXEml4kLrwoHodZ2nsl/4cHFu1",
	"ZrvmLpPxoKCpHQKjLvgcQanXn9woQlv0gs91o7KNHn6Bh+5Rvym8v+ub1lhL8NqDTo/S9Ba6oH+HLugt",
	"N960S/ywpCwdSkaz+WMtiHQwlEAXA6nIyFgrA32XuI4qjusE5VuAfsFxuuagrhp2HdOWUHd/absnmHWJ",
	"TS2fcjybe0pcL4iXHEZf8rUGZ6BDMgNZiDt6RyBNfmaHxqat6u09KN6V4M2NVRqPhS650OOqrYVdIctg",
	"yv/xy5tzlAuueMIzAzTtKJxfLHFsb++5VVg23Os8kbnL0DqQCUNdtNQwRVO0uBoKKdRFQ6Lp4ITUl29e",
	"Vvmo86MYEtsb0QhiuKMSu9bYM57Es3TYUl3aDug13DJEwTRPxTin9Q03zKA4pSYSPlzyftMC680XHdv9",
	"Y8i26G/XD2YQZ5dvBp3VpjU6u3zTNJJUgLr2vcTLbLDTht/WFsVJi2XunDbaqymhvJ3okXzkIR/2ev/q",
	"wY9d2bBObri0DuBeX/P271gMrXnbU+f277jTVd/OUjxb9t7+hrtMvC4dJfYyTxbzoJl6vVSbTpb165Bd",
	"8HqmLcG7XNzfX6FznOMpzShMcgcamcWJGL5JGs0thA1617yisJJ9L0X6550cF69scVMDooT5JG5U1qMa",
	"1PSOe7g55mMwycQZZaRPayoNN8NNNKxYxlzEUP1n2L6wuoRApgBRc4sYGhqA1+wUo5WUNK3bK9bsDu1l",
	"N6gLmK0wD/vTKrdTohx+Da1gJDYBI0P5OtTFQdrgytBq72Bs0r/ZV6uFGwGodXBQNtjkrfYOxh0WciMg",
	"tQ4Oyu8ZnW4EpdahKhS+nkd+MZbdwqb2D3skFHKn6/Yv0oC5x7Ohg/Kb6p6FmA1em3rjmm+ZeVrt8gUs",
	"hVH4YVbPAphNnMAI1/3f1A9bg5Xrjb9Nz8YfLRHhUcihw9jQqXFeSjyfjJDb0ALLRemf0FCDCtb2Xkun",
	"S32d+q/pUTSK7tWzaBQlIjk+6nMwabuoLHFuqimZRzVJJeTdD3vrp2Uycdcd3+EMs2RBhthMTQqcLPSG",
	"uMAQ7OODhsVK+T2DQgu3TP/1saO8MYSLpZv3DpLIpQKLc4BKLjuSVTvDlz4031wie+txd+glThaUEesC",
	"BakQscJ62hGVSBSM2drNZZ6M6PDo+cHkYHJwWC/acXNz1VGf1RLcJg0q3TrrgyuT1aQhg3WnbA4+W1Xo",
	"oaxR9f1kcgK2JlOP99np6fHp2qqDMGmWwI998106rDTHQKUpL+5MsL/9xKW65EL9hgwYeYBe4WRhP2ny",
	"FabMPLf+puH/Bg9jv+XQJyUK08x4p2FvFqx1E1GGMLJ+EwcI0APme15kqQNeVguGlO+USNMtpdL6MqQV",
	"ZPBIHSFZJAuE9UDOM5rc/sQL/dvCZAh2+IbKlYpLTZ7iN6bTYUCudCQG2tLbBsLa/MLckkB2/br/TSvB",
	"GISkQrdx2a16U/6mniPGlC1x5VVqNU+iP5AUCTr8/ujg8Nl3eot8e/gMPUajaJGK0sVe8+gYz8m/Hh+e",
	"Hj+bTCb29/ICoJXy8bXATOo5HF9V6fPcziJqvCgjBNsZrtz95ImqKqQkG+MkszkxNcJbsrJ35adHGcpl",
	"c/4z+pmsUHXNdrmxBgUhrvf7sOA6cqrYuslXGVdG/yozcxHWpbdtWOpnAPoL8zbncHuFXKsl+fr/fmG1",
	"mI9/u7n5+ib62n6ElfrmJrq5+eZ/lS2+2cJDZthMGdq2qlz05xcufIqSQr58+GP37SLMa6ETEqPyC9Ni",
	"5EuQkRa07kN4f9kg6Gp7aXKh4vfnoLaXprdAhSOp6dQxPG+5FjBD5gDwobcG0aMvuPcwEd5CjNqz4pHY",
	"WMAN5uudexb0CyiUDyFLIuZQBpEIcGQTEHJChICErabEitbgFYXcrlAI3/rvQeXmLKieb5HOnKhxxudj",
	"Q6Epd4Dzpz7XNNYlzu1U678+lqif/IQLIg8+seaNs06TB2CeksCSvk6i/g61HyqyZOJyie1ehUEmY41/",
	"niuphF0VmcQ9bxUbw9d7b54nmo1LZJOONbhKrohC1QOIGbsddLetZjeaKEtaHya1T4c14msf9LS1Rubo",
	"ffgMBHcRVZHBdsvdvt+1fWPw1RZ2gyC3DRi6iw6ZIIvQI6LMOF9ec7///nu4YplPh5PJ7lMGW92isvEp",
	"+u9YECy3q8HbBgjvDs2EDBAZwWezvZwg5hYFKILu2rWzFmcZv49K5dkKYX3haBy7TjaPBqhY+9y/k9Bu",
	"9lWA+ok58o4Tb/LNhzssqr/GM5N93ZsurYC7diGb1h0W+5K8JT3BLfB3LFD9lRkeZfelJtemoJOA6kDT",
	"yJ+0pOuvncvjLQgwsyZFJjz/82lZkxPeM8iUsaUfinAceHeS6E7rd5e9pyuT/HpDz3DXzZDV6rEx8rP2",
	"yLsDzY1DqItQaDu67C+MxZpQbYBllrOnAB2y01xcvkOX1l3LZELn6Wq7EwWSoJclnHtyLG0CDGY/Tvhy",
	"uV19318j13dUzgS4tZg/ANFHv/bvVsU9astn8mJWmoE73y6ev//5PBpFF88/XF3Cv1fXV/rfZ/bzyfn7",
	"d9sUJbOjMcgfkgwvsckDiMXtVsMpAYadjEiiVe0SD3qr8ZQFC4b7WwuiCsHiym66WdExxyWNoDfNMD9Z",
	"SsJP/VVept0WurS3tFJEiPKvRarl9cz8U66osH99fKp6/ANWsLTTtF/5fnp19jIaRZe/XOv/vr/S//z4",
	"Sv/3+sPZ+Sv95dn1+U/RKHr56uLVtf7i/P27d6/OdZP3l9dv3r+72oaRq22/pCwWJLnbi63Y3x/8tmNn",
	"woa0G/SZ+Xjy/uddtyNnJv3bNkKwAcdL3LALpJLf/tgfk3kPis3XvuoiNNqD0d/fffAGaGnfYk7qsPQJ",
	"uDMUcNwtH6Z3ky2S0d3pCSYR3hQI7JZxEnTj3oz1FC9UcPddvwdJc/HM/XECf+y491rhwAFFwLqXjzkb",
	"n0xOWpqB+Qcua6TnrtZ/O7MpB7cXhoWge9On9nhVrC4kH/+My+KvtUX4+OW6uDUtrWQ52/AVxbHkya08",
	"2VXkDLm/mgjwrhsr3Bk2DftzMeVtPOvuh62oy1Y2Jp7pOY79Ggb7SE5sS4d8cAjQSwfCJOCyaOmwJLZh",
	"kOb5vAKWCzKr+3TR/E4LTprfPduB9EsDF3CBg8ww98o6MNPROaTjeHAgjg/m6uoCnZ+VcTka1B0RdFbz",
	"NnNecx6vDisE34/37waRVwHUbYx9Rlt7SG1CXnRtndkDTumPndvMBdd2BOr5Yg2Pfz8b/+dk/D36283N",
	"eDTQsdWa2RsSwb6prgnRv76+PHehvI3aZLu4MgGUwR5MpnWn4xJlKXmIXkyqd4STo1NvXox9vp3eDa7N",
	"CaRWGnSS1nt4R3Dn2aEJt9khveobNsvlKMpmY/tXiTObjd2l1srwDpxuCzlercGvipNsg3iLG6f3BtKg",
	"2DXdsQB7hSIYQ65RIosSQdeKkkX6hMaUzvUpeWDgWjfC6QBsv/2ldQU4mkxGJ/C/w9HJ5Hh0MjkZnUxO",
	"RyeT56OTyXejk8PJ6OTweKR3x8nR96PTyWR0OjkcnU6ORqeT49Hp5OTjPl7ZPGZoXh7sb8PyBY385r4+",
	"AeVo+s3tfgnFfit7JYp6jeshGTRcL/Kk5mPnYNZoSCYBfixJ6ZW+gfQ9swnbslVV6h285BGfefMg65K1",
	"Vhjp1z8ic33VPOZK/X1LVPKt9SP3Kgx9K6kih9+eTCYHplbDqOp8Mrjzie38sexxT6b6x/FhW55/piJO",
	"61PZDwnQdXGhHs0ek1cMJ5Fb7l5GL7kilGaYWbbWC20Z3+PosuPG7Fyx4mMv6bKLof0ynrsoExbOYHXC",
	"tX9CT+j/67ru+/wf458Mm4/PTTa18UtjC6l0FzdF1fP9n+ECrdFX7gF9nskXpW7/WRylNyGs7kaG89xx",
	"KixHGfFQ8ns7WdFGLyi/Qmz7WEruaGof1pCmVBCcLff3JKlhdrxHFmpBmKKJ2QUfAC8UP2XpPU3VwoTG",
	"mv9u6/hSAhsbMGGvI4VZikVaih5SM2U1CdrU43Rjen5wjRA0Qi6bTJOQnAi6lcft3qYmwcmCPK2hzeAY",
	"F7LTrT1ZkNKz9kvowT9I6MECZxlhc9JnuFlrjxyXYJwHgYNaeleXj1THWyx/P44t5cCvTbDGaFt9/tjA",
	"YxL0xvgz4pp+DlxeVoW9LP6XaBZb7Jet4oCz6mnNWfUI7kc7ysdfAVnkyg3ZFd7bm1PKx9YabXlpmozB",
	"0aX8pLjzq0ylqv4awxO1+Tir9Zn5fXJBuaBqNU4yLFtf8tlMEgdFiqT6y4D/uM2B+SXU6Euo0WcNNVrQ",
	"msXviVyQsMhWY42qo+AlZcrnKk3T0yqNgyj6hw3HygrsVUV6mhnMClwhszngtjipSzBfQsj+wULI9KkZ",
	"h174vp48/DoZf382fo3Hs49/+1/6w8e/fbM/IsVtF5XitorHMYdA/PSTZs8ATRKjCanmpFStDidHJ55u",
	"NTaf9xIKpDGGZ+MdTbzoJKbXLaO/1x/sZwLPl4SpMaQKh+x17hs9J7lJIbIYa1lHxjLDcgFPcPAltBin",
	"XLW+sN8RkWhIKdGwxwWzJaBT7zfFx0WuP5g8QZ8KIlZjyYUaT+1A9iAhy7GPoY7rY2064lmRDfONq0+h",
	"A94eufdkNIwCE9+zPQ2/bj7VH4cRqQcXP71chDy6o/LPT54qY3/yP36yYhuIK7XPvx559tl893fjX6EG",
	"0XypKsgmp+5Grjdrxm2fKMr6V9XdKihdLr28vmbXWjbZh0gFgO4lPqUmAb032uPJ4eh4cjQ6nhyPjifP",
	"R8eT7z7uwacYcHX6yn+wv6JzmznbkMb76rrsA9373BkdDMLmc3TGk6pwFZnRB4hGXJD9yM6BRF6X7gqa",
	"xKDfz/5O3YE0lWdf6bK2D/5ctzFKP7ao5UfyxT9nB/+cpi3JkR0ew548dvqQfvHhsc+CFrUNRHei+int",
	"im4V+hbBuKSUslqqWKlsT7kU4O4+TgXvusR9uLpG19cXXzJtfMm08SXTxv4zbRABhez2ZG+NCknGFqYN",
	"dMo5iQmbU0ae0nbA0rHGNLaZXoPLcPn+FXplKHGEbV6B7YnoKnNy/ykpQzZ/Hey7cjhwPuyWqg13ar37",
	"VMEYZPIwER/7MuPWieDyzzCvKd7hoHzNZbUFlcDJbSyT+Jasno4VActYJmGC3K/oZ7Kq0SQVhUQBBduk",
	"OF2fvjGQkCuN+Nzi9SlSrujHfpymBpJzDVg70usYP7Rgoh3wyRp5jjUb5d6xGrMLp8yejwVRplK2/17r",
	"vcDAG0I0ahigRtU9b2Qr+/Vl9glaYqrPDmL9+dPqkZ8lH1Bdqj7Jg/XAhENed2u8HlW25FGXyWvDF3Fj",
	"w+l8HR/VBN6oFD3mL7NanfmQPP27mR2pvKiVe8SPchzVzvpRdI+pGs+4GEOqE+/zArNULvBt6VnQcIYb",
	"rXNmGTmb3ZhoZrNBw6WLZTg2eE82tF+9OfT5/6MLIR7v682+Bn7fQcVf8k8NC+KtidW/cnSx3l0xVnFG",
	"sFR7OZfr+9csk6S/k9I2ASh3r42/EeeEiGoHUq4NbP5gPfx7Q4T88IN1QUJ+iEFvmFA4tmB4ZEUtJuKx",
	"Z1hrgoX2lnR+43TznyPR/D9XeMVfL4Ti579iCMWX4IUvwQvt4AWpuPic4Qs7xRO0wxmCIQV7naQvZQv+",
	"2o7e5tK/X+/uzrvuF8fqL47VX2o4fHEa/uI0/MVpeN9Ow39dB95/Qke4Hf27vjjG7e4Y98U9bd/uaZ/T",
	"K+2LM9oXZ7QvzmhfnNG+OKP9ic5of46v2J/mDPal0tUXt7Uvbmtf3Nb+em5r/lvKNh5rxgmt5nS2xsj7",
	"Z7uP7dUVzPP+qlWk6/LR2tgzK+yQ1XTB6vC26vOc+uJz9KWIwRc3o63djIZU/tuo5t/wan871/nrr/C3",
	"QW2/ZHHrPUjUfWo+V1WsqkBMbQehj/89kIy3p1hHO09/Z+p/V+oCHppaq/ojYUTgDJ1dvhmh91cIsxQt",
	"sEjvsSBIdxFLZ2H1XKNwDmOYFjRL4xQrje1ocvj9ePLd+Ojw+vD5i+PDF6fPDiaTyX9G3jCiu8ODo4ND",
	"dHKKj4++++4gJXdwwVpJReBBPMmL2BGqD5UsehHpS2H29Ydv0DkX5Ovrt98g+nz8/HQy+QWdX/6C/g0d",
	"HTyf/PjT79EoYsUyTnJIra8XnUvlNA/zAr8kyxJ8ihXOM8wIzmm8JEsuVtGLk5Pnp6enx89G8DRffn36",
	"/PvJs5Ojw+fPtParcFb+cvjs2XeHp4fPJ6fPHkcRl2WNquiCsuIBnRwcnh5Mxqffjed6pmmC/uXZyfiX",
	"acFUga7eXqLrgqCzYo6eocPDF4dHL04O0S/X50jPZmT0/ejF4emzZyeTw9Oj01FU5Oa7754fn0we285h",
	"ZmXqX/rr1LWtX7rp0KyAoAdKjXda6c+mP4OysIZXh2CwzVF5WKxj8Bqf1Mfnc01jXxseCjh+VazSpPdd",
	"sZwSgfgMZXxOE5xpNvOyQzspH66VUfJcaxrsL+h+QQRBakFKPwYqkSgYC85DnWnrowuycMum9Nhg5lCD",
	"OlP/MWioHrM3x/r+qnNdHU83u1iPSKR/RZShJc0yKkkCh4mkLCHoVc6TxUFgIapd0YR6BRyD7M9rLcGB",
	"cXoHzpuaOGzNxy0hOc7oHUljxhWdrWJDSaCarJgH+M48dqGMSqWZD4t5sdTHIVoWUqEpQTmWkqT6ZNXM",
	"Y4GPhjo3gjXN0VPHfInVogW2PzO8bfaxfx4EyThO2wh/Lpsg26ReKSUtz5PD8eR4fHJSFVnQixXngs+1",
	"it52jjVmYO9wvblJ/zh5HOt/jvx//hY8cA01oOdJhZd5eLc4lSQ46e2SdzNMTdEnn/JRBCUeSRqqAeVz",
	"XWiu1s+5HDDpVm8bqo2117WPym5dzIOjBGay8kjppLfuz+33qvFNXJ5BRyPLRM+PyfHxd6fjo3SSjE9m",
	"08MxxkfPx98fJ9Pp8eFsdjQ5HsxbcVsd85iixXmdF6ONmUTKwSzSN1N9XOO17Ged8y4E23OTT2V4VNch",
	"NE2+yvg8rg0/cMjUiJ9xgS74HL1heaEkqL7vC6X/jppLr2FTaNYdpNA/3hJCFDpL9a/c4t4BgQERxCCJ",
	"UpTNB4Ep2/pMpmeqNn9RxzhmNLPWzcapl2Uxnw3Bb26gj6MIs9VmXbrmdsbFPRapJeP9DMrErINpO8VT",
	"LAmUhmlo1ZSlW6+W7mxceOcCL+OdYFUgAKImXWExJ6qMf1g3UtM8OH8fm2E3F3z+2kwMuqdqgXCWIaq+",
	"kihZ0CwVhCFBJC9EQmTUX7WtgtRYJjPj20UDZXyOLJi6MGzt6SlObjM+H2DPAa+2h4QzNqzxmso7By86",
	"ToWyDKB5u/Ff344OT56ffHf87OT5aAfrU6/tqMzF6G14tz7926rHWuQtx4YHhL9tH4NUyY5DwIjZ9m3J",
	"J7BJ71suCEqJglPYN3wgPOWFAtVYjwVgI8PfB6E1dCU+WxjesJQmWBGJ6AypBZUtePoeiMFE5kH2E0V6",
	"vjCwB0qto47pF0Y/FSRbIZoSpuiMEhmmH73VN4sFviMIKwTGVMQZQckCCzgOGVfgXYQpQzLHCZEH0aiu",
	"XV+FWTl8B34tKGFptoKQIH3JGTytEIBC2Ty2uS4NbGBy+xhdWSl4MQU7p+fbWT1WM7jdW2sCnJlVKdc+",
	"drStG0d4c4DXq7x3XOV7LUAbWGDuY8fuqxSShoS2N8hKt9lkz1Uj9HZcCSa036zWETA7zWZExMaM3lyu",
	"xj2d/l7Om+mGvmalHQaDDqwnVH6DKEMzwZkyzalEBr2+v8LDIGLkHpqi+wXNjKElscYFzdxUoimhbI5y",
	"wTVYkuqFqRzGQgI9yWhyu+CFJEPZxe9RKmUbygY7sJRIRZkRRltIiEodWyttTcstpEqb0s8hW9pCYpsd",
	"3dSZ123pwFi9jV2tezTazy73rgXd27y6twze5964vY1eAQrtdBel3SzaCEHXiusDlIglZWDkVAsiEDZi",
	"UCKMINjpoKWGzSjJAux2vSC1UwKa6c3v1kEtsEL3NMvQlCA9RixIenDD/l9eoAQzJzSkEkWiCkHAnK2p",
	"yI3eCsaunCQUZ0iumMIP6LebYjI5TmQ6pin8SZD55paszOffDm7Yay6QNTqMqCGuiQQLgn771Ta6evnm",
	"5b8tcK5IshjTFJE7wtQVHAn/ehOd5XlmC6DdROa3Ny//9SY6nBwe3kQffSBHPhRFpPrXm0hhqW6ij7+N",
	"0Ko+7ukK2WucnTrF0W/rKdIDvGqMxs6OXkRD7DSDBWbgcay/N3x9cMOC2xXkuIl1M4KooXrB25teZ7OK",
	"VNq7OUb2CDAD+HouCFZE6JVnI+R/QnpJPhU4k98coGs4FFi2MuQSWafVwPT37FxfTCChSwaZisCfHKAN",
	"cZ9qPt62cm5bhcO5o7H5VlNhupqpWDtGux6+wqGwUDLWnA/fpuXfVgbLatBaOM3Jwz4GXwo8e7sBo+pW",
	"4y97O24wxI7QlMy4ICOEZ4qI9ctfwvFnpxy4ARaNIoC2jxmoTMm1SsMN9UfLofJEhQF+Jc3mM3RXYk8f",
	"nfpvO4d6Wxeyrls6UrViELn9F3kL0OFiYz362nIYftKYAKmjRpKMJIqkliejgcWSjbwfdRV2906aNWce",
	"vPhvcuI1HQh8IKHTzjeZNd0FwEU4bmm4Pq0yoNNShiq11kKR35izzBb/9+6F4EVR6RygIG3+guVbhDY0",
	"qlwSMaZMKswS4L65FkF8Zg4MYzFVAs9mNGmf6zhNwYa9tbeQqQTd4x/jNFzGrRmnt52emRlOaEbVyje8",
	"3xLw7ysk7JElpuBGiMkSTEY2UZ7V5EZRlutWjNxrpimKJIcQ37LpkWZwpb9k8F9cpODcVkUDc6bbZDzB",
	"2cT9cej+KH86dn+cuD9O3R/P3B/Ph4inp5jEVnQWkKOPjVlyfPjsxPx1enJ0AkxhUsfpSVyYtHBaDsFL",
	"h+S6Kb7fbCBdhLcIrbo0bkp6SxA2V4tBERhbYN5vVPjTzM6Ssr8OmSUljWoVvSMof2kvr8lXEgvMhkWO",
	"bDF/FoWT/ftmo/YYmilHmo8z10bC98r/NZZa06jDnU832MKJzzt8ggR3vhNnBfav8s0HOZzGORGxWgiC",
	"06A5oHwHL+ls3jyHu743lRno+3HN+0aBL9wzeTOash3WmAtglxjycnYT7X4e+NDcdLC3WT8T+HetYaLR",
	"qmuUl4b0S916yGBDOoo+eImICVOC9rmfmnbItRvIhB70lc+Gbw20VyW0JhPWOrbvKxUxKzBUIvONRDYN",
	"2UCtaK2pq+MlqWPRIf2q/3r07PT0+NSP3grqja3HoFFJroX5MThzq6hzPaXLxzb85bXRsev1tc0v2zyd",
	"1vliyPOnXeArQ92uT6B1aIF52+Yp9Kz0Ibt6e32JTGyY1NfEFE1Xpdeh4kgSliKiUcq2Ar8d73nRb9u/",
	"UzbiuwzIkmDMDM1NN8Et3jjddnXL+YMpUreOm9fKp7LlZm+ezU3z2ElpWFblIRGVo9cmAL/3ObS1kOGq",
	"7OXjQNv4HrwEa9QIbsKUoelKkUGX2FEkFRe4s8L6Y21iygEGli3vPlGs0Nf7hDOCRMHA99RETg1crjx0",
	"pOSy90DJu06T94wgPRonU0OejVrZec+yVTivBPh0rYLLU5p3umeyiT80nYF5BP1Nz6I3g8il4hg6j1Fg",
	"RbtdCJf4YUlZ2q0emsSOHbr5o7uxhG+G1mO1edwYjOm0T6PsmnyntA0J4vAPB8D58oegUhVoBz5Ty4wn",
	"t/ESPwzxVRlGgdNii9zFEDRme0GSW2lSGrYnNCUZXg1znEk5U/q+YMoEhMEtsFx0rVzHkrrFK0S2zeoV",
	"Itt68X75cDFs9X75cOHqyTlxtX6+hh+2Q8k1KxzW0HkqSVIIqlbdGw8yUk41C1I2jynvIa2+QHGSF15y",
	"uirxDwTu5tj4wPan1fEgTXFyy2ezeB3zdffcaCFc5yql7WB8hctusY1ld8kZVVzEM0yzwL78B0yT2tTY",
	"AJKP/WPPNNjYuvZcr+SnLAYx1RkCaJzufB/v8s4syPjkEO5AUum/gmF9kogeZaVJsW5qkza0A5DK34zO",
	"Thn6YI/Wl++uWl6Nflyeu11Gh5MD/f+aajvPTB66a9yL0+PHHc31EFCoiJjhhGzQZ1vPyCE32gFKJdzJ",
	"tjX5NK7E3i2iWrCod6ll31pv6B7pMdBjiJKQ7smwoncEMmd1B2DpXyU8umqt2AzjIOg8S1i6Yd5Wl6fk",
	"sdeLRxOwfvjlUGLTIWDsskRGoyo/CriO6e96AyquAGJwLZtoNbpqA04pi16cHB89O33+3Siawtn83Xff",
	"fz85PPp+oqXYMo+nqxxS/cMH3d79Da3dByFdK8ZiAWrX4ZH30Wh4J6fP7HeKK/j43dEoShNuwKaCfIpe",
	"nMAfGt7hKEqlXsDJKCLw2+nJKFoImceHD6YAAXw40h8On53aj8fw8ch+OtGfTl3TU/3JAeEKnvUno4jq",
	"68rEComE5ErvoeOTZ6Mow1LFyeI2ehFdnLz/WUu3Cdz7TZIeCNXW7KYBHB9NTkaRGf0z+1ecUZPXbTKx",
	"X5iZMJ/JJztZJ99Xn0yL4+/1gPR3EO2oR3R68vy7Z6NIJoXQH78fRbKEPookdLN/uwihXy4hXkjPtl7T",
	"o0B5hl0yEnipfBz3QqIqLXW222d4ro81lyZvS7LaALXw2IWg1AvS2RtRM2wK/e8N4ILgzFzd9gZSULnf",
	"lWjHkv3y7udoFL159yYaRVfvz39+9eFDNILdBv9cv4ekBhcn5+/f6X+fm++fX11fDc8XVaMjm/MNeMEx",
	"tu46TW6fYLeAGB6it08H3p5G5o67z21kAG6/jWz//W4jA3SP28gA3Os2MiD3uI0MwJ230TPz/TP3/bMP",
	"V5f+9nr/8zn8635/7n7fet8li9uU37Mn2EDJ4tZdKfcxwRmN8VQ8xblYaVQ7gC6VwhBwyp4O9iYPJRsD",
	"Bw3ySYCXGun23FECr0EcaLbcACooansDyG/pBredTp7dKI3UcLhG7d/TYLVg2ZFOXwSYm8gTcKO92Qyy",
	"LstB5rxh80N2m+yuNSS7zVODxoFzsymRC8ywOx42P7Wq6+aQRavuo4NbH2/U+mSj1qcbtbb34SHt6aCC",
	"X4+NG/UTbCi4n+O52j6Lvb/Y1W1/X9CSxfwJWFpDltb+uW/Q090OoS64zaTGCpyRrfnEatyjqGC3TOuI",
	"IZt1PpTnPoGBZO8j+FTWRtw34N30iE6wT3RwD1SmHn0D2J6OiA20rkffvLYv9DUL3R6B7rrluqSjeCIW",
	"kMN2GPjZpHvSyeQwRnp0ltBBLcXdU131Ahd0fX9++f7f9fX73fuLH6JR9PbszbtrcFFHcK0Pyj05jDse",
	"R5FaCK5Uti8tGBIkk3Q7vUk9EevdEzpfPMWC3QuSUvk0gNX+z6PH/veeHp8/82Tmnu/qzwFQmCj4zmXd",
	"pc4u3/Q/gw18Dqye9oa6YPuPXU1XK89JpO2qzhOZx8YZqMcThEqXW77M/GDdVdc4hAScBF4aYOj9+dUl",
	"ck4qRtmBgtqBbFPVe3b5PhcdHj0vn8UHvli7l+cSyHeT0U7P0EMy93rDNPmWgc86VmOJH0ovl0ZYKVHS",
	"BosCvQjuDnc4Q1Oi7glhSN1zhAvFl1jRBJkllS5oUeKlnXGX8PAAgmtNik7pyq8aD4XKB3dzt1+5bg7e",
	"Wvpfwjjrbr4uXGZJ2dppMMu0+zSgP2se7AB656FxLXBJR0ZuR6aDfH9qaE1tk1AOWEHnlOFMBbLTetlO",
	"mrSEDmXyoC+1G/iS2PoHW3pztEnp2Y52lNccJAIZEqeiW7kolc08O0r4NbfiS1KLemm6dnid2uldiQvU",
	"QDPBl0CaRKbyx+5uQH+yS8/CpvXbNZ6lmqSQ3wdM78ahLH6vp80iuEvOvzZHb0OKz7WPzuFma2i+2qsZ",
	"YGtAhssHRfYAB+wprkfD8oJ62oywXXJDH86a7Ib2aDFpIdclkPTbgse2+Vw5KA7pXXmjlQdN0BvbOxfa",
	"P24rTUAOyFBmLST5ktQnS47At+2eF1mKMnprchdRDW1aKGJT+tDkdgzs4wpsyhumuAFnRChlCKoFaU1B",
	"EpZSNgee6eqv0RCcLKD7DUtJkmFByqxGN8An8iZy0YMHSJNfJAuUYEnkCN3YceomfsqQG1ZllYCDh7I7",
	"nt050JARJkBOOWSbxGqIDG2KzHWRUz7Lrjkut4uZqonmxoEZX5FG8mPvwBSQyIAlPXeYaSFXcc6zzGa5",
	"D3uuy1wQnBr3Yrlb4Fs9eM2mHV3mSV4UjSKINWDNetdGW3Zze375CzLdK4jOijccWk7E2KbMs2kNAY4t",
	"xSnsjczLkzoINDo3WU9g/qv+u5FXbYaEM5f7L2khymlO5D6wGEAGqCRS7ot6aSZX6p/txcJi+T2j0yVZ",
	"boYEL3lh8iZ+OHsLwZNkjiEmDxA4/IW5ak9XIJQ0JhDMnOiNENgFPdd1DaCQZRacmwhguDxnyO4sZOp6",
	"IM4QFE2x6O60iiZ3QujQCCU7UV4V7P2V+5wSAQnHQU++4hkWVKLDCWS6ybDNjsj4nCitSbqqHFvR58EA",
	"b2tIdqf1i+zOadb89lNBalF728y5AdIz6T9cvTTo9rDAPetrcAhSSOJ0/60QXb2PP7z65erV5fsP1wam",
	"zDOabD9Nt0QwkiGV5AggaZKdZUDy5JYoWePNHMqdQyK3smDKjrftV9ANcYFsN9iS41nBzIloEKESc50M",
	"heVtzTCOC8Wj0Z6J0Vj+N3vvw9y2rfQLfxW8msk0eY5lO0nbc07u3Hmu6ySN53Fbn9hp7711XhYmIYlP",
	"KJIlKDs+Td7P/g7+kSAJkCBFSpSEM3MaSyKBBbDYXfx2sUt1SYEKZvVR4BFlpq1xwqdSEWB26eWatMUM",
	"inIHbVJ2NHVALw3TIrsl9d0sUc88j9mBCQy9aBkynchSzZJmMoSJ+xBI+8Rwc0wdnkqwJUYJ9nGaZeEs",
	"2iqJFzssQqmnioFZ8XMvnvLQJ3XxcS8G5/R38DP5RnERQ2qiezLUeN58iavlLSyu8pz62miZjZpZP3Id",
	"IFO4X/RRa8tK9Dg+l5m1fgK5Hh4ns65MkS71TLnbKpxOs/449IBiGFpdsp0N3iCmiBOtUsfcIS5sUOcu",
	"xo5p1HfhJfMIcPmtFo74liGThXhIY3nBXqL5GNsskrtaOuTFFo+bBajxhzEO2rWfJK2fb9mHl0RxjDwn",
	"iOaGb7DSPA61zVbZSdEgBIxIfHrN17hyhO8FyIldwyX/7+jOkJTAxymRZm2uMxsTLZ5uweHklez4ZfY4",
	"OQy17IEYby2ebsdH4pV2JJHjFDEbza99swKA5N3lnWH5kbs8KZqutCF7wtRNVVT4eSs3vBVqhXvq65yx",
	"Kpn8lVClnjg6JCgOHonl/RAln/LTaCcCry5es55jhJ1ZggznmT2/wsgwKi6OosCBQRC5xktDX+Glvsxf",
	"ICSZd8GVecjycajnPcsJ3GFyeRM/Z4U0RCGF2lqaOIYPIfJA/vB6rJe3w8r2IYhRQ4lTUXKUP60sb6os",
	"CrgKnewgbuCSaieossfbKHsieMQV7E/osU130ptEqLR/m+XWCaLo0yrGbV9b+hijFm+JOLwOdGavdhtm",
	"9jpH4RyKXJi/36631gyQRnFsbFlnAIHBo7QSbGaKm720opQ7hvbCKqTUi+gggxc01V3Fxma/0+gLo+Ri",
	"jaWKm4oTH03a63HN+XOewGWNW4Q9UJfzw42WSxh6hLo4gtOlT06gYDoV2bhOwZR/OV0lAS3K/urkJEU4",
	"PRZ5m+dJtIonrybLR/oX95VzkcveZUUyk3QahVNR1VXCl2j2bNJAdgCv3IvP6FRlmOc/gjQCdzQV2xHz",
	"wM4COGd5xrmPRlkcitOvapj+RJpNVhyf4T1BfAT8GfD82QyxwsMLGBaqMtNXj/sMeajMoD6gMIrZsBPk",
	"0joX3ActGAIDmPJCq4U6BgaA31exWqrpIr90my3y5rFpDhXBC7IzkW8F/S4xD4YU20pRApmGpMYwdRet",
	"ApYaJjSD+8zkgFEcUlaNWM8mtnZyQx6XykRpphg3zXHLEK5qfWTR3PuG4sjMAcS2p1mQkXhDF2BUSj/U",
	"JYhGzjVkEknznpO0bhSNaEeemMzHUOqyJkFWGclkl+ecGD5ShhVZIrNAtH88/+cLKQ7tu+fKmnCLKPCc",
	"8HO//n7aaHSHowC1uGXTomnDC4lt203QzPDc3LblXvIJK1u+h4HfM8WdYyFhgtGUsfiUsK862ITvATk1",
	"YV1K77ygLH9RW6fAaHB5YzzKdKC6s5n00IUUCVFQK7X5I23ldi5wyuRgpbROV0noSJHIxQIDy1Sp5vQe",
	"KoWtRBr52CQnCRnvGBWkFX4wNFQgfjjXKY++wjhNlAYF/9ZUGMIUyYbULc6Sllpriq+sSZ+tSmK+QEB6",
	"h1bTC/mpBgaFn3ipNwGMinzclbI7rH5OVnwHPmhK8Ii6O1IpHlaCxyQY4C3tliWizEqs8vpPfphGGY28",
	"xhUHugNknB2hOk/iugor0kMLK4Q8pITXzGJ0eEUK1jqacSOgPcG/iCUsZDmnIT2CsCmfGvI266gkUrnv",
	"rl9lJBrPo3g3VDic7mSt8BYV1fQ7r63QzioP5N0rhTUzER3oeY4u9eo1SlmMbL7ZWflAIkTCOYC0unCW",
	"nJV8xSn/Bov85x1KoTVmdaeZ3qYiCaDhzQz2ErsG2yVEqRAVwhoTgVuVWkSiN3oS7pePiz2vd12EtYVR",
	"qK5hAIMgenBOkzRVG2AwiMM1wo/OLq9+BldJlEZuFNAD+B10PzHoqiXi0GlVxXt0AqbZxcluTYR+C1bk",
	"7+Cga3/OmlNfmHUeQ0S+WqNJEezEWrv3IfU342+7DNGPF9zMatqHfA5FcJbogG5B3szKT9H6bSWBoy4B",
	"0q4dL3oIBxAKNM7KaZU/pLh672iCFBatRxsDrDEa72Ge/rDEEskxjzrHyF2l/j0CDMACPLqQto7TASZk",
	"FiUucjAO7l92YED2dhrg++en673+fL3XX6z3epexs1Q5PLCw/f3Hwuv9aCnDUi8DcNESkpdCGLqow0xK",
	"lz/a7x1+GURc16jeCzF1wWvazkMHyk37oXmskzhfNC5OGHXejGHUfSeKd5+v8e6LNd7tNN44XFfLRHfU",
	"Ji8UpYWPKKHlc8kfRsVya3sIp1lsb+6cEKKcBQlyW/togleeh8Kph1i1xSVMPk09XRauKJySB5A3Fclc",
	"s0rei1VKvpuKi0AN7xctyextZmTWN0LjjIjxa74V6CvtIgXpK/EqmSPHtCpQC+HVRfhq9nExnsrcTGTP",
	"f36c3r+YSrcKs3OsdEFjIbAYFyXp1A3FX59Q9iX257QIr/vyhTuhcSLsv1Nm6NHsbv6fKzT11RtLVXXI",
	"XeE0Wk5TOJ+8msyjZPnqdjK9nWgiww2zLNMwpjWOFPnL0/sXHd936PvO/Qun2zGj0objhl2aCaIH6ufv",
	"l7fbHbfyQifVn7pNDg3gan37xky6qi7qXF+C87P8ig7pHiWpP/NdUYGsXxp4J0SccWBIzND19eX9y8nR",
	"5Oby+v758Wn21/PsrxfZXy+1k7f0w2EazqLSWq5oym6jtH0rwE7q0ytx60NKdYtBM6WpCxmixJ8VhEwY",
	"hWgiQZJrds06WERmla50LcmEZjepBIVfW+VdI8+qrvctCKcsXhjB+O+JuqUeFnTH7jQCnCYILkHMkZFC",
	"4IRwp595HrjWVjYSiKoOTRWtpAkMsU+LCzHkVIJHdfWreKau72jSFrJ76AVAOonQI9qMtAAZ9J79toqz",
	"Elf/OM2uDpLj1PPsE5+QB3QnZazoHa+VSZbuwXHa6TGL7JYE+mqj0PAIaHwcUcxWThadNmp8SoGlH3vK",
	"2dNkYSm4zpTj6vwIvKlOtbVKfK0K4ylQqg/nwXAZyOklSt6Gs5+uwNNrXlQRnGFMeDAKwU8w+bSKwSUM",
	"5ys4R8/AMvJWQSmLSdXPQHvDOHLUNUwLbzuslH+kShh1Lj8IsgfZrfiHhe8uWDo1RtSDHwSA9MgjBuV3",
	"aRlY5qXzU8yvMR+rq8n5Gd5YurMA0wXgbj4ywmM/9GnDymjDEst8NbsBmUuwWm+xmUOdCxp+R7XqVO9Q",
	"as8zvSmUQg+msM5fX52gNteFe0rc1VxaryFaQGxEfpVBKBbT2ojPj5/LtREfHh4kxfGPUzk7ZiYDista",
	"vSFrXXTWRWdddNZFtzkXHatYi/05DOYdWsvkQl7YxpRXenIOuqvkHq1D+Wa8i80OhjfUg+hGq9B6EA/P",
	"gzhfVa5OGAWdLSBeOLzqfBdv4ziclaGfmz3lx9uUku6Xm4OIht0ZxvXxFKqZvsmcSGgOXYo2uClKp2yD",
	"q12fazpO21wvPRA/K46hBsS2ztU27xYBTeuc3U3nLM2w0vqovgde3YP2vyLPT4zuF1wlaOZ/lq7HTENU",
	"zqb/NLdKjl+dfPzbs6dH5W/+Q3O1kzUZJ2hWdGL58T3Zxn58/71yCsSVpShOy3bKU3qUn3qreOrHX/x5",
	"GCVoypwiX+KEhvvzH589PWrxcP0YEtzqPPkYwqXvThHPppLB6GTxUCrfDeJo0OPkFUOVvlr3eadm0mwk",
	"0zS4n/I7VKqbylXXINMNTRerfEIFe1Z161pbUuBosv5ReyThAQIE6eZFZ1DRvQ+neUsKuNFGIdgohKYV",
	"Tf1OGGnqxk7fl4JtRISNiFBERFTUA89H/OCn7sIP51k63g73TLnXKmsLJBUvL3jqRglLmuHRAhIrjKb8",
	"PeaZ9e/Rs3JKIJoPyJ/RVCuh56SILN3kL5CgP6luxqEPpj54eHg45u8du9ESfCXCi5WRER5R6htTJPMJ",
	"C3lSaFerMCh67/STfx6FbLJ45lJBYjN3iZ7L+qauE3BDGlfZc7MEobf8Yi3jtJKFd3Z+WTLuoBs4mYFX",
	"mqzeDEseV6A0K8v5kgskfCx7LsF1xlzvV4HySqaSo2tiK0o+1yL38lALI7bFz0wjMtSb7mvDYGviMlh7",
	"5LQVcFW+Acf/7E8vVOeGNvTvh6ulEyVOAsO5JtlmL5BuzM6SHSur8bdL1B6x0Ru49q9RCiAQS0N4xw/9",
	"1IeB/+88nocmCiCWOvIAnW+UooRmB5PkIJvvyTyK5kzAlYl6NXk+fVkIGRNDn+DkXsFfGcNUech8w2Rv",
	"tItKKvOsnjqs5XhjIjvRViVJSYmfttWX135aDn4C5DtCJf0B+x4irAAxrexEyPFdRDOowSAAM5gsMcgy",
	"ZLNoIpiK545vw7f0Cd5a/pRoiF31JjJMTBNpOqubxb/LBZsgL0ApeIxWt6EgHgHsE/bM8qaVC1PNogQs",
	"owQB6N3D0EVZ5jtareJkAenp+KTw2m2IQi+O/DDFx7elsBc6dCq57mAg3BMwmEeJny6WxASLVqGXRHc+",
	"q2dE0/iKKvJ5eIwY40TipN+rAZvlqBonK7TLtti3333/dyIXq++9UL3nhOih+O5Hmr3OgeRVUVaWfMlf",
	"JVaEQxmM0cnLgpDhOHkBIEcapRtENFFB5lN5cXp6WpyHrxXzh0+qBCyW6kblU11bvo8/xm2gdgZVwSoS",
	"c1K2izJMhHbAt9uk3lpqbZL12Tkz1ZhL9gEm3ixqrD8nPakof8o5OXVjtXuja76QXJy2FZBNpZmPpAkV",
	"oxCsflSYyo+G6RZ5ew1ZhIjEImLQkMh1Zo5vy+KmUW/S4kpO01UYomByVNi71H3vTcVH+iCb8OJ3nxCK",
	"pzDw75HJnhL9CybOZEH1LvnNzZXk7eT1cktZ943YRFRgNJj/PpzABfdsm42jDLStywlz7afqs4evtJyE",
	"ck/go9X0dZreTPj4JXPR19iIyzR2F/rqOl60hL76BLNAQRAZVt3JcWFtXLTiQgX9zeFV8JQkeImhtsKJ",
	"W9jYXuL4MTtZU4/xTBd3ELnu+l2YnNFUTtYklUbf7uWcoAwwywohsyjC7A+fbHpObqN+0QdsH01wHCGH",
	"BvMqtvfVL28A/a0pWSd+DN0u0ZpRmPrhCk1VkQF1Vci9KEyDaD4No2QJu/goUDj3QzTVpPjjumqKUTq9",
	"h8ZU0VTUWL/x5CyZ3QFwWnyml5aCaN6yBPUSfp7OyDF+KiK2lGFP0wfop344Z89i7XM1NUTZAyhJan5n",
	"SeZwm+SNRxMmvR2ytDLX6ewjjXkktcJLXExF8vvuLdGk/mu2cw+TqRoYMmgj9mMU+CHPS9lyS/F5oJUO",
	"++DOBM2JYZaQHUg3qnqhqVd9lsD5lGcK7kC6ZEcYJvyUbaZMSk5q5SvWCNgz+iOIZsxScqOY5iekv/H7",
	"U2bmQy7Jv5aoY12oTAnyDr39pSGO/SZRUPWsyR2Jxw0MY9q1piQAbYvVBDAro95FFJgsK6NPt6y5vFeQ",
	"/yP9sadlZXSUZ5t1oVtWPica8rIMnUbzC92giU7osishMJmrl4FG/yivO+6cj0piKkF2FAoJMqWHWNIo",
	"c2dJv6Ru6QdmzImwQvadqGijaCf7qdIQf5Yn7adf8aN1oW32Hn/KDJdQGY1r7CjBlbo9Je9kBdv+xH/u",
	"aV8Jaso7S3Sj21u0Ww2JjCSO6RRaZW+pwJasTcW4z4KAje6aPdBmfKzH8uiyhpRjo2kAoJsqS+/Q94ue",
	"b/n5AqbtZAV8Xhzxghd/f4levvzHd9MX3qk7/XZ293wK4Yu/T//50r27e/l8Nntx+tK4DoYj1QfSJWcz",
	"jbRqVdBCJZi+lue4bo7UnC89o+P+c12jbf1A5XUuU3+jarrCLdVAqxLn0g1JpiKF1KqkW1bgKdfXlyc3",
	"l9dAaoIV0/mEHnFVA+W+EBXuIAKFaQUxTdxhbS5weqhcQj/EzYka1AaN+qYdYcVYXAFCnRv3MV5xhLLL",
	"62GUOnDGb+8UKumx44ZxPgipF02UNHnwVVZdhnmAaRKGf0chup1MODV3aBYlaBTkYJT4MFAfLhbwuTPz",
	"wzlKnDjxw1T31Ivvvjd4jp+Zi7vkLdkjhazkx5MuGdBwGiVwnpcVr3a/YgKn5jcHBkReQlpFuubMxZ/W",
	"bjZZnlxfstBMldwrShCV8qNRKtEMYBzIkqJ6MKmVdyVJpSCvJgiFvJzU5AcJ7qYYB24SEKJSlIiMG7Mo",
	"UaPKqszjpAusqvblYw44Az90g5VHhCTLch6iB3D+/pLG7aC7NEGIJUEnh2Dye7pIotV8Ac4vLyjfR6sU",
	"eChAKfsRgThB9360ohC9XLJNuqfvobvVXJmAHUvJRb7BgD4IAnSPgmPAqijQU778A/AxeP4d+xnDJSr/",
	"BuM48BnOD4OAFTO4vr48f3/JZxYD7C9XQQpDFK1w8MiaoncOkAcoigtoyAhmSVBOSVMvvvvuiKdDmfv3",
	"CIN/SAXSaN/UmmS0RKs0XqXgKYLuAtz5KUhQnCDMTughYs8/O54ctS8kqDkG4wJnlc5GMCuP0XgO4lHQ",
	"57I2/QFiBF5nGWTolfC0ZZP17WUeFz/0nPrL99W2X3MW+cEPPXDOX9Y0WncV36xl1kKleZPb+U0d0DbA",
	"NW+j0kXd9fmmptm75SYljmnf5i9x5k0sNLrWHCgGz4NDunIFj5ZS8EWx4W6cUWy9whuii/W4Q3Si5Q/R",
	"TTcOEc1XeIQ325VLeLsKPhEBnuvNhzwRC+bGdLTWM/PU1IXxZEeDutq5Nblk8te10IY2aYkRYlIK4MDB",
	"GzomZQSBYvbe8BnQNIPrjwyOu4DkEAvThXJ+aXE99DlNYA4EGy3qZQQ98Ia8yAwo7rIhphAPeDAKcKAl",
	"hGKUCD8KL3rO02uI+++kQ7dyBx7jQOMeat0X6UDc7iWPAO7E5SEXTicXp4rbSDuLJAqJ3UWOvxcnv4As",
	"rDyDOf5coUL1tvql+Bd5GlyzglRXIhSdNXXv86JnRi1diReklzW809ACuCJv0eMVS5znUNup4BX/7sjo",
	"ziWVOV2vzxQp/JW2kuUhk88epKtPfuxgFMwcunk8x4WK9FWqgaNgBtg74PzsCMBPEHz+7vSfIImiFJyf",
	"aSIsUphiB65SRZXbGGL8oMYxRF3gevSVPnUk2vmo7Z7GcwksWYvOq1z36yPtlGQYLE3aYL/nsRp02qSS",
	"dVLQBDkPkH2JQiJT6YONWDf9VT9LWhOdr6G3LETc1LEKeQGc0RdyHqCJSNeMLi2Roony1Po4JMJAwalS",
	"JtF42VVjM3C2KAkZ7nJQvgtbxInmO9dEibMB0R40p0DaHlMpbdjoDXsj38y+hxS4eGM773wPgV/5e0rR",
	"0HZuCmLFeI5oiOZ70WPdXElxlfVBVezxsphpnJH39IXi+3krBkamYidkr9duTanPWYLwYp1sHbp76LR9",
	"vIgeHA9ht3lExXcCNEehh9tM5/UiegCX/L1iawxCat/aT/y9YmshMdaEEd8lz1WJ6ehFl6yLVeI77a9d",
	"KXSK737qciP1NZr5IQIQ8K6zgp9ugmCKaAHOME0egR8CCGg35ISAASuXGCVgCfnNuyxCnXwLMY5cn7ZA",
	"mkwoBMetpNJtrXzQOHHz4dJ27Q1UnZLJZs3YJ5kKXWD6fMkKYgtyNIl4uvAESRED4rNpJAD9NR+F7NQn",
	"PKa/s5oxusmVNtpU3e1U9kRhMEf8Szpc8SEKj0rPsoGaX2TNN+hX1VhrvAX0zWzxSrA5beCG7sWLkDm+",
	"VP6AmY8Crw7yoA/Iq039Rg6xs2gYWvaRHo/FZ1rDVvqdlglnD9C0Vew39ucqEX/yJ+aBn7oL/gz/IH6K",
	"XfZf6YtT/o/01XP+T/5Vyp5K+c0PYi/wDrKP/Fn6GSWJ/DP5KP88g34g/04/8wfyGgPkb4z5c/RP+og6",
	"u/9nbQijLGqy1eB6/HfVjKSTjyyuHCV+5Bm1Wz7y0LaUR55sFVc0lZrBTZASmEQYk/LlWzqWdneLupZp",
	"VgyExrXTNFVH0sRkQv7OD2HyqIvhNLqeXdnPdNh64UW3skO0qqqk+OQN+0HEI2UFDWjTKW+6hczJu3uc",
	"qEklVj8jplb68DYqBP8SotxGKJJZuh0pixSjxSxKnRavCMHU8hXzbjLx1uLpVdLiaXNS0OfY7EFJ4LZ5",
	"3pwSIqQUObs+qwOqsqxdrR2fX7lCMCXqtN0Ynps/2a7h7OnNzFC6wa4MF6Ogddu9YT7TRd3d8pWW3QgD",
	"o90b5p1oIs948mjN9WTHNK9IZriYP21O+gqrkCeNuqQq6LFBadaF8yj0JO6gKLUqUm+eJys3XSXMVihb",
	"5+K3POqDRVoyX5QUeumHLJRR2FLlvAL0QIPr6ruYpaoRl1Kq6Vd+4IcmGtAGgwD46TcYuAs/8BIUggSx",
	"65t4Um/48WauUR4HWl7RuyhdzpepEydR5iBcc1TFFhWj409M+RPilkLjaNhrV+ytukG50F30MRTajmIA",
	"5+R7QXYD1fTZemLj1F3AXsilLSkJpr+YzjR/vI5qDkX2QHXWUpXsn+ESZfe+s8ssa24KHq6Aa0fHACJn",
	"FXvK2OfX7HfAfm9DWekyd6EfCkk4gc8gsNo5q76HG4+BnOgP9B1p9DN37jswjntYS9LUWRwrlvLt+Y8X",
	"4Npox5BHz+K4bn3EVZk+SOZNqWjmP63LcaKduhHNg+iOhSmbkc2frxL9I/2hr83CWpMIFyZglPQw91Jj",
	"jpCmijJjNzdXgBZ3wYYcRN6gL9TNeBDNHZ62poehSK0phnAZzcFb9quh2riM5vyFujEsoR+gfPJ6GEep",
	"RcVYfqJPGK4Ee7huCDFCfbASaaaG6CtE44vlTdFtQ9CGaseTRHORuWPNIbGWVKNhvxiuAX+6juhCXvb1",
	"qBZNKcjOMrX3sRCisdph+eG8jyHRA111OH44N9zN5NE6Qlde7AR3PZDKGlIQ++H11eWdIcPQZ2vJxSgh",
	"ZkofBPOmVCTznwznWDyuJ7xwnMxOg+elyxvVQ+9quYQMbC2Fpsa+44csY3XdGOkzDEuUar/yQA6F/4dn",
	"HWpq1g1WOGWxcyKy4xNCMc2t5bV+ucmHwCahMFm/ihHQemhu2ni2Zw/RolusSgGP1DSaxcKzUhvUd9/0",
	"Mr/0xJ7NanA1vcWfUnv5HzHR+X4Yr1JV9d4gQG4KrulT4l40T5mazNzvvn3xLWAuwuwmT7pAIETpQ5R8",
	"4hmwPry+Op7UFMYuwS/sB0DkKqsPHAGW/azg5M/Kej+fGNcG49YNdZBXbrixUUQzOgDh9g2iOT4GFylw",
	"YQjuEANUZuJikkcjHTw+A69uw/8AqRuTf4hJKP49v3wr/sS34S8J8LPmIEjQHH0+Bj88Aj4y4M+y3v8I",
	"ovmUNf4H8HGG7yBuy//x5O72FjyZ/XEb/p9oRRvNU4blg+UPP/3Pq9vV6elL947+g25vr//2DGTfzqRv",
	"/7gNbxYIkJM4aYpluaBX7UDu7RaFlKW54sR+g8E9THyKch2DdyhBhHryLBWEfALxKo6jJEUea/82pB28",
	"ug2/gPNKx+ALeJ2vFxjN/76AM3rbmpjG1MVKVtfHYAnjmEW9NLx/G36ZKv6n/HL7/1uXLDJc8INqGpnH",
	"LEHQA0/pvTiR4TgC7ILLs62s7nselfEDIa/9+2S41zeKdtltfseNPDQmZhbDPe9EFx3uDVRuElp/lMLp",
	"fPvz2Bi+2jfv6Q3R0HsGwJPf08/hMXk2Oabppj4ONdwb0oeC4DbDdVXtnoMnv9+5fAwuY2V2M+TjFleX",
	"Dddda7iJqt0EPBXhS3SNn4EnvycI8/EvvOTj9oabrDXc94p2KRenEUiQiyhXLxCYrYIgY2nK0c9xSoXa",
	"MZ2LP4eeCzHc92sNN1W1mwJ3A7ux23DTtYb7oGr3obBgtITpx7EM92Gd4UKVqIJu6kZhCJ78Dt2U5kz+",
	"OA6riiiMc0JZ1+HeKc0M5kukQa8j0rvcxflzN6rYcFWre4fcbAqfihhW6cqidF3x2eaH23F52XD/rFld",
	"umlHt7r/6kYVHa7rK9rlN7/9GDyFroticpbi52qigXHibkXvsqvkF1driCo31g+XHBqBasRsyPT3jxsf",
	"7hWlquNwZyq9K1x6VFaxTFh06E+/+f++AXg1m/mfafqW6+vLTe5d4QbsJqvYcEHTcMezd/sYrkoyz5hk",
	"fiqGvXWpXBxuN9HMhhvXrS5jYbZ5/XAu7V7w5HcPp5vcvvlwu+3eL7ch+AKWWIMKxSmgcRVLPwh8dlUf",
	"UzuL/OSQn54u8bOjJXZWxNZ8ejt58vLn28mzweGqOP0JryGcExU/J4jFmI/qf1/A+7XIosPFqnZFUaEx",
	"mZHgC09e0tGM5MNVrS5O7p3MknwqMhNs3Y5kw13rlID/1Ax3VDakPNyOZiQbbqoSVilKln7I/Hk4JSJr",
	"HCf8nKzr9lTx4bomw6UOEjeKPvmII7O7OdzY96rtXl28BqP73xdwxdPbrCGZ3/2kaJfGWS1Ruog88BR9",
	"fgWufrm+eTYCRUSxwZ8YYd2Ge6UbrgAeP7zPsyjS7DyAOT+3NlxCUOfVvfpFM9wYpgsQhcEjeCpGu4hw",
	"CsIoKQz72U4N94PJ6lKOPplF0X/eweR/3sF/P9siM6813F91w+WxHGyo5JuT58enz0awd3mgSDebWdWu",
	"nH9kRJI5hglGrFhZ5sYuTsFRUZwdyQzBDkUflOAr9fGu4iCCHvIAd/0xWEcUTkMJBXLENc2Pm4DnSF8f",
	"Mqq6HfFZAHDRimSWBPd35iYyiELmM+KHz28wwL5HHUWsnY/DnnndNyVS2xvNOHAYqc4CfebtBhCngM0C",
	"H/LMTzBLi8e+xil0P7Eieg8QgwT6hM/4bEjzQ9miNEMxSnDMCuUdgzehG5G18kPwDn2GHnL9JQzIBOaU",
	"HS3Q54/EaMYBHfE7TmjH4dI2a1aXMvE3uJD/maaDI3+SQfHAL0HkMAtNh0tGu+7quo4LpREbDZcmcWwY",
	"NGv1Y2/DpeM9hx1HLDOzj50E4dWSiIAvgN8tBH7o0bGEc+CzofuhGy3J55vLa5GNkbEzf5ulb1+wkwSa",
	"rQJAL2DRFDbsu4Bmu/HdTyiVeDYn4GPtcN+6F/i9oLTzcHHoy1zz8wV4yjOfUvTggo87Cp8Bfs0QeeDu",
	"UVp9JrFpfCD9UuKENAJ3iOb9kcaHQ/9jh9V9616H/nrMfF9U3F+oSBJfClklcNgnGAf321G8ZLgdjYzC",
	"3n2k+YIlUUW+ZEmEmVV19uZ6ev3u7BkdrLs1OAMH50VSWw73YgYeoxWtcQpDsApLEYU0cPAIhBFXPw9+",
	"EBC+ZHrnGPDXHyDjZZcHu/p50humq3wMwii9DRcw9AK2C2A5evEY/J9oBfAiWgUeiFcpDQNkiu2P/D4v",
	"8GAK/+Bhse9Y5K8c5TnF3h/gE3p8iBLv+DaUwrtfwxTSSrM0WRDVfH9kkYfH+YOvaQcQkwkRCbP8e8Rz",
	"FRFef4wRPx4d8X9Lhd4nPGhVFUG7hJ8dMoZ5ApdOXiqCVZR+9Y/n/3xRvWfDMtrS4hHRDKy8GIgWRDGJ",
	"Y/CDP5+jJCv4RVcqTVYhkSZeIe6X9aGtWfqPU9W9cR6PzKpFxLwka+kyCj1Tzgrhy9njhFAejEzkekQk",
	"d8ZOd9Eq9I7Bm2WcPlLJ5+exseLSZ9ZSMYb55B4mJ8kqPAlRGuKTED9XVjzkVV5LBEdJ2hQk/d3zb6tz",
	"VZ2eBD6IKlPO3Wo2o9mzS2v7nNayL5dW/ncezgcfsuVjbYCnfiglL+Y/PjsGtF4EfyZFyzhKYOIHj2AR",
	"BR6mIdcitMrLTUHJPGRlWQBZIiI7RJ7kdIGWZPT1qRbZWw7NQlSd1J8zctlzZF5F+5QwPyTHIxgEKKBx",
	"4XzHh1EK0GcXIU8a8fnVhyZ6NEVw+ZoXItY/6qP3WUEIVQUM6lekYg15bAA0aR6P5+c4fjGQf9dC9XHh",
	"bgJZnfT4NgTgP8AfqRv/wbYpD4QXD0EM/nji+q+euDH4/Un6ETyZpeDJ3ckTDJ7cPJw8uXFPntyk4MkP",
	"4EmKwRPonjyZuSdP7tyTJ9g9eZK44An+8+TJ3Z9/5D1N0WdiPyBv4C7Bk1kMnnxQ9TzFONhM7/lR9aRy",
	"5jqRDzgnJcP/RGnuFmzEE2qB0f+6YpREJRmNLCkO7f1JPrzk5MkNBE+ub/gw3fpx/vW3f31N5P7PL9/W",
	"kEAej8CTv6b/+ur6YAqmlJr5R/AkEX3e3t5OyP/zPwjRT5aYkwwYyWRFwJMbFzy5SQAlmdMKnsxc8OSO",
	"0OgCTiuQmJDeMNnGLG2QG4hc4WnYUpdWPZX4v/SRbAeeZ4//w6waOk9EnhqZPINr3ziJ0siNChXCVx4f",
	"m3nh9ExnZO01qo88fWdB3qPPsZ805aa9vfX+9nSJv+Avyy+LL96z/1RnqTWso6zN0hdGTrxK5oYJp3+O",
	"wBV9WsrvV6b505f/+rL88tOX+ZcfdUSzV7M8xLwGXGM2U5YXsFVCQPKFE6DQNHNycbg3j6xw5kPip8hJ",
	"I4McyV91bFCT+5Tl5W1VvLGS+OhGZE8qJztK3dhxF8j9pLiYmtX3FDPsRsslyhKAsuud6HPM/sAo9Pg/",
	"02Am/uKTX/gkfmaF87O/prNlSjP/il9UK0a2m2nG22q2zHxIIl+mGAhNmQmDOBymcVWVj8urn8EVFxb0",
	"OildB0dMskH+4kqPv6+/MCwDKTkitqNAk6+c9c7aFGcZtShps1AUUHCqJVkv//7Lf51PjiaXf39/fUX/",
	"vb65Jv9+zz9/e/7LzyZ1Eqr98+lk3X92A8ggCmcJk08dh5Q1qeCON/Q38CbvCfxEevp6NCHbpLelIUtO",
	"x7RAn51+W855KuuAN9l3H6yDgNbW7IO9WF5sia8yMpPsL/YH21DZXkqyv6QNdbS2PNFNgQED/SRyri/9",
	"0EmQe2+UVbie/aNPmq1Hdxzfgd+zj9/+8l/r77coZO69TjKx3JKoz7x2W1K+9h6XUjJ5tSjb8yOzOg8t",
	"WJ702Wl7qlsjaq2HdjANWRZpLNbd1jj0+6AJB70QQ3fQ1I08tD4rptEqVe7Jm18+3NDdKP74lv6x9o68",
	"h4mDPsdJL8z/e2YLflSKsl9hAt58jhPm7Jvw7vtSVr8X7E89BTTFADvMcQrEqWkg8f67iYmcrQYr4z8K",
	"anzo4Mj9hL9df5+UD9vsWam2xM35FTin5xfVyUocbswrE+Xnoa+KTvRJY8l7PJSoS9EWcdYjPfFgHlpE",
	"opRTtlzsInVjUeTiWbEECyttwmqpSDVRJn8BnLjg+T9fHD///h/Hp8enJ8+/B1/pwdlDnyevcv9NjvhX",
	"S7ZUj4bsVsXkaALTFLqLKU7uJywr6SpBk6OJF015Tq/saDINUYpdGKBk6tKzO/+ayfujSbCCtHQfzyOE",
	"3Sn0vCkrm4DdqR+6lQ+nhU/P2SfCnayARP7htPAJp4k4COE4QlPqUuR8fgdD78H30sU08Jd+Kr51p9Tw",
	"zz6lEeYfPJxOORTEP/K/ZoV3ZvI7QTSfstKH7LP0XOi7iP8ZJ36U+Onj1A0gxuUvo9kMI9EXq7vD/5LJ",
	"yftUbWXsByhMp14S0eE/+Km7mC6JijqapAl0P02xW9jxNIvXFKPknpBpoFYEaKOVMhLbUc5NUVaFg259",
	"KhOyRXHoorD/dlOjqjWWwCVJJlFKdNXoQg8mXpaLBxW0VZnamvqxGyD2B/E+oO8DVn+oSmWlCMm4JpWL",
	"FoHetbB/dSa4EFYSoe24VG07iGRKlyics1qAgnSsKJj1/z79z1e/n03/L5z+++Pfbm+f3k6e8o9UlT+7",
	"ndzePvuSPfGsl3PkwCO/ZuPk1bnWqF5Z4h8TYbGJemFHfUi17dQc69GGL2j4Zh2p1pY1OrIP7ceM1KMq",
	"I4mFOGrD3w0Sah6nTlaEowe8SzJeBmM5WiDhEfAiUYA1xuMBstrMWXnrJUrIWIgJR50CCbWPUELk7wNM",
	"QjbUMEqZDUNzLhLL9241z4yNdmdRPRgoG1G1quYrtSydvM2h0Dliv6p4rQWHXa4gYB1laprQTsvhd0Sw",
	"+qWKU0Ix0+RTzu6yQjv9/Pvp9J9n07dwOvv4ty/kw8e/PetnjjNjec0h/QSTT+BXwe3E5s7HksFwz09f",
	"fCuhcFP2uQfLI7Pz29pIP/suysnm4tdRebT9+P5bUTat447jB1dBmCTvDcVRzfwLP5g8jEI66fVZpVd6",
	"syTUMsFEu4yP1F95KtBMgiQ4ddI0aFVeUA8KSSdGzVRd34Cbm0saE+CK0kTrb5rfS+f3j/3oREZlsajW",
	"WqBZjj983JTWvqBQDh9J6Dq+199g1oJgOM6ig2Q2N0Gvs9lJjYtmt9sWpZmSxqikz71GKbhg/eUCHbsi",
	"Lrh3bhxytrGbBb7lQ8kTdvQjIyWcUaE1BYHq2WZxt0IecvSqR9pkTKw17MHey6mLI+SgcO6HfVJYxjrX",
	"VzNvKIlFsmnbo6b6x+yiCiWaAp7OMvK4EdUT2RKO2pod6Lvgp8hDLFiI+SWWKFql3er9ixjANgJt4of0",
	"9ufUQwF8FJSWowjTCG/nBJBGeN0DwE2Ec2FFoW5HWZGxk9jNoPMesQeWrT5HHEBWiZwSzwogimLPXXRc",
	"8xFgkIHdkCYBK9R4zsnPRpVFzK5/fhmE+F9i5u/jMZtCrpQjVTVatbjJJC2riIOkHvDsgkY/20j4gXqb",
	"jl9hAt5uy2UuO6mKHv4eh1c8WW3aD7/BIbJhlf3xtJOSN152X+uc8rKnvCbymTQn8nPQR/k9yho3OPD8",
	"hKUpeGYcLF123X/VD6gpAIAlYV8/AoAnczcOAWDPDxEDwEyTFgEAbhBhNHL3/dqu+DZu9JqA9vaGWAHH",
	"tm5w6wbv1aNaT8qAjtN2/e+EP7TsfiwKL50Q+tgzf1jHXV+Ou/pl2JinzpiMEbvm6sewH764Q3WyFDcs",
	"dnsNE9fYkO2FJsXb85jyAuRecJesO3lD2rwfm8RlxZM13GhUFBvT2NELs3mOGZ2Hpp5opSMm9ycMqUNr",
	"oHqz+b765Q1gPoWiO2H0RP+YvWpRegOUvn5Gi7B8FUZVIqfbx0vrB7UFWFS+o9MgkHsFMTOPaNZ/ffdG",
	"+KIEjukBRgmJa0QYeYPNECN/sCvGKKODX2tGVYMyJjDE+fSqB1UEDOVXCvBgVrX71YujCTF6Ji/+/hK9",
	"fPmP76YvvFN3+u3s7vkUwhd/n/7zpXt39/L5bPbi9OVEXF2k8saJk2hO859UIMK8+b8UWVeYkWWYjap6",
	"s3EG/YAmnIlWqQdT+qdMzdFEXPNVJnARM39eM1NVvsp/xqpa3ZqmcMvUHRIRMo+oGqxwxyrMMshFcaqu",
	"C89+xzlY2D7xyQ+sCXApEC3RZoJonAc9qYmj2Ys2Lb7nDbA2RQ4Z0/fBNXmBcKIfI/OXr/wYgVILiXt/",
	"t5o5vKJdx2niBf/e80Kl6i5YNtduPbDaZw0diNSq3boQJZoaOmHxPd264PE4ug6Qe++gMFrNF2bLKdp5",
	"Q98B1yxdZKlVHHq9rS/N86duv4fFrWm9p5Wt6aGHZa22rkyCRERXsIJ1cotiKn0Y1WXZkeAUoM/IXTHZ",
	"zbtQWs+zKHGR5zz6KPDM2PFyBYm15yIP/B/6lkBlo/mcBzdnuGxIxkN0medj9qcaZC1PdOgB0s0lzzCZ",
	"LhD5e87jk0lvOPVQkhQcdqs0ounc+umTd8CS1C7RshvPkBZFytqf0DJKHsEHerqW4vQGYAHSrQi8q11+",
	"7kQfjgYGR93U0ZBC/GkoAm4g/lTXu3brarctjOMApc6/URI5bhQ/klPYA0w8nmhkTdZ/Q1+jefHFe5T7",
	"SXdT0h3Iu6MPwRTSqp3kIUYaS70VLWNnCT9nrpJmVhVseh4tMxjxUngxODHaYTfn0nvNWlCOhPSA7onZ",
	"SGh2+J8wdaLQLcPkNG9wfU5eYkw7MAgi14y0t9T4BmfkDWbuni9gyCDzmecgb46cNKEppZHXxyJ7czTN",
	"GgRxFARkOUU85eK5PM0PXpbmaM1u2WsgSgRrlTiLJ0nGFb5iRXPAchWkfhygz2yWK2RiFHobIJN0Y0zj",
	"C+cOOfPAT90Fwk66SBBeREFHA+NslUZLmPouDIJH8MkPAgCBVAVbJJSOIU4BlDI3CwJykvzQT30YOA9+",
	"6EUPjrltf8FeBOxFlgadzEG0SucR4SKpdGLeHdlVeXlFB6cJKrrxDORCPhypUCNvCcRISQKnYDbwGshF",
	"b00XYTbAImS1PKqLMNvQIihIKFKQRikM5M7br0GVGNpoTgfLcE5Em0wR3aIvqoQtEPRQwmJhs0VoyHOr",
	"oIo3/5pFUIB3tFVAE4Vmp4DFC92it58F3p/ghd8YL0g9rbPevHEx03ke+fN82a95g3lvswQuUQs+LvXy",
	"lrwuj2Bs8v1FRb6naeywQps1eTN0dg6tz5mnsaCNBdF8lfitG/vw/qLc0hJ+XrDcrhkvv3zx9+//Xmu9",
	"1HSR8wBjbcxgxwA5cRQFDl7AfqyTa9IQuPACRJhNFmOkM2KnJ6oN2pfVTjtmrA1eC2NdeW5gKbJR4vB2",
	"6RR4hQPo3eOUC6PJEflAlA/02N/MJWYyI5e8I/Cal9+4Zh3JNFDGZEV+e1iDrMefSLOAlehlpbZF2RSW",
	"B8yJieRko1pLlrPmqMDmzbF+eBhsq83Ai5W/oWY8b4cYucyub9fWFXnPK7aVIJqhul1D79lL4JrWayEN",
	"0eO4s4jSNZTAFUo4U4GzZbQKaRkJdtCf5Ck1HVqxa51uWDvgMoo+rWJwTguAZeAwQgk7OK1iD6aocHLq",
	"os3pXZspu/LBmwQwBRE/ElFxs/DnC2fmOXRPGncEPhCr4J0/X4C3r8F7+q5oMYgeujZ4GT0U2xvsfN6k",
	"vGpO5zHEmPAKBXFLeox0x4RHR5NMKjRDuZy1BfyQ2cbkB1q4lzs2aJ+rkD7leChOF+YzfgPxJ9ry+1XI",
	"JBMLHFkgj65hAFPhN11XCkYP4JK1xoCca9LJKmBzVrgRtva0MZ7PWtMDQ3+ufFePDomTCK1u76SfnR68",
	"U//6cHEOMnA718ng5n8LHDpzXGX9E3FAjYMBgLUiQYQnqNKuBfkKhHFT2LnzPX+NOSE95yv4g8/d2PTC",
	"mmQc55ZxEGG8Zn90pumeZtbyZYR5zowoIaeYTHzJkNVRhx6pMKOQno+y+l8xpL4f3hnZ0PlxmhKRJo/r",
	"nrDpUN+TlsCN3DgrU+ZEDyEq4O7CBCpexDLZ37Qn7s76hTb79WgyyJkjg1UzuY2Vpw4hqyllBRmtlQcY",
	"B3pxQPV+d7V/fX1Z0vUi1V6prFq3poXmF3XXzmlNR7KeXK7QHtPPJfPFrHHpyJpX8qR6g45okhdQcLwF",
	"iys3b1wY4q/fgSvyJkolVx91aTlx4t/DFDHazXBg0jL1bIEr9nJO6if0GER9GBCkj8uIVXv9L/TIDxEz",
	"eq7qJqOxrhvhfLkUzSsFM7Wn3Sjx+uEjqeANvRb49WgSuTjmpimV/iyobe3eLoimvocB+AGlDwiF4OYh",
	"Ahk8CD5ww1WUdSPC+pfz6zwyaVImzQ/XJo0d7HsgTStu7mGC9fJmHkR3MGA6trNoEHdkMfiRNkf1nmZt",
	"yem6t+6ueGXEmv4S9GeCcG898quwJ1m0Wk3XGOH+OhZ7s6a/9HPYW3dStJW+Sy3P/Tvw7/Q8t0TLzMuY",
	"GT3/bIty/d/AvxMe8szryDDaCiT8vFCh1bj1AkKrGuzKi53gjjp5g+CX2eTV7/Whbex55w5SYVKeF48W",
	"tb3zQw/rr07Xd5A3Mfma5Rzq3BqPffkqJ5KnsZsOUfnGieSVh6OP5evfH+jcAMyPKrSIOQwC4NMq7ws/",
	"8BIUggThaJW4ciUv3iJZxHkk1u/D66vLu3yJ2JQrCny5KE6R58TwMYigJ1WdLZQZ5Y8B/hjz3/DawfhI",
	"FNmlUSDPv/37C/Y9Lb0qYZ6nfzdyV4m+rnhfwkiB3n1ep8ygTJ+qbe8ehi7yeL0Aetc3gBz3qVtK8Rix",
	"7mhMVotDomS25bFUtTxcfJpZHOSg0BmvLMPSqmBzlk/6dPrPqXP8ShOFS/Pyi0wJ2Gzs4h2mLgxf4rnC",
	"Wk0y2xeNW5o9VQ4zpzPyUSvhzKtHcIkoxe1+eH0FLn8A12L+q0G7K8yYQh3LTX6lJwz6WDnGmmLyWFkd",
	"MYYYP3AztRpQjVxyKlI8I8x9Tlg3XilNb9ZQtWOJTinM/wMba3U5+GS0UDn8DZ3SySewi4bgt4Q4ZZ2b",
	"oUv71UhLCG5YVz+IiZQmNVMSJpcKohmANL6efJ8mtNppcWZ74ZxsY0qMwc7bEKM6DsHNO6plXP5KmrIy",
	"ObptjQ33dQdSymSoSLhPktiBq3SBwtR3ofrSyGs080MO7xSfBXf8NEbrvwcrnKIEhJGH8PFt+NsChWCF",
	"GaSGgIfiBLmQaG5CBb0D74FburtvJ4Cwlgci1tQdxL4LxL4/ug3JlwF1BgMXhlIt938AdwET6KZkirAf",
	"ugh8QiiGAa1NnyarkIMkKVjFDPPzMcvncXwb3iwQuLi6Rm55XCyAAvgYLPz5IngEKHSjVQLnyKtWXyd0",
	"avn49vb329uPzu3t8e3tyavb2+nf/uM//+ft6vT0xffsv0H6P8gfL5FGp5avtMUstT0l+6xANXNiN9cj",
	"pr8ysSrvnF/fv78CFyFOiSVTmpCMV/hx2EMzVbX5IIgeMIAeOUrgNIFplLDI3xi5/uwRhBGHrcgceyiF",
	"foDBA+ETdwHDOcpCk6lhx42qBESuu0oIS/0cpQikC5jSh/hZmrKnL669IBCJDGsw9OgXhF3E+Cke+V85",
	"hxRkVnVpGSTlsEE6VDX56WN15DfRfB4gWrqfzAFFRVH4CJJVGJINwJ7FWXcMf75D5AEAMUiiiJb1r6pY",
	"3rXaBLjm88r2FwPwhCplqof8Rboi/QgiVqGHEs798yy7JdlYhCK2Vj7ymAZhBfzDFH4Gt5maZq/dTgjp",
	"MSpMqBe5qyUK02xCDcobU87yOedVRyltaMqj4kkyZL7ylYWryrQ6cakSg19ZpehkBlU0XS0ese/CAGTP",
	"kDW/95N0JX/Jjzg8juXV8++P1FLCOf5fmu1fqyTbCpcEQe+XMHjUlJ5m+Vxmj/TOC7tHXTdr+bo4/D02",
	"Q1JDWTnfNdtZQpw2H4zqGhJlQHSbyOcKjrqByNGV140nOg9jfx4iT1rrFH5CGET37FEIZtAPyKf/QV8g",
	"OgMxtwcLATgqfy2oOQY3RB+Jj6yaBliucEq2ItmAPtOICRGPxKY6Jbv5xXffFQ7PL777rimCG6cw5XzM",
	"F2XCV/moou7JcKnWpJufvCiA1WzrPYX0dithetYMYEeyZ8dS/X++akeiJ2V9dZq1s7DTjCwcumXLL38t",
	"WTjcpHVXOI2W0xTOJ68m8yhZvrqdTG8nUipUxibaG5sILKIH2bB4iFaBR7kAuFTnzMAyuieS/teLK8AL",
	"/iOstI/8GeD3VMA8Qhh40QMVlNmwh7QjjCdmFfouxKlDQ2G0qj6NmBBGAAJqq0YzQN8AD34QUBcgHTuV",
	"28zVigtj7YtMdqhx/LjefGWPgYsrwdBlwqpZAZhId/yYr6qDPrvBymOBgcWeLvkMFFiAmisS6yzhI7ij",
	"juZVTE0Usv7C8GWbCNytiIUTYa7ikEcUreg3s2mom5hIpfJIgJ9iFMyOTU8LdC9VBtphNSptqC7Wv84O",
	"Aq+AfnYBXtA9doeIReMd34Y0TgB5jM+YMf/idI/megk/X7AWXpwqTmr8lSRapSjhGYiKE/vzaokSZpR4",
	"xJCZ+SjJ/O+/ctPkPX0/E+RH5GQk9E3mOotCihxc/notnsePmNAGYpikvuvHMCWzSqfDx6XGj+hUr0L/",
	"zxWi5iGdLi7+qnqrrKtUB3zZFpN0uVBrqunRnWwmTQaogmX/q2SBirZansqLdu5XDYHaczp+DN08w02R",
	"wgu24o85e5KnF0kU+v9mx61seEAkP1XgXHqZVrC88fj0lbWT+7CT1Xsvj+tWQgVZJqQSlxpsJPIwe7/L",
	"VpI2RHkzSQ3rtpPC8iztqczcX0ahn0bk1H73KOkXLaK53pHvAfnzhZFTowELZYnyZcmplnz1RnD5+E2f",
	"zkGNyiTMYBAUDhrPK4msowewhOEjvUjNDTP6M9NECUpXSQhWIU/QMlsFwSN4ShSZT5TTKn1GNA87qQn9",
	"tohwyjEVNwqx79GLoKtwgWCQLh6p2qk9IPk8wqSZ9GiWcpOeU52bKskqbO5ps6Iq8THqYzkKi2E4/caT",
	"rz+ALZeQniGgPM0sEwMD0WKUzKJkyY5YC+R+UprxkqewOvggCuekqQfIA1GlKUgjPgHNg8j3reHBlWN7",
	"/D2N8OVTU5a+12LzNW9pJyesuFMTdI+SEncoM89fpOw858IVZmYi6SRHA9jCU+OaorkMKhDS08dgFTOj",
	"kJ56SadQgXYqE7VQCrOL3FlWuoze0yp8wXBQPmgavEhzupGl+v7bovn5Uk4QSz82iFhGgHoxRJeqNTDQ",
	"hbyR9mqwIL6/KknTKsHqSaQaA5L/UOKKq/tvQZSAi6v778UhTLX3PETLXCkOgpQdHhYoQdI5jvAL+hxH",
	"mCrYdVRpae0EifLq8YPLxRU4473nG+kBzpy7yHs0q9VgUFWBeZUweIAzL4li8OULkL66CyL3E/h/AsSy",
	"a/Oa+pWCCx4KH6up1NoneR84cfuWsrOT2XHyZHDZVv/un3L83AvTCwS1mfDZSnxV+OioE2jCqCkUgagp",
	"9MDzKprmQm5K9JklU9Sll3xTSAK/forJ5hTVqlnoK59k594b0kn+BmeAyABWO0uhbQtCwjwMqChbvmo6",
	"VIlt8ubMDxTylLxK30IpoE9ULHNfVRqLOgeiBM511QO/lsgr9aGcEvJbu9mgral60syBPp1QCIPHf6Mk",
	"v6dQ8tUS447fz6BpsN5/APRRCjRS++/6X5f+yf++vgaiLRDQa6L4GLwWOYTuHoXL9fiW2C7NAWh0vcsF",
	"WKTf/xtHIavEgNUPBBFUB2sF0dwhFrhI/MAv25f8XChlxj0XiiKggk/DO2LB87gHbsizmzFsSojh54fg",
	"t7O3IIjm+Pg2fC0HdZ6++NZ0GtjlgOq6ZTcFNGQT85LGBbB6K8dAJuA7sPTDFQ8qNQi4jMKUTFpIVE2g",
	"Mk2of4s6wYJoPue3T/MzkLjFywZdddur8FnCeCyBLOF1wNNmBI802oFxFBnnLWHvKfnudgJYvAX4hB55",
	"JEyU5M/RxqaksdsJaTNFCavpgFLq4FcZY/zOTZEycZlLDDWP2pECFm7Ju7cTkMJkjlLtyJeRR8MH9L2k",
	"bKsJxqOH+lkSLfmoLiFOpz/xVm4nefLddzc3V5xDj25D/xgdswMfofVhgdIFSog5Gkb01MYWiHEOTCGZ",
	"NYzSVAzsdnIxy3qZXvuhi2hfrJCX1JVunAlKE18FFt9kbl96R5g9RihCOIV3gY8XAMppdXjIC3NHHIOL",
	"GViFWRAG8xxzLrgVnd5OuKeYHK2Yd8SI7XnYbF5ypDm43cmLhOQBtJodyr1rwo7XJVHiTm8fA7b9AhoY",
	"BEKEPERY/G6VgiU5SXHnD9lufghwtKRnx0cRouICF2KxBcuD155hDBMK05o8iqQcMgTQEp6Tzx81kZcs",
	"rOk3OGOXmq55QHINhlGMYKC8y6dbpCqka0EGvoyZvMyEKQQhemACiWdjzgQrWaHvAEbEwjeUq6skUG+I",
	"LA8c3ejsyEeIpR3zyCNBE4+xM1unz3p5c0FHkDm1IPv7G/HCN7msPMpjnTx/NkMJoqiGCDSjRLLX+Cio",
	"zPIxkSjAXy6R58MUBY8AzogMThD0mJwhbB4yACIbfNYiO6aAp1SSVVvBKUyouOIBoc9oyJaPwRLBEMvU",
	"JThlMi5b1SV8BDDALMSM1tdDHvBned85YsOVD92NKVhGCaJp60LSOAxz+Rkl/twPZX2VjYYsbsDHRP2E",
	"aplZ2g4+Od4ThmnYD0QbcptBGT1GjEFuktbaxBVzmF1uj5LH/mziST197Sxi0aa6K6VdvEpmTXen21w6",
	"FoL9tw/v316CDxiRGQlTbi5jfvGGsIejPluo6jXQS/e53cnaZnk9+BFA2jLZRarmuzsAx9BFUw8FcqBA",
	"NOM9uDCGd37g08lQdOJgRORBGiWG3bkLmLBdSLFRHqhAw11ZS4gpacxCxDIzhtvYbhSm0KfRoYzABGFi",
	"zfIkN+7CfErPSkOlr7P9SGZaeb1MXPHw08drwnM8gzLEvksjIcknyox0C5Ovc35bpGnMgA/0mchoGLyO",
	"3JpI9tdyTCjf9KwV/OrkxItcfLyA9B7QcZTMT8TqcHQphS7lALSEPnkPr2KinP+XeMWNlhPhVMm6vGYP",
	"VTpbPh5L752QZ2Bw4q5wehJEcz9keGUh0unqgmpP5PlUGsOQiNcQUkOZtyU5xsFVEt37Hspy9skK4Kh0",
	"R4K2g8jUHN2Goi2iFjDthh+0Jvn+z2aUbJerAIYInF1dTI4mWSWFycvjU3oPO0YhjH32xfFLplAXdJFO",
	"qLtfJS3fU08HloK5kihKAQq9OPJDFiGV4XEXHjFWUHp2dfFGPEAdUtJNrhenp2IVeZJzmn6DadETcuDN",
	"+Aw2icSMCsZ6JROI13LIL9PpmsvoO+FmzpskiZixhlfLJSTqgE+EZhbIesA5JjrstY/diNikrOjaCQyi",
	"BWwxvWeXv7w7a5pf0ua+z3BpIpqm+EQqsmE41ZnPkHUFs9t26gk/y34fbLrpSBxBiH7KyfknR8F7mv8f",
	"UcpnIh+pmHI6AbQMUBxhxeS+YVNJhJQoJQnnkMhA0SSVScWJ5S9Jkzth9iDC6Q+R9zjItE5KAC87t3ye",
	"CmOWpjr5makOYoKwg/0G1lu13DJjZuxKKPqWEVG/1j9Aj+de6ItF+IoVNoyCSyqb8uQv3/vavDND9ZZs",
	"2JFUkfFjG6aXO2sm0WdFfyavqPLLrQT6fZkr8kUsm/oft8gUOhnw7em3zYv7c5S+jVah17PQjkIjpuAR",
	"nxzbRanSBUy+z0LjOUDHrJ9ldM8wgjDyEL1lQG1rP5wHPCCgzCmstXPebQOjXIQUPpJC94utAy8CD+w2",
	"IYgS4JIzbNF8E7z154pop4y5ys/kfCDcg6RN5TU99dLkwzgRZp6CJb9VRM+Up5Utg0enl84qmWOvPK09",
	"MYtmbSVmEStFNE2trBBtUBGtkA/5kg+2TzkJTjaMjZlIpcGrJk+tpq8inKqmvzh95Kmd3jJFGlm2MXpt",
	"y7tHSeqTM7lApGlw0n9H7NQNxdxoiMrfd/LgFr2SMKOEHDg7k5HViRc01IHTVTC6pXTp3zJT76GRWGcm",
	"G7wiUNm15W0aabpNrhQTKufBG883kBLkKa2UsGy1d2yl44oqW0mW3omb56Wk6LNSLbHyDvT4CKQXQIJm",
	"CcKLCuuJ56Wkl++zR1XrVuyONwuEQ5/P6kv9k2GUgjjC2L8LejOGmgetntkZdFM9yvEjSjEz5MhzDDlU",
	"2UdvaSsN2p3pK04QD3ig/iL+sko55eRXFGPu9hny+MSIq7fFvttEf/SyCE2TzK4VciboDaxRrbNgmWv6",
	"mTEMC7lvOH1z4NkTF5Exj9RX8c478ctga8j73phBrR+8mFA+ZjajwhVRN59nVxdHYAET7wEmiB6vfrmW",
	"gX/VxF6QdgecVkr3xibVYAbE7F5I37IpFnUbPYH1nsCHJmyX3lCVwpPOfrsGCZrTABMlhvTb9Xv286CY",
	"7gMWvWwY0BWzEvLy5NGsZoZk4cHmXobZdQfKM0/Ei+RNHd+G5wmit09hgKv5dnx+ZnwNUxgLhxXwcZYa",
	"x6c0vzl/kV8nocEYzHUNLs5+AkkUIADTFLoLFhtSXNzzBMEUZes7FKwsVrYH8/L5UFSVNwqPyHLpDHW1",
	"J789/WfzK2dBgqD3+OYzTXbWE0+rGK6edbXSJAOlG6BIGEp9ldy1d48smZ6vYEL2usyE9TB13sfF64FA",
	"6m9VopNzBEcCt4Ykq2a7SSjVKQMKSf92Dd63XTdZM7RYtF3wLNSJhjG6FVoxgxLLeI/iALoGm1jNC/z1",
	"Vvzwvv9NPG7ddbph3cVC/7rrrq3ws4INu+gtNwrxKmh2pRbtvHP6Fg8oVxvD7JFBLWGXdzE6M7g4PZ0t",
	"Ycwtk0JzOuOUPTSQZcq5ZExmqUxSJaUama7dt0gL6959cxvapYTbCj22Nk0zFqxVacU+Lujl441Zp8XO",
	"x2KitlnpBj82sVK7rmImtdst4Q4YqnphMdbgl1YcUWeprrOteROtmKLnDT1iXXa6OV3GVy5h67GblmpH",
	"ddYmAPfs6qIKvdeHPvPO8b5HP4t8sCbxz2Lq5BBotZF6zTMARiscPLJM41mP/GUawJPCJD0COI3iI5Cg",
	"IIIe+Zd+TcN4Fsj9BKAgkl1IKImiVSjHSw9wgJWDpMdyfNUHbp8FQTbD5E3JkNmKN//9iumtKGEX/GA1",
	"5Jt/U+KxOctVYLjD537TXZEf/XTf93JhEkz28dxPO1xnCCBOaV+Cz7KAcfW0b+A+w9xPt3WbQc2LVTb/",
	"0U+N7jVIrzNvFLXCJAtLc7shm+iB5GA+xaMShYSsJK+0WVn6H/PZHNG9BnmVKzyi26LtLzcUOtFvzSYL",
	"XprDHTjTlRl1N851bfghC4pr4gXSqDauknHAdf7zoCtiELxeXJMjkbOOtH4uH02nv4obp4p0ICyKUU4q",
	"oYoQy0OTv/a7lKUZrwj/OtdR7Wrxh4orNq5g2Ooyj0hH1PHfj9LEr3uW7vNoXMtMBanAL3C3MOLEde4E",
	"BbQwWr3x/I61v+8GtHZSTIxpvgYnxRslLW4Ji854hpQsJRwUpWErVQ4FvSyzgtbflr90KAuombL11/Pk",
	"DrqfEK8C3WSH6dyAog3lev0gOmgr3tO8LLjjexODSzezVRA4vKjzZFCbLJu1IbV/4bFGEyCzRb8O5/69",
	"y9dSsBtfXjMHL39f5GlzKwPUOX1FL8PzUGZUGLBblLjIYTBfR/bs32jhUzwqF3aBpiJz8IWVndgvTl9s",
	"oufi7mLXhIAo0k6jrtnKikSGFA6SNvF7+uv04rXiWs5rceEje5c31rhxd9CDf5ftzapMaKGATv4iR29D",
	"/70QJFneNLWvj7Soc+JrRYqaQbPaSRWogP9iDhYcjUlsVbXkiyZNNJa9ogx8EOs1mpCHuu1hEOMgOL0N",
	"g+dW155w98YNu7HadVuNKW5g5abgjC6czF+3sno/TczTTZqYMhBmbcydiqjpzcSMYYLClCai/XoC3QAb",
	"BYSfnV+CgBe+hSm9mCehH34oFXpnHWiSDwZnbtD1JCtRPqkmSCEUylKvnPhE1HXpV9QNeuXGDQ4NXSmw",
	"mhxQcn5ppGAfFlGA8hix80uc5+Km3879exQSfs3WVHtvp1deHdlpZ4iYqmBsAVWBNpoql2ZDaURd73uj",
	"Dvu+2URXhJbxKu759XTbyV+04pkhpCLYQhc2TZrK8ZZmjcdv8dZIkaoKo/3XBVbznxrt9zapukYurfYI",
	"m8mWeDTgjKBIoW0bkRmjDcOr3JsZiHu/VwY2GC1qo0kwq+fyRpddxmpcEuScTEZqzt88s4hVB2M0XseV",
	"h0W9kXNxO4yrUNOtdRP2mXqmRhA1HG771bbimGvF0Z6Ko9ONiaMBD9EWUh4OUtaKou5nblY21AxSfsue",
	"XRdQZs1sCacbNBkpn8vDQ4A5Z0h8yb7pAAELJlsDBd4qg+2e8iqw7UgUWM1WOsv4bWBEuIYGCwor9VO2",
	"LAVYOBMFa2upduAwp6ZXaLhBtJQyajMCrPW9r9gwX+DRIMN8pym1cCM0bLBd2gDDB7BThrclLTisBofr",
	"GL0RHebM1gs2bPXBaA3aUeHD+u0sxO4wALG+X4sR94gR18qjhuNvn3qXN2ul0j5LpdPNSaVhj9YWKh4O",
	"KtZLpO6n8EWaxg6cpSjJsv04ySpAZujxu5ubK3BG3gbv+dvgPXl7XTyZNEzbFc2SVvcQXtZP/+EBzlpm",
	"kqs4qfiiAyKtZ9w1MOoxMe3u6dKGrTAS9dpqw54FAdAy2rBAdys6LfStjod+V7N4BThcJ5YG0Mvt8HLd",
	"CPpF0NsJviKtWgrt4WVfIXbtko8GdNdRaGSJNKLynTZlG5ze7sftWO0W2ldD+2ttp0bsX8uxvXgD7F7a",
	"p8PEqBwIbcQIZaWSthjGvdCGKutw6NHhsJ6UbIA/hrU5eEdWVlpZOQKTS8tKmwZbrDNkOGfIGtJyTVSG",
	"Fs9p4R9hz/fhETknLe2rF4RP62H5PSQGKTEuXeuung3Ocmv6MrbJbjuqRmUmHpPm1G+us5KY2oBbQk+M",
	"dUTUOCKyBaq4HoSs6EWxdXAwsHJyvbsU6uWPwuZjdNgDw147Dtgij8tVQGnSKnAzh0DzJmrrAmi9f853",
	"cf9sxjC10H4NtF/P/mYAPmP/3iB7qzvGbiWPD4rXbnRZPg8Iumv7tzB73zB7g8QyAdPP+9PXEnx+GDr7",
	"wOXW6ebl1vAHegt2Dwx218msNU/+iPTeNu6fklwf7m+ecpIhjrTJfQ71lyf6QCP8JbYpMXO2+l1hb5kj",
	"18S+t82JO6ohK/w9Jj3ZsPnOVIJtA3B4A1kWE6/BxItLVQHGZYnSn4rsgJDndKpODGuh5M2SSmEUSvTY",
	"o8New+XSSo8LM88JqzUDzMBzs/3VFkA/sK21QevXwuk1cLrhzjDD1SV27A1ctypnt2zx8UHt9ZKgItIH",
	"BN3rKbHIe9/Iu6lwM4Hge9b6EgxvJdzBSbjTbUq4DQEMFqMfGKM3km5rIhF8LtvC9Xym+svPwxvcZ7i+",
	"ONUHCtgXGKfE1hIPdAXti3y5Jmy/fZ7cUVWq4PQxadPGjXim4tZNoPeNlFn8vga/L61WBcAvypc+FWcH",
	"EL9AbO/R7iaiS3knXCLKHjv2GssvrPW40HyZtAYbwQzRN95sbUH9A9xnG7WTLbRfA+232CZm8H6BLXsD",
	"+K0u2kW7fXwwf5NcUEj6AaH+Jmos2N832N9G3JkA/v0bBRLmb4XegQq9020LvY0BFBb/Hxj/NxZ4a0MZ",
	"3XL195+l/xAS9NvU/FXeqXD3+vn4+83Eb5Pw98nu41KwJon3FRkzN+IOsMn21/IHFNdL4RDoM5Xb2qn1",
	"B06q3zWPps2geVBegfHm0K9Lzdgxcf5wKfMPcrdt1ni2zoFa50CLzWLqHhgkIb7VSztqzY/RRTCuzPc2",
	"5/0WvARt5J6Zn2DIFPdW+h2u9DvdvvTbHH5h3QWDuwuMJV93pCOI5k4KkzlKzRwFl9Ec3LDn13UQXEZz",
	"1tIeegbkaT08j4DEJBLfZuvdwQUgs90a0P+2WW739GSFkUeiIBs22FmBCwfG9htosZi+UscVlqcA5cuC",
	"ohfN1g67lwjrFbNvFj5FiiQ67HFgX0F6aZFHA87nNGm1dyMab7iJ2qDwh7N/NmOZWrhdDbcbsH8jvi7x",
	"Xi+4utUdu2AijwpAr9/osnweBjCv798C5T0C5SYSq+G43be+5k1buXUgcut083Jr+OO8hbiHg7gbZVb3",
	"kz95CyUOfvBTd+GH8xZx8FxMgWvxrmksPCdFeXC5pvRkTYoI6b0BuzXzfXi4N1voMvNI/K3ghA5guLqb",
	"zrj4GNhz97RnHdOPRJOa78szHfMOjJybU2hBdHVgvG7VCoC6Wuz0rWDboexqwlsC7lqty/pRjbvhAFKi",
	"xx5C9hV4V/PfaDB4JXkGlkQjMN9+31XO/C1t3f3echs3rC1sr4btu+6YRixfvWMMYX3tXmG4vtVQu2no",
	"jwrpNxcTatk/DP5vTJV1BfToCugsBRsQiCHNBj0OYWXhYcjC07HIwo0CHda9MJx7oZscXBsSSdEyDmBq",
	"4m0oYcesAZA10IfL4SajZv+8DflMH5afocwnFZ4Wi252uCk1p9Xa4ge3MiH1R5uMGutQaMfXYzxhFGlT",
	"6tOMkYY9VdRRYs8TPZ4nSvKhTtr0pzxP/ooTNPNNXQllGaY+lbAmWxxLZB+CXozV7wLWqfpIkv3WeCbJ",
	"GMk6EEbnQMiWejSugxZb1sBfMNDmqtio+76zNmgSWw+B2kPQamM0AWID7YsCFma1zuEY66fbNNYHhr0O",
	"xFrfKuC1QUO9K7i1JqZ1FgRsKHuYL0JM7CFiWVUIqxV01TdiZVNDtOLZEeJUNRpvUFTKglEbAaNU4mJt",
	"lXbyF/3YCnBSm/yknY4ok+ElOc7LVNIobXz+i8WVdhhXGhmcpNbRpuhRLzslg4z2d5sMb2JabKgOG9JY",
	"omZQUC9MXsB/rD7YQ2v3dHPW7rCwjkVzhkZzerZ0U9/91OIu9DV5vpf7z6Sh/bv1LE3nAV51zplD5lKx",
	"0l1uNUvs1vkq89Y4bQcVWpl/x6LV6vfVWYH5hr6fXE+LvZSsjr2Vl6d4EVmSD70ospZ3jnPCer5onI2r",
	"yVTPKbCXFfYWwckXeTz3iTOatOq6+eqw2fZph+js/87ZjBFqgR3NteBmxm++AZzzXk/Xfq2+GLNBPC6f",
	"Zv0Wl2TyQL7N2v6tf7PPy7sGsqrpnm7fOrp8srYSa08l1unmJdbwx3aLUQ94xbZJWnU/4adu7LgL5H4y",
	"Q6pvzq8Ae3zdmlQ351fnpKE9DDGU5vSw4OqcOyQ+FQvdAagm7Z0zblujFNWWOW33lF2Zf0ei7Oq31RmX",
	"TnSpBwar6ymxWLU6gaa8OgWsWpIQfSiydkh1JrP6LUHVKHSK9ORUWFN+X8HqfI1Hg1VnJOn0dSNSbbZ9",
	"2hSf6rBzzndx52zEArVYtRqrbmT8RqQ6Z/xeyk5ZfTF6a3hUWHXtDpeE8jBIdW3vFqjuEahuFlQNJ+pc",
	"P/ZZbepQlPRhi6vTTYurwQ/sFqUeDqVuEFXrHe35/LUIqibk8MkxDa1mvdIl53+SlalBsHn7pPk9xbGL",
	"83540dcVLioyt8QAHfHtIouuB3Nvnx13U18qmHxEerNxC54p+HQDCHgjXRYI1wPhpbUq4+FFudKj6mwP",
	"jhco7RsjN5FYVWOxQJI9UewzYF5Y6lHh5jJl9UaBEYhuvM1aYumHt8M2aRJbfF2Pr5tvECOwvcCSfWHu",
	"Vv/snoU+Ohy+SSBUxftwqHwTLRac7xmcbyHlDJD6/q2AHLC3su4gZd3pdmXdphAIi+wPi+ybyrl1sQpG",
	"WGucn73WRw4VAaWyFvca2i/M9aFi+zLnlBk754HO6H6BMdeF97fOk7uqUaucPiqd2rQRz1TcuhGIv4ky",
	"i/HXaMziYlUx/oJ46VNxdkH5ZWL7zdliKrpUlqRMlT197DfSL6/1yKB+ibQGG8EQ7Dfdba1SvBzoRtuo",
	"oWwR/zrE33yfGGL+Mlv2kxHGaqNdtdxHCPw3CAaFrB8S+m+gxmL/vWP/LeSdEfrfbBZcdMsqY6XeAUu9",
	"021LvY1hFNYLMLQXwFTidYczHuDMuYu8xxY+gN/gDJBdWI//G4dNnQXBb3BGGtxT+L80xYcH/RcZRmJk",
	"ad07QP4lPlwD7t8+/+2e6lRx9Uj0ZvOGOytz5cDwfjNFFtpXh++XV6mA6xflR19KsB2eXySw15B9E7FU",
	"JKtIjD0+7CuEX1zn0cD3BbJq9HwjbG++qdpYmge2nzZm01qUXo3Sm26HRnS+yIa9hONb3bJL9vWowPjG",
	"vV+S3sOA8I1UWAC+RwDeWJQ1nOAHUOy8dSvQDkygnW5LoG0EJLDY+nDYupkwM4ETonQ5X6ZOnETEMDWA",
	"z0vIKJlwCTbn7U15ewAjuuGx6jDzA3v2SnTdFrBsL1BmqyBwOEnDni4q83oAmDnnhhoWEGxaXPmaEwSz",
	"9MUhQtOy5nxQ6mR47uqsrjoxbv/qrcSzo7LYlbQVeUXDHUNZ7wYUWfu9R/tdv/m1UqWD/jv5i+LpZsC5",
	"juMymLzQlwYibxJTtUz+DQbU/FYa/fyXRps/4w4LeA8IeJeZZTSQd4eN1YB/6/bF3aPg1gZbsOUuEB2M",
	"fzdszQC1ALfCYO3G+kqA6KfI82e+UitUICLlHnjj+alVBQdmH59u0z4u8uUq9qyVvIOYEBU8j91kmYF9",
	"7EJ30QEVkhAh1oLSm33OGl/3ZD6kGuXjP6yIR1esi+AculBmjl76bmbxpVH1HESHqHPqsp5GjNUMpFvo",
	"tI0KcZEoKvErXeGBUBV9rxZL6QdLcfkOK+9tY2XQCiJh4kANiGTuUtKeLoJQIxBULGmRkN1AQthqjQb/",
	"0G0IgyC/orJrw9zC+tkBzh7cvLLYhAqb0LNlU4QK48o23MhftrJ27Obd6abMu6EiRA7BvttqZMha5l2c",
	"ugu4dgwIbydz/AM/BO/Ort68UWtB3uk+RX9kM3k4UR/npUUvsCD9yTjMo8Q/WqSAtWrjOgy5cWTogkRT",
	"WQEVln84pEFPgcUa+ovbqO7mqlxooZxaog9FVmoVmKEVMMXeRB8WfdgN9EGs14jwh+YN0oBFlPm8JtCi",
	"JVfbyIo2isOiFmbM3BRCIVoxD52wwno/Lc6NbFs1uw0UEXEYduc2IyH6sjiDFU5R4tznQrpeCbPnS1zE",
	"31Z7ANgbhWX/NRPzw+2E0sBUnFg3lsn2tUwtedJ6F8x8s1VPUodsi2YULEvUFM0AeQN5wEVJ6s/IqiCs",
	"SpZCGsdplKgtsyS9pB036LArVmo8a6ugzP5coeQx12ZyhzvrI8pW5LCicBQ8JbM24xazoByqNFCYJo8i",
	"IkfBk9npgd9brj8jcxCOU9GWZUVXI2DdHXQm8Q0xLkCvQFRpb+UsLLPiUMBeHSUW2esR2ZOWNY0AH2pV",
	"QLXRuid/Sa0aonwSS1E3Ny5QRsRJNRVDRRTpQEAzASdzONEd+vOlRFpbwWZl6j4GQ6ll43jQSSV9GkOk",
	"MWBqra1aYzTvwv48EDPd4qLqVGqtNlJTiNcwKk+EgVmdZ88RW4Np258jBotVO4yDxHbD1cylouExgu71",
	"9WPYyiJGRLGRXjWGyDXredTX2fIJOqDQNInHsjWS+It+Zx6d1qhGM2jsmqudg7vMlqncsSFUElV61UKX",
	"bUh0Sk+Fhaf6g6cqS6re9a3USrvos4qZ2i7+TCtASt5r5QnThqCNOAQtW7HRwDyGm6UpDq3C8fx0qo1G",
	"2y0e34hpZgEUlcvfmEEbY8vEPH+DVXfkcE2MmRXIu2M3bmhj5mu9meCxA7Eetxk+1p/dyMlaK32OaEMZ",
	"QMaHg6/zS1f7c4lOjNzJrpQdVvxPxj05+4n11is6KehHvN89GU+JvexVO2OeHRXwUSSqfFrlTDIQ3FHX",
	"t0U7ekI7yjtdLTFaKKxWMEdFzqyR7adR4mi4197n0Onj3UZKXpd5azSAidmeMwiJqWyflmmE9nTLbN7O",
	"tLiLCncx5fOmiBXSTtqZz3lDVj3su9V7ulmrV/DiUCEkB2L+bjWEpCJZejB/C7W1F2kaO+4CuZ8MkJwg",
	"AO9ubq4Aex6kC5gCmBRiS/zQrNjvWRCQps5JS69zMGCjVf2HVLzyvB4WtCNxiMSs2WIbKdSHRRTkFxBl",
	"nnvw00V+O3Hu3yN6pytbZZ12HQO/7Z7TosLFI9F/DbvrrCSoAj9EeDA92EDM3qjCXjVbWFognGqERS+q",
	"7eQvWiTWEPTJKastgau4A61TeKxtAwFUJEkixNa/3deAGWmRRwMA5TRpVXgj9mO4i4wLSf+I0m4b6HwX",
	"N9BmbFMLC6nvMxnwf2NeAon/ubzIeZyM2ZzzmcPSao+dMJRH5R2t3+myhB7GQ1rfv/WR9hgRbiKyGk7d",
	"krbsRWPzpg9Iax+44DrdvOAa/lBv4e3h4O1GobXm6R+R3p1kFaAW6DYlGbwnL+kgbuMTC4cdaZOkxb2F",
	"uuWZPiy8W8U3JW7Olr8r+C2z5JoI+NZZcUd1ZIXBx6QpG3bfmUq0bQAUbyDLIuM1yHhxqSrwuCxS+lOS",
	"HXDynE71jaM1sHIDUaWwCyWC7Olhr0FzaaXHhZznhNUaAmYQutkGawujH9re2qABbEH1GlDdcGuYoesS",
	"O/YGsVuls2Pm+PgA93pRUBHqA0Lv9ZRY/L1v/N1UupkA8T3rfQmMtyLu8ETc6TZF3IZABovUD4zUG4m3",
	"7mhEEM2dFCZzlJqh9ZfRHNyw59eNRb+M5qylfQTo5Xk9PGxe4hKJa7MF7wDJy3y3Bhq/dZ7bPb1Y4eSR",
	"6MSGHXZWYMOBkfcGWizortRvheUpoO2ypOhFt7UD2SXCeg1GN5A+RZIkQqz9v6+4urTIo4HUc5q0+rsR",
	"STfcRW1Q9APaQJsxTi1ursbNDfi/ES6XeK8XpNxqj52wkkeFjdfvdFlCD4OI1/dvwfAewXATkdVw5O5b",
	"Y/OmreA6FMF1unnBNfyR3kLcw0HcjUKr++k/dVslWbk57yvHys35/qZYkSb1sFDtnD0kRhUr3QHPJu2d",
	"r51eZdustnvqrszAI1F39fvqjMsndj9vWCi7nhKLZKvDx+XVKSDZkojoQ5W1w7EzodUvjN0sdYoE5WRY",
	"a35fQex8jUeDYWck6TR2I4Jttn/aANhdto7NpaJTURa9VqPXjZzfiF3nnN8LdG01xvgN4lHh1rVbXBLL",
	"w6DWtb1b0LpH0LpZUjWcqnMF2SdifTBq+rDl1emm5dXgh3aLVQ+HVTfIKpPj/WMIl77rsGJ+LXKkvGYv",
	"gg/0xfo8KbyTKetE5DBXl/pgj7JWRRKN8RabV07f4QVXq5hBTlFfXtQO6LSS37ri1ANw2e6pLT3vjqW8",
	"heHmOlNz4MCotCl1Fp9Wqi71ghWAapXY6KjS2oHUKtpqbHltpbcK/U3FfBT9btp6t4Bz90puiuUbDfSs",
	"IK5RQzei0WtvFJXFt4u7ZMM2pkWZ1ShzFyZvBJ4VjWqrCVuJPxJLdlzVic12sFKaDlSz2IwiCyz3CCx3",
	"Ek4NZ+S1FbDuQGwF1+4KrtMxCK4NHrstwjwcwtxeaLU/oYualgZnczLr/G1QRJN1JdmJ/Wp0QNcW3B3z",
	"gbnmFFqanpEcRNWLp2MpsSYNh9FyqzFMsguOJtxQPoX2xQqaU6E9t8nntu4cUXty00iJNDLmCsWRbidl",
	"xHNjGSEdNrZrMHflCQPdM3PnvgPj2MDLWXJyST7Nt+c/XgDJhsFKmUKeOiM9Dc8uihroA5mEZP7ooA7L",
	"yylWXHZr8vU1Q5HKLNNeEonuRix8RlKsn/PoqDCgAk0lLpG4YiC8p6Z3i/H0g/GE2RZXiog2qunkL3rJ",
	"xshZGVYli+YkxBPGkqZ1ByKtiNEzLAV4lJgP/6UR8snW3TonB3ROyms2Fqdkw5YxcEBWeL8Fy+cW2h7x",
	"+8YNQeuKVBiOTXzdBOuvw9a8GSvK99cqPd20VToUmH8YZulWAfwejdLCBXDoBmaB4mfnlzwSc80kJmdu",
	"0PUIXL6SUuL088uC7PtzhZLHXPhBN3D4z30KvCF1M12cwwtDz1hNYvaz88sO0eZn55drZUHpkVf33gme",
	"M+tIlKJu95wVpNlQOlHXu40jV+c5YStSCBxne35N5dYuZFzwRb9pTerESFWH0f7tbc+9RXDEEo8mplxQ",
	"pFC3jciN0YZpVWN97/fKwBajRXLUQeU1XN7o9ctYrZecJVYdjNJ6HZWfUbORc3E7jINR0611LvYYQF4n",
	"iBpOt/1qW3HOteJoT8XR6cbE0YCnaIsqD4cqa0WRyaE7oQvsrRWBlzWi9utmXexV6F02qsOCdmfSamY+",
	"DP6dmRkuWugQdCf6sVF3puw5rrC7AlFFBhFrO1jQXU3f1jDuyTCe5RtUIRvaqKM2UXe5RKkLtvumIdpO",
	"K1s0fGpj7XYDqc0WbDRIbf0uMYBrM35vw+aSJbYvPL55a8/CsqoAuyaGbgJEOvGzCK2zcntfDc/TzRqe",
	"g8XVHYbluVUIpE/DcwSRdV3PuTa0zobWbTy0ri9mtbF1NrbOxtYNFFtXo97GEltnaMhb96UNrrPBdXu+",
	"WWx0nY2uswrBhtfZ8DobXjea8Dorj2x8nY2vs/F1fRy876D7CYWegx/81F344bxFta8f2LvgWrxbX/Ar",
	"l3GCGOWpgreaNdqtEtOI7X7dlB8efqxhIIm/VczQAV7WcWpXxHkUPLp7erKW80eiO1vszjMtCw+MWLeg",
	"0YLYahBbu24FXFsjfvrXt+2wbw3xLZFwvRZmPSkH33DmKFFkTx77Co1rWHA0QLmaPhPLohFH77D7Kqf8",
	"1hbwfm+8zZvbFnlXI+/d900jMK/ZN4YwvX7HMKDeaqtdtf9HBeWbSwudGhgG6zeny8L/PcL/a4jDBoBi",
	"WCuiBqewQvFAhOLpeITiZoEQ64MYzgfRVSCuA5n4XdIC0LfWdEWcBcEPfuhtK7J40FORf3gpA9iYJVb1",
	"TVMFkDf16lf8Yp5AYJtctYMa0h9Z/oCcoJL284fLG6Dr05r7PZr7dJIrAmJd3dUqhwAVNfr7p20OARzG",
	"r5U1Cgbe6MVUi9hvDLH3x5R7QL3TDND3HvfHjyjd680xtP240xj6IJpEAtJ1DN6EC/XI3wIEsgpgD63Z",
	"081Ys4MhN75NRDAkTtO7JevCOF0lqD0Q4yE3oAgMawAkyI2StaGZ16zVc0HVHkEz2UwfFjpT4hMZqCku",
	"dof4zzIPdo373DLX7Z6yK/LySBRe3QY7CwLwusQtwwZz1lFjozeVys2rLFAharMiLnpQe+0CNMsE9uTV",
	"ZR2Uhtdg0Qtm5o9bf+7eAjzllR4N1lPaDfWKvREAGmhvVWzKPd9YG7BgLT5Ugw+12hSNDsrypujRV2nV",
	"zS5Y2KPyj9bs/7JtPZC3tIYC6zDt0WHaToo1nNkH0uzKs7uVY3srx043KcfOM1RzUHTAQuXDQeUtZNga",
	"QMLMD1I+8Y2JFd6yZ9fN4Mua2cfoRTGZh5cygbOGnF+aftMBFBdctkba3e1y2O4puQLfjiUnvX4vnWUM",
	"NzAGXkODhcCVSitblgLyncmC9RVVO8Cbk9NrLt4m4VIqn8AosHb63tZPYgs8GlSb7zWlIm4EsQ32S5tM",
	"vIewVYa3J21OADVUXcfpjcg0Z7ZekvFajTBeo3ZcBT61+1kI3oGKe2r7tahzj6hzrUBqOAP3qXlF6Tcr",
	"lvZZLJ1uTiwNe762IPJwILJeJK1xFF+kaezAWYoSR5DTIj3vu5ubK3BG3gbv+dumCXrrcWXSMG1XNEta",
	"3UeYWT//hwc8a7lJ4nklY3RApvWcuwZWPSqu3T112rAXRqJhW+3YsyAAWk4bFvBuRaeFwNU5fN/VLF4B",
	"FtfJpSFUczvcXDeEfpH0lqKvSKyWRHuC2VeoXbvkowHfdRQaGSON6HynXdkGr7cbckuWu4X41RD/Wvup",
	"0Qeg5dhevAJ2M+3VgWJUjoQ2coSyUklfDONmaEOVdTz06HhYT0w2YCDDWh28IyssrbAcg9GlZaVNIy7W",
	"KTKcU2QNcbkuNIMIYW2dJXQ09T4S8+LoDHGmTe61f0Se6QN1i0h8U2LtbPm7ekFkllzT+bF1VtxRtVth",
	"8DGp24bdd6YSbRtwbTSQZT0aNR6N4lJVHBmySOlRS3bwW+SEqo4oa3krDGSVwp6UCLInkr12TkgrPS6f",
	"RE5YrSVg5oIw22BtHQ+Htrc2aAFb90KNe8Fwa5h5EyR27M2JYJXOjtnj43MV1IuCilAf0D1QT4n1CvTt",
	"FTCVbiZOgJ71vgT9WxF3eCLudJsibkMog0XxB0bxjcTbunAEn8y2sD2fqv4uN/AG9xq2L871gQL3Bc4p",
	"MbbEBF3B+yJjrgnfj4Apd1SbKlh9TAq1cSeeqdh1Eyh+I2UWx6/B8UurVQHyiwKmV93ZAcwvUNv77QMj",
	"4aUMp5OosmePvcb0C2s9LlRfJq3BTDBD9o13W1tw/xA32kZtZQvx10D8LfaJGcxfYMvegH6rjXbSdh8f",
	"3N8kGBSyfkDIv4kaC/r3Dfq3kXcmwH//ZoGE/Vupd6hS73TbUm9jKIX1AwzsBzCWeOvjGd0SHvWf6ugg",
	"shzZ/EZV5qnw9/pJjfpNZ2QzGfXK7+PSsSbZixRXjjfiFrAZi9byCxTXS+EY6PUq3Nr5iQbOTNT5JrK9",
	"g3xQ3oHxJiKqu9zaMfvQcHmHDnO7bdaAtk6CWidBi91i6iYYJKuQ1Uy7atGP0VUwrvRBNnHQFrwFbQSf",
	"mb9gyDxBVvwdsPg73b742xyIYd0Gg7sNjEXfGnBHEM2dFCZzlJo5DC6jObhhz6/rKLiM5qylffQQyPN6",
	"eJ4BiUskzs0WvIMrQOa7NVwAW+e53VOVFU4eiY5s2GFnBTYcGONvoMVi+0o1V1ieAqQvS4p+lFs7DF+i",
	"rFfs3kD8FEmSCLFngn0F66VFHg1In9OkVeCNqLzhLmqDxh/QBtqMdWphdzXsbsD/jTi7xHu94OtWe+yE",
	"mTwqIL1+p8sSehjgvL5/C5j3CJibiKyGM3ffGps3bQXXoQiu080LruHP9BbqHg7qbhRaaxz/U7dLfpyb",
	"847pceiq8z/J4uhw75vzfc+WU534w4PAK2wk8XeRAzqg4VUeXQMTHwc/7p7i1HD5SPSn0R48UzDqwFC5",
	"EV0WMFcHwyvWqoCbVwRLn9qzHYReIbVXIN1UZhWpq9BkDxf7iqlXlno0yHqZsnq7oBFkb7XP2kDth7nF",
	"NmkWW+xdjb232yGNMHyFJXsB460G2k0rfVTovIlEqAr4YZB6E1osXt8jXt9SzDUABMPYAbwDK+wOVtid",
	"blfYbQqGsBj/cBh/G0G3BmDxAGfOXeQ9tsD6f4MzQDZgfwVsf4Mz0uC+IvulOT48WL/IMRInSwvfAdAv",
	"MeIaaP4IGHD39KaKrUeiNZt33FmZLQdG8JspsvC9Gr4vr1IBuy8KkN70YDvUvkhhr5C9kWAq0lWkxp4e",
	"9hWsL67zaJD6Alk1qr4RozffVW2szUPbUBuzay0ur8blTfdDIyJfZMNe4HirXXbKxh4VCt+4+Uvyexj8",
	"vZEKC773CL4by7KGY/wAqp23biXaoUm0021JtI0gBRZhHw5hN5NmBpjCPIjuYNCInbPHiASj6GWhDeVZ",
	"5UfWblsgsr2MmK2CwMGIvjLskYFP1QFA4LXLLXEbX+QmtaluTqcGN8Y5nbVLJ6bsXxvJ/DgSNaTfImxV",
	"B1M8+o4tNK1QIHOxxyo72VhljCKRWE+ywuYFO9y8YONXNzbNl03zdZhpvqqaZmRZvXTCYzTJDayP0ibp",
	"2mCSrp3bDzbnls25pcm5ZWW7TaFlU2jZFFrbTqFl5ZDNiGUzYtmMWPUn5SRaxTIOW3XIsScaxMgVy2a1",
	"wiihmBqVG1yU/LlCyWMuS8QzJuIkW6FxWeh81g4Lls3Wdi44InMCkC8KVrfKQGZP7Rwf7Z5WouszKsNY",
	"oqjk3SM/DGUOa3u1lnCPlnBRLCikgrEWOvmLXkspQrQqGNVIktA2C/KjaNLyX1qJjkOXVXuE0jLJMxqA",
	"Vrd5jurtsqZN8OMBboLBDb+dRmUH0QYSNNuoDjJgRB3EZUW7NUM3vnuZmBwsxuwA7NCtAiFrWJ60XCki",
	"rWMRd2kQlVYKVpKC0Uh7U9oeEM0pPZ/vbm6u6KDwteh1zMFoymk6LPhDsbKlWqtsPc28j9XWQBrR/doQ",
	"Ip8X0C+wzwHGoSl4cnyV6VX0FZlCwQlDlqZvJsiiIz2iI9XV1QmNjspKCZro4toUvEZDYSGPgSVN5VFt",
	"DZKINWsgiRr5vV9L3mImQ2EmiqUbDYBivtEMQt163Scqa2/XNsmGbUsb96a6XNeGxZuCT4w4nIeeNPA3",
	"b9Uqgj2xgE9HYAGvYs9awDuPy/Rq/AbR3JlFyQNMvLUQmiCaA9GOLij9rehnn66hFybwsLAbec2LsVJ8",
	"pc1AG2kGlWgNHWtNfLjozF5Rb8Gro4vwLtBVDa3kizxkjHcNBRa86Qm8kUSGTmK0VFqtkBqpe81BMwsT",
	"J63WXDjUCh0961o8ZnduGoo1Gw0QY7BxDBAYmf/bsH3Bftsjnt+KmWhhGBUMY8TgTfhLV/7OL/lYub7f",
	"RuvpNozWIS8EHYbVulXAZQijtVAx4M4PO6Av9K3m3E2iTIEue9MPfuitcYoecVJxNq2HhcmwMedcSlbX",
	"DIYhb1avxQruUXotapGZ7fLV7rkdyPyPCpXJCSryDFnYoXAYXZ8WgOkxeoZOckVE9KDCWmExVN7ojXS9",
	"KNKhMk0CR8HFGzXdbT2bTSE4dG1HA92ot5sBWtPjDvkRpXu+PYY2JO31pJrrSToWb8JreuRw3qpVAvtp",
	"1p5uxqwdCqk5ALt2qxDNECatN0/g0umGzdB3TREaCV/SgTSvSXv7i9TIU31YeI3EKBL/ZsttBt3kjVQ1",
	"puwSaY3hjIDtdk/j5cw8KjinTNbmQJ36ni200yO0k0sCjTTpTSW2wnokAdXG2q9VjKx1IwlljX6L/GwD",
	"+WncjQYg0BBb50eUHsK+2YzFaoGhGmDIYAc0YURDbADevFUee28/n27Sfh4KPToYA3qrGNLAtvMYCrTt",
	"J3pka7qNu6abBY9sGThbBm5vysCZ6biRlYZrF9q/pdIdFiey1eTGW03uELaQLUBnC9BpCtBZDWJr1tma",
	"ddbluoM166zosmXubJk7i3b3XeZuCf0AJQ4K08RH7YMkyUwXmyjh20Vpxx7FIumZ8rDyE33mDSfIrCpa",
	"qd26qhT8USfPu7ar6UFLS3dYsHlp8Dn/5+zzaHbaYC0B0tKjSF6m5dj28ZcyPTvOzLunnyUueRzV4aJK",
	"WJEVJK4Z6nzRRII9YfR4wihMtk5YtVbXrQI4C3KuTRhOo9JmfbQQdDJ3b6BY1cEK1D1C+2WWGQ3cb7Sr",
	"DSB/uZ1+t2bBnh7rvjw0a/3RxpvWeBAMN1UTIDecuuOdWH1nDxDbg/jaHCCGQvkO6ASxVZyv38NDvtm7",
	"gH0SuifEjB+Cd2dXpD+9+dFfMccxZYQtTehhYnBYVfWRr3oNAsfQMQHCoWWcPoKfig3WImq7UN9xJOlX",
	"y/t+fEBYbdEZwRWD4mC28OOmoLDqJq8KjfbKrAMUhtepH9AkhNQsbOsH7BLahMeDNJlsGmOgCbctHLCX",
	"zL41M9GGjqqKB5hxuBL1+Sny/JlfkOxtGPyN56dWnB+E3Xq6Fbu1wIsDFXA8LCt2C4KKCplHQ0FlYL8S",
	"CUEe4ZPbtWij1IxSdf/8/7P37b2N41i+X4UIFphZbCqV6Z65wPb9K13VnQkmtRVU0jP3YqrWoC3a0Y0s",
	"GRKdlG9jvvuCL4mS+JT1tIUFtqcciaR4fufJw3OkadzST1KUJdErSk1hY/HMhM9j5P0/r7BNXIKEAG8B",
	"FLe0qWIUkTQlQGE4OmEBHGmqyUFyekcYBaFGFfipLqtM+AIiXYV9zPPPEZ+2Ij4yrytljZ+u9IrzSDIq",
	"D/XUpJRTuMddZEnI7eGo94wk4wmFlySMjCbCZGdUh/iSxHCeIaaZwUZiDc/RKVV0yoU7bBlJDZmDjzAz",
	"yGyb9xXccrbNu8osOhvjfNC8olZs8x064vqg/LJDhTyEUmOq8wPyvTgoD2mSYHSh009CLhHrvKJepU8v",
	"4C4g43hZkOKF5RTXr/LLWPK+J1gsZLLInZ7+zUExrtuB1WVVAIA6vhlonn4OjbWYDCVttVomeWpgr/CY",
	"JMx8LkiY1TAb3l2aoR4vRpCVZ2ciLE8oXFZgZDTRMivfOgTLijFaZD/JCp55b1ATe77lZ7rl58BAtnha",
	"J+qLjz/z0Gzs9xRsczX2u4q1nY21P2isrTVDv+nlPSmoJo+jtSBO8sKe/OVnGQCrJy0SWnvEvniul19c",
	"a76j54XM8cWiDFnFhL6dBqLme3ndh6J2qHQGxGWCp0ryjz0dcf9OLVYU0Jyv3E0nyDOu+I5KSToFdXxz",
	"nyRz6xQgPYw5N+ctqfKWjhLs1dZArMW9r+NB37If7q9TiohA1wDv5zAOGtmSI24nwjb0vNwQ9s0FJIsm",
	"sjb/g/aPrYXzBG78T9yHQtT0ImctNXL9UwcLUrRw7cgZOYPercOfh1dat7p3bdXqKy+vxLtFtV5rsUH1",
	"MmbuSX0ung2l7Wg8GzWHOXg2LfLGLcInyxhd24vzqbLhVFkHbttRcovY5qPOgv/UrNfrfqzXro55z8B8",
	"HfSAt1XLVW6PbY23lBvIO1yj0DeKlVu+n1qwxdJy/IRDLhWENO5x+PacRIh2Hiejyph7C/EzZXT6x034",
	"iugNiJzSOi05NN6m3HEwG2nLQSV33ZQgCKIwRlkP3Qezk9Z4XXUTpFzcvKWgRaG9/532HnWMyDj2Vc1P",
	"ku1qjo1tETtzS9WzC9NIRB5NsMahMbE1btN2Z+Jb2oz4HJjn22Ates/94LqMW73BajsylLDHZUWBb/LN",
	"7qhnR4az1jiHRtx/6r8Rd0dnlmfTh3v4k0sXcWXxr9vW1HzoWWidg9C67l9ode+/zwHr7gLWVoHV0NVv",
	"WtSav2ePXy/h6sWQKPhIxzm16PV5lqqul6l+9ChRzYuU1fQlB5B/xuBw0JqechthyWlDgctOS03PZaZ7",
	"scBrpewePcvYaTSZVwahtcCnVhzpItUmoaNE8ZxNcpLx6ceRFYzWs5tDULpNNrlF+KR5pHuzcg5Bq0PQ",
	"JojbgjltIpwPO2uC07Rwr/uzcLsK2czFmrsO17Ru3WK4jBqUbGavtVCs+YnNf0IxGr6j5xWiwYKMApeU",
	"rm4BGvpu24WU2fxzfMYFrKMKz0grKiOGUrSr4Ix21jk202JsBnOmrAqJo3SXV2CGyZq26xxrhI0Kv7Mx",
	"fpJhGUbc0URldIzmEJNpm0OEjXd67NG5ETlf8jREZfQQt8Vk2kY4H3pWAidm0173ZdN2FY45B6N20GjM",
	"MfZsmmxSuD2q67sYQwisXZoQ3fBuC2O4qUWd1d7yLcIPYinH1mfttMibWOSZlestaJNXb2NU/sSI7Fi0",
	"lw0j6vY2AQqv48sGGnMp365K8/IvH1VVXnlNlRKRnOJd1eTVzzxHTNoqx5vzmpb1PRSNX11ejp78QqVd",
	"YjAT2lKuVyc91Nidi/ZOpGgvp9d46vbaOceliC//LAnYPgxhsrUmwQE9mHNzyomyXK8LfK19kfxEuFF6",
	"i3ZIs/iehIF53aeB2VlDorOwMIftRtSKgZnCN2sQ4683D+RNldkYxmAXwTAGGH3HKpXJ3y0RvU//064G",
	"ycrf048ow7uGkiqQP4tvBVmu9CqqLtpnGKUGJcceqOysi567rOjRD89o9ZLtt06KdBv8BazECz6zdBx7",
	"aYMqtyhGKYwAY55eLQ+VPaDkHYlny4yhDwc97LNnHg7ijOzPjg9J5siPFbG6BhnClyBOxEYw9IC3MIrA",
	"EoGAGNxEclNLZZ89I1GJM38ExVQNB5qmh9lLuFuodjlHxxpGGboUu75MkgjBWNVnUVotVyRiDWEc4hDm",
	"WmYf43BLVA/tJMZMrf/z7gv7+d0N/1m8THWhef0KVdN8+UkcHcArjMIAEq++ROxLWqwt2WO6qkMYb0CI",
	"NSsj4yzEOEeu7Z6XjeN7BG4e7sAq2W5hHPD6cQWOQIbIP8huLw/gD//7D2J9jCGLBda2/OI4W7Iby9BD",
	"HrUaXmwsB/8LvWkUN2PQWVN5a6q6gdyYOscawTO9rF/RqZ/QBgZ+Lsg74HnXKdlc1EjSmkgGq8vFUUJZ",
	"EjUqiiCd+eaDKMOLX/IpTqlfa7Fx53X4m0rUFLgTFHY79xUj5Hn03o1b8/nm5q2uMB3VEXF5UVVxw9HR",
	"0SGxae75lLilU+K0YFCFjPBRS14nxLlkOaJ7q162aHA6HwhP40A4J9hoToTNXOJwGFzTpJ7dXU8N6/1b",
	"f/NZseqs2AZs2zFxjmsfPPP3Z/l9sgbodb8GaFeHyGdigQ56iny8ARrGm+NiImQAtdalQ59ULIR+0ZnF",
	"QTgVc3iRGd3iH2G8aRDzIOPP8Q4XKI4r1qEJLhN6dhbj6Oh4Zo5viPgGY8YK77uqFb+YBsHJMfEMpdxQ",
	"YHGOY0wkjkGINZ4YhpITXGIXVP55xitOBMv9WmZzjEIZo9AA1xqb8MWtiEucuxw+LQPxuh8DsbMYxOlb",
	"iMPGH440EEfYtqKRAzq3rZjbVtjbVgwBrbltxdy2Yg5xdNi2wqDJRtG2wsUgn4uVz20rzrltxYnyyNy2",
	"Ym5bIbWtmDXB3LZiblsxt63wsW4znO5XeE8BelSdAQiKocA6SbfQueDAY7GGMVdJlLaqWbmBKcVaCppY",
	"78hL5LOrP9u4ehVnAMm07sOfvvqrMMpYVKCRf23A7E5BGpc1K8k2lGRTaeagQPfBbhEtj0qx3Ac7EC3F",
	"5Qd1suVvHx/ul6eVbSl27rwOLvbB7p1EbAl5lMRu5xflQfyTMNlUcxamG0RHdVQhL6mMj98+PoD7ZVdH",
	"Ffp556OKlo4qylytkAzu6sjrZIK9k0uTI5I0NXKlhtP75ZwepNWw0z6MYNQdzVlEGdtKbWs9kqhoW89k",
	"z98+PkSnwRN9m4bz4YMq4dOqJewnEEcAmo8yC/qTM1Gv+zFR75edRVLOwkQd9KihLDiujjRRSyk1wSaF",
	"28UyjAP/WErAWgmQd+1JolGyAeskfYOpNlH0Ixnv5zAOmvnJIz7Vl3f5vOIuEkYk2OaUdou7FIPUz+gl",
	"XPnnjw6LuOkdMRQ4HlVwprqsSkVJgpuOwjPmmecQTYvZpIUQ0AiSNnSgVwBHEks+WUVGTchGt8klBcDn",
	"1KKTTDKltB1NWMfKgw5hnS645hbhE2eZfqzTuTu3IfnUAfy2CFAX2OfDzyrjlG3l6z5t5a4CRWdjLA8a",
	"LOrOTo6SzQLDdIOwQ6woisB9sgFP7Hl7fIjNpAsN3ScbNtLJhYbkTT2v0FAFIhJac2o7KdW35yRCIOJd",
	"eGTQ0eY7hO3pHzfhK4ppMyhBaZ0uHRxw09N2NRiPRN1Z2OumhEEQhTHKOtN/lrWcjAJsV5+VyEObwqjE",
	"RBtK7f3vYRyg747RH2ldalueDlak9dhVHRvbJnkqzceKVdyR+dT2fMj/ZDXowxijDb03NAeBxhMEkog8",
	"mlBQsSat4raGghxZqOYPG2zFc+GefkzSORVIHQpyAL/1UFPCHhcWBcDJN7vDnp1lznpj/LbxqE5NzWwu",
	"y+Zuzk7N889npy2enbrIK4uX3bau5kPPUusspNZ1/1Krey9+jmJ3F8W2SiwXhz9DaUQF6jG3RMUg6lsG",
	"+RQndUU0/6ozuyQqUTPPsOW/Od4Q5U83uBsq5pmvh7rCc1wXREuLquTfC1R0dUnUMPdsR7doR+8LJlXI",
	"Bx+V5HdTNMeP/9VQrVjRQHTu4zGRC5+CYOO582lkDpcLn01gLhlhp4Lx/g29Oe/PEOxtRejLPogSwJkN",
	"vQ80AFEwiQziSp0sacVdIrlrZJ6r+wH2WbnGPsFHyf/QORDTw9D04mJkY0bneei8ji49jtnb6MnboP+j",
	"Lg5cNc/738l/FO6Gzl9wsaOAGFNtR0l/9ZIe5y6uTsxBGZdzotKoJpNs5oPBTL/ZIXFwSLSg5me56hIy",
	"M7Bne7TbOjQme7SzIjTZXO2+0xI0TU3Q10IKGwOA5Zgff0sZ7iuR9O+54B62gn0to8SCxEKKDFzXTLnv",
	"EqVLy9aRPEo2Gae7080w6Xw9SjYgjHd7nFFuTPaY/G9dbi9bzUXH+SXlItWupki7lCH7oiuWfZ9sMsN5",
	"tOBaRAyQMN5o9ljkahHiOXYDKFOgm5wjxeaPKPXICo37ZAPuir3+zPda1nsDX6lxQJaeyRmMmjP5FXh6",
	"DjMQZuDtGaWIAvAjxBA8RDBG4Obhjt7yQXEGcMKgmd+gETXkd2lCuE8nI9judy0j+EYMIxwKkLlLBSlL",
	"JSeHSFOpiwB9kjmdt0P+pwsbXaK0tCoNv8uh1skFHPOv8JcF738PA8c8hgJ3mhTioGD2mpQy3JcTK7fm",
	"DjNC3X3U5A0HXs5l3WTUXN1is47q5paG1pZDegf6FTaFjXqSsB4B6a77kRY63TCkD2DEg+1aQKuQKKzM",
	"AWExbq123bdWO9JwHUEaubde4/5REyNXuK/dW7ncsejazBV7MZydW3xoM0OXfUETS5fN3KGpy5Y2OltX",
	"XlZdLLBdmby1mxPXVyx42rscfu0avPnirfqRU6tvk5dPOyqbV0dxB6PXRkRfq3c89LvuSXKM1fDVg8LF",
	"8m0PF4XpOyg2Rq7nrvvXc9O3f700HTvAdLB984Jrwl7lbypF3hc+aocEFQvXy562D2gq3/+l+H6x0eKz",
	"zXudGxTWCxLlrQYZhnhv2nCbEGFPgTBoJEB2EGOUktf+++vX4Pc//+sd+c8P8n/+498uLntVQiLXYhoK",
	"SEtTDwztYxxukQe/ojjYJWGMqeu5pNlEtHM8gMErjFcoAHxMkCGMw3iTyShPlv8PrTTns1/Ye7+ICbpk",
	"9/wrhmP42n4h6cPzwqthtkpeUXqwEPA9XEVuEYebD/c0Zy0D+yyMNywBRVAsWb0gdWGsRz7xX9m8nFY3",
	"ZNYOyQRX0YIudqAAQvVif755EonIb3w7XIjkJq5hnM9FDcKgLWrdWaV6Pi+KcXqYgusgUDIVuS0R9xgc",
	"lepQEmKFKHMFVkVGt4UulpBJjPBf+HqOqnzbB2iyhdg6L/RMxZKXAYdymqgxZ46IxlwghDGPheaCwh08",
	"D0nWM3ra90gFcChuDqOKvqqWVhfujIxTDsCyL8CJkyTVhGKkMD95fgcPxFCuQ/YmCB7Y3wRSP9yPGpcV",
	"gTYyaBrFrUQIAINg0HS34h6dtKq21bXzYQARrgz1ecCfLIDGCjPwCqO9jxhmo3oIYpXV6Fnwrvxdv/Zg",
	"YCrOFqauz8WBRKHPDwa5ZzQEBYQYETiQ7j52ZglOEkLXParm07M1D83E5RKuXhBtplgSmeT5ciEMt2J8",
	"/L0/1OJSumYxfJmP9L3xOjD8cxZiX4aPkBQbzHdc7LSEA76rTukXbByRelHUhOUAUZlqbdOufTNNkA0G",
	"ASfdqOw03fIqwGKUOcZG85ZRg7ocdUhCCYY1cB8h37wqu/HlKJqE6HiEvWthEyWxh2v352basVWWUkam",
	"ZNRVyWnEl0M1ND5W7TDG3CqSz2k6n5ksaLpSvVM6LtSgQqOgLSksQhimMM5CFOOjQcbHniDQurMTWrMR",
	"eoW/FhlTzofR4t3bBAjjdWJxZKqJ3IC8k27VOce3CHMX/IE9fUcm6BACfFEL+iG9HaGbt0SQ4E761UKH",
	"LdzZHUohLLdwxw5/LY7jJ7j7lZ8RGyXX3RpQNgYwyhKQPSdvYB9vYQw3KCgmA1ECA9btlK9eU+EkjFfR",
	"PkCLfIxSGYmcCmsYZSjPqlkmSYRg3HHwg27zRLRkjdoSsj6R73CAlIMN/wVtk1dEAxRkJh4PLix5Mb2i",
	"3nuEYFpAzYayT3ygljWkBsoBt2XpjPRjgjB70SCW1rdh1q+q5EmBTf184XaLghBiFB1AdohXGa/RQrOT",
	"bFMvyBvHconCFbmpEHXoNHZXrNWR7uBnVPlFKRw/x2hYxHYs3abkAlQJpqK67cSUvOt+Yjo6KTWI1Gjf",
	"RdjC3SjPemvrqtN6fKe8EqQbafym2VilswohmsMYQN5w3C5fH5+TNxOnjSVqYoHFWOUl2fgiRbeaQVWI",
	"TJ/UKT0xb4LgE9z9wk/P2jwvPVXpdxil7DvoJN/ks69MeG5NcjomxlChKRagtGt5YkMYXJmPQvRMVydh",
	"wwsvR8YZJ+YEkY16QYf3LDdpHDd5Mw+8NHKGZF0hUquL+5ymU5Xx468P0+AwVcOAE9vZl8pPUQjuGIus",
	"kpStIKAJWAlAcPXMbwFDMpntvGQWYb3YJLuUEAFz857STi392J/qFxjlDf4nH+Bb/hi7ITeq8x6rTcMA",
	"POWjHQ829LRxMhyuXhYYLqMG/iB9GbCX1QmY5IEnNniHCCh9xDCJZvRLQf6p+XlbvgE+hJAC9PZEioIG",
	"zFTgA1roYT23loadSKBT2sGp6GkJNS2ApqsYjwebt3IzqqaHb/LbyeswIs+T1bFTVEDUy9XX/fX1jysC",
	"Nvq/EGA/sIUmaelHKkf5Lxkia8AoIGbwKtluoU6R03kvvOK5f0MH8PYcrp7BGwJvMMb5NQlq1iepZq4X",
	"dPCb6BP8DuL9dolSdgOeTcDuv6eUzPwO/A4S7czPo1VTr5J9jFWTF5Xfa7N/Xq8zhPmXhnFAmBdl4Dl5",
	"A1sYE+8CbTOyBdlLuCOEs64ioSOal9GTIGkSEexGPoBfasG9kpzQhfhYvTeQpGC/CyAtF0W/7x2T7SJS",
	"QrFJf1JEcFvn8NbsW8L9CwYOP5oeCKUIp6kYrGQBM3YsJlLbwnrtKa4aqK1j5bqa3xRqA3uPCFOw0SuM",
	"TTVUFuIGykeqN0kHUGsbOvTQLTGMYKMrPK/2nhmnSg4R+m+3ixQhRuIaxar2YVeaEpZkgqNRML2GSGSz",
	"RnWkUCyognVC1Y4adOrmnBt0tnTknDHmqjKzXtT73Qsh0Mjj2v5t/9Wsr4DfOqVoC+a+/xNpq0mpNpq6",
	"qhoucLneQoWfX6P/iaG6awNq0k0yO2topoWk9TaMLyL5u7OsnYZBd92PQddVh8szsOgGLZXrZdDtklZK",
	"bj4+fP5FVWZTrf12ydnU1qQb06ieJiEN/X+87qRLSU34CsOIhqLovMY7QoQK4nZQdwKmWP9USiJqtlHm",
	"KMI0tjBsVrwL3kL8TJN5eIhZG+cgA5tUz3Yf4XAHU0z01fYd1Q+GkCkt87LfUTlXW+YTvQmbILZEnAD+",
	"4OUFO265+OliGcaQ1U4pCUairsgzHyGG74pTk3wq8vdtuEX8LYy+4/e7CIb0Ak09onpsxKImtWswywnB",
	"YxQ1gkwu+9GOsTpeXaSMh2+fT6113bmAsZqU+Td0evqsckHzmUfih+YLUkkbqydqoAi7+TQyilwfeRqk",
	"PtCxn9i05VmS7VREsSfhXpbw0lRWlKvGrJLdkedAZD/ZMCaj5ZE8cXTawZhCIGRL+faNGa9dHScVZHc3",
	"suQzpfx9k101CGo8QhRdhRxybI3rJKmyLAVQ6V8nXRy4Cs8WxazXGQxzzul2ak5ibGZcO8yjJfJUwohu",
	"RmXxXaM53SgQ0NywZJ8Uxg6mZveQOc2jELNQnM3WuILGVgUq/S//DW7Iyo62Zdkwgmc0Jkph2N6Qx4eQ",
	"ssWnT517OOHO1YpWAK65SU0HK2reuhjZp4/gkVj0lDbjs+ilZSmIyAB1IhZ9zh19aCJ/c58tT2Puh1VF",
	"arL9J8jTWuydnqPBvmtcjgbkiPF3NCTO8kYs9ztmuE7KVps9HX3+Vw4EpQ1nSQKTtIA3K4l8sJmdZsOx",
	"+xw0V8Nx2g3MTZqxJVtxkyb73VFRC7pINoyjyuWhi1vyzhy6OIYFOPXOMHQhoa5RtEJGLQ9XmFBbhCtO",
	"H7Uj0TqUOOMLV0jLUhCRI2r68Qojf7Wqe/zjFHyT80CFe1xigsyrA9kJxiXYd40rLqFXMW4noEIgNIxM",
	"zICdlCk2Rya0kQmbweYSmmjKTFJsYmao2UrsITbhZCWeQHCiYwtxi7IMblrIEBYDOedVfGIvzOGJY7gg",
	"J9+55lYoYdc8u4IP55dfcQ5IHoky4vQZX9CitDAFIQWwTiTPQuKTbjMtBH/7lbeRl5gHMdwCGJNkZgPg",
	"Ti+IIb5sPFVqpFU1T7DIJUTV93IIYsygnaDRNocyzEkWBo6y1toxMpRHMGNmrNmG7C2k4WpDTjuqYebt",
	"BmajBLPMo2oOlQBl2SCPdAWepH+BFYzBEvHy56xcOX5GYQoyDPHeeDNaGqdlOfIrXQ1dSzEHX5GmtHf+",
	"xwKXKN5vCQXWMIwQ6/uy2KXJJkVZJhVb7qeFACFyiaC91wiy4aKCWRklhkDDI4YpFqEGmVqsghYDJ+8D",
	"Va//TV7uFkrlMl9cDoMk5mXlcQLekvQFaEvGF3aFVYOYasj/qTMkqYD0VOaaVHgTP/yn1zLQd7jdRYi9",
	"E6CLn/78w39eXggR99PFCsZxgtkMdQRcghTB1TMKeI+x7+F2vwVwm+xjiscfrgF58BWVYFhUQyIrLlfh",
	"YIuo77e0pkYlOp6ShHUUSHaozBStVT5Xb5GZ5Y5UGY6tBAnvSq+ZQgjdcakM2JZadDn53fK8o3G7nQHi",
	"mklgFvpKx3vipL7uVdyOtVGfhfhWha9yRj8k222Iy3IefUerPW9Kmm8APblQGwRgm23qxw504Mlh7/i6",
	"2tfDmQY5biPWpCjEXZTUd1jVXIz1qPJ8NZ5saliUrYnXIghnVDQKOcNf1eqXEsH/ntvYXffcaLWxa83s",
	"V5eCVG7MxTiyqtRrcwxeYIh94hKiRi19ryhSq+n7BnF2LkV7KxviVbWXvPo+hsSN0pLiljdkZvPkx4bG",
	"msmUtpa6jZ+pQwUIGxA/eoOwmCJJwR+JAZKs8+Ltl2AJVy/0f5CvQOm/axxuylXKMA4f6eLygg9FHqNj",
	"qaI5l5rlkmlqy9WshceOPYLSfBImZ9RzXRLDaAUz1nyVeaUgpNF99jHqtbAhTau5vPj+LkA7FAcoXtHY",
	"Mh3iSjzGRu/WXGZQXDDZYOaov/Q47V2MURrDCDzSTQCcO9th61uEM0beUiMz8m8t2yYpD1f4l0J/hhjs",
	"MySJDzoY68NIJHiGCf0vAbraXIEt3GWXIMsisEIpDtesieLVlYbt6VDnI3jZzjUUvfTl9xsUoxRGHrQk",
	"btIWxnCDAsDfpgQVhb+V8XY22y17vPNC6nxZE6ul7rzDBZMyPrRXV4f5eAI01XFZSWy++/qa6zU69laB",
	"/ba6YDFP6yXYZdwlK4zwuwynCG67KcjuimMVjOt7Ui3ZLgg62ZrtvshVsoeLBPTKZNNxJzNPgzB70Qai",
	"VRxktFNrROYLX/RdAL62kHGEnN3ooRGbRp3Ha0FRXBG5THwCp5mU5eQnQniTFi5Jw5IUs4ngiejgxhRX",
	"qmRjNlR1KgOIk1gNLJEQNUpk2aNZ2Uu4ywPLrTYdO0+7Y9odLmv7POV0Km/G9rRZiFvc0GXbwp2Lq/YJ",
	"7jp30+hXTNo7kzezDa9MjOfeBKtErV7bYeVrlUzviTXDsoBThc1P+VefWncsDzQ2E1iNPKx8Da6e1Se4",
	"s5k/OQ2H8qTyBYzPg6rvd9uek3IGg8c0OoLOHpIPZdv0jPIJ3DyiQisOhp4hvSBJe9paQB513WLafkdO",
	"/dPzNxTs4qm2syxayAdvvn11H+9L53ZiIVdm3+Px8f6DPGmXOWfVD5xm413NPjfySiqDWTyPMq28c6Cm",
	"EQMi7k5lW6bcA9iDIZT8UNkJqXZCq4mXjVcygTTLYZ29KpiPVww+rZArRHN17GySxgyNidl0NgOr+nnc",
	"kRyXaaVZ5OB9o3UAbOLp0osK7oguebajQfS3/iysSV1A8QSK2a2tjqa1hctO7FmJvaFd2eshrRfZAR3Y",
	"kBJLme+uODrgXh6Y0rJqWC5BJIN2WjHhqXztziiBTq/4wbB1DxwILIGst7IHxluOJ17DoEH5gia1oj4c",
	"USZqLpUw2lIJLrcZuyuE4MG3c1UDa1UD/4oGbuLcpIFHQbbrvoRpa5X3Pky3h7sdM0YLYIA6CMPCdUxF",
	"DY6vZ9Az2Nv0PDsum9DtZlxO2LX98/X/cnrhhm62sME6L+bgYvq8wfX7dB+hDGG/7gd5Qh5cAzGAUpf+",
	"A66/iAk65Pw3uF7kH+IR9eyoLL9qeyTS/AOunTJWiV0rDaE5HC62uNeU1PLCOkzP///hrv+jWQlQKjxJ",
	"Hz/Zcvb8eLJMxzJErULDK81U3rTlQRvyYC+UUG00auRh+04ulecejftkoqiD16QiE989g3gfDZWu+5IB",
	"47w5YSa+rWi4Sdvwx0wkb42i56zErs1iJj+5mk+GFJW1j9Rm/H/xombstpHZLq5cVqKv0PoquAwvnXUs",
	"Ln75pfLJ63Q5/s32y0UQphedy8sJVwHRkq6B5c4y811QkNvw6uz5TnHQp5Rds887oexNAXeTf5A7B3Nu",
	"pO4inI5VWhLfjTyUK71TombTfnJ+WpT6Bl8md2R6weygF/HEJzdxk4rLVx6a3tVL6jeXrCdr4uTv6xlh",
	"4e2N1a/mSXpU55pNVzyNIh2xzo3l62qzz2W5DidB1KC9XxDawSh8RcH70jnr+1W0zzBKF67lpIuBAH/V",
	"o7j03/KXP7B3NZWmO3OYql+rOrYzfdXw/pPr/ktwKG2yMzA2UbKE0YIv3uqUE86T1la8nYEM8fPvdZEU",
	"pYTHLX3pI1p3enL1mqa7hbS+vk+vbhGmu8WWAPINLghWsIlVaTnsuzYFv7TdXRd3Lxiozcz5tlEwkvT6",
	"YyDaZoaDyzpuREaDJoFpNDq7TRXswb9u0jaFby4SFsU4TEsMXxb+MEriTVHQRmQjp+g1pP8j3m+XKAX7",
	"LIw3QJlgAv769PQAGP1sOrykV45kh3KASwTA6lkrBYf+kz31zSEx9rP4CCkLqZJsw3SpIc3GomxNmTbl",
	"jf7wjFYv2X7rlMqzDf4CVuIFn1m6SJ5qS/utKsDR6T1lyFdmQQs7aDWfHsPGWMHdGmQIX4I4yTmL0ga8",
	"hVEElggExB+FMcsU3+2z53xF+SMopuot0F0WeQl3CxU98r1fwyhDOeaXSRIhGKu6HUir5YlmYg1hHOKQ",
	"B0m1i1AI4uZrSOLoAF5hFAY0Blmi0iWVV8keAyIhDkQyhVizMjLOQozjvbZBTJS+vOk/jUfcOmQ1z+K2",
	"/VzVTmlqM/Nmik4n4bblYJRdl7vZwNTbCOMMw3jlkgUgqf2/f/nyAPJX6SGzrgoTefSOP9l5mKH4mp6D",
	"DPdhhiu74mto8WxFlhSr22vd8Xpll88yuiD2qHfl7rmygeIKpkVMJqgweDIxLPNjmxK43HDSfp5vEMks",
	"rZVlteqO+o8SGdXWsiOTMLaCR8PgXV3WSHvMO41TshyLTnxx2dDGMAP6FuH20PytLyNliIMQZzIZD0Ga",
	"0om/f8qSZ/y2zfVs25z+gUn7Zkp2iFeLTZrsdx4J41UxQQYBbBCTv/h4iFe35KnOHUb5qwZzGaVdadVp",
	"LMY1uY3yZp+l31hgYHyeY3VtA8lX8zJm79HTeywYs13B3IIHWSzN1YdsLj9mJ3J2IlVOpJ09fN1IV1Rz",
	"R7IlSH/rz3oZ0Jd0oZanN+lKLsmfPFkpNAWj53o2es7KrWzVfsEpXL0s2P4c41qyAYxuJX2kc5+y/EHD",
	"eZV8Aa16lPRBozcp9vgsXUmZ9ONzJuurG0iy2hYyO5S+DqXgulaFcRvuJH3I2ZVsJjxmP3L2I5V+pJEr",
	"vH1IBygL/7EFHH/r00wZ0n20EMnXdXSgkuw2nqTEmYZ1cz1bN+fnOTYyVNgnWp1D4RoWYwK2l1qvsHjy",
	"i9jFzkBafM9CfE/37T+oOyjth5hZRQC+V3Y65D0ETMRIYlSf2NQWRkEL4+0g9hS4+9ioyvcOYoxS8tp/",
	"f/0a/P7nf70j//lB/s9//NtFv61hagiZQlmQNESvhL1rtG6IsYadi7RXNFtuXlQSGh6F6dtpZJTTrNTB",
	"6HJUDY4kFPfc64gKO00jAyXRnJsa/c0BXerORo3AcnI9jtSYcG13NLcgGkELInUNfi1buYh3j15ELgwo",
	"nL67j7oYUyNmlBHZ0Ng49cZFBuFqUd/H0rVkN55uWyN3+TlW89AbOKZGQ9DJ3NN0ExqLEBhTX6Hj8dVm",
	"FMV9NRM6KBqA/XJuaaK7d2jF2s/aq9SBjxBD8BDBGIGbhzvweYdi8t/yGArR/Vh54Ch8u5ZJaE0nlj+6",
	"+i15o97S74rNXRDTDe7C1x8bbvPrj/ad/izmOKUtf/3RbdfzjxfbLwY0bzd/TIiJ1T5NUUx9BozEj+UV",
	"XYIwXkX7IIw3dIFhvE4uAa3kfAC7NCF7QX/MLukw2SV4RjDCz7xkwiUtZqOs2KCORjzyL7EFH4giASla",
	"pyh7Jovjq1/DFdZFH/jTKmFYFHnptNU//7beeiT701sGHB/tG11uhlb7NMQHSoslzMLVAu7x88VP//xG",
	"9ow4RoJS+zS6+OniGePdT+/fX1/R/3v/+iM9+Sn+llX++C2f+XdBsJsP9/Ql8c/cDSx+ipJneFGvGvQJ",
	"xnBDYLGEqxdURWAG/giDVxivUAC2SYD+vcDIz+x5eQ7+0+NbiFcEal/2ETJNuU4pVgKwDH0mDiuzJni7",
	"2eKHNGH16ou/fCB+fPmHHV7xbRA/sVIpimV+gW+afplb8gFoSwCiXWW52JU8YYrvqU1X+ukRJ2lpqR/R",
	"KoIpIivep8ZdFEXxKovUruyjKKInz7ZJ4Tbf2Iqd9XAH4B4nQZitkleUAhQHuySMqfQQ7/O/HUqDHmK4",
	"DVe/7WgBKekPv364vbvZ7Uo/0RCpE1gcP/NX/rw8y22ITVPwKoOOE7CSnvLwf316eqAFc6o/UsGTc0P1",
	"D1n1V247ql74wmVa9W93MasyXgGbdMKm/FWE5JV/fCpHlPIn7pPNr0n6BtOg8usTTIlONeyw4Kco2VTw",
	"egV+o4US8TPKUAExcEj2NFYvHkYgjHd7zFqZrBETNPm498kmu/waE02a7HH+XIbigA++BTgB6DtGaQwj",
	"sg6hm5M0A+RRnKRwg7Krr3FBajKs/K2fYBih9JcYlwHPfq48uSv9+7/gFjENIP/6gOr/ro3+wNZJ91LJ",
	"KhR65DPFeRvTlFfgKQHwNQkp62QYxpg/QZ59Q+LxMAZhjFH6CqMM4GeIAUylmkPLCIG3ZxR/jWnJS/bS",
	"uwBF8ACSHSPhP55RDKDov4qTCiuFGdjCgFXtk/1bsE8jQE0QwHytr3Fu0pCXaJk5stIwy/YIQOG1Udqy",
	"IS7lbsLMseMnhOS7hCUgam2C/8tQ9TXGZMX7TDyfScgjy6cVB8lw7DyGWQIQF6Nfgbt1+VvCDFDvn6yX",
	"iMQ0DGgj5K8xfTnM5Ha04XaLghBiFB1KgFPw5ReUJVEFN1+oX2rX6Qxxzhr2sQZQ9ktdsZf+/IS2u6gi",
	"6h9ZGLisHzSrzUKMMvDHLNzuIlRVuWSFV+CRPsJxmYUBPbqDvGWFUBAUn6zLT4TEHmRf41USx2hFfH2c",
	"gBCD1xAK5bkQO5WkBA3vxD+DMEU02F+WB3QZpc8suSK6PxS+SOmJBFX/XZO8teMppu4xDGOUSusifygN",
	"hsPVS41a5McnflYh/UoFX/mndL8i5kdJ0AtrV/rp6UNd7z190Okx+he1GitWpcFI+URX1fY5P9qldxQQ",
	"lWuEg6U3Gf+z8x/8jL7GcsCZogenMD/Zefj8+MSdMxhFonGFYl6iqmKEOABzCVYafhEGXEySp9+ILKZi",
	"krU6Li/zkis/PmnpuOnhtye6JPJHPv/XmH4pLB2DEnGUNwCnwiofEyo/Iy8QWplyEQaX5Y3aIvJGmG3J",
	"HIRnw1WIowMdXGwC4cvcca30fy9xlM7W+O3jw/2y9EOG0ijMsPzbP+D65yQ4MDB9+9f/BAAA//+drTuq",
	"Hy4LAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
